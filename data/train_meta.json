[
    {
        "instruction": "Write a function `run_comparison_suite` that takes a list of test cases. Each test case is a tuple containing `(test_name: str, original_func: callable, transformed_func: callable, args: tuple)`. For each test case, execute both `original_func(*args)` and `transformed_func(*args)`, compare their numerical results for closeness (using a fixed tolerance, e.g., 1e-5), and store the boolean comparison result. Return a dictionary mapping each `test_name` to its boolean result (True for close, False for not close)."
    },
    {
        "instruction": "Implement a function `are_close` that takes two numerical inputs (which can be scalars or arrays of the same shape) and a floating-point tolerance value (e.g., 1e-5). Return `True` if the absolute difference between corresponding elements of the inputs is less than or equal to the tolerance, and `False` otherwise."
    },
    {
        "instruction": "Develop a higher-order function `apply_transform`. It should accept a function `original_func`. Inside `apply_transform`, assume there's a predefined internal mechanism to create a `transformed_func` based on `original_func`. The function should return this `transformed_func`."
    },
    {
        "instruction": "Create a function `compare_function_outputs` that takes three arguments: an `original_function`, a `variant_function`, and a tuple of `arguments`. It should call both functions with the provided arguments unpacked: `result_orig = original_function(*arguments)` and `result_var = variant_function(*arguments)`. Assuming the results are numerical, compare them for near-equality using a fixed tolerance (e.g., absolute difference < 1e-5). Return `True` if they are close, `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a data type identifier (which could be a standard type object or a descriptive string like 'int', 'float', 'object') and returns a simplified category string: 'numeric' for standard numerical types (integers, floats), 'object' for object types, and 'other' for anything else."
    },
    {
        "instruction": "Implement a function that receives a data structure (like an array or list) as input. The function should determine the data type of the elements within the structure (assuming uniform type for simplicity) and return `True` if this data type is one of ['int32', 'float64', 'complex128'], and `False` otherwise. Handle potential empty inputs gracefully (e.g., return False)."
    },
    {
        "instruction": "Develop a function that takes an input item and a collection (e.g., list, set) of 'valid' items. Return `True` if the input item is found within the 'valid' collection, and `False` otherwise. The comparison should be based on equality."
    },
    {
        "instruction": "Create a function that accepts a positive integer `size` and a default value. It should return a new 1D array (or list) of the specified `size`, filled entirely with the provided default value."
    },
    {
        "instruction": "Design a function `run_checked_job` that accepts a function `job` (which takes no arguments) as input. Inside `run_checked_job`, simulate acquiring a temporary resource (e.g., create a non-empty dictionary). Then, call the `job()` function within a try/finally block. In the `finally` block, ensure the simulated resource is 'released' (e.g., clear the dictionary). The function should return `True` if the resource was successfully released (i.e., the dictionary is empty after the `finally` block), and `False` otherwise."
    },
    {
        "instruction": "Write a higher-order function `transform_and_check_internals`. It takes a function `worker_func` (which accepts a list of numbers and returns a number). `transform_and_check_internals` should internally create a 'transformed' version of `worker_func` (e.g., wrap it to count how many temporary helper objects it creates during execution). It then calls this transformed function with a sample list (e.g., `[10, 20]`). After the call, it must simulate a check to count how many of those internally created temporary objects were successfully 'cleaned up' (e.g., based on a simulated reference count or cleanup flag). Return this count of cleaned-up objects."
    },
    {
        "instruction": "Implement a function `prefill_first_arg`. It takes a function `f` (that requires two or more arguments) and a value `val`. It should return a *new* function that accepts the remaining arguments for `f` (starting from the second one) and invokes `f` with `val` as the first argument followed by the provided remaining arguments."
    },
    {
        "instruction": "Write a function that accepts a list of numbers and returns their sum. If the list is empty, it should return 0."
    },
    {
        "instruction": "Create a mechanism (e.g., using a class with specific methods) that manages a simulated resource. It should perform a setup action (e.g., print \"Acquiring Resource\") when entering a specific code block and a teardown action (e.g., print \"Releasing Resource\") upon exiting the block, guaranteeing the teardown even if errors occur inside the block."
    },
    {
        "instruction": "Implement a higher-order function (a function that takes a function as input) that returns a new function. The new function should execute the original input function and also track the number of times it has been called. Include a way to query this call count."
    },
    {
        "instruction": "Develop a function that takes two arguments: a function `func` and a data structure `args` (like a list or tuple). The function should call `func` using the elements of `args` as its arguments and return the result produced by `func`."
    },
    {
        "instruction": "Write a function that accepts a numerical array (potentially multi-dimensional) and returns the sum of all its elements as a single scalar value."
    },
    {
        "instruction": "Create a function that takes two arguments: `rows` (an integer) and `cols` (an integer). If both are positive integers, return a new 2D numerical array initialized with zeros, with the shape (`rows`, `cols`). If either argument is not a positive integer, raise a `ValueError`."
    },
    {
        "instruction": "Design a function `process_batch` that takes a list of items. For each item, it should attempt to call a (hypothetical, not implemented) function `create_item_specific_array(item)` which is expected to return an array whose dimensions depend *only* on the *type* of the item, not its value. If `create_item_specific_array` throws a `TypeError` (simulating a dynamic shape error), `process_batch` should catch it and return an empty list. Otherwise, it should collect the created arrays and return the list of arrays."
    },
    {
        "instruction": "Develop a function that accepts a configuration value `config`. If `config` is a positive integer `n`, the function should return a 2D numerical array of shape `(2, n)` filled with zeros. If `config` is *not* a positive integer (e.g., float, string, negative), raise a `TypeError` with a message indicating an invalid type for shape definition."
    },
    {
        "instruction": "Implement a function that takes a single argument `size`. Check if `size` is a non-negative integer. If it is, return a 1D numerical array of that `size` filled with zeros. If not, return `None`."
    },
    {
        "instruction": "Write a function that accepts two numerical scalar inputs, `x` and `y`, and returns the sine of their product."
    },
    {
        "instruction": "Write a function `create_calculator` that accepts a numerical scalar `factor`. It should define and return an inner function `calculate(value)` which computes `sin(factor * value)`."
    },
    {
        "instruction": "Develop a function that computes a directional derivative for `f(y) = sin(x*y)`. It should take three numerical scalar arguments: `x_param`, `eval_point`, and `direction_scalar`. Calculate the derivative of `f(y)` with respect to `y` (treating `x_param` as a constant), evaluate this derivative at `y = eval_point`, and multiply the result by `direction_scalar`. Return the final scalar value."
    },
    {
        "instruction": "Implement a function that takes two numerical scalar inputs, `a` and `b`. It should compute the derivative of the function `f(y) = sin(a*y)` with respect to `y`, and then evaluate this derivative at `y=b`. Return the result."
    },
    {
        "instruction": "Implement a function that takes a numerical input. If the input is a scalar (0-dimensional array), return the scalar plus 1.0. If the input is a 1D array, return a new 1D array with each element incremented by 2.0."
    },
    {
        "instruction": "Develop a function that checks if a given numerical array input represents a single scalar value (i.e., is 0-dimensional). Return True if it's a scalar, False otherwise."
    },
    {
        "instruction": "Write a function that accepts a numerical array and two numerical constants, `c1` and `c2`. If the array is 0-dimensional (a scalar), return the scalar plus `c1`. If the array is 1-dimensional, return a new 1D array where each element is the corresponding input element plus `c2`."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and returns a new 1D array where each element is the corresponding input element incremented by 2.0."
    },
    {
        "instruction": "Write a function that accepts a tuple containing exactly two numerical elements. The function should return the second element of the input tuple."
    },
    {
        "instruction": "Implement a function that accepts two arguments: a number `arg1` and a tuple `arg2` containing two numbers `(tup_val1, tup_val2)`. The function should return a tuple containing two elements: first, the sum of `arg1` and `tup_val2`, and second, `tup_val1`."
    },
    {
        "instruction": "Write a function that takes two arguments: a numerical value `num` and a tuple `data_tuple` containing exactly two elements `(item1, item2)`, where `item2` is also numerical. The function must return a specific nested tuple structure: `((sum_val, {'x': item1}), item2)`, where `sum_val` is the result of adding `num` and `item2`. Ensure the output structure matches this format exactly."
    },
    {
        "instruction": "Develop a function that takes two arguments, `val1` and `val2`. It should return a tuple containing two elements: first, a dictionary `{'x': val1}`, and second, the value `val2`."
    },
    {
        "instruction": "Implement a function to compute the matrix product of two given 2D numerical arrays, `matrix1` (shape M x N) and `matrix2` (shape N x P). Return the resulting M x P matrix. Assume compatible shapes."
    },
    {
        "instruction": "Create a function that accepts two 2D numerical arrays, `A` (M x N) and `B` (N x P). It should compute their matrix product `C = A @ B` and return the dimensions (shape) of the resulting matrix `C` as a tuple `(M, P)`."
    },
    {
        "instruction": "Write a function `apply_transformation(transform_matrix, data_matrix)` where `transform_matrix` is a fixed M x N numerical array representing a linear transformation. The function should take a `data_matrix` (N x P numerical array) and return the result of applying the transformation, which corresponds to the matrix product `transform_matrix @ data_matrix` (an M x P array)."
    },
    {
        "instruction": "Write a function that accepts two positive integers, `rows` and `cols`, and returns a new 2D numerical array (matrix) of shape (`rows`, `cols`) filled with consecutive floating-point numbers starting from 0.0."
    },
    {
        "instruction": "Implement a function that simulates analyzing a simple function call. It should accept: (1) the number of arguments the function expects, (2) a list of the actual arguments provided, and (3) a description of which arguments are returned (e.g., indices [0, 3] means return the first and fourth). The function should validate if the number of provided arguments matches the expected number and return the description of the outputs."
    },
    {
        "instruction": "Write a function that models a dynamically sized array. It should take an integer `n` and a data type string. Return an object or dictionary representing an array whose size is dependent on `n` (e.g., shape `(n,)`) along with its data type."
    },
    {
        "instruction": "Create a function that accepts a description of an array, including its shape (a tuple of positive integers) and data type (e.g., 'int32', 'float32'), and returns a string summarizing these properties."
    },
    {
        "instruction": "Design a function that takes a list representing abstract function arguments (e.g., ['arg1', 'arg2', 'arg3', 'arg4']) and returns a new list containing only the first and fourth elements from the input list."
    },
    {
        "instruction": "Write a function `select_arguments` that accepts five arguments (arg1, arg2, arg3, arg4, arg5) of any type. The function should return a tuple containing only the second and fifth arguments: `(arg2, arg5)`."
    },
    {
        "instruction": "Create a function `nested_array_processor` that takes two 1D numerical arrays, `input_arr1` and `input_arr2`, assumed to be of the same size. Inside this function, define a nested helper function `inner_processor` that accepts five arguments: `dim_size` (integer), `arr_a`, `arr_b`, `arr_c`, `arr_d` (1D arrays). `inner_processor` should return a tuple containing its second and fifth arguments: `(arr_a, arr_d)`. The main `nested_array_processor` function should calculate the size of `input_arr1`, then call `inner_processor` with the calculated size, `input_arr1`, `input_arr2`, `input_arr1`, and `input_arr2`. Finally, `nested_array_processor` should return the result from `inner_processor`."
    },
    {
        "instruction": "Implement a function `process_array_with_size` that accepts a 1D numerical array. Inside this function, determine the size of the array. Then, call a hypothetical, pre-existing helper function `helper_func(size, array)` passing the calculated size and the original array. Return the result from `helper_func`. (You don't need to define `helper_func`)."
    },
    {
        "instruction": "Develop a function `check_shape_consistency` that takes a primary dimension value (an integer) and a list of array objects. It should return `True` if all arrays in the list are 1D and have a length equal to the primary dimension value, and `False` otherwise."
    },
    {
        "instruction": "Create a function that defines a structure representing a computational step (an \"operation\"). This structure should include the operation's name (e.g., \"identity\"), its expected input type specification (using the structure from Task 1), and its expected output type specification."
    },
    {
        "instruction": "Write a function that creates a simple data structure to represent a data type, storing its name (e.g., \"integer\", \"float_array\") and shape (e.g., \"scalar\", \"1D\"). The function should take the name and shape as strings and return the structure."
    },
    {
        "instruction": "Implement a function `validate_input_match(operation_spec, input_variable_spec)`. It takes an operation specification (from Task 2) and an input variable type specification (from Task 1). Return `True` if the input variable's type matches the operation's expected input type, `False` otherwise."
    },
    {
        "instruction": "Develop a function `validate_computation_sequence(sequence)`. The input `sequence` is a list of structures, where each structure contains an operation specification (from Task 2) and references to its input/output variable specifications (from Task 1). The function must check if, for every operation in the sequence, the type of the variable provided as input matches the operation's expected input type. Return `True` if all checks pass, `False` otherwise."
    },
    {
        "instruction": "Implement a function `step(current_state)` that simulates one iteration of a process. It takes `current_state` (any data type) and returns it unmodified."
    },
    {
        "instruction": "Implement a function that takes one argument. Inside, perform a calculation or process that yields two distinct results based on the input (e.g., duplicating it). Ensure the function returns only the *second* result, effectively ignoring the first."
    },
    {
        "instruction": "Write a function that takes a single data item `value`. It initializes a state as a pair `(value, value)`. It then simulates a single step of an operation where the state is passed through unchanged (using logic like Task 2). Return the final state pair."
    },
    {
        "instruction": "Write a function that accepts a single data item. Create a structure (like a pair or tuple) holding this item twice. Return only the second item from the structure."
    },
    {
        "instruction": "Write a function `apply_fixed_offset` that accepts a numerical value `x`. Inside this function, define another function `add_zero` that takes a numerical value `y` and returns `x + y`. The `apply_fixed_offset` function must call `add_zero` with the specific input `0.0` and return the resulting numerical value."
    },
    {
        "instruction": "Implement a function `outer` which defines a nested function `inner`. The `inner` function should return the constant numerical value 0.0. The `outer` function should call `inner` and return its result."
    },
    {
        "instruction": "Create a function `outer_func` that takes one numerical argument `x`. Inside `outer_func`, define a nested function `inner_func` that takes one numerical argument `y` and returns the sum `x + y`, using the `x` from the outer scope. The `outer_func` should return the `inner_func` itself (the function object, not the result of calling it)."
    },
    {
        "instruction": "Write a function that accepts two numerical inputs, `a` and `b`, and returns their sum `a + b`."
    },
    {
        "instruction": "Write a function `check_elementwise_equality` that takes two numerical arrays and an absolute tolerance value. It should return `True` only if both arrays have identical shapes and the absolute difference between corresponding elements never exceeds the specified tolerance. Otherwise, it should return `False`."
    },
    {
        "instruction": "Develop a function factory that accepts a scalar binary function `f(x, y)`. This factory returns a *new* function that takes two numerical input arrays, `A` and `B`. The returned function should first determine the broadcast shape of `A` and `B`. If compatible, it applies `f` element-wise to the broadcasted versions of `A` and `B` and returns the resulting array. If incompatible, it should signal an error."
    },
    {
        "instruction": "Implement a function `get_broadcast_shape` that takes two tuples, representing the shapes of two arrays. It should return a tuple representing the shape of the arrays after broadcasting, following standard broadcasting rules. Raise an error if the shapes are incompatible."
    },
    {
        "instruction": "Write a function that takes two numerical arrays of the *same* shape and applies a simple scalar binary operation (e.g., multiplication) element-wise. It should return a new array containing the results, maintaining the original shape."
    },
    {
        "instruction": "Create a function that checks if a given callable object appears to conform to a specific signature: accepting exactly two positional arguments and returning one value. Return `True` if it seems to match, `False` otherwise. You can use introspection or a test call with dummy inputs."
    },
    {
        "instruction": "Write a function that takes the shapes of two arrays (represented as tuples of positive integers) and returns the shape of the resulting array after an outer-product-like operation. For input shapes `S_A` and `S_B`, the output shape should be the concatenation `S_A + S_B`."
    },
    {
        "instruction": "Create a function that accepts another function `f` (which takes two numerical inputs and returns one numerical output) and two numbers `x` and `y`. Your function should return the result of `f(x, y)`."
    },
    {
        "instruction": "Generalize the previous task. Write a function that takes a binary scalar function `f` (2 inputs, 1 output) and two numerical arrays, `A` (with shape represented by tuple `S_A`) and `B` (with shape `S_B`). It should return a new array `C` such that element `C[idx_A + idx_B] = f(A[idx_A], B[idx_B])`, where `idx_A` and `idx_B` are valid multi-dimensional indices for `A` and `B` respectively. The shape of `C` should be the concatenation of `S_A` and `S_B`."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) and a binary Python function. Apply the function cumulatively along a specified axis (0 for columns, 1 for rows). Return a 1D array containing the results for each column/row."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a binary Python function (e.g., add, multiply). Apply the function cumulatively to the elements from left to right and return the single resulting scalar value."
    },
    {
        "instruction": "Write a comprehensive reduction function. It takes a numerical array, a binary Python function `op`, an optional axis index, and an optional `identity` value. If axis is None, reduce the entire array to a scalar. If axis is given, reduce along that dimension. Handle empty arrays or reduction along an axis of size 0 by returning the `identity` value if provided, otherwise raise an appropriate error. The function must work for multi-dimensional arrays."
    },
    {
        "instruction": "Implement a function that takes a binary Python function `op` (accepting two scalars, returning one scalar) and wraps it so it can be used for reduction. The wrapper doesn't need to perform the reduction itself, just prepare the function."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a binary function (operating on two scalars, returning one). It should return a new 1D array where each element is the result of cumulatively applying the binary function to the elements of the input array. For example, if the input is `[a, b, c]` and the function is `f`, the output should be `[a, f(a, b), f(f(a, b), c)]`."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array, a binary function (scalar inputs/output), and an integer representing the axis. Perform a cumulative application of the binary function along the specified axis. The output array should have the same shape as the input."
    },
    {
        "instruction": "Develop a function that validates an axis parameter for a given multi-dimensional array shape. It should accept the array's shape (e.g., a tuple of dimensions) and an integer axis value. Return the validated, non-negative axis index, correctly handling negative indices (e.g., -1 refers to the last axis). Raise an error or return an invalid indicator if the axis is out of bounds."
    },
    {
        "instruction": "Implement a generalized cumulative operation function. It takes a multi-dimensional numerical array, a binary function (strictly 2 scalar inputs, 1 scalar output), and an axis. It should perform the cumulative application along the specified axis, similar to Task 2, but must robustly handle various valid array dimensions and axis values (including negative indices). Return the resulting array of the same shape."
    },
    {
        "instruction": "Implement a function that performs a segmented sum on a 1D numerical array. It takes the 1D array and a 1D array of sorted integer start indices. It returns a new 1D array where each element `k` is the sum of the input array's elements from index `indices[k]` up to (but not including) `indices[k+1]`. The last segment runs from `indices[-1]` to the end of the input array."
    },
    {
        "instruction": "Implement a generalized segmented reduction function for a 2D numerical array along axis 1 (columns). Inputs: a 2D array `A` (M rows, N columns), a 1D array `I` of sorted start indices (length K <= N), and a binary function `f` (takes two scalars, returns one scalar, assumed associative). Output: A 2D array `B` (M rows, K columns) where `B[r, k]` is the result of reducing the segment `A[r, I[k]:I[k+1]]` (or `A[r, I[k]:]` for the last segment `k=K-1`) using the function `f`. Assume segments can be empty; the reduction of an empty segment should be a sensible default (e.g., 0 for sum, 1 for product)."
    },
    {
        "instruction": "Write a function that takes an array shape (tuple of positive integers) and an axis index (integer, potentially negative). It should return the size of the dimension specified by the axis. Handle invalid axis indices by raising an error."
    },
    {
        "instruction": "Create a function that generates a 1D array of `k` random, sorted integer indices suitable for segmenting an array dimension of size `N`. Inputs: `k` (number of indices/segments), `N` (dimension size). Output: 1D array of `k` unique integers between 0 and `N-1`, sorted in ascending order."
    },
    {
        "instruction": "Develop a function `check_loop_iterations(start, end, max_iterations)` that checks if the number of iterations in a loop from `start` to `end` (exclusive) exceeds a given `max_iterations`. Return `True` if `(end - start)` is greater than `max_iterations`, otherwise return `False`. Handle invalid ranges where `start >= end` (return `False`)."
    },
    {
        "instruction": "Write a generic loop executor `execute_iterations(start_index, end_index, initial_state, body_function)`. It should iterate with an index `i` from `start_index` (inclusive) to `end_index` (exclusive). In each step, it updates the state using `new_state = body_function(i, current_state)`. Return the `final_state` after the loop completes. The state can be any data structure."
    },
    {
        "instruction": "Implement a function `run_loop(start, end, initial_value, update_func)` that simulates a loop. It iterates from `start` up to (but not including) `end`. In each iteration `i`, it calls `update_func(i, current_value)` to get the `next_value`. It starts with `initial_value` and returns the final value after all iterations."
    },
    {
        "instruction": "Write a function `increment_value(index, current_value)` that takes an integer `index` and a number `current_value`. It should return `current_value` increased by 1, ignoring the index."
    },
    {
        "instruction": "Write a function that takes two numerical arguments, `a` and `b`. It should return `a + 1` if `a > b`, otherwise it should return `b + 2`."
    },
    {
        "instruction": "Create a function that accepts three arguments: a condition `pred`, a function `func_true`, and a function `func_false`. All functions (`func_true`, `func_false`) take no arguments. If `pred` evaluates to true, call and return the result of `func_true()`. Otherwise, call and return the result of `func_false()`. Assume `pred` is boolean."
    },
    {
        "instruction": "Write a function that takes a single argument. If the argument is exactly `None`, the function should raise a `TypeError` with the message \"Input cannot be None\". Otherwise, the function should return `True`."
    },
    {
        "instruction": "Develop a function that accepts a predicate `pred`, two functions `func_true` and `func_false`, and a single argument `arg`. First, rigorously check if `pred` is exactly `None`. If it is, raise a `TypeError` stating \"Condition cannot be None\". If `pred` is not `None`, evaluate it. If true, call `func_true` with `arg` and return the result. If false, call `func_false` with `arg` and return the result. Ensure the functions handle the type of `arg`."
    },
    {
        "instruction": "Implement a function that takes an integer index, a list containing exactly one function, and an input value. The function should execute the single function in the list with the input value and return the result, *regardless* of whether the provided index is 0, positive, or negative."
    },
    {
        "instruction": "Write a function that takes a single numerical input and returns its negation."
    },
    {
        "instruction": "Create a function that accepts a list containing exactly one function, an index (which must be 0), and a value. The function should apply the function from the list to the value and return the result."
    },
    {
        "instruction": "Develop a function `select_and_execute` that takes an index `i`, a list of functions `branches`, and an operand `x`. If `branches` contains only one function, `select_and_execute` should apply that function to `x` and return the result, ignoring the value of `i`. Assume the function signature matches the operand type."
    },
    {
        "instruction": "Write a function that takes a single number as input. If the number is strictly less than 2, return the boolean value True, otherwise return False."
    },
    {
        "instruction": "Write a function that takes three arguments: a number `val`, a function `op1`, and a function `op2`. If `val` is less than 2, the function should call `op1` with `val` and return its result. Otherwise, it should call `op2` with `val` and return its result."
    },
    {
        "instruction": "Develop a function that accepts one numerical input `x`. If `x` is less than 2, the function should return `3.0 * x`. Otherwise, it should return the sine of `x`."
    },
    {
        "instruction": "Create a function that accepts a single number and returns that number multiplied by 3.0."
    },
    {
        "instruction": "Implement a function that takes a floating-point number `x` and a list of three predefined functions (e.g., `f1(y)=3*y`, `f2(y)=sin(y)`, `f3(y)=-y`). Calculate an index by taking the integer part of `x`. Clamp this index to be within [0, 2]. Return the result of applying the function at the clamped index to the original number `x`."
    },
    {
        "instruction": "Write a function named `apply_indexed_operation`. It should accept an integer index, a list of functions (where each function takes one numerical argument and returns a numerical result), and a numerical operand. The function must select the appropriate function from the list using the index, ensuring the index is clamped to the valid range `[0, list_length - 1]`. It should then call the selected function with the provided operand and return the result."
    },
    {
        "instruction": "Write a function that takes a single floating-point number as input and returns the integer part of that number (equivalent to flooring the number)."
    },
    {
        "instruction": "Develop a function that receives a floating-point number and a list of numerical values. Determine an index using the integer part of the input number. Clamp the index to the valid range for the list (0 to length-1). Return the numerical value stored at that clamped index in the list."
    },
    {
        "instruction": "Develop a function that takes a numerical input `x` and returns either `3.0 * x` or `sin(x)`. The choice should be determined by calling a separate boolean function `check_condition(x)` which returns `True` if `x < 2.0` and `False` otherwise. Implement both the main function and the `check_condition` function."
    },
    {
        "instruction": "Implement a higher-order function named `apply_conditional`. It should accept four arguments: a predicate function (takes one input, returns boolean), a function `func_true` (takes one input, returns output), a function `func_false` (takes one input, returns output), and an input value. The function should evaluate the predicate with the input. If true, it applies `func_true` to the input and returns the result; otherwise, it applies `func_false` and returns its result."
    },
    {
        "instruction": "Create a function that takes three arguments: a boolean value `condition`, a value `if_true`, and a value `if_false`. It should return `if_true` if `condition` is true, and `if_false` otherwise."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number. If the number is less than 2.0, return the number multiplied by 3.0; otherwise, return the sine of the number."
    },
    {
        "instruction": "Design a flexible function that implements conditional array computation. It should accept a scalar input `x`, a threshold `t`, two 1D numerical arrays `arr1` and `arr2` of the same size, and two functions `f1` and `f2` (each taking a scalar and returning a scalar). If `x` is less than `t`, compute `s1 = f1(x)` and return a new array representing `arr1` element-wise multiplied by `s1`. Otherwise, compute `s2 = f2(x)` and return a new array representing `arr2` element-wise multiplied by `s2`. Ensure the output array size matches the input arrays."
    },
    {
        "instruction": "Write a function that takes a scalar number `x` and a constant 1D numerical array `c`. Calculate the sine of `x`, and then return a new 1D array resulting from the element-wise multiplication of `c` by the computed sine value. The output array should have the same size as `c`."
    },
    {
        "instruction": "Implement a function that accepts a single scalar number. If the number is less than 2, return the 1D numerical array `[1.0, 2.0]` multiplied by the number. Otherwise, return the 1D numerical array `[3.0, 4.0]` multiplied by the sine of the number. The output should always be a 1D array of size 2."
    },
    {
        "instruction": "Create a function that performs scalar multiplication on a 1D numerical array. It should accept a scalar value and a 1D array, returning a new 1D array of the same size with each element multiplied by the scalar."
    },
    {
        "instruction": "Implement a function that takes a scalar numerical value `s` and returns a 1D numerical array representing `[1.0, 2.0]` scaled element-wise by `s`."
    },
    {
        "instruction": "Implement a function that accepts a single scalar numerical input `x`. If `x` is less than 2.0, it should return a 1D numerical array calculated as `[1.0, 2.0]` element-wise multiplied by `x`. If `x` is 2.0 or greater, it should return a 1D numerical array calculated as `[3.0, 4.0]` element-wise multiplied by the sine of `x`."
    },
    {
        "instruction": "Create a function that takes a scalar number `val`, and two callable functions, `f_true` and `f_false`. If `val` is less than 2.0, the function should call `f_true` with `val` and return its result. Otherwise, it should call `f_false` with `val` and return its result. Assume both callables accept one scalar argument and return compatible types."
    },
    {
        "instruction": "Create a function that accepts a single number. If the number is less than 2.0, return the 1D numerical array `[1.0, 2.0]`; otherwise, return the 1D numerical array `[3.0, 4.0]`."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array (e.g., a list of numbers) and applies a specific transformation function (e.g., `f(y) = abs(y) - 1.0`) to each element independently. It should return a new array of the same size containing the transformed elements."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array (matrix) as input. The function should compute the absolute value of each element in the matrix and return a new matrix of the same dimensions containing these absolute values."
    },
    {
        "instruction": "Write a function that simulates a stateful iterative process. It takes an initial numerical value `x` and an initial integer state `s`. It iterates exactly 10 times. In each iteration: (1) Generate a boolean condition based on the current state `s` (e.g., check if `s` is even). (2) Update `x`: if the condition is true, `x` remains `x`; otherwise, `x` becomes `abs(x) - 1.0`. (3) Update the state `s` using a simple deterministic formula (e.g., `s = (s * 3 + 1) % 100`). Return the final value of `x` after 10 iterations."
    },
    {
        "instruction": "Write a function that accepts a boolean flag and a floating-point number. If the flag is true, the function returns the number unchanged. If the flag is false, it returns the absolute value of the number minus 1.0."
    },
    {
        "instruction": "Create a function `indexed_multiply_loop` that takes an initial numerical value `val`. It iterates three times, with an index `i` going from 0 to 2. In each iteration, it updates `val` by multiplying it with `(i + 1)`. Return the final `val`."
    },
    {
        "instruction": "Implement a function `fixed_multiplier_loop` that accepts a starting numerical value `start_val` and a multiplier `m`. The function should multiply `start_val` by `m` exactly 3 times and return the final value."
    },
    {
        "instruction": "Develop a function `loop_and_sensitivity` that takes an initial numerical value `x`. It iterates 3 times, doubling the value in each iteration. Return a pair: the final value after 3 iterations, and the total factor by which the initial value `x` was multiplied to get the final value (which is 8 in this case)."
    },
    {
        "instruction": "Write a function `apply_thrice` that takes a numerical value `x` and a function `op`. It should apply the `op` function to `x` exactly three times sequentially (e.g., `op(op(op(x)))`) and return the final result."
    },
    {
        "instruction": "Write a function to compute the mathematical derivative of the power function `f(x, y) = x^y` with respect to `x`. The function should accept two numerical inputs, `x` (base) and `y` (exponent), and return the calculated derivative value `y * x^(y-1)`. Assume `x > 0` and `y >= 1` are numerical types."
    },
    {
        "instruction": "Implement a function that iterates a fixed number of times, conditionally updating a value. It accepts an initial value, an `update_func` (value -> new_value), a `condition_func` (value -> boolean), and the number of iterations `N`. In each iteration, if `condition_func(current_value)` is true, apply `update_func` to get the next value; otherwise, keep the current value. Return the value after `N` iterations."
    },
    {
        "instruction": "Design a function that processes a list of inputs sequentially, maintaining a state. It takes an initial state and a list of inputs. For each input, it calls an `update_rule` function `(new_state, output_element) = update_rule(current_state, input_item)`. The function should return a list containing all the `output_element`s generated during the processing of the input list."
    },
    {
        "instruction": "Write a function that calculates the power of a number using iteration. It should accept a floating-point base `x` and a non-negative integer exponent `y`. Return `x` raised to the power of `y` by repeatedly multiplying the base `y` times, starting the accumulation from 1.0."
    },
    {
        "instruction": "Develop a function that receives a configuration setting (represented as a string, e.g., \"mode1\" or \"mode2\") and a 1D numerical array. Based on the configuration string, apply a specific predefined element-wise transformation (e.g., mode1 applies `x -> x + 1`, mode2 applies `x -> x * 2`) to the array and return the transformed array."
    },
    {
        "instruction": "Design a function that takes a 1D numerical array and a dictionary. The dictionary maps condition names (strings) to functions that operate element-wise on arrays. The function also takes a condition name string. It should look up the function associated with the given condition name in the dictionary and apply it to the input array, returning the result. Include error handling for when the condition name is not found in the dictionary (e.g., return the original array or raise a specific error)."
    },
    {
        "instruction": "Write a function that takes a single floating-point number and a boolean flag. If the flag is true, return the sine of the number; otherwise, return the cosine of the number."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array. It should return a new array of the same size where each element is the result of applying one of two provided mathematical operations based on whether the original element was positive or non-positive. The two operations should be passed as arguments."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and two callable functions (func1, func2) as input. The function should also accept a boolean flag. If the flag is true, it applies func1 element-wise to the array and returns the result. If the flag is false, it applies func2 element-wise and returns the result."
    },
    {
        "instruction": "Create a function that accepts a 1D array of floating-point numbers and a string identifier ('primary' or 'secondary'). If the identifier is 'primary', return an array containing the element-wise sine of the input. Otherwise, return an array containing the element-wise cosine."
    },
    {
        "instruction": "Develop a function that takes a non-negative integer `n` and returns a 1D array containing the sequence of floating-point numbers [0.0, 1.0, ..., n-1.0]."
    },
    {
        "instruction": "Write a function that takes a 1D array of floating-point numbers and returns a new array of the same size where each element is the cosine of the corresponding input element."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new 1D array containing the element-wise cosine of the input array."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new 1D array containing the element-wise sine of the input array."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array. It should perform three distinct element-wise operations based on the input (e.g., calculate sine, calculate sine again, calculate sine a third time using potentially different internal paths) and return a new 1D array that is the element-wise sum of the results of these three operations."
    },
    {
        "instruction": "Define a primary function that takes a single numerical input `x` and returns `3 * sin(x)`. Then, define a secondary function that computes the analytical derivative of the primary function with respect to `x`. This secondary function should also take `x` as input and return the corresponding derivative value."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a configuration string (e.g., \"config1\", \"config2\", \"default\"). If the string is \"config1\" or \"config2\", apply an element-wise sine operation to the array. If the string is \"default\", apply an element-wise identity operation. Return the resulting array, preserving the input's shape and data type."
    },
    {
        "instruction": "Develop a function that accepts a string identifier (e.g., \"TypeA\", \"TypeB\"). If the identifier is \"TypeA\", it should return a *new function* that computes the element-wise sine of a 1D numerical array. Otherwise, it should return a *new function* that performs an element-wise identity transformation."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and a boolean flag. If the flag is true, return the element-wise sine of the array. If false, return the array unchanged. Ensure the output matches the input's shape and data type."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns an identical array (an element-wise identity operation). The output must have the same shape and data type as the input."
    },
    {
        "instruction": "Develop a function that takes one argument intended to be a loop count. Before proceeding, check if this argument is a non-negative integer. If it is not a non-negative integer, raise a `TypeError` with the message 'Loop count must be a non-negative integer.'. If the check passes, the function should simply return `True`."
    },
    {
        "instruction": "Create a function that accepts a single argument. It should check if the argument is a whole number (integer). Return `True` if it is an integer, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes an integer `n` and an initial value `carry`. The function should iterate `n` times. In each iteration, it should update the `carry` by applying a simple, predefined operation (e.g., adding 1 to it). Return the final `carry` after `n` iterations."
    },
    {
        "instruction": "Write a higher-order function named `repeat_apply`. It should accept three arguments: an integer `count`, a function `op`, and an initial `value`. The `op` function takes one argument and returns one value. `repeat_apply` must first validate that `count` is a concrete non-negative integer, raising a `TypeError` if not. If valid, it should apply the `op` function to the `value` exactly `count` times, using the result of each application as the input for the next. Return the final result after `count` applications."
    },
    {
        "instruction": "Implement `run_loop(data_list, num_steps, use_fast_path)`. Validate that `num_steps` is a non-negative integer and `use_fast_path` is a boolean. Raise `TypeError` or `ValueError` on failure. If valid, return `num_steps` if `use_fast_path` is true, otherwise return `len(data_list)`."
    },
    {
        "instruction": "Write a function `guarded_runner(runner_func, control_value, payload)`. Before calling `runner_func` (a callable), verify that `control_value` is *either* an integer *or* a boolean. If not, raise a custom `ControlValueError` (assume this error type exists). If valid, call `runner_func(payload, control_value)` and return the result."
    },
    {
        "instruction": "Develop a function `apply_config(settings, input_val)`. `settings` is a dictionary. Check if `settings['level']` is an integer greater than 0 and `settings['active']` is a boolean. Raise a custom `ConfigurationError` (assume this error type exists) if checks fail. Otherwise, return `input_val * settings['level']` if `settings['active']` is true, else `input_val`."
    },
    {
        "instruction": "Write a function `check_int_param(control_param, data)` that raises a `TypeError` if `control_param` is not an integer. Otherwise, it returns `data`."
    },
    {
        "instruction": "Write a function that applies a given processing function `func` to each element of a batch. `func` takes parameters and a 2D array (one sequence) and returns a scalar value. The main function takes the parameters for `func`, a 3D array representing the batch of sequences (batch_size x time_steps x features), and `func`. It should return a 1D array containing the scalar result of applying `func` (with the given parameters) to each sequence in the batch."
    },
    {
        "instruction": "Write a function that accepts two 1D numerical arrays and returns a new 1D array formed by appending the second array to the end of the first."
    },
    {
        "instruction": "Implement a function representing one step in a sequence model. It takes two weight matrices (W_trans, W_out), a current state vector, and an input vector. Concatenate state and input. Compute `next_state = tanh(W_trans @ concatenated)` and `output = tanh(W_out @ concatenated)`. Return the `next_state` vector and the `output` vector."
    },
    {
        "instruction": "Develop a function that simulates a recurrent process over a sequence. It accepts parameters (like weights), an initial state vector (e.g., all zeros), and a sequence of input vectors (as a 2D array: time_steps x features). Using a step function (like Task 2's logic) internally, it iterates through the input sequence, updating the state and generating an output at each step. Return the sequence of all outputs as a 2D array (time_steps x output_features)."
    },
    {
        "instruction": "Develop a function that takes a positive integer `N`. It should generate and return a list of all coordinate pairs `(row, column)` corresponding to the lower triangular part (including the main diagonal) of an N x N matrix. That is, all pairs `(i, j)` such that `0 <= j <= i < N`."
    },
    {
        "instruction": "Write a function that takes a square 2D numerical array (matrix) as input. It should create and return a *new* matrix of the same dimensions, containing only the elements from the lower triangle (including the main diagonal) of the input matrix. All elements above the main diagonal in the output matrix should be zero. Use nested iteration to access elements and construct the new matrix."
    },
    {
        "instruction": "Implement a function that takes a square 2D numerical array (matrix). Using iteration, create and return a new 1D array containing all elements from the main diagonal of the input matrix."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and two integer indices (row, column). Return the element located at that specific row and column index."
    },
    {
        "instruction": "Design and implement a function that takes a 1D numerical array. This function should compute a sum based on applying a 'safe square root' element-wise (if element `x < threshold`, use `threshold`, else use `sqrt(x)`). The implementation must be carefully constructed to ensure that its *gradient* (if computed) would be numerically stable and avoid producing `NaN` or `Infinity`, especially for input arrays containing zeros or values close to the threshold. Return the final sum."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and a small positive threshold `t`. For each element `x` in the array, calculate a value: `t` if `x < t`, otherwise the square root of `x`. Return the sum of all these calculated values."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array as input and returns `True` if the array contains at least one Not-a-Number (NaN) value, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and applies a given scalar transformation function `f` to each element. It should return a new 1D array containing the results of applying `f` to each element of the input array."
    },
    {
        "instruction": "Create a function that iteratively applies an update rule for a fixed number of steps. It takes an initial state (e.g., a 1D numerical array), an update function `update_fn(state)` which returns the next state, and a number of iterations `N`. Return the final state after `N` applications."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `conf` and a scalar `param`. It should return the scalar result of summing all elements of `conf` multiplied by `param`."
    },
    {
        "instruction": "Implement a function that performs a single step of gradient descent. It should accept a current 1D numerical array `x`, a function `grad_fn` that computes the gradient of an energy function at `x`, and a scalar `step_size`. It should return the updated 1D array `x - step_size * grad_fn(x)`."
    },
    {
        "instruction": "Develop a function that simulates minimizing an energy function for a fixed number of steps using gradient descent. Inputs are an initial 1D numerical array `x0`, a function `gradient_fn(x)` that computes the gradient of the energy at `x`, a scalar `step_size`, and an integer `num_steps`. Return the final 1D array after `num_steps` iterations of `x = x - step_size * gradient_fn(x)`."
    },
    {
        "instruction": "Write a function that takes a tuple of four numbers (a, b, c, d) and returns a new tuple where the elements are shifted left, and the last element is replaced by 0.0. Specifically, the output should be (b, c, d, 0.0)."
    },
    {
        "instruction": "Write a function that takes a list or 1D array of initial numerical values. For each value, it should construct an initial state tuple (0.0, 1.0, 2.0, value) and then apply a 2-step update process (where each step transforms state (c0, c1, c2, c3) to (c1, c2, c3, 0.0)). Return a list containing the final state tuple for each initial value."
    },
    {
        "instruction": "Create a function that accepts a single numerical value 'x' and constructs an initial state tuple (0.0, 1.0, 2.0, x). Return this tuple."
    },
    {
        "instruction": "Implement a function that simulates a fixed 2-step state update process. It takes an initial 4-element numerical tuple 'state'. In each step, update the state using the rule: (c0, c1, c2, c3) -> (c1, c2, c3, 0.0). Return the state tuple after exactly two update steps."
    },
    {
        "instruction": "Write a function that takes an integer `n` and returns a 1D numerical array (vector) of size `n` containing all zeros."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `A` (shape M, N), an initial 1D array `x0` (shape N,), and a positive integer `k`. The function should iteratively update the vector `k` times using the rule `x_next = A @ x_current`, starting with `x_current = x0`. Return the final vector after `k` iterations."
    },
    {
        "instruction": "Create a function that calculates the sum of all elements in a 1D numerical array (vector) and returns the resulting scalar value."
    },
    {
        "instruction": "Implement a function that performs matrix-vector multiplication. It should accept a 2D numerical array (matrix) of shape (M, N) and a 1D array (vector) of shape (N,) and return a 1D array (vector) of shape (M,)."
    },
    {
        "instruction": "Write a function that takes a boolean condition and two arguments (value_if_true, value_if_false). Return `value_if_true` if the condition is true, otherwise return `value_if_false`. The arguments can be of any basic type."
    },
    {
        "instruction": "Implement a function that accepts a boolean condition and two functions, `func_true` and `func_false` (both taking no arguments). Execute and return the result of `func_true` if the condition is true, otherwise execute and return the result of `func_false`."
    },
    {
        "instruction": "Develop a function that generates a 1D numerical array of a specified `size` (integer) where every element is initialized to a given `fill_value` (number). Return the newly created array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and an integer index. Return the element located at that index within the array. If the index is out of bounds, return a default value like None or 0."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array (e.g., a list of integers). For each element, use its value as a starting number and its position (index) in the array as a limit. Repeatedly add 2 to the starting number while it is less than the limit (index). Return a new 1D array of the same size containing the resulting numbers."
    },
    {
        "instruction": "Write a function that takes a 1D array of integers. For each element at index `i` with value `v`, initialize a counter to `v`. While the counter is strictly less than `i`, check if `i` is even or odd. If `i` is even, add 3 to the counter; otherwise (if `i` is odd), add 1 to the counter. Return a new 1D array containing the final counter value for each element."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical array. It should return a new 1D array of the same length, where the element at each position is simply its own index."
    },
    {
        "instruction": "Write a function that accepts two integers: `initial_value` and `limit`. Repeatedly add 2 to `initial_value` as long as it remains strictly less than `limit`. Return the final `initial_value`."
    },
    {
        "instruction": "Implement a function that takes one numerical input `x`. It should compute `y = 2 * x` and return a tuple containing `y` and `2 * y`."
    },
    {
        "instruction": "Create a function that accepts a single number `x`. If `x` is strictly less than 3, return a tuple containing the number repeated twice. Otherwise, return a tuple containing `(-1, -1)`."
    },
    {
        "instruction": "Create a higher-order function that takes three arguments: a condition-checking function (which takes one argument and returns boolean), a 'true case' function (which takes one argument), and a 'false case' function (which takes one argument). The higher-order function should also take a fourth argument: an operand. It should apply the condition-checking function to the operand. If the result is true, it calls the 'true case' function with the operand and returns the result. Otherwise, it calls the 'false case' function with the operand and returns its result."
    },
    {
        "instruction": "Write a function that takes a single number as input and returns `True` if the number is strictly less than 3, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a single number. If the number is zero, return the result of adding the number to itself. Otherwise, return the result of multiplying the number by itself."
    },
    {
        "instruction": "Create a function that takes a boolean value and a number. If the boolean is true, return the number unchanged. If the boolean is false, return the number negated."
    },
    {
        "instruction": "Implement a function named `execute_conditionally`. It should accept a boolean condition, two callable functions (let's call them `action_if_true` and `action_if_false`), and a single data value. If the condition is true, the function should call `action_if_true` with the data value and return its result. Otherwise, it should call `action_if_false` with the data value and return its result."
    },
    {
        "instruction": "Write a function that takes one numerical input and returns a boolean value indicating whether the input is equal to zero."
    },
    {
        "instruction": "Write a function that accepts three numerical inputs and returns their sum."
    },
    {
        "instruction": "Implement a function that takes a single numerical input `x`. If `x` is exactly 0, the function should return the result of adding `x` to itself twice (x + x + x). Otherwise, it should return the result of multiplying `x` by itself twice (x * x * x)."
    },
    {
        "instruction": "Create a function named `execute_conditionally` that takes one numerical input `val`, and two functions, `f_zero` and `f_nonzero`. If `val` is 0, call `f_zero` with `val`, `val`, `val` as arguments and return its result. Otherwise, call `f_nonzero` with `val`, `val`, `val` as arguments and return its result. Assume `f_zero` and `f_nonzero` each accept three numerical arguments."
    },
    {
        "instruction": "Write a function that accepts three numerical inputs and returns their product."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x` and returns a tuple containing `x` and `x`."
    },
    {
        "instruction": "Implement a function that takes an integer `i` and returns an index based on these rules: return 0 if `i <= 0`, return 1 if `i == 1`, and return 2 if `i > 1`."
    },
    {
        "instruction": "Create a function that accepts a single numerical input `x`, calculates `y = 2 * x`, and returns a tuple `(y, 2 * y)`."
    },
    {
        "instruction": "Develop a function that takes an integer `selector` and a list of exactly three functions `options`. Each function in `options` accepts one numerical argument and returns a tuple. Your function should select and call a function from `options` based on the `selector` value: use `options[0]` if `selector <= 0`, `options[1]` if `selector == 1`, and `options[2]` if `selector > 1`. The function should pass the `selector` itself as the argument to the chosen function and return the result."
    },
    {
        "instruction": "Create a function that accepts two arguments: a function `func` and a numerical value `val`. The function `func` is guaranteed to accept exactly two numerical arguments. Your function should call `func` with `val` provided as both the first and second argument and return the result."
    },
    {
        "instruction": "Write a function that takes a single number `x`. It should return the integer 0 if `x` is less than or equal to 0, and the integer 1 otherwise."
    },
    {
        "instruction": "Write a function named `select_and_apply`. It takes a numerical value `operand` and a list `operations` containing exactly two functions. The first function performs addition of two numbers, and the second performs multiplication. If `operand` is non-positive (<= 0), use the first function (addition). If `operand` is positive (> 0), use the second function (multiplication). Apply the selected function to the `operand` (passed as both arguments to the chosen function) and return the result."
    },
    {
        "instruction": "Implement a function that takes a single number `x`. If `x` is less than or equal to 0, the function should return the result of `x + x`. If `x` is greater than 0, it should return the result of `x * x`."
    },
    {
        "instruction": "Develop a function `validate_input_type` that accepts one argument. If the argument is a number (integer or float), return `True`. If the argument is a string or a list, the function must raise a `TypeError`. For any other type, return `False`."
    },
    {
        "instruction": "Write a function `apply_conditional_logic` that takes a single argument `pred`. It should internally determine if `pred` is numerically zero or non-zero. Based on this, it conditionally executes one of two internal paths, finally returning a tuple `(result_boolean, original_pred)`. The function must raise a `TypeError` if `pred` is a string or a list."
    },
    {
        "instruction": "Create a function `package_output` that takes one argument `data`. It should return a tuple where the first element is a boolean indicating if the input was non-zero (True) or zero (False), and the second element is the original `data`. Assume input is numerical."
    },
    {
        "instruction": "Implement a function `conditional_return` that takes a single numerical input `value`. If `value` is non-zero (evaluates to true), return the tuple `(True, value)`. If `value` is zero (evaluates to false), return the tuple `(False, value)`."
    },
    {
        "instruction": "Create a function that accepts a single number `x`. If `x < 2`, return `2 * x`. If `x` is between 2 (inclusive) and 5 (exclusive), return `3 * x`. Otherwise (if `x >= 5`), return `4 * x`."
    },
    {
        "instruction": "Implement a function that replicates nested conditional logic using function composition. It should take an input value `x`. Define helper functions for comparison (`is_less_than_2`, `is_less_than_5`) and multiplication (`multiply_by_2`, `multiply_by_3`, `multiply_by_4`). Combine these using a structure that first checks `is_less_than_2(x)`. If true, call `multiply_by_2(x)`. If false, then check `is_less_than_5(x)`. If true, call `multiply_by_3(x)`, otherwise call `multiply_by_4(x)`. Return the final result."
    },
    {
        "instruction": "Write a function that takes a single number `x`. If `x` is less than 2, return `2 * x`. Otherwise (if `x` is 2 or greater), return `3 * x`."
    },
    {
        "instruction": "Implement a function that acts as a conditional selector using functions. It takes a boolean condition, a function `true_fn`, and a function `false_fn`, along with an input value `val`. If the condition is true, it calls `true_fn(val)` and returns its result. Otherwise, it calls `false_fn(val)` and returns its result."
    },
    {
        "instruction": "Implement a function that takes a numerical input `val` and a numerical threshold `t`. It should return the number 100.0 if `val` is less than or equal to `t`, and return `val` otherwise."
    },
    {
        "instruction": "Create a function that takes one numerical input. If the input is greater than or equal to 10, return the integer 0. Otherwise, return the input value itself."
    },
    {
        "instruction": "Write a function that accepts a single number. If this number is strictly less than 3, the function should return the floating-point number 5.0. Otherwise, it should return the original number unchanged."
    },
    {
        "instruction": "Write a function that takes a list of numbers and a threshold value. Return a *new* list of the same size where each element is either the string \"below\" if the corresponding input number was less than the threshold, or the string \"at_or_above\" otherwise."
    },
    {
        "instruction": "Write a function that takes a single number `x` as input and always returns a 3-element tuple `(x, 2.0, 4.0)`, where the first element is the input number and the others are fixed floating-point constants."
    },
    {
        "instruction": "Create a function that accepts a single number. If the number is strictly less than 3, return the tuple `(1, 2.0, 3.0)`. Otherwise, return the tuple `(0, 2.0, 4.0)`. Ensure the output is always a tuple of three numerical values with potentially mixed types (integer, float)."
    },
    {
        "instruction": "Implement a function that takes one numerical input `x`. It should return a tuple of three numbers. If `x` is strictly less than 3, the tuple should be `(1, 2.0, 3.0)`. If `x` is 3 or greater, the tuple should be `(x, 2.0, 4.0)`. The types within the tuple can be mixed."
    },
    {
        "instruction": "Develop a function that takes a numerical input `val`. Based on a condition (e.g., `val < 3`), it should return one of two predefined 3-element tuples containing numerical values. The first tuple should contain specific constant values (e.g., `(1, 2.0, 3.0)`), while the second tuple should use the input `val` as its first element and constants for the others (e.g., `(val, 2.0, 4.0)`)."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical array. It should produce a new array of the same dimensions where each element is 0 if the corresponding input element was positive (> 0), and 1 otherwise."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and returns a boolean array of the same size. Each element in the output array should be `True` if the corresponding element in the input array is greater than 0, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a single number. Return 0 if the number is positive (greater than 0), and 1 otherwise."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array. For each element, if it is less than 5, the corresponding output element should be 100; otherwise, it should be 200. Return the resulting array."
    },
    {
        "instruction": "Develop a function that performs a cumulative sum scan on a 1D numerical array. It should accept the array and a boolean flag indicating the direction (forward if false/default, reverse if true). Return the resulting array of cumulative sums."
    },
    {
        "instruction": "Implement a function to compute the reverse cumulative sum of a 1D numerical array. For input `[a, b, c, d]`, the output should correspond to `[a+b+c+d, b+c+d, c+d, d]`."
    },
    {
        "instruction": "Write a function that calculates the forward cumulative sum of a 1D numerical array. Given an input array `[a, b, c, ...]`, it should return `[a, a+b, a+b+c, ...]`."
    },
    {
        "instruction": "Create a function that reverses the order of elements in a given 1D array. Input `[a, b, c]` should produce `[c, b, a]`."
    },
    {
        "instruction": "Implement a function to calculate the cumulative sum of elements along a specified positive axis (dimension index) in a multi-dimensional numerical array. The output must have the same dimensions as the input."
    },
    {
        "instruction": "Modify the cumulative sum function to support negative axis indexing (e.g., -1 refers to the last axis). Ensure it works correctly for input arrays with 2 or more dimensions."
    },
    {
        "instruction": "Create a function that takes a list representing dimensions (shape) and generates a multi-dimensional numerical array of that shape filled with consecutive integers starting from zero."
    },
    {
        "instruction": "Develop a robust function that computes the inclusive prefix sum (cumulative sum using addition) along a given axis (positive or negative) for a multi-dimensional numerical array. It must handle arrays with a dimension of size zero and return an output array of the identical shape."
    },
    {
        "instruction": "Create a function that calculates the reverse cumulative sum of a 1D array of numbers. The i-th element of the output array should be the sum of all elements from index i to the end of the input array. The output array must have the same size as the input."
    },
    {
        "instruction": "Implement a function that computes the forward cumulative sum of a 1D array of numbers. The i-th element of the output should be the sum of the first i+1 elements of the input. The output array should have the same size as the input."
    },
    {
        "instruction": "Implement a generic scan function for a 1D array. It should accept the input array, a binary associative function (e.g., add, multiply), and a boolean flag indicating the direction (True for reverse, False for forward). Return a new 1D array of the same size containing the scan results."
    },
    {
        "instruction": "Write a function that takes a 1D array of numbers and returns a new 1D array containing the elements of the input array in reverse order."
    },
    {
        "instruction": "Write a function `select_and_run(index, functions_list, argument)` that selects an item from `functions_list` using `index` and attempts to call it with `argument`. Before selection, it must validate that *all* items in `functions_list` are callable. If any item is not callable, raise a `TypeError` indicating that the list should only contain callables. If the index is invalid for the list, raise an `IndexError`. Otherwise, return the result of the selected function call."
    },
    {
        "instruction": "Implement a function `apply_if_callable(func, value)` that attempts to call `func` with `value` as an argument. If `func` is not callable, it should raise a `TypeError` with a message indicating a callable argument was expected. Otherwise, it returns the result of `func(value)`."
    },
    {
        "instruction": "Create a function `conditional_execute(condition, true_func, false_func, value)` that executes `true_func(value)` if `condition` evaluates to true, and `false_func(value)` otherwise. Before execution, it must check if *both* `true_func` and `false_func` are callable. If either is not, it should raise a `TypeError` indicating which argument was expected to be callable."
    },
    {
        "instruction": "Design a function `repeat_action(n_times, action_func, initial_state)` that calls `action_func(current_state)` exactly `n_times` (where `n_times` is a non-negative integer), updating the state with the return value each time. It must first verify that `action_func` is callable. If not, raise a `TypeError` stating a callable action was expected. Return the final state."
    },
    {
        "instruction": "Implement a function `conditional_operation` that takes a boolean flag, a number `num`, and an object `container` (which has a numerical attribute `value`). Define two internal functions: one that adds `num` and `container.value`, and another that subtracts `container.value` from `num`. The `conditional_operation` function should execute the addition if the flag is true, and the subtraction if false, returning the numerical result."
    },
    {
        "instruction": "Write a function `select_and_apply` that takes a boolean condition, two functions (`func_true`, `func_false`), and two numerical arguments (`arg1`, `arg2`). If the condition is true, it should return the result of `func_true(arg1, arg2)`; otherwise, it should return the result of `func_false(arg1, arg2)`."
    },
    {
        "instruction": "Create a simple class `ValueContainer` that stores a single numerical value in an attribute named `value` during initialization. Then, write a function that takes an instance of `ValueContainer` and returns the stored `value`."
    },
    {
        "instruction": "Write a function `process_conditionally` that accepts a boolean condition, two functions (`op_true`, `op_false`), and two arguments (`arg1`, `arg2`). These arguments can be either numbers or instances of a `DataWrapper` class (which has a numerical attribute `data`). The provided functions (`op_true`, `op_false`) must correctly handle combinations where arguments might be numbers or `DataWrapper` instances (e.g., by accessing `.data` when needed). The function should return the result of applying the selected function (`op_true` if condition is true, `op_false` otherwise) to `arg1` and `arg2`. Ensure the implementation works correctly for all four type combinations (number/number, number/wrapper, wrapper/number, wrapper/wrapper)."
    },
    {
        "instruction": "Write a function that accepts a single value. It should raise a `TypeError` with the message 'Predicate type must be boolean or number' if the input value's type is not a boolean or a number (int/float)."
    },
    {
        "instruction": "Create a function that takes a single value. It should raise a `TypeError` with the message 'Predicate must be a scalar' if the input value is not a scalar (e.g., it's a list, tuple, string, or other non-scalar type)."
    },
    {
        "instruction": "Develop a function `check_type_shape_match(val1, val2)` that compares two values. If both are numerical arrays, raise a `TypeError` with a message indicating mismatch if they do not have the exact same element data type AND the exact same shape. If they are other types, check for exact type equality and raise `TypeError` if types differ."
    },
    {
        "instruction": "Implement a function `check_structure_match(struct1, struct2)` that compares two data structures (e.g., dictionaries, lists). Raise a `TypeError` with a message indicating a structure mismatch if they do not have the exact same nesting and keys/indices. For example, `{'a': 1}` matches `{'a': 2}` structurally, but not `{'a': (1, 2)}` or `{'b': 1}`."
    },
    {
        "instruction": "Develop a function for element-wise conditional logic across three arrays. It receives three 1D numerical arrays of the same length: `condition_array`, `true_array`, and `false_array`. Produce a result array where the i-th element is `true_array[i]` if `condition_array[i]` is less than 3, and the negation of `false_array[i]` otherwise."
    },
    {
        "instruction": "Create a function that applies a conditional operation element-wise using a scalar condition. It accepts a scalar number `condition_val`, and two 1D numerical arrays `true_array` and `false_array` (assume they have the same length). If `condition_val` is less than 3, return `true_array`. Otherwise, return a new array containing the negation of each element in `false_array`."
    },
    {
        "instruction": "Implement a function that performs an element-wise conditional operation based on an array of conditions and broadcasts a scalar value for one branch. It takes a 1D numerical array `condition_array`, a 1D numerical array `true_array` (same length as `condition_array`), and a scalar number `false_val`. Return a new array where the i-th element is `true_array[i]` if `condition_array[i]` is less than 3, otherwise it's the negation of `false_val`."
    },
    {
        "instruction": "Write a function that computes the element-wise negation of a 1D numerical array. It takes one 1D array as input and returns a new 1D array of the same size, where each element is the arithmetic negative of the corresponding input element."
    },
    {
        "instruction": "Write a function named `apply_conditional_logic`. It should accept three arguments: a boolean `condition`, a function `func_if_true`, and a function `func_if_false`. Both `func_if_true` and `func_if_false` accept a single scalar argument and return a tuple of two scalars. `apply_conditional_logic` should also accept a fourth argument, a scalar `operand`. If `condition` is true, the function should call `func_if_true` with `operand` and return its result. Otherwise, it should call `func_if_false` with `operand` and return its result."
    },
    {
        "instruction": "Implement a function that receives a boolean value `use_first_path` and a scalar number `value`. If `use_first_path` is true, return `(value, value)`. If `use_first_path` is false, calculate `doubled_value = 2 * value` and return `(doubled_value, 2 * doubled_value)`."
    },
    {
        "instruction": "Write a function that takes a single scalar number `x`. If `x` is less than 3.0, it should return a tuple containing `x` repeated twice, i.e., `(x, x)`. Otherwise, it should return the input unchanged."
    },
    {
        "instruction": "Develop a function that takes one scalar number `input_val`. It must return a tuple of two scalar numbers. The logic is: if `input_val < 3.0`, the output tuple is `(input_val, input_val)`; otherwise, the output tuple is `(2 * input_val, 4 * input_val)`."
    },
    {
        "instruction": "Develop a function that computes both the value and the derivative of a specific piecewise function at a given numerical input `x`. The function is `f(x) = 2.0` if `x < 3`, and `f(x) = 2.0 * x` if `x >= 3`. Return a pair `(value, derivative)`. Assume the derivative at the point `x=3` is the derivative of the second piece (i.e., 2.0)."
    },
    {
        "instruction": "Create a function that accepts three arguments: a boolean condition, a numerical value `val`, and another numerical value `ignored_val`. If the condition is true, it should return a constant 2.0 (ignoring `val` and `ignored_val`). If the condition is false, it should apply a specific operation (multiply by 2.0) to `val` and return the result (ignoring `ignored_val`)."
    },
    {
        "instruction": "Implement a function that takes a single numerical input `x` and always returns the result of multiplying `x` by 2.0."
    },
    {
        "instruction": "Write a function that evaluates a piecewise function defined as follows: `f(x) = 2.0` for `x < 3`, and `f(x) = 2.0 * x` for `x >= 3`. The function should take `x` as input and return `f(x)`."
    },
    {
        "instruction": "Create a function that accepts a single numerical input `x` and returns the cosine of `x`. This represents the derivative of the trigonometric part (`sin(x)`) of a potential piecewise function."
    },
    {
        "instruction": "Implement a function that takes a single numerical input `x` and returns the constant value `3.0`. This represents the derivative of the linear part (`3.0 * x`) of a potential piecewise function."
    },
    {
        "instruction": "Write a function `approximate_derivative` that takes another function `func` (which accepts a single number and returns a single number) and a numerical point `x`. It should return a numerical approximation of the derivative of `func` at `x` using the central difference method `(func(x + h) - func(x - h)) / (2 * h)`, using a small default value for `h` (e.g., 1e-5)."
    },
    {
        "instruction": "Develop a function that computes the derivative of a specific piecewise function based on an input condition. It takes a numerical input `x`. If `x` is strictly less than 2, it should return 3.0. Otherwise, it should return the cosine of `x`."
    },
    {
        "instruction": "Develop a function that accepts a 1D numerical array `x` of size 2. If the first element `x[0]` is less than 2.0, the function should return the element-wise product of `x` and `[1.0, 2.0]`. Otherwise, it should return the element-wise sine of `x`."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and returns a new 1D array of the same size where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array `v` of size 2 and returns a new 1D array computed by element-wise multiplication of `v` with the constant array `[1.0, 2.0]`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns `True` if its first element is less than 2.0, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that computes the analytical derivative of a specific piecewise function `f(x)`. The function `f(x)` is defined as: `f(x) = C` (a constant) if `x < T` (a threshold), and `f(x) = A*x + B` if `x >= T`. Your derivative function should take the input `x`, and the parameters `T`, `C`, `A`, `B`. Return the derivative value. At the point `x=T`, return the derivative corresponding to the `x >= T` case (which is `A`)."
    },
    {
        "instruction": "Write a function that numerically estimates the derivative of a given single-variable function `f` at a point `x`. Use the central difference formula: `(f(x + epsilon) - f(x - epsilon)) / (2 * epsilon)`, where `epsilon` is a small positive value (e.g., 1e-6). The function should accept the function `f`, the point `x`, and `epsilon` as arguments and return the estimated derivative as a numerical value."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x`. If `x` is less than 3, return the constant value 2.0. Otherwise, return the value `2.0 * x`."
    },
    {
        "instruction": "Create a function `conditional_execute` that takes a boolean condition, two callable functions (`true_branch`, `false_branch`), and a numerical input value `x`. If the condition is true, the function should call `true_branch(x)` and return its result. Otherwise, it should call `false_branch(x)` and return its result. Assume both branches accept `x` and return a numerical value."
    },
    {
        "instruction": "Develop a function that calculates the derivative of a trigonometric function. It should accept a scalar numerical input `v`, a scalar constant `C`, and a string identifier ('sin' or 'cos'). If the identifier is 'sin', it returns the derivative of `C * sin(v)` with respect to `v`. If 'cos', it returns the derivative of `C * cos(v)` with respect to `v`."
    },
    {
        "instruction": "Create a function that takes two scalar numerical inputs, `x` and `y`. It should return `2.0 * cos(y)` if `x` is less than 3.0, and `0.0` otherwise. This represents the analytical partial derivative with respect to `y` of the function described in Task 1."
    },
    {
        "instruction": "Write a function `check_gradient_y` that takes a two-variable function `f(x, y)`, its analytical partial derivative function `grad_f_y(x, y)` (which computes \u2202f/\u2202y), input values `x_val`, `y_val`, and a small step `epsilon`. It should compute the numerical gradient of `f` with respect to `y` at `(x_val, y_val)` using the central difference formula `(f(x_val, y_val + epsilon) - f(x_val, y_val - epsilon)) / (2 * epsilon)`. The function should return `True` if the absolute difference between the numerical gradient and the analytical gradient `grad_f_y(x_val, y_val)` is below a small tolerance (e.g., 1e-5), and `False` otherwise."
    },
    {
        "instruction": "Implement a higher-order function `conditional_executor` that takes a boolean condition, two functions (`func_true`, `func_false`), and two corresponding arguments (`arg_true`, `arg_false`). If the condition is true, it should call `func_true(arg_true)` and return the result. Otherwise, it should call `func_false(arg_false)` and return its result."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x`. If `x` is less than 2.0, it returns `3.0 * x`. Otherwise, it returns the sine of `x`."
    },
    {
        "instruction": "Create a function that calculates the derivative of the function `f(y) = sin(y)` evaluated at a specific point `p`. The function should take `p` and another numerical input `v`, and return the result of `cos(p) * v`."
    },
    {
        "instruction": "Write a function that takes a numerical point `p`. It should return two results: first, the value of a piecewise function evaluated at `p`, and second, a *new function*. The piecewise function is `f(y) = 3.0 * y` if `y < 2.0` and `f(y) = sin(y)` otherwise. The *new function* returned should accept a single numerical input `v` and compute the product of the derivative of `f` (evaluated at `p`) and `v`. The correct derivative (`3.0` or `cos(p)`) must be used based on the value of `p`."
    },
    {
        "instruction": "Implement a function that calculates the derivative of the function `g(y) = 3.0 * y`. Since the derivative is constant (3.0), the function should take a numerical input `v` and simply return `3.0 * v`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (vector) and returns a new 1D array where each element is multiplied by the corresponding element in the constant vector [1.0, 2.0]. Assume the input vector has the same size as the constant vector."
    },
    {
        "instruction": "Develop a function that calculates and returns the sum of all elements in a given 1D numerical array (vector)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array (vector) and returns a new 1D array where each element `y_i` is the result of applying the cosine function to the sine of the corresponding input element `x_i` (i.e., `y_i = cos(sin(x_i))`)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `x` of size 2. If the first element `x[0]` is less than 2.0, the function should return a new 1D array calculated as `[1.0 * x[0], 2.0 * x[1]]`. Otherwise, it should return a new 1D array where each element `y_i` is `cos(sin(x_i))`."
    },
    {
        "instruction": "Write a function that accepts a single number as input and returns its cube."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array. For each element `x` in the array, it should calculate the derivative of `x**2` if `x > 0`, or the derivative of `x**3` if `x <= 0`. Return a new 1D array containing these calculated derivative values."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array and applies a given single-argument numerical function to each element independently. Return a new 1D array containing the results."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and two callable functions, `func_pos` and `func_nonpos`. It should return a new 1D array where `func_pos` is applied to elements strictly greater than zero, and `func_nonpos` is applied to elements less than or equal to zero."
    },
    {
        "instruction": "Develop a function that accepts a boolean predicate, two distinct data pairs (e.g., tuples/lists of numbers), and two functions. If the predicate is true, apply the first function to the first data pair and return the result. Otherwise, apply the second function to the second data pair and return the result. Assume the functions are compatible with their corresponding pairs."
    },
    {
        "instruction": "Write a function that accepts a boolean value and two numerical values. If the boolean is true, return the first numerical value; otherwise, return the second numerical value."
    },
    {
        "instruction": "Create a function that takes a pair of numbers (e.g., a tuple or list of length 2). It should return a new pair where the first number is the same as the input's first number, and the second number is always zero."
    },
    {
        "instruction": "Design a flexible conditional execution function. It should take a boolean flag, two arbitrary input data structures, and two transformation functions. Based on the flag, it selects the corresponding input and applies the corresponding transformation function to it, returning the output. The function should gracefully handle potential mismatches if a transformation function cannot process its assigned input data structure (e.g., by returning a specific error indicator or a default value)."
    },
    {
        "instruction": "Develop a function taking two numbers, `initial_value` and `multiplier`. Run a process exactly twice. Start with `initial_value`. In each step, update the current value by multiplying it by `multiplier`. Return the value after two steps."
    },
    {
        "instruction": "Create a function taking two numbers, `start` and `end`. Simulate a loop that runs `end - start` times, initialized with `start`. In each step, the value remains unchanged. Return the final value."
    },
    {
        "instruction": "Write a function that takes an initial numerical `carry` and a list containing two numbers. Iterate through the list. For each element, perform a 2-step calculation: start with the current `carry`, and in each step, multiply it by the *previous* carry value (use the initial `carry` as the 'previous' for the first element). Update the `carry` with the result of this 2-step calculation. Return the final `carry` after processing both elements."
    },
    {
        "instruction": "Write a function that accepts a starting number. Increment the number by 1 repeatedly as long as it is less than 5.0. Return the final number."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays of size 3 (let's call them `primary_input` and `secondary_input`). It must return *two* separate 1D arrays: the first is `primary_input` element-wise multiplied by `[0, 1, 2]`, and the second is `secondary_input` element-wise multiplied by `[0, 1, 2]`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and multiplies each element by its corresponding index (i.e., first element by 0, second by 1, third by 2, and so on). Return the resulting 1D numerical array."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array `x` assumed to be of size 3. Define a constant 1D array `c = [0, 1, 2]`. Return a new 1D array resulting from the element-wise multiplication of `x` and `c`."
    },
    {
        "instruction": "Create a function that accepts a boolean condition, two functions (`func_true`, `func_false`), and an input value. If the condition is true, it calls `func_true` with the input and returns its result; otherwise, it calls `func_false` with the input and returns its result."
    },
    {
        "instruction": "Write a function `select_and_apply` that takes a predicate function `pred` (which accepts a value and returns a boolean), two transformation functions `transform_if_true` and `transform_if_false`, and an input `value`. The function should first evaluate `pred(value)`. If the result is true, it should apply `transform_if_true` to `value` and return the result. Otherwise, it should apply `transform_if_false` to `value` and return the result."
    },
    {
        "instruction": "Write a function `conditional_apply` that takes a boolean `condition`, two functions `func_true` and `func_false`, and a value `operand`. If `condition` is true, it should return the result of calling `func_true(operand)`. Otherwise, it should return the result of calling `func_false(operand)`."
    },
    {
        "instruction": "Create two simple functions: `add_one` which takes a number and returns the number plus 1, and `add_two` which takes a number and returns the number plus 2."
    },
    {
        "instruction": "Develop a function `is_non_zero` that accepts an integer as input and returns `True` if the integer is not equal to 0, and `False` otherwise."
    },
    {
        "instruction": "Create a function `apply_twice` that takes another function `f` and a value `x` as input. It should return the result of applying `f` to `x` twice, i.e., `f(f(x))`."
    },
    {
        "instruction": "Write a function that computes the element-wise gradient (derivative) of another function `h` applied to each element of a 1D numerical input array. Assume `h` is a simple mathematical function with a known derivative (e.g., identity, square, etc.) and contains conditional logic based on the input value."
    },
    {
        "instruction": "Develop a function that accepts a single number. If the number is less than zero, return the number unchanged. If the number is zero or positive, return the number unchanged."
    },
    {
        "instruction": "Write a function that takes a single number as input. If the number is negative, return the number itself. Otherwise, return the number itself."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical array `input_arr` and a scalar value `scalar_val`. It must return two items: first, a *new* 1D array of the same size as `input_arr` where element `i` is `input_arr[i] * 2` if `input_arr[i] < 3`, else `input_arr[i] * 3`; second, the original `scalar_val` unchanged."
    },
    {
        "instruction": "Write a function that accepts two numerical inputs, `x` and `y`. If `x` is less than 3, return the tuple `(x * 2, y)`. Otherwise, return the tuple `(x * 3, y)`."
    },
    {
        "instruction": "Create a function that takes a positive integer `N` and returns a 1D numerical array containing the sequence of integers [0, 1, ..., N-1]."
    },
    {
        "instruction": "Develop a function `apply_elementwise_with_scalar` that takes three arguments: a binary function `op` (accepting two scalars, returning one scalar), a 1D numerical array `data`, and a scalar `constant`. The function should return a *new* 1D array where the i-th element is the result of `op(data[i], constant)`."
    },
    {
        "instruction": "Implement a function that takes a boolean flag, an integer `n`, a function `double_it` (which doubles an integer), and a function `halve_it` (which halves an integer). If the flag is true, return `double_it(n)`. Otherwise, return `halve_it(n)`. Ensure `halve_it` can return a non-integer result."
    },
    {
        "instruction": "Create a function that accepts a single value (e.g., number or string). It should return the exact same value, ensuring the output is consistently wrapped in a basic container like a single-element list."
    },
    {
        "instruction": "Develop a function that accepts a single numerical value (integer or float). It must return the value packaged within a standard list format. For example, input `5.0` should return `[5.0]`."
    },
    {
        "instruction": "Write a function that takes a boolean condition, two single-argument functions (`func_true`, `func_false`), and an operand. Return the result of applying `func_true` to the operand if the condition is true, otherwise return the result of `func_false(operand)`."
    },
    {
        "instruction": "Write a function that takes a 3D numerical array `Input` (shape Dim1 x Dim2 x Dim3) and returns a 2D array `Output` (shape Dim1 x Dim3) where `Output[i, k]` is the sum of `Input[i, j, k]` over the middle index `j`. Use nested loops."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays, A (shape M x K) and B (shape K x N), and computes their matrix product C (shape M x N) using nested loops. C[i, j] should be the sum of A[i, k] * B[k, j] over all k."
    },
    {
        "instruction": "Implement a function that takes a 3D numerical array S (shape N x T x K) and a 2D array W (shape K x D). Compute and return a 2D array R (shape N x D) where R[n, d] is the sum of S[n, t, k] * W[k, d] over all possible values of the indices t and k. Use nested loops."
    },
    {
        "instruction": "Create a function that accepts three numerical arrays: S (shape N x T x K), W (shape K x D), and V (shape D x C). Compute the resulting array L (shape N x C) where L[n, c] is the sum of S[n, t, k] * W[k, d] * V[d, c] over all possible values of t, k, and d. Implement this using explicit loops suitable for floating-point inputs."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (representing random samples) and returns the total count of elements in the array that are finite numbers (i.e., not infinity or NaN)."
    },
    {
        "instruction": "Implement a function to compute the Cumulative Distribution Function (CDF) for the F-distribution. It should take a floating-point value `x` and two positive degrees of freedom (numerator `d1`, denominator `d2`) as input, and return the probability P(F <= x)."
    },
    {
        "instruction": "Write a function that accepts two numerical inputs, representing numerator and denominator degrees of freedom. Return `True` if both inputs are strictly positive numbers, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that compares a 1D array of observed floating-point samples against a theoretical CDF function (which takes a value and returns a probability). Calculate the empirical CDF from the samples. Find the maximum absolute difference between the empirical CDF and the theoretical CDF evaluated at each sample point. Return this maximum difference."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array of non-negative 'parameter' values and an output shape tuple (e.g., `(R, C)` where `C` must equal the length of the parameters array). It should generate and return a 2D numerical array of the specified output shape. The generation process is flexible, but it *must* ensure that if the parameter value at index `j` is 0, then all elements in the j-th column of the output array (`output[:, j]`) are also 0."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) and an integer `K`. It should return a new 2D array containing only the first `K` columns of the input array, preserving the number of rows."
    },
    {
        "instruction": "Write a function that accepts two 2D numerical arrays of the exact same shape. It should return `True` if all elements in the first array are strictly equal to the corresponding elements in the second array, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes an integer `N` and a positive number `V`. It should return a 1D numerical array of size `2*N`, where the first `N` elements are exactly 0 and the next `N` elements are exactly `V`."
    },
    {
        "instruction": "Develop a function that takes a square 2D numerical array and returns `True` if the matrix is symmetric (equal to its transpose) within a small tolerance, and `False` otherwise."
    },
    {
        "instruction": "Create a function to generate `N` random samples from a multivariate distribution defined by a 1D mean vector and a 2D covariance matrix. Return a 2D array of shape (N, num_dimensions) containing the samples. You may assume access to a standard normal random number generator."
    },
    {
        "instruction": "Implement a function that calculates the empirical covariance matrix from a 2D numerical array. Assume rows are observations and columns are variables. The function should return a square 2D numerical array representing the covariance between columns."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (representing a mean vector) and a 2D numerical array (representing a covariance matrix). Return `True` if the length of the 1D array matches the number of rows (and columns) of the 2D array, assuming the 2D array is square. Return `False` otherwise."
    },
    {
        "instruction": "Write a function that takes an integer `N` and returns two numerical arrays: a 1D array of zeros with shape `(N,)` and a 2D array of ones with shape `(N, N)`."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array representing multiple samples (rows) of several variables (columns). It should take the array and a small tolerance value as input. Return `True` if the first column is element-wise approximately equal to the second column within the given tolerance for all samples, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that checks if a given numerical array contains only Not-a-Number (NaN) values. It should accept an array of any shape and return `True` if all elements are NaN, `False` otherwise."
    },
    {
        "instruction": "Develop a function to detect the presence of any Not-a-Number (NaN) values within a numerical array. It should take an array of any shape and return `True` if at least one element is NaN, `False` otherwise."
    },
    {
        "instruction": "Write a function that generates a 2D numerical array of a given shape (e.g., M rows, N columns) filled with random floating-point numbers between 0.0 and 1.0 (exclusive of 1.0). The function should take the shape tuple (M, N) as input and return the generated array."
    },
    {
        "instruction": "Implement a function that produces a 2D numerical array of shape (M, N) containing random integers. The function should take the shape tuple (M, N), a 1D array `low_bounds` of size N, and a 1D array `high_bounds` of size N (exclusive). For each column `j`, the generated integers must be greater than or equal to `low_bounds[j]` and strictly less than `high_bounds[j]`. Return the M x N array."
    },
    {
        "instruction": "Create a function that generates a 2D numerical array of shape (M, N). It should accept the shape tuple (M, N), a 1D array `min_vals` of size N, and a 1D array `max_vals` of size N. Each column `j` of the output array should contain random floating-point numbers between `min_vals[j]` (inclusive) and `max_vals[j]` (exclusive). Return the resulting M x N array."
    },
    {
        "instruction": "Develop a function that checks if a given numerical array has a specific target shape. The function should accept the array and a tuple representing the target shape (e.g., (10, 2)), returning `True` if the array's shape matches exactly, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts one argument. It should return `True` if the argument is a numerical array containing only integer types, and `False` otherwise (e.g., if it contains floats, strings, or is not an array)."
    },
    {
        "instruction": "Write a function that takes a shape tuple (e.g., (2, 3)) and returns a new numerical array of that shape filled entirely with floating-point zeros."
    },
    {
        "instruction": "Implement a function that takes an input value. If the input value is not a floating-point number or a numerical array containing only floating-point or complex numbers, it should raise a `TypeError`. Otherwise, it should return `True`."
    },
    {
        "instruction": "Write a function that accepts a single argument (which could be any data type, including a numerical array) and always returns the floating-point value `1.0`, effectively ignoring the input."
    },
    {
        "instruction": "Implement a function that takes a data item `X` and an integer `N`. The function should apply a specific, predefined, deterministic operation `Op` (which takes `X` as input) `N` times, collecting the results. Ensure the *exact same* `X` is used for each application of `Op`. Return a collection (e.g., a list or array) of the `N` identical results."
    },
    {
        "instruction": "Create a function that accepts a single 'key' (representing a PRNG state) and an integer `N`. Inside the function, simulate splitting the key into two new keys `N` times, using the *original* input key for each split. Return a data structure containing `N` pairs of keys, ensuring the structure reflects these dimensions (e.g., an N x 2 structure where each element is a key)."
    },
    {
        "instruction": "Design a function that simulates applying an operation `F` multiple times based on a count `N`, where `F` takes a 'state' as input and returns a result. The key constraint is that the *same initial state* must be fed into `F` for each of the `N` applications, regardless of how the applications are scheduled (e.g., sequentially or conceptually in parallel). Verify and return that all `N` results produced by `F` are identical."
    },
    {
        "instruction": "Write a function that takes two data structures (e.g., arrays, lists of lists) assumed to contain numerical or comparable elements. The function should return `True` if the structures have the same shape/dimensions and all corresponding elements are equal, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that generates 1000 floating-point numbers intended to follow a standard normal distribution and calculates their sample mean and sample standard deviation. Return both values."
    },
    {
        "instruction": "Write a function that takes an integer `n` and returns a 1D numerical array of size `n` containing random floating-point numbers sampled from a standard normal distribution (mean 0, standard deviation 1)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array of samples. It should return a function that calculates the empirical cumulative distribution function (ECDF) value for a given input `x`. The ECDF at `x` is the proportion of samples less than or equal to `x`."
    },
    {
        "instruction": "Write a function that takes an initial integer seed and returns a new, distinct integer seed based on the input. This function should aim to produce a sequence of unique seeds when called repeatedly with its own output."
    },
    {
        "instruction": "Develop a function `create_complex_from_components(real_part_array, imag_part_array, complex_type)` that takes two 1D arrays of floating-point numbers (real and imaginary parts) and constructs a 1D array of complex numbers of the specified `complex_type`. Ensure the output array has the same length as the input arrays."
    },
    {
        "instruction": "Create a function `extract_real_imag(complex_array)` that takes a 1D array of complex numbers and returns a tuple containing two 1D arrays: the first with the real parts and the second with the imaginary parts."
    },
    {
        "instruction": "Implement a function `generate_normal_floats(size, scale)` that returns a 1D array of the specified `size` containing floating-point random numbers drawn from a normal distribution centered at 0 with the standard deviation given by `scale`."
    },
    {
        "instruction": "Write a function `generate_scaled_normal_complex(size, scale)` that produces a 1D array of `size` complex numbers. Both the real and imaginary components of these numbers should independently follow a normal distribution with a mean of 0 and a standard deviation specified by `scale`. The function should return the resulting complex array."
    },
    {
        "instruction": "Write a function that computes the lower Cholesky decomposition of a symmetric, positive-definite 2D numerical array (input matrix, shape D x D). Return the lower triangular factor L (shape D x D) such that L @ L.T equals the input matrix."
    },
    {
        "instruction": "Create a function that accepts a square 2D numerical array (factor matrix, shape D x D) and its dimension D. Construct and return a new symmetric, positive definite 2D numerical array (shape D x D) by calculating `factor @ factor.T + D * identity(D)`."
    },
    {
        "instruction": "Develop a function that whitens data. It takes a 2D numerical array of centered data (shape N x D, where mean is already subtracted) and the inverse of a lower triangular matrix (shape D x D, e.g., inverse Cholesky factor of the original covariance). Return the transformed 2D array (shape N x D) obtained by multiplying each centered data vector (row) by the inverse triangular matrix."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (shape N x D) representing N data points in D dimensions, and a 1D array (shape D) representing the mean vector. Return a new 2D array (shape N x D) where the mean vector has been subtracted from each data point (row)."
    },
    {
        "instruction": "Develop a function that takes an input array `data` and an optional positive integer `N`. If `N` is provided, the function returns `N` copies of `data` stacked along a new leading dimension (output shape `(N, *data.shape)`). If `N` is not provided (e.g., is `None`), it should default to stacking 2 copies (output shape `(2, *data.shape)`)."
    },
    {
        "instruction": "Write a function that takes an input array `data` and returns a new array containing two copies of `data` stacked along a new leading dimension. The output shape should be `(2, *data.shape)`."
    },
    {
        "instruction": "Implement a function that takes an input array `data` and a tuple of positive integers `dims`. It should return a new array containing multiple copies of `data`, arranged according to the shape specified by `dims`, followed by the original dimensions of `data`. The output shape should be `(*dims, *data.shape)`."
    },
    {
        "instruction": "Create a function that accepts an input array `data` and a positive integer `N`. It should return a new array containing `N` copies of `data` stacked along a new leading dimension. The output shape should be `(N, *data.shape)`."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array where rows represent samples and columns represent different features. It also accepts a 1D array of thresholds, with one threshold per feature column. The function should return a 1D array where each element represents the count of samples whose value in the corresponding feature column exceeded the threshold for that feature."
    },
    {
        "instruction": "Write a function that takes a single probability value `p` (a float between 0 and 1, exclusive) and calculates a corresponding threshold value using the formula `-log(-log(1 - p))`. Return the calculated float threshold."
    },
    {
        "instruction": "Write a function that estimates a probability through simulation. It accepts three arguments: `samples_per_batch` (integer), `num_batches` (integer), and `threshold` (float). Inside, simulate `num_batches` iterations. In each iteration, generate `samples_per_batch` random numbers (e.g., uniform floats [0,1]), count how many exceed the `threshold`. Sum these counts across all batches and return the final estimated probability (total count / (`samples_per_batch` * `num_batches`))."
    },
    {
        "instruction": "Implement a function to generate a 2D numerical array of pseudo-random floating-point numbers. The function should take two integers, `rows` and `cols`, and return an array of the specified shape filled with random numbers (e.g., uniformly distributed between 0 and 1)."
    },
    {
        "instruction": "Create a function that requires a single numerical seed value for initialization. If a collection (like a list or tuple) of seeds is provided instead of a single number, raise a `ValueError` explaining that only one seed is permissible. If a single seed is correctly passed, the function should return a confirmation string like 'Initialization successful with seed: [seed_value]'."
    },
    {
        "instruction": "Implement a function that accepts a single data processing parameter. Validate the input: if it's a list or tuple containing multiple parameters, raise a `ValueError` stating 'Expected a single parameter, got multiple.'. If the input is valid (a single parameter), return the parameter itself."
    },
    {
        "instruction": "Write a function designed to process a batch of identifiers, provided as a list or tuple of strings. This function should explicitly accept a collection. It should iterate through the identifiers and return a new list containing the length of each identifier. It must *not* raise an error when given a list/tuple."
    },
    {
        "instruction": "Develop a function that takes an input argument intended to be a single item. Check if the argument is a collection (list, tuple). If it is, raise a `ValueError` specifying that the function cannot operate on batched inputs. If it's a single item, return a dictionary `{'status': 'valid', 'item': input_item}`."
    },
    {
        "instruction": "Create a function that accepts a positive integer `count`. The function should generate and return a sequence (like a list or tuple) containing exactly `count` unique numerical identifiers."
    },
    {
        "instruction": "Write a function that takes a starting numerical value and a positive integer `quantity`. Generate a sequence of `quantity` numbers, where each number is derived from the starting value using a simple, deterministic rule (e.g., sequential increments or a simple hash). Return the sequence, ensuring its length is exactly `quantity`."
    },
    {
        "instruction": "Develop a function that receives a single configuration object (treat it as opaque) and a positive integer `k`. It should produce a list containing `k` new, distinct configuration objects derived from the input one. Ensure the output list has exactly `k` items."
    },
    {
        "instruction": "Write a function that takes an initial seed value (e.g., an integer) and a positive integer `n`. It should return a list containing exactly `n` derived values based on the seed (the specific derivation method is not important, but the count must be `n`)."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and two integers, `rows` and `cols`. Reshape the input array into a 2D numerical array with the specified number of `rows` and `cols`. Assume the total number of elements in the input array matches `rows * cols`."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays `vector1` and `vector2` of the same length `N`. Apply a predefined binary operation `op(x, y)` element-wise, pairing `vector1[i]` with `vector2[i]`. Return a new 1D array of length `N` containing the results."
    },
    {
        "instruction": "Write a function that takes a single numerical value `scalar` and a 1D numerical array `vector`. It applies a predefined binary operation `op(x, y)` using `scalar` as the first argument and each element of `vector` as the second. Return a new 1D array containing the results, with the same length as `vector`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `vector` and a single numerical value `scalar`. It applies a predefined binary operation `op(x, y)` using each element of `vector` as the first argument and `scalar` as the second. Return a new 1D array containing the results, with the same length as `vector`."
    },
    {
        "instruction": "Write a function that takes a representation of a pseudo-random generator state and returns two new, independent states derived deterministically from the input state."
    },
    {
        "instruction": "Create a function that accepts a representation of a pseudo-random generator state and an integer `N`. It should return a list containing `N` new, independent states derived deterministically from the input state."
    },
    {
        "instruction": "Develop a function that takes a collection (e.g., an array) of pseudo-random generator states. Apply a transformation function (which splits one state into two, like in Task 1) to *each* state in the input collection conceptually in parallel (like a map operation). Return a new collection structured such that if the input has N states, the output has dimensions (N, 2), containing the pairs of generated states."
    },
    {
        "instruction": "Create a function that takes two data structures representing generator states (or similar opaque objects containing underlying data). Compare their essential internal data for equality and return `True` if they represent the exact same state, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a list of data objects (where each object is assumed to have an identical shape) and an integer `N`. Verify that the list contains exactly `N` objects. Return `True` if the count matches `N`, `False` otherwise."
    },
    {
        "instruction": "Design a function `split_resource(resource, N)` that takes a resource object (which has a `.shape` attribute, e.g., `(2, 3)`) and an integer `N`. The function should return a new structure representing `N` distinct conceptual 'splits' or 'derivations' of the original resource. This new structure should itself have a `.shape` attribute equal to `(N, *resource.shape)`. The exact splitting mechanism is not defined, focus on creating a structure with the correct output shape."
    },
    {
        "instruction": "Write a function that takes two shape tuples (e.g., `(10, 2)` and `(10, 2)`) and returns `True` if they are identical (same length and same elements in the same order), `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes a data object (assume it has a `.shape` attribute returning a tuple) and an integer `N`. Return a list containing `N` copies (or references) of the original data object."
    },
    {
        "instruction": "Create a function `map_transform(transform_func, primary_input, secondary_input, map_over_primary)` that accepts: a transformation function `transform_func(p, s)` (which takes two numerical arguments and returns one numerical result), two inputs `primary_input` and `secondary_input`, and a boolean `map_over_primary`. If `map_over_primary` is true, assume `primary_input` is a 1D numerical array and `secondary_input` is a single numerical value; apply `transform_func(p_element, secondary_input)` for each `p_element` in `primary_input`. If `map_over_primary` is false, assume `primary_input` is a single numerical value and `secondary_input` is a 1D numerical array; apply `transform_func(primary_input, s_element)` for each `s_element` in `secondary_input`. Return a 1D numerical array containing the results, with a length matching the input array that was mapped over."
    },
    {
        "instruction": "Write a function `combine_state_data(state, data_item)` that takes two numerical inputs (a 'state' value and a 'data_item' value) and returns a new numerical 'state' value based on a simple arithmetic combination (e.g., `state * 3 + data_item`)."
    },
    {
        "instruction": "Implement a function `apply_to_state_array(state_array, data_item)` that takes a 1D numerical array 'state_array' and a single numerical 'data_item'. It should apply a transformation function (like the one from Task 1) using each element of 'state_array' combined with the *same* 'data_item'. Return a 1D array containing the results, having the same length as 'state_array'."
    },
    {
        "instruction": "Create a function `apply_to_data_array(initial_state, data_array)` that takes a single numerical 'initial_state' and a 1D numerical array 'data_array'. It should apply a transformation function (like the one from Task 1) to each element of 'data_array', using the *same* 'initial_state' for every application. Return a 1D array containing the results, having the same length as 'data_array'."
    },
    {
        "instruction": "Implement a function `batch_split_tokens(token_batch, m)` that takes a 2D array `token_batch` (where each row is a token, shape `(N, L)`) and an integer `m`. Apply a `split_token` operation (similar to Task 2) with count `m` to *each* token (row) in the batch. Collect and return all resulting tokens in a single 3D array. The output shape should be `(N, m, L)`."
    },
    {
        "instruction": "Create a function that generates a basic 'state token' represented as a 1D numerical array of size 2. Return this array."
    },
    {
        "instruction": "Given the dimensions of an initial token (e.g., `(L,)`), a first split number `N`, and a second split number `M` (applied to each of the `N` results), write a function that returns the expected dimensions (shape) of the final collection of tokens after both splits are performed sequentially (the second split applied to all results of the first)."
    },
    {
        "instruction": "Write a function `split_token(token, n)` that takes a 1D numerical array `token` and an integer `n`. It should return a 2D array where each row is a new token derived from the input. The output shape should be `(n, token_length)`. (The derivation logic can be simple, e.g., copying and slightly modifying)."
    },
    {
        "instruction": "Implement a function `get_token_data(state_token)` that takes a state token and returns its underlying raw data representation (e.g., the numerical tuple or array it encapsulates)."
    },
    {
        "instruction": "Develop a function `compare_token_sequences(sequence1, sequence2)` that takes two lists of state tokens. It should compare the tokens element-wise based on their underlying raw data (using a function like `get_token_data`). Return `True` if all corresponding tokens in the sequences have identical data, `False` otherwise."
    },
    {
        "instruction": "Write a function `split_state(state_token, n)` that takes an abstract 'state token' (representing some internal state, e.g., a small numerical array or tuple) and an integer `n`. It should return a list containing `n` new, distinct state tokens derived deterministically from the input token."
    },
    {
        "instruction": "Create a function `process_tokens_iteratively(token_list)` that accepts a list of state tokens. For each token in the input list, it applies a predefined 'split' operation (generating exactly 2 new tokens from each input token). Return a list of lists, where each inner list contains the 2 derived tokens corresponding to an input token. Implement this using explicit iteration (e.g., a loop)."
    },
    {
        "instruction": "Implement a function `apply_to_each` that takes two arguments: a list of input values `inputs` and a function `operation`. It should apply the `operation` function to every element in the `inputs` list and return a new list containing the results in the corresponding order."
    },
    {
        "instruction": "Develop a function that receives a primary seed value and an integer `n`. The function should first generate `n` unique sub-seeds from the primary seed. Then, for each sub-seed, it should generate a random integer between 0 and 100. Finally, it should return a 1D numerical array of length `n` containing these random integers."
    },
    {
        "instruction": "Create a function that accepts a single seed value and returns one pseudo-random integer between 0 and 100 (inclusive)."
    },
    {
        "instruction": "Write a function that takes a primary seed value and an integer `count`. It should return a list containing `count` distinct derived seed values generated from the primary seed."
    },
    {
        "instruction": "Create a function that accepts a seed and a positive integer `N`. It should return a 1D numerical array of length `N` containing pseudo-random integers, each between 0 (inclusive) and 100 (exclusive), generated based on the initial seed. The process must be deterministic."
    },
    {
        "instruction": "Implement a function that takes a main seed and a positive integer `K`. It should return a list or array containing `K` new, unique seeds derived deterministically from the main seed. These derived seeds should be suitable for independent pseudo-random number generation."
    },
    {
        "instruction": "Write a function that takes a seed (representing PRNG state) and returns a single pseudo-random integer between 0 (inclusive) and 100 (exclusive). Ensure the function is deterministic: the same seed should always produce the same integer."
    },
    {
        "instruction": "Develop a function that takes a list of `K` unique seeds. For each seed, it should generate one pseudo-random integer between 0 (inclusive) and 100 (exclusive) using a deterministic process based solely on that seed. The function should return a 1D numerical array of length `K` containing these generated integers in the order corresponding to the input seeds."
    },
    {
        "instruction": "Write a function that takes a list of `M` inputs and a generator function `gen_func`. `gen_func` accepts one input and produces a 1D array of numbers. Your function should call `gen_func` for each of the `M` inputs and combine all the resulting numbers into a single, flat 1D output array."
    },
    {
        "instruction": "Write a function that generates an array of `N` floating-point numbers, uniformly distributed between 0.0 (inclusive) and 1.0 (exclusive). The function should take `N` as an argument."
    },
    {
        "instruction": "Implement a function that takes a list of 1D numerical arrays (potentially of different lengths) and returns a single new 1D array containing all elements from the input arrays concatenated together in order."
    },
    {
        "instruction": "Develop a function that performs a basic uniformity check on a 1D array of floating-point numbers expected to be in the range [0.0, 1.0). It should divide the range into 10 equal sub-intervals (bins) and count the number of elements falling into each bin. Return the counts for each bin as a 1D array or list of 10 integers."
    },
    {
        "instruction": "Create a function that generates an initial representation for a PRNG state given an integer seed value. Input: integer seed. Output: a data structure representing the initial PRNG state."
    },
    {
        "instruction": "Develop a function that takes a single PRNG state representation and generates a nested structure of new states. Input: one PRNG state representation, and two integers `M` > 0, `N` > 1. Output: An M-element list, where each element is itself a list of N new PRNG state representations, all derived deterministically and uniquely from the single input state."
    },
    {
        "instruction": "Implement a function that applies a state-splitting operation element-wise to a collection of PRNG states. Input: a list of `M` PRNG state representations and an integer `N` > 1. Output: a list of `M` lists, where each inner list contains `N` new PRNG states derived from the corresponding input state using deterministic splitting logic."
    },
    {
        "instruction": "Write a function to compare two methods of generating structured PRNG states. Method A applies an element-wise split (producing 2 new states per input state) to an initial list of `M` states. Method B applies a nested split (producing an `M`x`2` structure) to only the *first* state from the initial list. The function should take the initial list of `M` states, generate results using both methods, compare their underlying data representations, and return `True` if identical, `False` otherwise. Assume helper functions for splitting and data extraction exist."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array, an index, and a numerical value. It should modify the array *in-place* by adding the given value to the element at the specified index."
    },
    {
        "instruction": "Develop a function that modifies a 1D numerical array of at least size 2 *in-place*. The function should first add 1.0 to all elements, then add 1 to the element at index 0, and finally add 5 to the element at index 1."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a list of update instructions. Each instruction is a tuple: either `('all', value)` to add `value` to all elements, or `(index, value)` to add `value` to the element at `index`. The function must apply all instructions sequentially to the array *in-place*."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and a scalar value. It should modify the array *in-place* by adding the scalar value to every element. The function should not return a new array."
    },
    {
        "instruction": "Implement a function that accepts a numerical 2D array and modifies it in-place by adding 1 to every element. The function does not need to return anything."
    },
    {
        "instruction": "Write a function accepting four numerical 2D arrays: `arr_A_mut`, `arr_B`, `arr_C_mut`, `arr_D`. Modify `arr_A_mut` and `arr_C_mut` in-place by adding 1 to each element. The function should return exactly two outputs: 1) A new array calculated as the element-wise sum `modified arr_A_mut + arr_B + modified arr_C_mut + arr_D`. 2) A new array calculated as the element-wise sum `arr_B + arr_D`. Assume input shapes allow for these additions (potentially requiring broadcasting)."
    },
    {
        "instruction": "Write a function that takes two numerical 2D arrays of the exact same shape and returns a new 2D array representing their element-wise sum."
    },
    {
        "instruction": "Develop a function that accepts two numerical 2D arrays, 'mutable_array' and 'constant_array', with compatible shapes for addition. The function must first add 1 to every element of 'mutable_array' (modifying it directly). Then, it should return a *new* array containing the element-wise sum of the *modified* 'mutable_array' and the 'constant_array'."
    },
    {
        "instruction": "Implement a function `add_at_index_inplace` that accepts a 1D numerical array `arr`, an integer `index`, and a number `value`. Modify `arr` *in-place* by adding `value` to the element at the specified `index`. Ensure the index is valid for the array's length."
    },
    {
        "instruction": "Implement a function `setup_array_updater` that accepts a mutable 1D numerical array `data_array` (assume length >= 2). This function should return a *new* function, `update_data`, which takes no arguments. When `update_data` is called, it modifies the original `data_array` *in-place* by: adding 1.0 to all elements, adding 1 to the element at index 0, and adding 5 to the element at index 1. `update_data` returns nothing."
    },
    {
        "instruction": "Create a function `add_scalar_inplace` that takes a 1D numerical array `arr` and a scalar number `value`. Modify `arr` *in-place* by adding `value` to each element. The function should return nothing."
    },
    {
        "instruction": "Write a function `create_zero_vector` that takes a positive integer `size` and returns a new 1D numerical array of that `size`, filled with zeros."
    },
    {
        "instruction": "Write a function that accepts a single numerical scalar value and returns that value increased by 9."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array (e.g., size 3) and adds 1.0 to every element in the array. Assume the array is mutable and modified in-place."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array (e.g., size 3) as input and modifies its third element (index 2) by adding 7 to it. Assume the array is mutable and modified in-place."
    },
    {
        "instruction": "Develop a function that modifies a predefined, accessible 1D numerical array (e.g., size 3, initialized to zeros) which is *not* passed as an argument. The function should add 1 to the element at index 0 and 5 to the element at index 1 of this external array."
    },
    {
        "instruction": "Develop a function that takes a mutable 1D numerical array and an index `idx`. It should add 1.0 to the element at `idx`, and then add 1.0 *again* to the element at the *same* index `idx`. Assume the modification happens in place."
    },
    {
        "instruction": "Write a function that takes an integer `size` and returns a new 1D numerical array of that size, initialized entirely with zeros."
    },
    {
        "instruction": "Implement a function that initializes a mutable 1D numerical array of size 3 with zeros. It then adds 1.0 to the element at index 0 and adds 1.0 to the element at index 2. The function should return the final state of the array."
    },
    {
        "instruction": "Write a function that takes an integer `size`, a list of indices `update_indices`, and a list of numerical values `add_values` (of the same length as `update_indices`). It should create a 1D numerical array of `size` initialized with zeros. Then, for each corresponding index and value from the lists, it should add the value to the element at that index in the array. Return the final array."
    },
    {
        "instruction": "Develop a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array (matrix) with the specified dimensions (`rows` x `cols`), initialized entirely with zeros."
    },
    {
        "instruction": "Implement a function that accepts a positive integer `n` and a numerical value `val`. It should return a 1D numerical array of length `n` where every element is equal to `val`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array as input and returns a new 1D numerical array containing the exact same elements in the same order."
    },
    {
        "instruction": "Create a function that takes a positive integer `n` as input and returns a 1D numerical array of length `n` containing only zeros."
    },
    {
        "instruction": "Implement a function that takes an object containing a numerical array and associated metadata. The function should simply return the metadata associated with that object."
    },
    {
        "instruction": "Create a function that associates a piece of metadata (e.g., a string label representing distribution) with a 1D numerical array. Return an object from which both the original array and the associated metadata label can be retrieved."
    },
    {
        "instruction": "Create a function `process_mutable_array` that accepts an object holding a mutable 1D numerical array and associated metadata. Inside this function, access the array data (e.g., get all elements). The function should return the accessed data (as a new array or view) packaged with the *identical* metadata from the input object. Crucially, ensure that the metadata of the *original* mutable array object passed into the function remains unchanged after the function executes."
    },
    {
        "instruction": "Create a function that takes an object holding a mutable 1D numerical array and its associated metadata attribute. Implement a way to access a slice of this array (e.g., `obj[:]`). Ensure that accessing the slice returns an object representing the sliced data which *still* possesses the *exact same* metadata attribute as the original object."
    },
    {
        "instruction": "Write a function that accepts a single argument of any data type and returns that argument exactly as received."
    },
    {
        "instruction": "Implement a function that takes one input value. It should return `True` if the input value's type is considered mutable (e.g., a list or dictionary) and `False` otherwise."
    },
    {
        "instruction": "Write a higher-order function `wrap_check_return` that takes a function `target_func` as input. It should return a new function, `wrapped_func`. When `wrapped_func` is called with arguments, it first executes `target_func` with those arguments. It then checks if the returned value is of a mutable type (e.g., list, dict). If it is, `wrapped_func` must raise a `ValueError` indicating that mutable return types are forbidden. If the return type is not mutable, `wrapped_func` returns the value."
    },
    {
        "instruction": "Create a function `execute_and_validate` that accepts two arguments: a function `callable_func` and a value `input_val`. This function should call `callable_func(input_val)`. If the result returned by `callable_func` is of a mutable type (like list or dictionary), `execute_and_validate` must raise a `ValueError` with the message \"Mutable return value detected\". Otherwise, it should return the result."
    },
    {
        "instruction": "Write a function that accepts two arguments and returns `True` if they are the exact same object in memory, and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes two arguments. Inside the function, check if both arguments refer to the identical object. If they do, raise a `ValueError` with a descriptive message. Otherwise, the function should complete without error."
    },
    {
        "instruction": "Define a simple class representing a mutable container that holds a single value (e.g., a number or string). Implement methods to initialize the container with a value and to retrieve the stored value."
    },
    {
        "instruction": "Implement a higher-order function (or decorator) that takes an arbitrary function `f` as input. It should return a new function that wraps `f`. This new function, before calling `f`, must check if any two of the arguments passed to it are the exact same object. If aliasing is detected among any pair of arguments, it should raise a `ValueError`. Otherwise, it should call the original function `f` with the provided arguments and return its result."
    },
    {
        "instruction": "Create a function `conditional_update(predicate, state_container)` where `state_container` is an object or structure holding a single mutable numerical value (e.g., a list `[value]`). If `predicate` (a boolean) is true, update the value in `state_container` to 1.0. If `predicate` is false, update the value to 2.0. The function modifies the state in-place."
    },
    {
        "instruction": "Write a function `update_value(state_container, new_value)` that takes a mutable container holding a single numerical value (e.g., a list `[value]` or a simple custom object with a value attribute) and a numerical `new_value`. The function should modify the value within the `state_container` to `new_value`."
    },
    {
        "instruction": "Design a function factory `create_stateful_updater()`. This factory should initialize an internal mutable numerical state (e.g., to 0.0). It should return a *new* function, let's call it `update_state_based_on_flag`. This returned function accepts a single boolean argument `flag`. When `update_state_based_on_flag` is called, it should modify the internal state (captured from the factory) to 1.0 if `flag` is true, and to 2.0 if `flag` is false. The state must persist across calls to `update_state_based_on_flag`."
    },
    {
        "instruction": "Implement a function `select_value(condition, value_if_true, value_if_false)` that returns `value_if_true` if the boolean `condition` is true, and `value_if_false` otherwise. Inputs are a boolean and two numerical values. Output is a numerical value."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns the maximum absolute value among its elements. If the array is empty, return 0."
    },
    {
        "instruction": "Create a function that calculates the dot product of two 1D numerical arrays (vectors) of the same size. It should return a single scalar value."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array (`data`) and a 1D numerical history array (`history`). It should: 1. Find the maximum absolute value (`new_max`) in `data`. 2. Update `history` by shifting elements right and inserting `new_max` at index 0. 3. Find the maximum value (`history_max`) within the *updated* `history`. 4. Return `data` divided by `history_max`. Handle potential division by zero (e.g., return `data` if `history_max` is zero or very close to zero)."
    },
    {
        "instruction": "Implement a function that updates a fixed-size 1D history array. It takes the history array and a new numerical value. The function should shift all existing elements one position towards the end (discarding the last element), insert the new value at the beginning (index 0), and return the modified history array."
    },
    {
        "instruction": "Write a function that accepts a boolean flag and two values. It should return the first value if the flag is true, and the second value otherwise."
    },
    {
        "instruction": "Write a function that takes a single argument. If the argument is `None`, raise a `TypeError`. Otherwise, return the argument unchanged."
    },
    {
        "instruction": "Implement a function that checks if a given input variable is of a mutable sequence type (e.g., a list). It should return `True` if it is, and `False` otherwise (e.g., for tuples, strings, numbers)."
    },
    {
        "instruction": "Develop a function that takes a boolean condition and two functions (no arguments). It executes the function corresponding to the boolean condition. If the executed function's return value is identified as a mutable sequence type (like a list), the function must raise a `ValueError`. Otherwise, it should return the value."
    },
    {
        "instruction": "Write a function `are_same_object` that accepts two variables, `a` and `b`. It should return `True` if `a` and `b` refer to the exact same object in memory, and `False` otherwise."
    },
    {
        "instruction": "Create a function `check_aliased_args` that takes a dictionary mapping argument names (strings) to their values. It should check if the values associated with two specific keys, say `'input_val_1'` and `'input_val_2'`, refer to the exact same object. If they do, raise a `ValueError` with a message indicating that these arguments cannot be the same object. Otherwise, do nothing."
    },
    {
        "instruction": "Implement a function `validated_conditional` that takes a boolean condition, two functions (`on_true`, `on_false`), and two operands (`operand1`, `operand2`). First, check if `operand1` and `operand2` refer to the exact same object in memory. If they do, raise a `ValueError` explaining that aliased operands are disallowed. Otherwise, execute `on_true(operand1, operand2)` if the condition is true, or `on_false(operand1, operand2)` if false, and return the result."
    },
    {
        "instruction": "Develop a function `format_alias_error` that takes the name of an operation (string) and the names of two arguments (strings, e.g., 'arg_X', 'arg_Y') found to be aliases. Return a formatted error string: 'ValueError: Operation [operation_name] received the same object for arguments [arg1_name] and [arg2_name].'"
    },
    {
        "instruction": "Write a function that explicitly raises a `ValueError` with the exact message \"Operation failed due to invalid arguments\" if its input is negative, otherwise returns the input unchanged."
    },
    {
        "instruction": "Implement a function `conditional_apply(use_first, func_a, func_b, data)`. If `use_first` is true, call `func_a(data)` and return its result. Otherwise, call `func_b(data)` and return its result. `func_a` and `func_b` are functions that each take one argument."
    },
    {
        "instruction": "Create a function `create_offset_adder(offset)`. It should take a number `offset` and return a *new function*. This returned function should accept one argument `x` and return the sum `offset + x`, using the `offset` value captured from the outer scope."
    },
    {
        "instruction": "Write a function that accepts a list containing one number. The function should modify this number (e.g., double it) *in-place* within the list. It should return nothing. Verify that the original list passed to the function has been modified."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and a scalar value. It should return a *new* 1D array where each element is the corresponding element from the input array plus the scalar value."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array as input. Return a *new* array of the same size where each element at index `i` is the result of the calculation `input[i] + 2`."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array. It should modify the array *in-place* by adding the integer `2` to every element. The function does not need to return anything."
    },
    {
        "instruction": "Implement a function that receives a list of numbers (e.g., `[0, 1, 2, 3, 4]`). It should process this list and return a *new* list where each number is the corresponding number from the input list incremented by `2`."
    },
    {
        "instruction": "Write a function `cumulative_add` that takes an initial integer `count` and a non-negative integer `n_steps`. The function should simulate adding 2 to the `count` exactly `n_steps` times. Return the final `count`."
    },
    {
        "instruction": "Create a function `create_stateful_incrementer` that accepts an initial integer `initial_state`. It should return a *new* function, let's call it `increment_and_get`. Each time `increment_and_get` is called (it takes no arguments), it must increase an internal state (initially `initial_state`) by 2 and return the *updated* state. The internal state must persist across calls to `increment_and_get`."
    },
    {
        "instruction": "Develop a function `generate_offset_arithmetic_sequence`. It takes an integer `n` (length >= 0), an integer `start_value`, and an integer `increment`. Return a list of length `n` where the element at index `i` is `start_value + (i + 1) * increment`."
    },
    {
        "instruction": "Create a function that simulates iterative updates. It takes an initial integer `state` and the number of iterations `n`. In a loop that runs `n` times, add 2 to the `state` in each iteration. Return a list containing the value of the `state` *after* the update in each iteration."
    },
    {
        "instruction": "Write a function that takes a positive integer N and returns a 1D numerical array containing the sequence of integers from 0 up to (but not including) N."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array 'A'. It should return a new 1D array 'B' of the same size, where each element B[i] is the product of the corresponding element A[i] and its index i (i.e., B[i] = A[i] * i)."
    },
    {
        "instruction": "Develop a function that receives a 1D numerical array 'A'. It should compute and return a new 1D array representing the cumulative sum of 'A'. The element at index 'i' in the output array should be the sum of all elements from index 0 to 'i' (inclusive) in the input array 'A'."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array 'A'. It should return a new 1D array 'B' of the same size, where each element B[i] is the sum of the corresponding element A[i] and its index i (i.e., B[i] = A[i] + i)."
    },
    {
        "instruction": "Write a function `is_value_mutable(value)` that returns `True` if the input `value` is of a mutable type (e.g., list, dictionary, set) and `False` for immutable types (e.g., number, string, tuple)."
    },
    {
        "instruction": "Create a function `apply_and_check(func, arg)` that executes `func(arg)`. If the return value from `func` is identified as a mutable container (like a list or dictionary), raise a `ValueError` with a descriptive message. Otherwise, return the value."
    },
    {
        "instruction": "Implement a function `accumulate_checked(items, initial_value, step_func)` that iterates through a sequence `items`. In each step, it calls `new_value = step_func(current_value, item)`. Before updating `current_value` to `new_value`, check if `new_value` is a mutable list. If it is, raise a `ValueError`. Otherwise, continue the accumulation. Return the final accumulated value."
    },
    {
        "instruction": "Develop a function `raise_if_mutable(obj)` that accepts a single object. If the object is determined to be mutable (e.g., a list or dictionary), the function should raise a `ValueError`. Otherwise, it should return `None`."
    },
    {
        "instruction": "Design a function that takes a list of arguments intended for another operation. This function must check if any two arguments within that list are references to the *exact same mutable object* (e.g., the same list instance). If such aliasing is detected among mutable arguments, the function should raise a `ValueError` with a descriptive message. Otherwise, it should return `None`."
    },
    {
        "instruction": "Write a function that takes two arguments and returns `True` if they are the exact same object in memory (aliases), and `False` otherwise. It should return `False` if the arguments have the same value but are different objects."
    },
    {
        "instruction": "Create a function that accepts a list or tuple of objects. It should return `True` if any two distinct elements in the input collection refer to the exact same object in memory, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes an integer `n` > 0 and an initial value `val`. It should create and return a list containing `n` separate, mutable list objects, where each inner list initially contains only the value `val`. Modifying one inner list should not affect any other inner list in the returned list."
    },
    {
        "instruction": "Write a function `are_same_object(var1, var2)` that accepts two variables and returns `True` if they reference the exact same object in memory, `False` otherwise."
    },
    {
        "instruction": "Write a function `check_closure_arg_identity(outer_var, inner_func, arg_var)`. Assume `inner_func` is a function that captured `outer_var` from its defining scope. This function should check if `arg_var` is the *exact same object* as `outer_var`. Return `True` if they are identical objects, `False` otherwise."
    },
    {
        "instruction": "Create a function `setup_potential_alias()` that initializes a mutable list `shared_list = [10]`. It should then return *both* the list `shared_list` itself *and* a simple function (e.g., a lambda or inner function) that takes one argument `input_list` but internally reads from the original `shared_list` (via closure). The returned function should just read the first element, e.g., `lambda input_list: shared_list[0]`. Ensure you return a tuple: `(shared_list, accessing_function)`."
    },
    {
        "instruction": "Implement a function `is_mutable_container(data)` that returns `True` if the input `data` is a list, dictionary, or set, and `False` for other types like numbers, strings, or tuples."
    },
    {
        "instruction": "Implement a function that simulates tracking inputs in a simple computation graph node. The function receives an 'input specification'. If the specification is a concrete value (e.g., the integer 3), it should return a representation indicating a 'literal constant' with that value. If the specification is symbolic (e.g., a string 'n'), it should return a representation indicating a 'variable input'."
    },
    {
        "instruction": "Design a data structure or class to represent a variable within a computation. It should be possible to check if two instances of this structure refer to the exact same conceptual variable (identity check)."
    },
    {
        "instruction": "Create a function that takes an object representing a multi-dimensional numerical array and returns a tuple of integers representing its shape (dimensions). For instance, for a 2x3 array, it should return `(2, 3)`."
    },
    {
        "instruction": "Write a function that accepts a single positive integer `n` and returns a new 1D numerical array of length `n` where all elements are equal to 1."
    },
    {
        "instruction": "Implement a function that takes a positive integer `n`. It should conceptually create a 1D array of size `n` filled with floating-point ones and return the sum of its elements (which should simply be `n` as a float)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (list or similar structure) and returns the sum of its elements as a single floating-point number."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array containing floating-point numbers. Return a single floating-point number representing the sum of all elements in the input array. Ensure the output type matches the precision expected for floating-point sums."
    },
    {
        "instruction": "Create a function that accepts a positive integer `n` and returns a new 1D numerical array of size `n` where every element is equal to 1.0 (floating-point)."
    },
    {
        "instruction": "Implement a function that accepts a 1D numerical array. The function should calculate and return the sum of the array's elements. Additionally, it must increment a counter variable defined *outside* the function's scope exactly once during its execution."
    },
    {
        "instruction": "Write a function that accepts a one-dimensional list or array of numbers and returns their sum as a single numerical value."
    },
    {
        "instruction": "Design a reusable counter mechanism. Create a function that, when called, returns a *new* function. This new function, when invoked, increments an internal counter (specific to its creation context) and returns the updated count. Each call to the original function should create an independent counter."
    },
    {
        "instruction": "Create a function that takes a non-negative integer `N` and returns a one-dimensional list or array containing the sequence of integers from 0 up to `N-1`. If `N` is 0, it should return an empty sequence."
    },
    {
        "instruction": "Create a function that takes a positive integer `size` as input and returns a 1D numerical array of that size, filled entirely with the floating-point value 0.0."
    },
    {
        "instruction": "Write a function that takes an integer `n`. If `n` is positive, it should return a 1D numerical array of size `n` filled with 1.0s. If `n` is zero or negative, it should return an empty 1D array."
    },
    {
        "instruction": "Implement a function that takes two arguments: a positive integer `length` and a floating-point number `fill_value`. It should return a 1D numerical array of the specified `length`, where every element is equal to `fill_value`."
    },
    {
        "instruction": "Write a function that accepts a positive integer `n` and returns a 1D numerical array (vector) of size `n` containing only the floating-point value 1.0."
    },
    {
        "instruction": "Create a function that accepts two 2D numerical arrays (matrices) with the same number of columns. Return a new 2D array formed by stacking the rows of the second array below the first."
    },
    {
        "instruction": "Write a function that takes one 2D numerical array, a positive integer 'N', and an axis index (0 or 1). Return a new 2D array created by concatenating the input array with itself 'N' times along the specified axis."
    },
    {
        "instruction": "Develop a function that accepts a list containing multiple 2D numerical arrays and an axis index (0 for rows, 1 for columns). Assuming shapes are compatible, return a single 2D array resulting from joining the input arrays along the specified axis."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays (vectors) and returns a new 1D array by joining them end-to-end."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array of 12 elements and reshapes it into a 2D array with 3 rows and 4 columns. Return the new 2D array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array (vector) of length L and reshapes it into a 2D array (matrix) with N columns. Assume L is divisible by N. Return the resulting M x N matrix."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and reshapes it into a 2D array with exactly 2 rows. The number of columns should be automatically determined based on the total number of elements in the input array. Return the new 2D array."
    },
    {
        "instruction": "Write a function that accepts a numerical array and a target shape tuple (e.g., (2, -1) or (3, 4)). It should attempt to reshape the input array into the target shape. If the target shape contains '-1', infer that dimension based on the total element count. If the target shape is compatible (total elements match), return the reshaped array. If incompatible, return an indicator that the reshape failed (e.g., None or raise an error)."
    },
    {
        "instruction": "Define a function `outer_transform` that accepts a numerical array. Inside `outer_transform`, define a separate helper function `inner_transform` that also accepts a numerical array and returns an array of the same shape with each element transformed (e.g., squared). `outer_transform` should call `inner_transform` with its input and return the result produced by `inner_transform`."
    },
    {
        "instruction": "Write a function that takes a numerical array (e.g., list of lists or equivalent) and returns a new array of the same shape where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Develop a function that accepts a numerical array. This function must contain a nested function definition. The outer function should compute an element-wise transformation (e.g., sine) on the input array. The nested function should also compute the same element-wise transformation. The outer function must call the nested function with the original input array and return the element-wise sum of its own transformation result and the nested function's result. The final output array must have the same shape as the input array."
    },
    {
        "instruction": "Create a function that accepts two numerical arrays of the exact same dimensions and returns a new array of the same dimensions where each element is the sum of the corresponding elements from the two input arrays."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array as input. It should generate and return a new 2D array of the same shape and data type, filled sequentially with numbers starting from 0, incrementing row-by-row."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array. It should create a corresponding 2D array (same shape and type) filled sequentially from 0 upwards (row-wise). Return a new 2D array representing the element-wise sum of the original input array and the sequentially filled array."
    },
    {
        "instruction": "Implement a function that reshapes a given 1D numerical array into a 2D array with specified dimensions (rows, columns). The function should take the 1D array, the number of rows, and the number of columns as input. Assume the total number of elements matches rows * columns."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array and returns the total count of its elements (rows * columns)."
    },
    {
        "instruction": "Write a function that accepts a 3D numerical array with shape (Depth, Height, Width). Return a new 3D array where the last two dimensions (Height and Width) of each 2D slice along the Depth axis are transposed, resulting in an output shape of (Depth, Width, Height)."
    },
    {
        "instruction": "Create a function that takes two 2D numerical arrays, `matrix_a` and `matrix_b`. Return `True` if `matrix_b` is the exact transpose of `matrix_a`, and `False` otherwise. Ensure dimensions are compatible for transposition."
    },
    {
        "instruction": "Develop a function that receives a square 2D numerical array (matrix). Return `True` if the matrix is symmetric (equal to its own transpose) and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array (matrix) with dimensions M rows and N columns. It should return a new 2D array representing the transpose, with dimensions N rows and M columns."
    },
    {
        "instruction": "Write a function that accepts a single square 2D numerical array (matrix) and returns the result of multiplying the matrix by itself."
    },
    {
        "instruction": "Create a function that takes an integer `N` and returns an `N x N` 2D numerical array where every element has the value 1.0."
    },
    {
        "instruction": "Implement a function to multiply two 2D numerical arrays (matrices). It should take matrix `A` (shape M x N) and matrix `B` (shape N x P) and return their product (shape M x P). Ensure it handles cases where the matrices cannot be multiplied according to standard rules."
    },
    {
        "instruction": "Write a function that computes the power of a square matrix. It takes a square 2D numerical array `A` and a non-negative integer `k` and returns `A` multiplied by itself `k` times (`A^k`). Handle the base case where `k=0` (result is the identity matrix)."
    },
    {
        "instruction": "Develop a function that attempts to multiply two 2D numerical arrays, A and B. If the inner dimensions match (columns of A == rows of B), return the resulting product matrix. If the dimensions are incompatible, return `None`."
    },
    {
        "instruction": "Write a function that accepts the dimensions (rows, columns) of two matrices as tuples, e.g., `(M, N)` and `(P, Q)`. Return `True` if the first matrix can be multiplied by the second matrix (in that order), and `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes a single square 2D numerical array (matrix) as input. Check if its dimensions allow it to be multiplied by itself. If yes, return the result of the matrix multiplied by itself. If not (which shouldn't happen for a square matrix, but check anyway), return an empty array or signal an error."
    },
    {
        "instruction": "Write a function that accepts two 2D numerical arrays, A (shape M, N) and B (shape P, Q). Determine if matrix multiplication is possible in the order A @ B *or* in the order B @ A. Return the shape of the resulting matrix for the *first* valid multiplication found (check A @ B first). If neither order is valid, return `None`."
    },
    {
        "instruction": "Develop a function that accepts a boolean condition and a square 2D numerical array. If the condition is true, the function should return the element-wise trigonometric sine of the input array. If the condition is false, it should return the result of multiplying the input array by itself."
    },
    {
        "instruction": "Create a function that accepts a square 2D numerical array (matrix) and returns the result of multiplying the matrix by itself."
    },
    {
        "instruction": "Implement a function that takes a boolean value, two functions (func_true and func_false), and an argument arg. If the boolean is true, it should call func_true(arg); otherwise, it should call func_false(arg). Return the result of the called function. Assume func_true and func_false both accept arg and return compatible types."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and computes the trigonometric sine of each element, returning a new array of the same shape."
    },
    {
        "instruction": "Develop a function that takes a positive integer `N` and a target numerical data type (e.g., float32, int64). It should return a 1D array containing the integer sequence `[0, 1, ..., N-1]`, explicitly cast to the specified target data type."
    },
    {
        "instruction": "Implement a function that takes a single 1D numerical array as input. The function should calculate the length of this array, generate a sequence of integers from 0 to length-1, cast this sequence to the same data type as the input array, and finally return the element-wise sum of the input array and the generated, typed sequence."
    },
    {
        "instruction": "Create a function that takes two 1D numerical arrays of the exact same size and data type. It should return a new 1D array representing their element-wise sum."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array. It should determine the array's length, `L`. Then, it should create a sequence of numbers starting from `L-1` down to `0` (i.e., `[L-1, L-2, ..., 0]`). This sequence must be cast to the same data type as the input array. Finally, the function should return the element-wise sum of the input array and this reversed, typed sequence."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array representing a column vector (shape M x 1) and broadcasts it to a target shape (M x N). The output should be a 2D array where each column is a copy of the input column vector."
    },
    {
        "instruction": "Implement a function that determines if a given numerical array with shape S1 can be broadcast to a target shape S2 according to standard array broadcasting rules (comparing dimensions from right to left, dimensions must match or one must be 1). The function should return True if broadcasting is possible, False otherwise."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (vector) of length N and returns a 2D array of shape (N, N) where each row is a copy of the input vector."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array of length N and a target number of rows M. It should return a 2D array of shape (M, N) where each row is identical to the input 1D array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array as input and returns a new 1D array of the same size and data type, filled entirely with zeros."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays of the same size and data type. It should return a new 1D array representing the element-wise sum of the two input arrays."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array of the same size and data type where every element is identical to the corresponding element in the input array (effectively creating a copy via addition to zero)."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array and returns its size (number of elements) as an integer."
    },
    {
        "instruction": "Develop a function that takes a list containing multiple 1D numerical arrays, all guaranteed to have the same length (N). The function should return a single 2D array of shape (K, N), where K is the number of arrays in the input list, formed by stacking the input arrays along a new first dimension. Handle the case of an empty input list (e.g., return an appropriately shaped empty array)."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays of the same length (N) and returns a single 2D array of shape (2, N) by stacking the first array as the first row and the second array as the second row."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is the cosine of the corresponding input element."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array. It should compute two new 1D arrays of the same length: one containing the square of each input element, and another containing the cube of each input element. The function should return a 2D array formed by stacking these two computed arrays along a new first dimension (resulting shape: 2xN)."
    },
    {
        "instruction": "Develop a function `create_sequence_generator()`. This function returns *another* function, `generate(n)`. The `generate(n)` function should produce a 1D array `[0, 1, ..., 2*n - 1]`. The outer function `create_sequence_generator` should perform a one-time setup action (like printing 'Setup complete') only when it's initially called, not when `generate(n)` is called."
    },
    {
        "instruction": "Implement a function that takes an integer `n` and returns a 1D numerical array `[0, 1, ..., 2*n - 1]`. This function must also increment a counter variable accessible in the surrounding scope each time it is executed."
    },
    {
        "instruction": "Implement a function that acts as a cached sequence generator. It takes an integer `n`. The *first time* it's called (regardless of the value of `n`), it should simulate a costly setup (e.g., print 'Cache miss - performing setup') and return the sequence `[0, 1, ..., 2*n - 1]`. Subsequent calls (even with different `n`) should *not* repeat the setup simulation but should return the correct sequence for the given `n`."
    },
    {
        "instruction": "Create a function that uses a closure to maintain an internal counter, initialized to zero. Each call to the function should increment this internal counter by one and return the *new* count value."
    },
    {
        "instruction": "Implement a function that accepts a 1D numerical array and an integer `n`. The function should return the sum of the first `n` elements of the array. Ensure it handles cases where `n` might be 0."
    },
    {
        "instruction": "Write a function that computes the average of the first `n` elements of a 1D numerical array. It takes the array and the integer `n` as input. Return the average as a floating-point number. Handle the case where `n` is 0 gracefully (e.g., return 0)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and an integer `n`, and returns a new 1D array containing only the first `n` elements of the input array. Handle potential edge cases like `n` being zero or larger than the array length."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array and two integers, `start` and `end`. It should return the sum of the elements in the array from the `start` index (inclusive) up to the `end` index (exclusive)."
    },
    {
        "instruction": "Create a function that accepts a data structure holding an integer `value` and a positive integer `upper_bound`. The function must return a string formatted exactly as \"value{\u2264upper_bound}\", replacing `value` and `upper_bound` with the actual numbers."
    },
    {
        "instruction": "Write a function that takes an integer `value` and a positive integer `upper_bound`. It should return a simple data structure (like a tuple or a basic object) containing both the value and the bound, but only if `value <= upper_bound`. If the value exceeds the bound, return `None`."
    },
    {
        "instruction": "Develop a function that takes an integer `value` and a positive integer `upper_bound`. If `value <= upper_bound`, it should return the string representation \"value{\u2264upper_bound}\". Otherwise, it must return the exact string \"Error: Value exceeds bound\"."
    },
    {
        "instruction": "Implement an identity function. This function should accept a single argument of any type and return that exact argument without any changes."
    },
    {
        "instruction": "Design a function that receives an object having an attribute `value` which holds a positive integer. The function should return a list of integers from 0 to `object.value - 1`."
    },
    {
        "instruction": "Create a function that accepts a string potentially representing a non-negative integer. Return the integer value if valid, otherwise indicate an error (e.g., return None or raise an exception)."
    },
    {
        "instruction": "Develop a function that generates a sequence of numbers. It accepts a non-negative integer `count` and returns a 1D array containing the first `count` non-negative integers (i.e., 0, 1, ..., count-1)."
    },
    {
        "instruction": "Implement a function that takes a non-negative integer `limit` and generates a 1D numerical array of 32-bit integers ranging from 0 to `limit - 1`. If `limit` is 0, return an empty array."
    },
    {
        "instruction": "Write a function `generate_zeros(n)` that accepts a non-negative integer `n` and returns a 1D numerical array of length `n` filled with zeros."
    },
    {
        "instruction": "Implement a class `ExecutionTracker` with a method `run()`. Each time `run()` is called, it should increment an internal counter (initialized to zero) and return the counter's new value. The `run` method doesn't need to accept any arguments."
    },
    {
        "instruction": "Write a function `process_integer(n, history_set)` that takes a positive integer `n` and a set `history_set`. Add `n` to the `history_set`. Return a 1D numerical array of length `n` containing only zeros. The function should always return the array, regardless of whether `n` was already in the set."
    },
    {
        "instruction": "Create a function `create_array_if_in_bounds(value, limit)` that takes two integers. If `0 <= value < limit`, return a 1D numerical array of length `value` containing only zeros. Otherwise, return `None`."
    },
    {
        "instruction": "Write a function that takes a non-negative integer `N`. It should first generate a 1D numerical array containing integers from 0 to `N-1`, and then return the sum of the elements in this generated array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns the sum of its elements."
    },
    {
        "instruction": "Create a function that accepts a non-negative integer `N` and returns a 1D numerical array containing the sequence of integers from 0 up to (but not including) `N`."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and a mutable counter object (e.g., a list containing an integer `[0]`). The function should increment the counter's value by one and return the sum of the array's elements."
    },
    {
        "instruction": "Develop a function that accepts a single non-negative integer `limit` and generates a 1D array (or list) containing the sequence of integers starting from 0 up to (but not including) `limit`."
    },
    {
        "instruction": "Write a function that takes a 1D array (or list) of numbers. It should return a new array of the same size, ensuring the output elements are of a specific numerical type (e.g., 32-bit integers), potentially converting from the input type, after doubling each input element."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array (or list) and returns a new array of the same size where each element is the sum of the corresponding input element with itself."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array (or list) and a scalar numerical value. It should return a new array of the same size where each element is the sum of the corresponding input element and the provided scalar value."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and returns its first row as a 1D array."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) and an integer index `k`. It should return the `k`-th row of the matrix as a 1D array. Ensure it handles cases where `k` might be out of bounds."
    },
    {
        "instruction": "Develop a function that receives a 1D numerical array and two positive integers, `rows` and `cols`. First, reshape the 1D array into a 2D array (matrix) with the specified `rows` and `cols`. Then, return the first row of this newly formed matrix as a 1D array. Assume the input 1D array has `rows * cols` elements."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix) and returns its first column as a 1D array."
    },
    {
        "instruction": "Develop a function that analyzes a list of operation names representing a computation (e.g., [\"sin\", \"sin\", \"cos\", \"add\"]). It should return `True` only if the operation 'sin' appears exactly twice and all other distinct operations present in the list appear exactly once. Otherwise, it should return `False`."
    },
    {
        "instruction": "Create a function that takes a string representing a simple mathematical expression involving functions like \"sin\", \"cos\", and \"add\" (e.g., \"add(sin(x), cos(y))\"). Return a dictionary where keys are the operation names (\"sin\", \"cos\", \"add\") found in the expression and values are their counts. Ignore variables and parentheses."
    },
    {
        "instruction": "Write a function that accepts a list of strings representing operation names (e.g., [\"add\", \"sin\", \"cos\", \"sin\"]) and a list of required operation names (e.g., [\"add\", \"sin\", \"cos\"]). Return `True` if all required operations are present at least once in the first list, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes two numerical inputs and calculates the result of applying a specific sequence of operations: take the sine of the first input, take the sine of that result, take the cosine of the second input, and finally, add the last two results together. Return the final numerical value."
    },
    {
        "instruction": "Create a function that accepts two strings: an 'operation_name' and a 'source_location'. Return a single formatted string combining them as 'operation_name @ source_location'."
    },
    {
        "instruction": "Implement a function that takes a list of strings representing recorded operations (e.g., ['sin', 'cos', 'sin']). Return a dictionary where keys are the unique operation names and values are the counts of their occurrences in the input list."
    },
    {
        "instruction": "Write a function that takes two numerical inputs, calculates the sine of the first input, then takes the sine of that result, and finally adds this to the cosine of the second input. Return the final numerical result."
    },
    {
        "instruction": "Design a function that processes a list of structured items, where each item represents an operation and has attributes like 'name' (string) and 'location' (string). Return a summary dictionary where keys are unique combinations of 'name @ location' and values are the counts of how many times each unique combination appeared in the input list."
    },
    {
        "instruction": "Write a function that takes two numerical scalar inputs, adds them, takes the sine of the sum, takes the cosine of the second input, and returns the sum of the sine and cosine results."
    },
    {
        "instruction": "Design a function that takes a list of strings, where each string describes a basic computational operation (e.g., \"add\", \"sin\", \"cos\", \"concatenate\", \"sum\"). The function should return a dictionary mapping each unique operation string to its frequency count within the input list."
    },
    {
        "instruction": "Implement a function that calculates the sum of all elements in a given 1D numerical array."
    },
    {
        "instruction": "Create a function that accepts two numerical scalar values and returns a 1D array containing these two values in the specified order."
    },
    {
        "instruction": "Design a function `compute_and_count(a, b)` that calculates `v1 = sin(a)`, `v2 = cos(b)`, `v3 = v1 + v2`, and `v4 = sin(v3)`. The function should return a tuple containing the final numerical result `v4` and the integer count (4) representing the total number of elementary mathematical operations (sin, cos, add, sin) performed in this specific sequence."
    },
    {
        "instruction": "Implement a function that takes two numerical inputs, `x` and `y`. Inside the function, compute an intermediate value `s` by taking the sine of `x`. The function should then return the sum of the sine of `s` and the cosine of `y`."
    },
    {
        "instruction": "Write a function that takes two numbers `x` and `y` and returns their sum."
    },
    {
        "instruction": "Write a function that takes a single number `x` and returns the result of applying the sine function to it."
    },
    {
        "instruction": "Create a function that accepts a string representing a simple mathematical expression involving only variable names, addition '+', sine 'sin()', and cosine 'cos()'. Return a list containing the unique names of the operations (e.g., 'add', 'sin', 'cos') present in the expression."
    },
    {
        "instruction": "Design a function that accepts a list of strings, where each string represents a basic computational step using specific function names (e.g., ['t1 = sin(x)', 't2 = sin(t1)', 't3 = cos(y)', 'result = add(t2, t3)']). Analyze this list and return a data structure (like a dictionary) mapping each unique operation name ('sin', 'cos', 'add') to the total number of times it appears across all steps."
    },
    {
        "instruction": "Implement a function that takes two numerical inputs. Apply the sine function to the first input. Apply the sine function again to the result. Apply the cosine function to the second input. Return the sum of the results from the second sine application and the cosine application."
    },
    {
        "instruction": "Write a function that takes a string representing a simple mathematical expression (e.g., 'sin(sin(x)) + cos(y)'). Return a dictionary where keys are the names of the mathematical operations ('sin', 'cos', 'add') found, and values are their corresponding counts in the expression."
    },
    {
        "instruction": "Write a function that takes two numerical inputs, `x` and `y`, and returns the result of `sin(sin(x)) + cos(y)`. Ensure it handles standard floating-point numbers."
    },
    {
        "instruction": "Create a function that accepts byte data assumed to be compressed using the Gzip format. It should decompress this data and return the original bytes. Handle potential decompression errors (e.g., invalid format) by returning an empty byte string or raising a custom error."
    },
    {
        "instruction": "Write a function that takes Gzip-compressed bytes as input. This function should first decompress the bytes, then decode the resulting bytes as a UTF-8 string, and parse this string as JSON into a dictionary. Finally, verify that the resulting dictionary contains exactly the following top-level keys: `'sampleType'`, `'sample'`, `'stringTable'`, `'location'`, `'function'`. Return `True` if all steps are successful and the keys match, `False` otherwise (e.g., decompression failure, decoding error, JSON parsing error, key mismatch)."
    },
    {
        "instruction": "Develop a function that receives a dictionary (map) and a list of required string keys. Return `True` if the dictionary contains *all* the specified keys at its top level, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes two lists representing the shapes of two multi-dimensional arrays and two lists representing pairs of corresponding batch dimension indices. Return `True` if the batch dimensions are compatible (i.e., have the same size for corresponding pairs), and `False` otherwise."
    },
    {
        "instruction": "Write a function that validates input for a generalized tensor dot product. Given two shapes (e.g., lists/tuples of integers) and dimension specifications (contracting and batch dimensions as pairs of indices), check if: (a) all dimension indices are valid for their respective shapes, (b) contracting dimensions have matching sizes, and (c) batch dimensions have matching sizes. Return `True` if valid, `False` otherwise."
    },
    {
        "instruction": "Create a function that takes two multi-dimensional numerical arrays and two lists of dimension indices (one list per array). Compute the sum-reduction over the specified dimensions for each array. For example, if array A has shape (X, Y, Z) and dimensions [1] are specified, the output should have shape (X, Z)."
    },
    {
        "instruction": "Implement a function that performs a generalized tensor dot product. It should accept two multi-dimensional numerical arrays (A, B) and dimension specification parameters: `contract_dims` (a list of pairs `(dim_A, dim_B)`) and `batch_dims` (a list of pairs `(dim_A, dim_B)`). The function should sum over the element-wise product along contracting dimensions and align batch dimensions, returning the resulting array."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array where each row represents a vector. Return a 1D array containing the L2 norm (Euclidean length) of each row vector."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array `data` and a 1D array of integer `indices`. It should return a new 2D array composed of the rows from `data` at the specified `indices`."
    },
    {
        "instruction": "Implement a function that takes two pairs as input: `pair1 = (value1, index1)` and `pair2 = (value2, index2)`. The function should compare `value1` and `value2` and return the pair corresponding to the larger value. Assume values are numerical and indices are integers."
    },
    {
        "instruction": "Develop a function that receives a 1D numerical array. Process this array in non-overlapping windows of size 2. For each window, determine the index (relative to the original array) of the element with the maximum value. Return a 1D array containing these maximum value indices. Assume the input array length is always even."
    },
    {
        "instruction": "Develop a function for 2D convolution supporting kernel dilation. Inputs are a 4D input array, a 4D kernel array, 2D strides, and 2D dilation factors (dilation_h, dilation_w). Assume 'valid' padding. The dilation factor specifies the spacing when applying the kernel. Return the 4D output array."
    },
    {
        "instruction": "Implement a function for grouped 2D convolution based on feature groups. Inputs: a 4D input array (N, H, W, C_in), a 4D kernel array (C_out, kH, kW, C_in_per_group), and an integer group count `G`. Assume C_in and C_out are divisible by `G`, strides are (1,1), and padding is 'valid'. Perform `G` independent convolutions and concatenate the results along the channel dimension. Return the 4D output array."
    },
    {
        "instruction": "Write a function that rearranges the dimensions of a multi-dimensional numerical array. It takes the array and a tuple or list specifying the new order of axes (e.g., (0, 3, 1, 2) for a 4D array) and returns the rearranged array."
    },
    {
        "instruction": "Create a function that applies padding to a multi-dimensional numerical array based on a list of pairs, where each pair specifies the padding width (before, after) for the corresponding dimension. Fill padded areas with zeros. Return the padded array."
    },
    {
        "instruction": "Write a function that takes a 2D array of 32-bit floating-point numbers and returns a new 2D array of the same shape where each element is converted to a 32-bit integer (e.g., via truncation)."
    },
    {
        "instruction": "Create a function that accepts a 2D array of 32-bit integers and returns a new 2D array of the same shape where each element is converted to a 32-bit floating-point number."
    },
    {
        "instruction": "Implement a function that takes a numerical array (potentially multi-dimensional) and a target data type identifier (e.g., 'int32', 'float32'). It should return a new array of the same shape with elements converted to the specified type. Handle conversions between 32-bit integer and 32-bit float types."
    },
    {
        "instruction": "Develop a function that converts the element type of a given N-dimensional numerical array from one specified numerical type (e.g., 'float32') to another (e.g., 'int32'). Ensure the output array has the exact same dimensions (shape) as the input array."
    },
    {
        "instruction": "Write a function that simulates the effect of reducing only the exponent range of a floating-point number. Given a float and a positive integer `exponent_bits`, return the number clamped to the representable range defined by the new exponent size. Keep the mantissa precision unchanged."
    },
    {
        "instruction": "Implement a function that simulates the effect of reducing only the mantissa precision of a floating-point number. Given a float and a positive integer `mantissa_bits`, return the number modified as if its fractional part has reduced precision (e.g., by rounding or truncation based on the new mantissa size). Keep the exponent unchanged."
    },
    {
        "instruction": "Write a function that takes a single floating-point number and two positive integers, `exponent_bits` and `mantissa_bits`, and returns the number converted to a lower-precision format defined by these bit counts. The specific conversion details (e.g., rounding mode) can be simplified (e.g., truncation)."
    },
    {
        "instruction": "Develop a function that validates parameters for a precision reduction operation. It should take two integers, `exponent_bits` and `mantissa_bits`, and return `True` if both are non-negative, and `False` otherwise."
    },
    {
        "instruction": "Write a function that reinterprets the bits of elements in a numerical array of any dimension. It should accept the input array, the original data type identifier, and the target data type identifier. First, check if the original and target types have the same byte size. If they do, return a new array with the same dimensions as the input, where each element's bits are interpreted according to the target type. If the sizes differ, indicate an error (e.g., return None or raise an error)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array of 32-bit floating-point numbers and returns a new 1D array of the same length containing 32-bit integers, where each integer corresponds to the bit pattern of the respective input float."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix) of shape (M, N) with elements of a specific data type (e.g., 32-bit integer) and returns a new 2D array of the same shape (M, N), but with elements interpreted as a different data type of the *same size* (e.g., 32-bit float), preserving the underlying bit patterns."
    },
    {
        "instruction": "Develop a function that determines if two given data type identifiers (e.g., 'float32', 'int32', 'int64') represent types occupying the same number of bytes in memory. Return true if they have the same size, false otherwise."
    },
    {
        "instruction": "Create a function that accepts three 1D numerical arrays of the same length: `min_vals`, `operand_vals`, `max_vals`. Return a new 1D array where each element `i` is the corresponding `operand_vals[i]` clamped between `min_vals[i]` and `max_vals[i]`."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array `min_limits` and a 2D numerical array `data`. Assume the length of `min_limits` matches the number of columns in `data`. Return a new 2D array of the same shape as `data` where each element `data[i, j]` is clamped so it is not less than `min_limits[j]`. (This task focuses only on the lower bound and broadcasting)."
    },
    {
        "instruction": "Implement a function that takes a numerical scalar `minimum`, a numerical array `operand`, and a numerical scalar `maximum`. Return a new array of the same shape as `operand` where each element is clamped between `minimum` and `maximum`."
    },
    {
        "instruction": "Write a function that takes three numerical scalars: `minimum`, `value`, and `maximum`. Return `minimum` if `value` is less than `minimum`, `maximum` if `value` is greater than `maximum`, otherwise return `value`."
    },
    {
        "instruction": "Create a function to perform matrix-vector multiplication. It should accept a 2D numerical array (matrix) of shape (M, N) and a 1D array (vector) of shape (N,) and return a 1D array (vector) of shape (M,)."
    },
    {
        "instruction": "Develop a function that validates if the shapes of two numerical arrays are compatible for a standard dot product. It takes two shape tuples (e.g., `(M, K)` and `(K, N)`, or `(K,)` and `(K,)`) and returns `True` if their inner dimensions match for multiplication, and `False` otherwise."
    },
    {
        "instruction": "Write a function that computes the dot product of two 1D numerical arrays (vectors) of the same size. It should take two vectors as input and return a single scalar value."
    },
    {
        "instruction": "Write a function to calculate the dot product of two 2D numerical arrays (matrices) containing floating-point numbers, prioritizing numerical accuracy. Given matrices A (shape M, K) and B (shape K, N), compute the product C (shape M, N) while aiming to minimize potential precision loss during intermediate calculations."
    },
    {
        "instruction": "Write a function that computes the dot product of two 1D numerical arrays (vectors) of the same size. Return a single scalar value representing the sum of the element-wise products."
    },
    {
        "instruction": "Write a function that performs a generalized dot product between two multi-dimensional numerical arrays. Inputs: array A, array B, a list of dimension indices in A to contract, and a corresponding list of dimension indices in B to contract. Assume the contracting dimensions are compatible. Return the resulting array, whose shape consists of the non-contracted dimensions of A followed by the non-contracted dimensions of B."
    },
    {
        "instruction": "Create a function to perform standard matrix multiplication. It should take two 2D numerical arrays, A (shape M x K) and B (shape K x N), and return their product C (shape M x N)."
    },
    {
        "instruction": "Implement a function that performs a tensor contraction between two 3D numerical arrays, A (shape I x J x K) and B (shape K x L x M), contracting along the last dimension of A (index 2) and the first dimension of B (index 0). Return the resulting 4D array (shape I x J x L x M)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array of shape `(M,)` and a target leading dimension size `N`. Return a 2D numerical array of shape `(N, M)` where the original 1D array is replicated `N` times along the first dimension."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array of shape `(M, K)` and a target leading dimension size `N`. Return a 3D numerical array of shape `(N, M, K)` where the original 2D array is replicated `N` times along the first dimension."
    },
    {
        "instruction": "Write a function that takes a single numerical value (scalar) and a target dimension size (e.g., `N`). Return a 1D numerical array of size `N` where every element is the input scalar value."
    },
    {
        "instruction": "Develop a function that accepts a numerical array of any shape `S` and a tuple `B` representing desired *leading* dimensions. Return a new array with shape `B + S`, where the data from the input array is replicated across the dimensions specified by `B`. If `B` is empty, return the original array."
    },
    {
        "instruction": "Implement the core logic of the `broadcast_array` function from Task 3. Handle potential errors gracefully, such as invalid `dimension_mapping` (e.g., out-of-bounds indices, incorrect length compared to input rank) or incompatible shapes (e.g., input dimension size mismatching the corresponding output dimension size). Return the broadcasted array or raise/return an informative error indicator upon failure."
    },
    {
        "instruction": "Develop a function `validate_broadcast(input_shape, output_shape, dimension_mapping)`. It should return `True` if the provided shapes and mapping are valid for a broadcasting operation (where input dimensions are placed according to the mapping and their sizes match the corresponding output dimensions), and `False` otherwise. Check conditions like mapping length vs. input rank, valid mapping indices, and matching dimension sizes."
    },
    {
        "instruction": "Write a function that takes a single numerical value (scalar) and a target shape (tuple of positive integers). Return a new array filled with the scalar value, having the specified target shape."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array (vector) of size N, a target 2D shape (R, C), and a single integer `dim_index` (0 or 1). If `dim_index` is 0, place the input vector along the dimension specified by `dim_index` (output shape (N, C)), replicating it across the other dimension. If `dim_index` is 1, do the same (output shape (R, N)). Assume N matches the corresponding dimension size in the target shape."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array and a tuple of dimension indices (which can be positive or negative). Return a new array with all specified dimensions removed. Assume all specified dimensions are guaranteed to have size 1."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and a single non-negative integer `dim`. If the dimension `dim` of the input array has size 1, return a new array with that dimension removed. If the dimension does not have size 1, return the original array unchanged."
    },
    {
        "instruction": "Develop a function that takes a multi-dimensional numerical array and a tuple of dimension indices. Verify that each specified dimension index corresponds to a dimension of size 1 in the input array. If all checks pass, return the array with those dimensions removed. If any specified dimension does *not* have size 1, the behavior is undefined (or can optionally return the original array)."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array and a tuple of dimension indices (positive or negative). Remove the specified dimensions. If any specified dimension index is invalid (out of bounds) or refers to a dimension that does *not* have size 1, raise a specific error (e.g., ValueError or IndexError) indicating the problem."
    },
    {
        "instruction": "Write a function that flattens a multi-dimensional numerical array into a 1D array. It should take the multi-dimensional array as input and return a 1D array containing all its elements, preserving the element order (row-major/C-style)."
    },
    {
        "instruction": "Create a function that checks if two shapes (represented as lists of positive integers, e.g., `[2, 6]` and `[3, 4]`) are compatible for a reshape operation. Compatibility means they must describe the same total number of elements. Return `True` if compatible, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a list representing the shape of a multi-dimensional array (e.g., `[2, 3, 4]`) and calculates the total number of elements it contains. Return -1 if the shape is invalid (e.g., contains non-positive numbers)."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and a target shape (list of positive integers). If the total number of elements matches, return a new array with the target shape, containing the elements of the input array in their original order (row-major/C-style). Otherwise, indicate an error (e.g., return None or raise an exception)."
    },
    {
        "instruction": "Develop a function that calculates the output shape of an array after edge and interior padding. Input: the original array's shape (e.g., a tuple like `(M, N)`) and a padding configuration (e.g., `[(p0_low, p0_high, p0_int), (p1_low, p1_high, p1_int)]`). Output: the shape tuple of the array *after* padding is applied."
    },
    {
        "instruction": "Implement a function that pads a 1D numerical array with interior padding. It takes the array, a padding value, and a tuple `(pad_before, pad_after, pad_interior)`. Add `pad_before` elements at the start, `pad_after` elements at the end, and insert `pad_interior` padding elements *between* each original element. Return the new padded array."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array (rank >= 2), a padding value, and a padding configuration (a list of tuples `(pad_low, pad_high)` for each dimension). Return the new array padded only at the edges (no interior padding) according to the configuration."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array, a padding value, and a list of two tuples `[(pad_dim0_before, pad_dim0_after), (pad_dim1_before, pad_dim1_after)]`. Return a new 2D array padded along the edges of each dimension according to these specifications using the given padding value."
    },
    {
        "instruction": "Write a function that takes three numerical scalar inputs: `condition`, `value_if_true`, `value_if_false`. If `condition` is negative, return `value_if_true`; otherwise, return `value_if_false`."
    },
    {
        "instruction": "Develop a function that takes three 2D numerical arrays of the same shape (M, N): `conditions`, `values_if_true`, `values_if_false`. Return a new 2D array of shape (M, N) where each element `[i, j]` is chosen from `values_if_true[i, j]` if `conditions[i, j]` is negative, and from `values_if_false[i, j]` otherwise."
    },
    {
        "instruction": "Write a function that performs element-wise selection between two numerical arrays (`x`, `y`) based on a third array (`c`). The function accepts `c`, `x`, and `y`. `x` and `y` must have the same shape and data type. `c`'s shape must be broadcastable to the shape of `x` and `y` (e.g., `c` is scalar, or `c` has the same shape as `x` and `y`). Return an array with the same shape/type as `x`/`y`, selecting from `x` where the corresponding element of `c` is negative, and from `y` otherwise."
    },
    {
        "instruction": "Create a function that accepts three 1D numerical arrays of the same size: `conditions`, `values_if_true`, `values_if_false`. Return a new 1D array where each element is selected from `values_if_true` or `values_if_false` based on whether the corresponding element in `conditions` is negative."
    },
    {
        "instruction": "Create a function to extract a rectangular sub-region from a 2D numerical array (matrix). Input includes the matrix, a tuple for start indices (row, col), and a tuple for end indices (row, col, exclusive). Return the extracted sub-matrix."
    },
    {
        "instruction": "Write a function that extracts a contiguous sub-section from a 1D numerical array. It should take the array, a start index, and an end index (exclusive) as input and return the corresponding sub-array."
    },
    {
        "instruction": "Write a general function to slice a multi-dimensional numerical array. It should take the array, a sequence of start indices, a sequence of end indices (exclusive), and an optional sequence of positive integer strides (defaulting to 1 for all dimensions if omitted). Return the extracted sub-array. Ensure the lengths of index/stride sequences match the array's dimensionality."
    },
    {
        "instruction": "Implement a function that slices a 1D numerical array with a specified step size. It accepts the array, a start index, an end index (exclusive), and a positive integer stride value. Return the resulting sliced array."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix), an integer `axis` (0 for rows, 1 for columns), and a list of positive integers `sizes`. Split the matrix along the specified `axis` into sub-matrices according to `sizes`. Return a list of the resulting sub-matrices. Assume the sum of `sizes` matches the dimension length along `axis`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a list of positive integers `sizes`. Split the array into contiguous sub-arrays whose lengths are given by `sizes`. Return the list of sub-arrays. Assume the sum of `sizes` equals the length of the input array."
    },
    {
        "instruction": "Implement a function that validates inputs for an array splitting operation. It takes the shape (a tuple/list of integers) of a multi-dimensional array, an integer `axis`, and a list of positive integers `sizes`. Return `True` if `axis` is a valid dimension index for the shape and the sum of `sizes` equals the length of the dimension specified by `axis`, otherwise return `False`."
    },
    {
        "instruction": "Implement a function that splits an N-dimensional numerical array along a specified `axis` into multiple sub-arrays. The function should take the array, the `axis` index, and a list of integers `sizes` defining the length of each sub-array along that `axis`. Return a list containing the resulting sub-arrays. Assume the sum of `sizes` matches the dimension length along the `axis`."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and returns its transpose. The input shape (M, N) should result in an output shape (N, M)."
    },
    {
        "instruction": "Develop a function that accepts a 3D numerical array with shape (Depth, Height, Width) and returns a new 3D array where the Height and Width dimensions are swapped for each depth slice. The output shape should be (Depth, Width, Height)."
    },
    {
        "instruction": "Create a function that checks if a given tuple of integers is a valid permutation of the indices (0, 1, ..., N-1) for a given integer N. It should return True if it is a valid permutation, False otherwise."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and a tuple representing a permutation of its axes. The function should return a new array with dimensions rearranged according to the permutation. For example, if the input array has shape (A, B, C) and the permutation is (2, 0, 1), the output array should have shape (C, A, B)."
    },
    {
        "instruction": "Create a function that calculates the product of all elements in a given numerical array. It takes the array and an initial value (1) as input and returns a single scalar value representing the total product."
    },
    {
        "instruction": "Write a function that finds the minimum value within a numerical array, considering specific data types. It should accept the array and return the minimum value. Ensure it correctly handles initial comparison values for different types (e.g., positive infinity for floats, maximum representable value for integers/unsigned integers) when performing the reduction implicitly across all elements."
    },
    {
        "instruction": "Implement a function to find the maximum element along specified dimensions of a numerical array. It should accept the array, an appropriate initial value (like negative infinity for floats or the minimum representable value for integers), and a tuple of dimension indices. It returns an array with the specified dimensions reduced."
    },
    {
        "instruction": "Write a function that computes the sum of elements along a single specified dimension of a multi-dimensional numerical array. It takes the array, an initial value (0), and the dimension index as input. It returns an array with the specified dimension removed."
    },
    {
        "instruction": "Write a function that takes two pairs of numbers, `(a1, b1)` and `(a2, b2)`, and returns a new pair `(a1 + a2, b1 * b2)`. Ensure the function handles standard numerical types."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays of the same length, `arr1` and `arr2`. It should return a pair of numbers `(sum_val, prod_val)`, where `sum_val` is the cumulative sum of elements in `arr1` starting from 0, and `prod_val` is the cumulative product of elements in `arr2` starting from 1."
    },
    {
        "instruction": "Develop a function that accepts two multi-dimensional numerical arrays of identical shape, `arr1` and `arr2`, and a tuple specifying axes (dimensions) along which to reduce. It should compute the sum of `arr1` and the product of `arr2` along these axes, using initial values 0 and 1 respectively. Return a tuple containing the two resulting arrays with reduced dimensions."
    },
    {
        "instruction": "Create a function that accepts a numerical data type identifier (e.g., 'int32', 'float64') and returns a tuple containing the additive identity (0) and the multiplicative identity (1) appropriate for that data type."
    },
    {
        "instruction": "Implement a function that finds either the minimum or maximum element's index along a given dimension of a multi-dimensional numerical array. The function should accept the array, the dimension (axis index), and a string ('min' or 'max') indicating which operation to perform. Return an array of integer indices."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns the *index* of the maximum value. If multiple maxima exist, return the index of the first one encountered."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array and an integer representing an axis. It should return a new array containing the *indices* of the minimum values along the specified axis. The output array's shape should be the same as the input array's shape but with the specified axis removed."
    },
    {
        "instruction": "Write a function that applies a specified index-finding operation ('find_min_index' or 'find_max_index') along a given axis of a multi-dimensional numerical array. The function should take the array, the axis index, and the operation type as input. It should return an array of integer indices corresponding to the results of the operation along that axis. Ensure the output array has the correct shape (input shape with the specified axis removed)."
    },
    {
        "instruction": "Write a function that finds the maximum value within sliding windows of a 1D numerical array. Inputs: the array, window size, stride, and window dilation factor. The dilation factor specifies spacing between elements considered within a window (e.g., dilation 2 means consider elements at index i, i+2, i+4...). Use 'VALID' padding. Return the 1D array of results."
    },
    {
        "instruction": "Develop a function that applies a sum reduction over sliding windows on a 1D numerical array. Inputs: the array, window size, stride. Implement 'SAME' padding: pad the input (e.g., with zeros) so the output has length `ceil(input_length / stride)`. Return the 1D array of results."
    },
    {
        "instruction": "Write a function that computes the maximum value within fixed-size, non-overlapping 2x2 blocks of a 2D numerical input array. Return a new 2D array containing the maximums. Assume the input dimensions are multiples of 2."
    },
    {
        "instruction": "Create a function that performs a generalized sliding window reduction on a 2D numerical array. Inputs: the array, an initial value, a binary reduction function (e.g., add, max), window dimensions, strides, and explicit padding amounts (top, bottom, left, right). Apply the reduction function over the windows of the padded input. Return the resulting 2D array."
    },
    {
        "instruction": "Develop a function to compute the cumulative product along a specified axis of a multi-dimensional numerical array. Include a boolean `reverse` parameter to control the accumulation direction (forward or backward along the axis). Input: N-D array, integer axis index, boolean flag. Output: N-D array of the same shape and numerical type."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array (containing floats or integers) and an axis index. It should compute the cumulative sum along that axis, ensuring the output array maintains the exact same numerical data type (float or integer) as the input array. Input: N-D array (float or int), integer axis index. Output: N-D array of the same shape and data type."
    },
    {
        "instruction": "Write a function that computes the cumulative sum of elements in a 1D numerical array. For input `[a, b, c]`, the output should be `[a, a+b, a+b+c]`. The function should accept a 1D array and return a 1D array of the same size and numerical type."
    },
    {
        "instruction": "Implement a function that performs cumulative summation along a specified axis of a multi-dimensional numerical array. Input: N-D array, integer axis index. Output: N-D array of the same shape and numerical type, where each element represents the sum accumulated along the specified axis up to that element's position."
    },
    {
        "instruction": "Implement a function that extracts sliding windows from a 2D numerical array. It should take the array, window dimensions (height, width), and strides (vertical, horizontal) as input. Return a list or generator yielding each window as a 2D array. Assume 'VALID' padding (no padding applied)."
    },
    {
        "instruction": "Write a function `apply_batched(func, array, batch_axes)` that applies a given function `func` to slices of a multi-dimensional `array`. `batch_axes` specifies which axes are batch dimensions (e.g., `(0,)` or `(0, 1)`). `func` operates on a single slice (with batch dimensions removed). The function should iterate through the batch dimensions, apply `func` to each slice, and combine the results into an output array with the original batch dimensions preserved."
    },
    {
        "instruction": "Develop a function `select_gather_add(operand_array, value_array, window_shape, strides)` taking two same-shaped 2D numerical arrays, window dimensions, and strides. For each window position ('VALID' padding logic): identify elements in the `operand_array` window that meet a condition (e.g., greater than or equal to zero). Sum the corresponding elements from the `value_array` window. Return a 2D array containing these sums for each window position."
    },
    {
        "instruction": "Create a function `apply_padding(array, padding_config)` that takes a multi-dimensional numerical array and a padding configuration (a list of tuples `[(p_before_dim0, p_after_dim0), (p_before_dim1, p_after_dim1), ...]`). It should return a new array with the specified padding added, filled with zeros."
    },
    {
        "instruction": "Create a function that iterates over a multi-dimensional numerical array using specified window dimensions and strides. For each window, it should identify the *index* (relative to the start of the input array) of the element with the maximum value within that window. Inputs: N-dimensional array, window dimensions, strides. Output: An array containing the indices of the maximum elements for each window position."
    },
    {
        "instruction": "Implement a function that performs an additive scatter operation based on indices. Inputs: a source numerical array `values`, an array `indices` (same shape as `values`) where each element specifies a target index in the output, and the desired shape of the output array. Output: An array of the specified output shape, initialized to zeros, where `output[indices[i]] += values[i]` for every element `i` in the flattened `values` and `indices` arrays."
    },
    {
        "instruction": "Develop a function that simulates a 'select-and-scatter-add' operation for a 2D numerical array. It takes an input 2D array, a second 2D array `grads` (representing incoming values, shape matches the *output* size of a corresponding pooling operation), window dimensions (height, width), and strides (vertical, horizontal). For each window in the input array, find the location (row, col) of the maximum value. Add the corresponding value from `grads` to an output array (same shape as the input array, initialized to zeros) at that location. Assume 'VALID' padding. Return the output array."
    },
    {
        "instruction": "Write a function that takes the shape of an N-dimensional array and returns the shape of the output after applying a windowed reduction (like max pooling) with given window dimensions, strides, and 'VALID' padding. Inputs: input shape (tuple), window dimensions (tuple), strides (tuple). Output: output shape (tuple)."
    },
    {
        "instruction": "Create a function that accepts an array's shape tuple (e.g., `(2, 3, 4, 5)`) and an integer `k` representing the number of trailing dimensions. Return a tuple containing the sizes of these last `k` dimensions (e.g., for `k=2`, return `(4, 5)`)."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array, an integer `k` (representing the number of trailing dimensions), and a transformation function `func`. The `func` takes a k-dimensional slice of the input array and returns a transformed slice of the same shape. Apply `func` independently to all k-dimensional slices formed by the last `k` axes of the input array. Return the reconstructed array."
    },
    {
        "instruction": "Implement a function that computes the 1-dimensional Discrete Fourier Transform (DFT) for a given 1D array of complex numbers. The function should accept the 1D complex array and return a new 1D complex array representing the frequency domain."
    },
    {
        "instruction": "Write a function that accepts a shape tuple (e.g., `(10, 20, 5)`) and a non-negative integer `k`. Return a tuple containing the indices of the last `k` dimensions. If `k` is 0, return an empty tuple. If `k` exceeds the number of dimensions, return indices for all dimensions."
    },
    {
        "instruction": "Implement a batched gather operation. Given a 3D numerical array `batched_data` (e.g., Batch x Length x Features) and a 2D integer array `batched_indices` (Batch x NumIndices), where indices refer to the `Length` dimension, return a 3D array `output` (Batch x NumIndices x Features). For each batch `b`, `output[b, i, :]` should be `batched_data[b, batched_indices[b, i], :]`."
    },
    {
        "instruction": "Create a function that extracts contiguous slices of a fixed size from a 1D numerical array. It takes the 1D `data` array, a 1D integer array `start_indices`, and an integer `slice_size`. Return a 2D array where each row is a slice of length `slice_size` starting at the corresponding index from `start_indices`. Handle boundary conditions where a slice might extend beyond the data array length."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `data` and a 1D integer array `indices`. Return a new 1D array containing elements from `data` at the positions specified by `indices`. Ensure index bounds are handled (e.g., skip invalid indices or raise an error)."
    },
    {
        "instruction": "Implement a function to select specific rows from a 2D numerical array (matrix). It accepts the 2D `matrix` and a 1D integer array `row_indices`. Return a new 2D array composed of the rows from the original matrix at the specified indices, maintaining the original row order from `row_indices`."
    },
    {
        "instruction": "Develop a function that performs scatter-add with windowed updates. Inputs: a multi-dimensional `operand`, an `indices` array specifying starting coordinates for updates, an `updates` array containing blocks (windows) to add, and configuration defining which dimensions of `updates` form the window and how `indices` map to `operand` dimensions (e.g., index dim 0 maps to operand dim 1). Return a *new* array representing the `operand` after adding the update windows at the specified locations. Accumulate additions if windows overlap."
    },
    {
        "instruction": "Write a function that handles batched scatter-add. Inputs: `operand` (shape B x D1 x D2), `indices` (shape B x N x K), `updates` (shape B x N x ...), where B is the batch dimension, N is the number of updates per batch item, and K relates to operand dims. Apply scatter-add logic (adding `updates` elements/slices to `operand` locations based on `indices`) independently for each batch element `b` from 0 to B-1, respecting the mapping between index dimensions (K) and operand dimensions (D1, D2). Return the resulting batched array (shape B x D1 x D2)."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array `matrix`, a 1D integer array `row_indices`, and a 2D numerical array `row_updates`. The number of rows in `row_updates` must match the length of `row_indices`, and the number of columns must match `matrix`. Return a *new* matrix where the row `row_updates[i]` is added to the row `matrix[row_indices[i]]` for all `i`. Accumulate additions for duplicate `row_indices`."
    },
    {
        "instruction": "Implement a function taking a 2D numerical array `target`, a 2D integer array `indices` (shape: num_updates x 2), and a 1D numerical array `updates` (shape: num_updates). Each row `indices[i]` specifies a `(row, column)` index into `target`. Return a *new* array like `target` where `updates[i]` is added to the element `target[indices[i][0], indices[i][1]]`. Accumulate additions for duplicate index pairs."
    },
    {
        "instruction": "Extend the generalized scatter function from Task 4 to support batching. The `target`, `indices`, and `updates` arrays can now have one or more leading batch dimensions, specified by the caller. The scatter operation (including index mapping and window updates) should be performed independently for each corresponding slice along the batch dimensions. Return the updated target array, preserving the batch dimensions."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `data`, a 1D array of integer indices `indices`, and a 1D array of `updates`. Return a *copy* of `data` where the elements at the specified `indices` are replaced by the corresponding values in `updates`. If an index appears multiple times, the last corresponding update value should be used. Ensure all indices are within the bounds of `data`."
    },
    {
        "instruction": "Write a function to scatter updates into a target N-dimensional numerical array. Inputs are the `target` array, an `indices` array specifying starting coordinates for updates within the target, and an `updates` array containing the values to scatter. Also provide mapping rules: specify which dimensions of `updates` correspond to the window/slice being updated, which dimensions of the target are *not* indexed by `indices` but *are* part of the window, and how the dimensions of `indices` map to dimensions in the `target`. Return a copy of the `target` array with specified windows updated by values from `updates`. Assume updates overwrite existing values."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array `data`, a 1D array of integer indices `indices`, a 1D array of `updates`, and a numerical function `func`. First, apply `func` element-wise to each value in the `updates` array. Then, return a *copy* of `data` where elements at the specified `indices` are replaced by the corresponding *transformed* update values. Handle duplicate indices by using the last transformed update value."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and an integer `k`. It should return a new 1D array containing the indices of the `k` largest values from the input array. The order of indices should correspond to the descending order of their values. Assume `k` is positive and not greater than the array length."
    },
    {
        "instruction": "Develop a function that accepts a multi-dimensional numerical array and an integer `k`. It should operate along the last dimension of the array. For each slice along the last dimension, find the `k` largest values and their corresponding indices within that slice. Return two arrays of the same rank as the input: one containing the top `k` values for each slice (sorted descending), and one containing their original indices within the slice. The shape of the last dimension in the output arrays should be `k`."
    },
    {
        "instruction": "Write a function that generates an array of a specified shape filled with random integers. The function should take the desired shape (e.g., a tuple like `(3, 5)`) and an upper bound (exclusive) for the random integers (lower bound is 0). Return the generated array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a tuple containing the largest value in the array and its index. If multiple elements share the largest value, the index of the first occurrence is sufficient."
    },
    {
        "instruction": "Develop a function to create a numerical array of a given shape (e.g., (3, 4, 5)) filled with small random numbers of a specified numerical data type."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and an integer specifying a dimension index. Conceptually, treat each slice along this dimension as an independent item and return the original array, signifying that each item was processed."
    },
    {
        "instruction": "Write a higher-order function `apply_batch`. This function accepts another function `op`, input data (a multi-dimensional numerical array), and a dimension index `batch_axis`. `apply_batch` should simulate applying `op` to each slice of the input data along the `batch_axis` and return the collected results in an array of the same shape as the input. Assume `op` is an operation that doesn't change the shape of the slice it receives."
    },
    {
        "instruction": "Write a function that takes a numerical array of any shape and returns a new array containing the exact same elements in the same shape."
    },
    {
        "instruction": "Write a function that accepts two 2D numerical arrays, `A` and `B`, of identical shape, and an axis index. Sort array `A` based on the values along the specified axis. Apply the exact same element permutations (derived from sorting `A`) to array `B` along the same axis. Return both the sorted `A` and the correspondingly permuted `B`."
    },
    {
        "instruction": "Develop a function that takes two 1D numerical arrays of the same length, `keys` and `values`. It should return two new arrays: `sorted_keys` (the `keys` array sorted ascendingly) and `sorted_values` (the `values` array permuted according to the sorting order determined by `keys`)."
    },
    {
        "instruction": "Implement a function that performs a *stable* sort on a 1D numerical array containing potentially duplicate elements. Return a new array sorted ascendingly, ensuring that the relative order of equal elements is preserved from the original array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array containing the same elements sorted in ascending order."
    },
    {
        "instruction": "Implement a function that takes two 2D numerical arrays (matrices) and an axis index (0 or 1). It should compute the vector dot product along the specified axis. Assume the dimension specified by the axis is the same size for both matrices, and the other dimension is also identical. Return a 1D array containing the results."
    },
    {
        "instruction": "Write a function that computes the dot product of two 1D numerical arrays (vectors) of the same size. It should take two 1D arrays as input and return a single scalar value representing their dot product."
    },
    {
        "instruction": "Write a function that takes the number of dimensions (rank) of an array and an axis index (which can be negative). It should return the equivalent positive axis index. Ensure the function handles valid negative indices correctly (e.g., -1 refers to the last axis). Raise an error or return an indicator if the axis index is out of bounds for the given rank."
    },
    {
        "instruction": "Develop a function that calculates the vector dot product of two multi-dimensional numerical arrays along a specified axis. The function accepts the two arrays and an integer axis index (which can be negative). It must handle broadcasting for dimensions *not* specified by the axis index. The dimension size along the specified axis must be equal for both input arrays. Return the resulting array."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array and two non-negative integers specifying padding widths before (`pad_before`) and after (`pad_after`). It should return a new 1D array where the padding consists of zeros. For example, padding `[1, 2, 3]` with `pad_before=2` and `pad_after=1` should result in `[0, 0, 1, 2, 3, 0]`."
    },
    {
        "instruction": "Write a function to perform constant padding on a 2D numerical array (e.g., a list of lists). It should accept the input 2D array, two pairs of non-negative integers representing padding widths `((top_pad, bottom_pad), (left_pad, right_pad))`, and a single numerical `constant_value`. Return the new 2D array with padding applied to all sides using the `constant_value`."
    },
    {
        "instruction": "Implement a function that pads a 1D numerical array using potentially different constant values at the start and end. It should accept the input array, two non-negative integers specifying the padding width before (`pad_before`) and after (`pad_after`), and two numerical values specifying the constant value to use for the before padding (`const_before`) and after padding (`const_after`) respectively. Return the new padded 1D array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (e.g., a list of numbers), a single non-negative integer `pad_width`, and a single numerical `constant_value`. It should return a new 1D array padded with `pad_width` elements of `constant_value` at both the beginning and the end."
    },
    {
        "instruction": "Create a function that accepts a positive integer `n` and generates a 1D numerical array of size `n` containing only the value 1.0."
    },
    {
        "instruction": "Write a function that computes the sum of all elements in a given 1D numerical array and returns the resulting scalar value."
    },
    {
        "instruction": "Implement a function that takes one argument. Inside the function, check if the argument is a standard 1D numerical array. If it is, return the sum of its elements; otherwise, raise a type error."
    },
    {
        "instruction": "Write a function `process_array` that takes a 1D numerical array. This function should define and call an inner helper function `calculate_sum` which sums the array elements. Before calling `calculate_sum`, `process_array` must verify the input is a valid numerical array type. Return the sum."
    },
    {
        "instruction": "Write a wrapper function `try_numerical_op(operation_func, arg1, arg2)` that attempts to call `operation_func(arg1, arg2)`. If the operation raises a `TypeError` (e.g., due to mixing standard lists with numerical arrays), the wrapper should catch it and return the string 'Invalid Input Types'. Otherwise, it should return the result of the operation."
    },
    {
        "instruction": "Implement a function `safe_elementwise_add(arr1, arr2)` that performs element-wise addition if both inputs are numerical array types of compatible shapes. If either input is not a numerical array type (e.g., a standard Python list), the function should raise a `TypeError`."
    },
    {
        "instruction": "Develop a function `validate_numerical_pair(op1, op2)` that returns `True` only if both `op1` and `op2` are numerical array types suitable for mathematical operations. It should return `False` if either operand is a standard Python list or any other incompatible type."
    },
    {
        "instruction": "Create a function `safe_vector_dot(vec1, vec2)` that computes the dot product if both inputs are 1D numerical array types. If either input is not a numerical array type (e.g., a standard Python list), the function must raise a `TypeError`."
    },
    {
        "instruction": "Develop a function that takes a single integer `n` as input. Using a loop that runs `n` times, calculate the sum of integers from 0 up to (but not including) `n`. Return the sum."
    },
    {
        "instruction": "Write a function that accepts a number and returns its square (the number multiplied by itself)."
    },
    {
        "instruction": "Implement a function that takes one numerical input. If the input is strictly positive, return the input multiplied by 2. Otherwise (if zero or negative), return the input plus 2."
    },
    {
        "instruction": "Write a function that takes a single number. Return 1 if the number is positive, -1 if it's negative, and 0 if it's exactly zero."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array, applies the hyperbolic tangent (`tanh`) to each element, and then computes the sum of the resulting transformed elements. Return the final scalar sum."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a new array where each element is the hyperbolic tangent (`tanh`) of the corresponding input element."
    },
    {
        "instruction": "Write a function that takes a start value, end value, and a number of points `N`. It should return a 1D numerical array of `N` evenly spaced points between start and end (inclusive)."
    },
    {
        "instruction": "Implement a function that calculates the sum of all elements in a given 1D numerical array and returns the scalar sum."
    },
    {
        "instruction": "Write a function that attempts to execute a potentially problematic operation (passed as a callable function object like a lambda) on a given numerical array. If the operation fails and raises a 'TypeError', the function should catch it and return `True`. If the operation succeeds or raises a different error, it should return `False`."
    },
    {
        "instruction": "Write a function that takes two integers, `rows` and `cols`, and returns a 2D numerical array (matrix) of shape (`rows`, `cols`) filled with sequential integers starting from 0."
    },
    {
        "instruction": "Develop a function that receives any Python object as input and returns `True` if the object is a multi-dimensional numerical array (e.g., list of lists of numbers, or a dedicated array type) and `False` otherwise. Do not check for specific library types."
    },
    {
        "instruction": "Implement a function that accepts a 1D numerical array containing `N*M` elements and two integers `N` and `M`. The function should return a new 2D numerical array of shape (`N`, `M`) formed by reshaping the input array. Ensure the total number of elements is compatible."
    },
    {
        "instruction": "Develop a function that takes an input variable and returns `True` if it represents a 2D numerical array containing only 32-bit integer values, and `False` otherwise."
    },
    {
        "instruction": "Write a function `safe_convert_to_list(array_object)` that attempts to convert a given `array_object` into a nested Python list structure. If the conversion is successful, it returns the list. If the conversion fails specifically because the object represents an abstract or non-concrete array (indicated by a `TypeError` during the attempt), the function should catch this `TypeError` and return `None`. Any other type of error should not be caught."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array of shape (`rows`, `cols`) containing sequential integers starting from 0, arranged row-wise."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (M rows, N columns) and returns a standard Python list of lists, where each inner list corresponds to a row from the input array, preserving element order and values."
    },
    {
        "instruction": "Develop a function that takes a single scalar value and a tuple representing a target shape (e.g., `(2, 3, 4)`). Return a new multi-dimensional array of the target shape where every element is the input scalar value."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (e.g., `[a, b]`) and a target shape `(M, N)` where `N` matches the array length. It should return a 2D array where the input array is repeated across all `M` rows. Example: input `[1, 2]`, shape `(3, 2)` -> `[[1, 2], [1, 2], [1, 2]]`."
    },
    {
        "instruction": "Implement a function that takes an input numerical array `arr`, a target shape tuple `shape`, and a tuple `broadcast_dims` indicating how input dimensions map to output dimensions. The length of `broadcast_dims` must equal the number of dimensions of `arr`. The size of `arr` in dimension `i` must equal the size specified in `shape` at index `broadcast_dims[i]`. Return a new array with the target `shape` by replicating `arr` along the dimensions *not* specified in `broadcast_dims`. Include input validation for dimension compatibility."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (e.g., `[a, b]`) and a target shape `(M, N)` where `M` matches the array length. It should return a 2D array where the input array is repeated across all `N` columns. Example: input `[1, 2]`, shape `(2, 3)` -> `[[1, 1, 1], [2, 2, 2]]`."
    },
    {
        "instruction": "Create a function that generates a 2D numerical array (matrix) of specified dimensions (rows M, columns N) filled with sequential floating-point values starting from 1.0."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array (matrix) and a 1D array of non-negative integer indices. Return a new 2D array constructed by selecting the *columns* from the input matrix specified by the indices, preserving their order."
    },
    {
        "instruction": "Implement a function that accepts a 2D numerical array (matrix) and a 1D array of non-negative integer indices. Return a new 2D array containing the rows from the input matrix specified by the indices, maintaining the order and allowing for duplicate rows if indices are repeated."
    },
    {
        "instruction": "Write a function that performs element lookups based on index pairs. It should accept a 2D numerical array (matrix), a 1D array of row indices, and a 1D array of column indices (of the same length). Return a 1D array containing the elements located at each corresponding (row, column) index pair from the input matrix."
    },
    {
        "instruction": "Generalize Task 2. Write a function that takes a 2D numerical array `data`, a 2D integer array `indices`, and an integer `axis` (0 or 1). Return a new array containing elements from `data` selected along the specified `axis` using `indices`. The output shape must match `indices`. Ensure dimensions of `data` and `indices` are compatible for selection along the given `axis`."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array `data` and a 1D integer array `indices`. Return a new 2D array where, for each row in `data`, the element at the column specified by the corresponding value in `indices` is selected. The length of `indices` must match the number of rows in `data`. The output should be a 1D array."
    },
    {
        "instruction": "Implement a function that selects elements from a 2D numerical array `data` based on a 2D integer array `indices`. The selection must occur along the second axis (columns, axis=1). The output array's shape must match the `indices` array's shape. Assume the first dimension of `data` and `indices` are compatible."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array `data` and an integer `col_index`. Return a 1D array containing all elements from the specified column `col_index` of the input `data`."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix), an integer column index, and a numerical value. The function should return a new matrix where all elements in the specified column index across all rows are updated to the given numerical value. The input matrix dimensions should be preserved."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where the element at index 0 is replaced with the floating-point value `1.0`. The original array should not be modified."
    },
    {
        "instruction": "Develop a function that accepts a 1D numerical array, an integer index, and a numerical value. It should return a new 1D array identical to the input, except the element at the specified index is replaced by the given value. Ensure the original array remains unchanged."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix). It should return a new matrix of the same dimensions where the first element (index 0) of each row is set to the floating-point value `1.0`."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array (matrix) and a scalar value. Return a new 1D array representing the first column of the input matrix after each of its elements has been divided by the scalar."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and a non-negative integer column index. Return a 1D array representing the column specified by the index."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array (vector) and a single numerical value (scalar). Return a new 1D array where each element of the input array has been divided by the scalar."
    },
    {
        "instruction": "Implement a function that accepts a 2D numerical array (matrix) and a scalar value. Return a *new* 2D array of the same dimensions, where the *first column* is replaced by the original first column's elements each divided by the scalar, and all other columns remain unchanged."
    },
    {
        "instruction": "Create a function that accepts a shape tuple and a data type identifier. It should return a new numerical array of the specified shape and type, with all elements initialized to one."
    },
    {
        "instruction": "Develop a function that creates a numerical array filled with zeros. It should accept a shape tuple, a data type identifier, and an identifier for a target computational resource. The function must ensure the returned array is allocated on the specified resource and return the array."
    },
    {
        "instruction": "Write a function that takes a shape tuple (e.g., `(2, 3)`) and a data type identifier (e.g., 'float32'), and returns a new numerical array of that shape and type, filled entirely with zeros."
    },
    {
        "instruction": "Implement a function that takes a shape tuple, a data type identifier, and a fill value. It should return a new numerical array of the given shape and type, where every element is set to the provided fill value."
    },
    {
        "instruction": "Develop a function that allocates memory for a numerical array of a given shape and data type but does not initialize the elements (they might contain arbitrary values initially). The function should return this uninitialized array."
    },
    {
        "instruction": "Implement a function that takes a shape (tuple of integers), a data type, and a fill value. It should return a new numerical array of the given shape and type, where every element is initialized to the provided fill value."
    },
    {
        "instruction": "Write a function that takes a shape (tuple of integers) and a data type (e.g., 'float32', 'int64') and returns a new numerical array of that shape and type, with all elements initialized to zero."
    },
    {
        "instruction": "Create a function that accepts a shape (tuple of integers) and a data type. It should return a new numerical array of the specified shape and type, filled entirely with the value one."
    },
    {
        "instruction": "Develop a function that takes a template numerical array and returns a new, potentially uninitialized numerical array that strictly mirrors the template's shape and data type. The exact element values are not specified, only the shape and type."
    },
    {
        "instruction": "Write a function that takes a numerical array as input and returns a new array of the exact same shape and data type, filled entirely with zeros."
    },
    {
        "instruction": "Design a function that accepts a template numerical array and a string indicating the creation type ('zeros', 'ones', 'fill'). If the type is 'fill', it also accepts a scalar fill value. The function should return a new array matching the template's shape and data type, initialized according to the specified type (all zeros, all ones, or the fill value)."
    },
    {
        "instruction": "Create a function that accepts a numerical array and produces a new array with identical dimensions and data type, populated exclusively with ones."
    },
    {
        "instruction": "Write a function that accepts a numerical array and returns a new array filled with zeros, having the exact same dimensions and data type as the input array."
    },
    {
        "instruction": "Implement a function that receives a numerical array and a scalar fill value. It should return a new array where every element is equal to the fill value, while preserving the shape and data type of the original input array."
    },
    {
        "instruction": "Develop a function that takes a numerical array and returns a new, *uninitialized* array with the identical shape and data type. The contents of the returned array are not specified."
    },
    {
        "instruction": "Create a function that takes a numerical array as input and produces a new array filled entirely with ones, matching the shape and data type of the input."
    },
    {
        "instruction": "Write a function `process_scalar(value, target_type=None)` that first creates a container holding the `value`, converting to `target_type` if specified (as in Task 3). It should also determine if the container's type resulted from inference based on the `value`'s original type being 'special' (as defined in Task 4) *only when* `target_type` was `None`. Return the container and this boolean determination."
    },
    {
        "instruction": "Develop a function `create_typed_scalar_container(value, target_type=None)` that takes a number `value` and an optional `target_type` string. If `target_type` is given, return a container holding the `value` converted to that type. If `target_type` is `None`, return a container holding the `value` with its original type."
    },
    {
        "instruction": "Write a function `convert_scalar(value, target_type)` that takes a single number (`value`) and a string representing a numerical type (e.g., 'int32', 'float64', 'int', 'float'). Return the `value` converted to the specified `target_type`."
    },
    {
        "instruction": "Implement a function `was_type_inferred_from_special_input(input_type_str, was_target_type_specified)`. Assume you have a predefined list of 'special' input type strings (e.g., ['int', 'float']). The function returns `True` if `was_target_type_specified` is `False` AND the provided `input_type_str` is in the 'special' list, otherwise `False`."
    },
    {
        "instruction": "Write a versatile function `as_array(data, copy=None)` that converts various inputs (`data`: list, existing numerical array, data buffer) into a specific 1D numerical array type. If `copy` is True, always return a copy. If `copy` is False, return a view or reference if possible, but raise `ValueError` if `data` is a data buffer. If `copy` is None, make a copy for lists and data buffers, but potentially return a reference for existing arrays of the correct type. Ensure output array values match input sequence."
    },
    {
        "instruction": "Develop a function that attempts to create a 1D numerical array representation from an input object (could be a list, array, or data buffer). Add a boolean parameter `prevent_copy`. If `prevent_copy` is true and the input object type *requires* a copy to be made into the target array format (e.g., input is a data buffer), the function must raise a `ValueError`. Otherwise, return the resulting array."
    },
    {
        "instruction": "Implement a function that takes an input sequence (like a list or another 1D numerical array) and converts it into a 1D numerical array. Include a boolean parameter `force_copy`. If `force_copy` is false, the function should avoid copying the data if the input is already in the desired array format; otherwise (or if input is not the desired array type), it should create a copy."
    },
    {
        "instruction": "Write a function that takes a standard Python list of numbers and returns a new 1D numerical array containing the same numbers. Ensure the returned array is always a distinct copy."
    },
    {
        "instruction": "Write a function to find the index of the minimum value in a numerical array along a specified axis. It must handle multi-dimensional arrays. If the array dimension along the specified axis is zero, it must raise a standard error (like ValueError) indicating the operation cannot be performed on an empty sequence/dimension. Otherwise, it should return an array containing the indices of the minimum elements along the specified axis."
    },
    {
        "instruction": "Develop a function that finds the index of the first occurrence of the maximum value along a specified axis in a non-empty 2D numerical array. Input is the 2D array and the axis index (0 or 1). Output is a 1D array of indices."
    },
    {
        "instruction": "Implement a function that finds the index of the first occurrence of the minimum value in a non-empty 1D numerical array. Input is the 1D array, output is a single integer index."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array and an axis index (e.g., 0 for columns, 1 for rows). If the array's dimension size along the specified axis is 0, raise a standard error (like ValueError) with a message about attempting the operation on an empty dimension/sequence. Otherwise, return None."
    },
    {
        "instruction": "Write a function that manually performs an axis permutation (transpose) on a multi-dimensional numerical array. Given the array and a permutation tuple, create and return the new array by explicitly mapping elements from the old indices to the new indices based on the permutation, without using any built-in transpose methods."
    },
    {
        "instruction": "Implement a function that transposes a multi-dimensional numerical array. It should accept the array and an optional tuple specifying the new axis order. If the tuple is not provided or is empty, the axes should be reversed. Return the transposed array."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and a tuple representing a permutation of its axes. Return the array with its axes reordered according to the permutation. Example: Input array shape (2, 3, 4), permutation (1, 2, 0) -> Output shape (3, 4, 2)."
    },
    {
        "instruction": "Develop a function to check if a given tuple is a valid permutation for the axes of a multi-dimensional array. The function takes the array's shape (as a tuple) and the permutation tuple. It returns `True` if the permutation contains each axis index from 0 to ndim-1 exactly once, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a single non-negative integer index. It should return a new 1D array with the element at that specific index removed."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and a single integer index. This index can be negative, where -1 refers to the last element, -2 to the second last, etc. Return a new 1D array with the element at the specified index removed."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array, an integer `axis` (0 for rows, 1 for columns), and a 1D array of non-negative integer indices. Return a new 2D array with the rows or columns specified by the indices along the given axis removed."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical array and a 1D array of integer indices. Return a new 1D array where all elements corresponding to the provided indices have been removed."
    },
    {
        "instruction": "Develop a function that generates a specified number of unique random integers within a given range `[0, max_val)`. The number of integers requested must not exceed `max_val`. Return the unique integers as a 1D array."
    },
    {
        "instruction": "Construct a function that removes elements from a multi-dimensional numerical array based on a 1D array of unique integer indices along a specified axis. The function should accept the array, the unique indices, and the axis (which can be positive, negative, or indicate flattening). Return the resulting smaller array without altering the original."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a 1D array of unique integer indices. It should return a new 1D array with the elements at the specified indices removed."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix), an integer axis (0 for rows, 1 for columns), and a 1D array of unique integer indices. Return a new 2D array where the rows or columns specified by the indices along the given axis have been deleted."
    },
    {
        "instruction": "Develop a function that calculates the required size for a 1D mask based on an input array's shape (e.g., a tuple of dimensions) and an axis index. If the axis index is a non-negative integer, return the size of that dimension. If the axis index is `None`, return the total number of elements in the array."
    },
    {
        "instruction": "Write a function that removes elements from a multi-dimensional numerical array based on a 1D boolean mask along a specified dimension (`axis`). The function takes the array, the mask, and the axis index (`None` or an integer). If the axis index is `None`, treat the array as flattened before removal. The length of the mask must match the size of the specified dimension (or the total number of elements if axis is `None`). Return the modified array, ensuring its shape is correctly adjusted."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a 1D boolean array (mask) of the same size. Return a new 1D array containing only the elements from the input array where the corresponding mask element is `False`."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (e.g., a list of lists) and a 1D boolean array (mask). It also takes an integer `axis` (0 for rows, 1 for columns). Return a new 2D array where rows (if `axis=0`) or columns (if `axis=1`) corresponding to `True` values in the mask are removed. Ensure the mask length matches the dimension size along the specified axis."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (list of numbers) and a non-negative integer `k`. Return a new 1D array where each element from the input array is repeated `k` times consecutively."
    },
    {
        "instruction": "Develop a function that takes a multi-dimensional numerical array, a repetition value (either a single non-negative integer or a 1D array of non-negative integers whose length matches the size of the input array's specified dimension), and an axis index. Return a new array with elements repeated along the specified axis according to the repetition value. Handle negative axis indices correctly. If the axis is specified as None, flatten the input array first before repeating."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix), a non-negative integer `k`, and an axis index (0 for rows, 1 for columns). Return a new 2D array where each slice (row if axis=0, column if axis=1) is repeated `k` times along that axis."
    },
    {
        "instruction": "Write a function that repeats elements of a numerical array along a specified axis using a given repetition count (integer or array). Add an extra parameter `expected_output_dim_size`. The function must return an array where the dimension specified by the axis has exactly `expected_output_dim_size` elements. If the repetition results in fewer elements, pad the dimension with zeros; if it results in more, truncate the result along that dimension."
    },
    {
        "instruction": "Write a function to compute the N-th order difference of a multi-dimensional numerical array along a specified axis. The function must handle optional values or 1D arrays (matching other dimensions) to prepend *and* append to the data along the specified axis before the differencing process begins. Ensure correct output shape based on N, axis, prepend, and append."
    },
    {
        "instruction": "Implement a function to compute the N-th order difference of a 1D numerical array. It takes the array and a non-negative integer N (order) as input. For N=2, it calculates the difference of the first differences. If N=0, it returns the original array."
    },
    {
        "instruction": "Develop a function that calculates the N-th order difference of a multi-dimensional numerical array along a given axis. Additionally, the function should accept an optional scalar value to prepend to the data along the specified axis *before* calculating the first difference. Handle different orders N."
    },
    {
        "instruction": "Create a function that calculates the first-order difference of a multi-dimensional numerical array along a specified dimension (axis). The function should take the array and the axis index as input. The size of the specified dimension in the output should be one less than the input."
    },
    {
        "instruction": "Create a function that takes an object possessing 'shape' (a tuple of integers) and 'dtype' (a numerical data type) attributes. It should return a new numerical array filled entirely with ones, conforming to the specified shape and data type."
    },
    {
        "instruction": "Write a function that accepts any object that provides access to a 'shape' attribute (returning a tuple of integers) and a 'dtype' attribute (returning a numerical data type identifier). The function should simply return a tuple containing these two extracted values: (shape, dtype)."
    },
    {
        "instruction": "Write a function that accepts an object which has 'shape' (a tuple of integers) and 'dtype' (a numerical data type) attributes. The function should return a new numerical array initialized with all zeros, matching the provided shape and data type."
    },
    {
        "instruction": "Implement a function that receives an object with 'shape' (a tuple of integers) and 'dtype' (a numerical data type) attributes, along with a scalar 'fill_value'. The function must produce a new numerical array of the given shape and data type, where every element is set to the 'fill_value'. Ensure the fill value is appropriately cast or compatible with the target data type."
    },
    {
        "instruction": "Implement `split_array_equally(array, num_sections)`. It takes a 2D numerical array and a value `num_sections`. First, verify `num_sections` is an integer type; if not, raise a `TypeError`. Then, attempt to split the array along its first axis into `num_sections` equal sub-arrays. If splitting is possible, return the list of sub-arrays. If the axis size is not divisible by `num_sections`, raise a `ValueError`."
    },
    {
        "instruction": "Create a function `is_strict_integer(value)` that returns `True` if the input `value` is of an integer type, and `False` otherwise (floats, strings, lists, etc., should return `False`)."
    },
    {
        "instruction": "Write `split_array_at_indices(array, indices)`. It takes a 2D numerical array and a list `indices`. Verify that *all* elements in `indices` are integer types; if not, raise a `TypeError` indicating invalid index types were provided. If all indices are valid integers, split the array along its first axis at the specified indices and return the list of resulting sub-arrays."
    },
    {
        "instruction": "Develop a function `are_all_integers(values)` that takes a list `values`. Return `True` if every element in the list is strictly an integer type, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar value. It should create a new 2D array by appending a column composed entirely of the scalar value to the right side of the input array. Ensure the new column has the same number of rows as the input array."
    },
    {
        "instruction": "Implement a function that takes two 2D numerical arrays (matrices) with the same number of rows and joins them side-by-side horizontally to create a single wider matrix."
    },
    {
        "instruction": "Create a function that accepts a list of lists of 2D numerical arrays. Each inner list represents a row of blocks. The function should assemble these blocks into a single large 2D array. Assume blocks within an inner list have the same number of rows, and blocks in the same column position across different inner lists have the same number of columns. Return the assembled 2D array."
    },
    {
        "instruction": "Create a function that accepts two 2D numerical arrays (matrices) with the same number of columns and stacks them vertically (one above the other) to produce a single taller matrix."
    },
    {
        "instruction": "Create a function that takes one argument and returns `True` if the argument is an integer, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a single positive integer `n` and returns a 1D numerical array of length `n` containing only zeros."
    },
    {
        "instruction": "Write a function that accepts a tuple of positive integers representing dimensions (e.g., `(rows, cols)`) and returns a new multi-dimensional numerical array of that shape filled with zeros. Ensure the input is validated to be a tuple of integers, raising a `TypeError` if not."
    },
    {
        "instruction": "Implement a function that attempts to create a 1D numerical array of zeros of a specified size. The function should accept one argument representing the desired size. If the provided size is not an integer, the function must raise a `TypeError`. Otherwise, it returns the 1D array of zeros."
    },
    {
        "instruction": "Write a function that takes a single 2D numerical array (matrix) of shape (M, N) and returns a list containing its individual rows, where each row is represented as a 1D array of shape (N,)."
    },
    {
        "instruction": "Create a function that accepts a list of N-dimensional numerical arrays, all with the same shape, and joins them along a *new* first dimension. For example, stacking three (2, 3) arrays should result in a (3, 2, 3) array."
    },
    {
        "instruction": "Write a function that takes a list of 1D numerical arrays (vectors) of the same size and stacks them into a 2D array (matrix), where each input vector becomes a row in the output."
    },
    {
        "instruction": "Implement a function that takes a list of 1D numerical arrays (vectors) and concatenates them end-to-end into a single, larger 1D array."
    },
    {
        "instruction": "Design a function simulating `N` steps of an update process. Inputs: two initial numerical arrays `A` and `B` (same shape), integer `N`. In each step, calculate an intermediate array `G` where `G[i] = 1` if `A[i] > 0` and `0` otherwise. Update `B` by adding `G` to it (`B = B + G`). Array `A` remains unchanged. Output: The final array `B` after `N` steps."
    },
    {
        "instruction": "Write a function to compute the analytical gradient of the sum of element-wise ReLU activations. Input: a numerical array `Z`. Output: an array of the same shape where elements are 1 if `Z[i] > 0` and 0 if `Z[i] <= 0`."
    },
    {
        "instruction": "Write a function that calculates the sum of all elements in a numerical array. Input: a numerical array (any dimension). Output: a single scalar number representing the sum."
    },
    {
        "instruction": "Implement the Rectified Linear Unit (ReLU) function. Input: a numerical array. Output: a new array of the same shape where each element is `max(input_element, 0)`."
    },
    {
        "instruction": "Implement a function that validates a potential shape argument. It accepts one input. If the input is a sequence (list or tuple) containing only positive integers, the function should return normally (e.g., return `None` or `True`). If the input is invalid (not a sequence, or contains non-positive-integers), it must raise a `TypeError` with a descriptive message about the requirement for a sequence of positive integers."
    },
    {
        "instruction": "Write a function that takes a sequence of positive integers representing dimensions (e.g., `[height, width]`) and returns a formatted string describing it, like `\"2D shape: 10x5\"`. Handle 1D shapes appropriately (e.g., `\"1D shape: 10\"`). Assume the input is already validated."
    },
    {
        "instruction": "Develop a function that accepts a sequence (list or tuple). It should return `True` if all elements in the sequence are positive integers, and `False` otherwise. Return `False` for an empty sequence."
    },
    {
        "instruction": "Write a function that accepts a single value and returns `True` if the value is a positive integer, and `False` otherwise."
    },
    {
        "instruction": "Create a function `find_insertion_point(sorted_array, value, side)` that takes a 1D sorted numerical array `sorted_array`, a single numerical `value`, and a string `side` ('left' or 'right'). Return the index where `value` should be inserted into `sorted_array` to maintain order. If `side` is 'left', return the first valid index; if 'right', return the last valid index. Assume the array contains only finite numbers."
    },
    {
        "instruction": "Develop a function that takes a 1D sorted floating-point array which may contain NaN values (assume NaNs are grouped at the end) and a single value (which could be NaN). Return the insertion index for the value. Treat all NaNs as equivalent and greater than infinity. Use the 'left' insertion rule (find the first possible index for the value)."
    },
    {
        "instruction": "Write a function `find_indices(sorted_data, query_values, side)` that takes a 1D sorted numerical array `sorted_data` (potentially containing -inf, +inf, NaN, -0.0, 0.0) and a 1D array `query_values`. Return a 1D array of indices where each element from `query_values` would be inserted into `sorted_data` according to the `side` parameter ('left' or 'right'). Ensure consistent handling of special values: -inf < finite < +inf < NaN, and -0.0 is treated as equal to 0.0."
    },
    {
        "instruction": "Implement a function that accepts a 1D sorted array of floating-point numbers potentially containing positive and negative infinity. Given a single value (which could also be +/- infinity), return the index where it should be inserted to maintain the sorted order (-inf < finite < +inf)."
    },
    {
        "instruction": "Develop a function accepting a numerical array `A`, a target shape `S`, and a target data type `T`. The function must return a new numerical array filled with zeros, conforming to the specified shape `S` and data type `T`, irrespective of `A`'s original shape or data type."
    },
    {
        "instruction": "Design a function that determines the final data type for a newly created array. It takes the data type of a template array (`template_dtype`) and an optional explicitly requested data type (`requested_dtype`). If `requested_dtype` is provided (not null/None), it should be returned. Otherwise, `template_dtype` should be returned."
    },
    {
        "instruction": "Implement a function that receives a numerical array `A`, a scalar fill value `V`, and a target shape `S`. It should generate a new numerical array with dimensions specified by `S` and the same data type as `A`, where every element is equal to `V`."
    },
    {
        "instruction": "Write a function that accepts a numerical array `A`. It should return a new numerical array with the exact same dimensions (shape) and data type as `A`, but filled entirely with zeros."
    },
    {
        "instruction": "Develop a function that takes a scalar `s` and a numerical array `arr`. Conceptually broadcast `arr` to a larger, specified target shape `T` (assuming `arr` is broadcast-compatible with `T`). Then, multiply the conceptually broadcasted array element-wise by the scalar `s`. Return the final array with shape `T`."
    },
    {
        "instruction": "Implement a function to check if a given numerical array `A` can be broadcast to a target shape `T`. The function should return `True` if broadcasting is possible according to standard rules (dimensions match or are 1, checked from right to left), and `False` otherwise."
    },
    {
        "instruction": "Write a function that scales a multi-dimensional numerical array by a given scalar factor. It should take the array and the scalar as input and return the resulting scaled array."
    },
    {
        "instruction": "Write a function that explicitly broadcasts a numerical array `A` to a compatible target shape `T`. Assume compatibility is pre-checked or handle incompatibility gracefully (e.g., return an error indicator). The function should return the resulting broadcasted array. Input: array `A`, target shape `T`. Output: Broadcasted array of shape `T`."
    },
    {
        "instruction": "Develop a function to split a 3D numerical array of shape (D, H, W) into `k` smaller 3D arrays along the third dimension (axis 2). W must be divisible by `k`. Return a list of `k` arrays, each of shape (D, H, W/k)."
    },
    {
        "instruction": "Implement a function that splits a 2D numerical array (matrix) into `k` smaller matrices by dividing it horizontally along its rows (axis 0). The input matrix has shape (M, N), and M must be divisible by `k`. Return a list of `k` matrices, each of shape (M/k, N)."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array, an integer axis index `axis`, and an integer `k`. The function should split the array into `k` equal sub-arrays along the specified `axis`. Ensure the size of the dimension specified by `axis` is divisible by `k`. Return a list containing the `k` sub-arrays."
    },
    {
        "instruction": "Create a function that splits a 2D numerical array (matrix) of shape (M, N) into `k` smaller matrices by dividing it vertically along its columns (axis 1). N must be divisible by `k`. Return a list of `k` matrices, each of shape (M, N/k)."
    },
    {
        "instruction": "Implement a higher-order function `wrap_creator` that takes an array creation function `creator_func` (which expects a shape tuple) as input. `wrap_creator` should return a *new* function. This new function checks its arguments: if called with multiple integers (like `new_func(2, 3)`), it raises a TypeError with a helpful hint about using a tuple; otherwise, it calls the original `creator_func` with the arguments provided (assuming they are valid for `creator_func`, e.g., a shape tuple)."
    },
    {
        "instruction": "Enhance the function from Task 1. When raising the TypeError because multiple integer arguments were received (e.g., `func(2, 3)` instead of `func((2, 3))`), the error message must contain a specific hint suggesting the correct tuple-based usage, like 'Did you mean to pass a shape tuple like (arg1, arg2)?'."
    },
    {
        "instruction": "Create a function that takes a single argument, expected to be a tuple of positive integers (e.g., `(rows, cols)`). The function should return a new 2D numerical array initialized with zeros, having the dimensions specified by the input tuple."
    },
    {
        "instruction": "Write a function that accepts arguments. If it receives exactly one argument and that argument is a tuple of integers (representing a shape), it should return True. If it receives two or more integer arguments directly, it should raise a TypeError. For any other input, it can return False."
    },
    {
        "instruction": "Write a function to generate a 3D array with given dimensions (Batch, Sequence, Features), populating it with random unsigned 8-bit integers (0-255)."
    },
    {
        "instruction": "Implement a function that computes the inclusive cumulative sum along the *last* axis of an input 3D numerical array. Return a new array of the same shape containing the sums."
    },
    {
        "instruction": "Write a function that takes three positive integers (B, S, F) as input. Generate a 3D array of shape (B, S, F) with random unsigned 8-bit integers. Then, calculate the cumulative sum along the third axis (F). Return the resulting 3D array, ensuring the final elements are unsigned 8-bit integers, correctly handling potential overflows according to standard unsigned 8-bit arithmetic."
    },
    {
        "instruction": "Create a function that takes a 1D array of unsigned 8-bit integers and calculates its cumulative sum. The output must also be a 1D array of unsigned 8-bit integers, reflecting the behavior of 8-bit arithmetic (e.g., sums wrap around modulo 256)."
    },
    {
        "instruction": "Write a function that accepts a list containing a mix of Python integers and floating-point numbers. Determine and return the promoted numerical data type (typically floating-point) suitable for representing all elements without loss of information."
    },
    {
        "instruction": "Write a function that analyzes a list of numerical values, where some values might have explicit precision specified (e.g., a mix of standard 64-bit floats and 16-bit floats). Determine the most specific common numerical data type (considering precision) that can accurately represent all elements in the list."
    },
    {
        "instruction": "Create a function that accepts a single Python number (int, float, or complex) and identifies whether its default numerical array representation would be integer, floating-point, or complex."
    },
    {
        "instruction": "Create a function that takes an input which is either a single scalar number (int, float, complex) or a list of numbers. Return `True` if the input is a scalar, indicating a potential 'weak type' inference, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that estimates the unscaled covariance matrix of polynomial coefficients obtained from a least-squares fit. Inputs are a 1D numerical array `x`, an integer `deg`, and optionally 1D weights `w`. Calculate the covariance matrix based on the properties of the least-squares problem's design matrix (and weights, if provided). Return the 2D covariance matrix of shape `(deg + 1, deg + 1)`."
    },
    {
        "instruction": "Develop a function for polynomial fitting that incorporates rank determination using singular values. Inputs are 1D numerical arrays `x`, `y`, an integer `deg`, and a float `threshold`. Solve the least-squares problem, but effectively treat singular values of the design matrix smaller than `threshold` times the largest singular value as zero when computing the solution. Return the 1D array of coefficients and the computed rank (integer)."
    },
    {
        "instruction": "Implement a function to find the coefficients of a polynomial of degree `deg` that best fits the data points `(x, y)` in a least-squares sense. Inputs are two 1D numerical arrays `x` and `y` of the same length, and an integer `deg`. Return a 1D array of `deg + 1` coefficients, ordered from highest degree to lowest."
    },
    {
        "instruction": "Create a function that performs weighted least-squares polynomial fitting. It takes 1D numerical arrays `x`, `y`, `w` (weights) of the same length, and an integer `deg`. Return the 1D array of `deg + 1` polynomial coefficients that minimize the sum of `w[i] * (p(x[i]) - y[i])**2`, ordered from highest degree to lowest."
    },
    {
        "instruction": "Implement a function for basic 1D linear interpolation. It takes three 1D numerical arrays: `x_query` (points to interpolate at), `x_points` (data point coordinates, assumed sorted), and `y_points` (data point values corresponding to `x_points`). Return a new 1D array containing the interpolated values corresponding to `x_query`. Handle cases where query points fall outside the range of `x_points` by clamping to the boundary values."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns `True` if all elements in the array are finite numbers (i.e., not NaN or infinity), and `False` otherwise."
    },
    {
        "instruction": "Modify a 1D linear interpolation function (like in Task 2 or 4) to handle periodic data points. Add an optional `period` parameter. If `period` is provided, map both the query points (`x_query`) and the data point coordinates (`x_points`) into the range `[0, period)` before performing the interpolation. Ensure the interpolation wraps correctly around the period."
    },
    {
        "instruction": "Extend a 1D linear interpolation function (like in Task 2) to support optional boundary values. Add parameters `left_fill_value` and `right_fill_value`. If `left_fill_value` is provided and a query point is below the minimum `x_points` value, return `left_fill_value`. If `right_fill_value` is provided and a query point is above the maximum `x_points` value, return `right_fill_value`. If fill values are not provided, use default boundary handling (e.g., clamping)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and an integer `N`. It should return a list containing `N` new 1D arrays, where each new array is an equal-sized segment of the original array. Assume the length of the input array is divisible by `N`."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix) and an integer `N`. Split the matrix into `N` smaller matrices by dividing it vertically (along the second dimension, columns). Return these as a list of matrices. Assume the number of columns is divisible by `N`."
    },
    {
        "instruction": "Develop a function that takes a multi-dimensional numerical array, an integer `axis`, and an integer `N`. Split the array into `N` equal sub-arrays along the specified `axis`. Handle both positive and negative `axis` values (where negative values index from the end). Return a list of the sub-arrays. Assume the size of the dimension specified by `axis` is divisible by `N`."
    },
    {
        "instruction": "Write a function that determines if a multi-dimensional array can be split into `N` equal sections along a given `axis`. It should take the array's shape (e.g., a tuple of dimensions), the `axis` index, and the integer `N` as input. Return `True` if the dimension size along the `axis` is evenly divisible by `N`, and `False` otherwise. Handle negative axis indexing."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and reverses the order of elements along *all* its axes. The output array should have the same shape and data type as the input."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) and an integer axis index. It should return a new matrix where the elements along the specified axis are reversed. For example, reversing axis 0 of `[[1, 2], [3, 4]]` yields `[[3, 4], [1, 2]]`."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and a collection (e.g., a tuple or list) of axis indices. Return a new array where the elements have been reversed along *each* of the specified axes. The function should handle potentially empty collections of axes (returning the original array) and maintain the input array's shape and data type."
    },
    {
        "instruction": "Develop a function that accepts a multi-dimensional numerical array and a single integer axis index (which can be negative, counting from the end). Return a new array with elements reversed along that specific axis, preserving the original shape and data type."
    },
    {
        "instruction": "Design a function that accepts a multi-dimensional numerical array and an integer representing an axis. The function should return a new array of the same shape where the order of elements along the specified axis is reversed. Handle cases for different valid axis inputs for arrays of varying dimensions (e.g., 1D, 2D, 3D)."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array (e.g., a list of lists, representing a matrix) and returns a new 2D array where the order of the rows is reversed, but the elements within each row remain in their original order."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array and returns a new 2D array where the order of elements within each row is reversed (i.e., flip left-right). The order of the rows themselves should remain unchanged."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array (e.g., a list of numbers) and returns a new 1D array containing the same elements but in reversed order."
    },
    {
        "instruction": "Develop a function that flips a numerical array horizontally (reversing elements along the second dimension). It must first check if the input array has 2 or more dimensions. If not, it should indicate an error (e.g., return None or raise an exception). Otherwise, it returns the flipped array."
    },
    {
        "instruction": "Implement a function that reverses the order of elements along a *specified* dimension (axis) of a given multi-dimensional numerical array. The function should take the array and the axis index as input and return the modified array, preserving shape and data type."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and returns a new 2D array where the order of columns is reversed. The output should have the same shape and data type as the input."
    },
    {
        "instruction": "Create a function that accepts a 3D numerical array and reverses the order of elements along its second dimension (axis=1). The output array must retain the original shape and data type."
    },
    {
        "instruction": "Create a function that rotates a 2D numerical array (matrix) by `k * 90` degrees. `k` is an integer; positive `k` means counter-clockwise, negative means clockwise. Input: 2D array, integer `k`. Output: rotated 2D array."
    },
    {
        "instruction": "Write a function that validates if a given pair of axis indices is valid for performing a planar rotation on an array with a specific shape. Inputs: a tuple representing the array shape, a tuple `axes` containing two integers. Output: Boolean (True if axes are valid - distinct, non-negative, and within the number of dimensions; False otherwise)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and rotates it 90 degrees counter-clockwise. Input is a 2D array, output is the rotated 2D array."
    },
    {
        "instruction": "Develop a function to rotate an N-dimensional numerical array by `k * 90` degrees in the plane specified by a given pair of axes. Inputs: N-D array, integer `k`, a tuple `axes` containing two distinct axis indices. Output: Rotated N-D array."
    },
    {
        "instruction": "Write a function that accepts three numerical arrays: `condition` (boolean), `x`, and `y`. These arrays may have different shapes but must be broadcast-compatible (e.g., `condition` shape (M, N), `x` shape (N,), `y` shape (M, 1)). The function should return a new array whose shape is the result of broadcasting the input shapes, containing elements selected element-wise from the broadcasted versions of `x` or `y` based on the broadcasted `condition`."
    },
    {
        "instruction": "Implement a function that takes a 1D boolean array `condition` and two 1D numerical arrays `x` (e.g., integers) and `y` (e.g., floats) of the same length. Perform element-wise selection based on `condition` and return a new 1D array containing the selected elements, ensuring the output array's data type can accommodate elements from both `x` and `y` (e.g., floats in this case)."
    },
    {
        "instruction": "Develop a function that accepts three lists representing the shapes of three arrays (e.g., `[ (2,3), (3,), (2,1) ]`). Return `True` if these shapes are broadcast-compatible according to standard array broadcasting rules, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes three 1D arrays of the same length: a boolean array `condition`, and two data arrays `x` and `y`. It should return a new 1D array where the i-th element is `x[i]` if `condition[i]` is true, and `y[i]` otherwise."
    },
    {
        "instruction": "Develop a function that takes three 1D numerical arrays: `x` (length M), `y` (length N), and `z` (length P). Return three 3D arrays, each of shape (M, N, P). The first output array should contain values from `x` varying along the first dimension and broadcast across the others. The second should contain values from `y` varying along the second dimension, and the third values from `z` varying along the third dimension."
    },
    {
        "instruction": "Write a function that calculates the output shapes for coordinate grid generation. Input: a list of 1D numerical arrays (coordinate vectors), an indexing mode string ('xy' or 'ij'), and a boolean sparse flag. Output: a list of shape tuples for the corresponding output grid arrays, without computing the arrays themselves."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays, `x` (length M) and `y` (length N). Return two 2D arrays, both of shape (M, N). The first output array should have each column being a copy of `x`. The second output array should have each row being a copy of `y`."
    },
    {
        "instruction": "Implement a function taking two 1D numerical arrays, `x` (length M) and `y` (length N). It should return two \"sparse\" grid arrays using Cartesian (\"xy\") indexing. The first output should have shape (1, M) containing `x`. The second output should have shape (N, 1) containing `y`."
    },
    {
        "instruction": "Develop a function `generate_array_sequences(start_array, stop_array, num_points, axis)` that takes two numerical arrays (`start_array`, `stop_array`) and generates `num_points` evenly spaced samples between corresponding elements along the specified `axis`. Handle broadcasting if input shapes differ. The output array should contain these sequences along the specified `axis`, including the `stop_array` values as the last points."
    },
    {
        "instruction": "Implement a function `generate_typed_sequence(start, stop, num_points, precision)` that generates `num_points` evenly spaced floating-point numbers from `start` to `stop` (inclusive). The `precision` argument ('single' or 'double') dictates the output array's data type."
    },
    {
        "instruction": "Write a function `generate_sequence(start, stop, num_points)` that returns a 1D numerical array of `num_points` evenly spaced values, starting at `start` and ending exactly at `stop`."
    },
    {
        "instruction": "Write a function `generate_sequence_edge_cases(start, stop, num_points)` that generates an evenly spaced sequence from `start` to `stop` (inclusive). It must return an empty 1D array if `num_points` is 0, and a 1D array containing only `start` if `num_points` is 1."
    },
    {
        "instruction": "Develop a function that generates logarithmically spaced numbers where the start exponent `s` and end exponent `e` can be multi-dimensional numerical arrays (broadcastable). Inputs also include number of samples `n`, base `b`, `include_end` boolean, and an integer `axis`. The logarithmic spacing should be computed along the specified `axis`. Return the resulting numerical array."
    },
    {
        "instruction": "Create a function that generates a 1D array of `n` logarithmically spaced numbers. Inputs are start exponent `s`, end exponent `e`, number of samples `n`, base `b`, and a boolean `include_end`. If `include_end` is true, the last sample is `b**e`; otherwise, the sequence stops before `b**e`. Return the 1D numerical array."
    },
    {
        "instruction": "Implement a function that takes scalar start/end exponents (`s`, `e`), a number of samples `n`, and a base `b`. It should produce a 1D numerical array of `n` logarithmically spaced samples between `b**s` and `b**e`. The function must also accept a string specifying the desired output data type (e.g., 'float64', 'complex128') and return an array of that type."
    },
    {
        "instruction": "Write a function that takes a start exponent `s`, an end exponent `e`, and a number of samples `n`. It should return a 1D numerical array of `n` values logarithmically spaced between 10<sup>s</sup> and 10<sup>e</sup> (inclusive)."
    },
    {
        "instruction": "Write a function generating geometric sequences. It must accept `start` and `stop` (scalars or broadcastable arrays, real or complex), number of points `n`, an `axis` for sequence insertion, and an `endpoint` flag. For real inputs, corresponding `start`/`stop` pairs must have the same sign (or be zero). Handle broadcasting and axis insertion correctly."
    },
    {
        "instruction": "Develop a function generating a geometric sequence between scalar `start` and `stop` with `n` points. Include a boolean `include_endpoint` parameter. If `True`, the sequence must contain `stop`; if `False`, the last point should be calculated based on the geometric progression without necessarily equaling `stop`."
    },
    {
        "instruction": "Implement a function taking broadcastable numerical arrays `start_arr`, `stop_arr`, an integer `n` (>=0), and an integer `axis`. Generate `n` geometrically spaced samples between corresponding elements. Insert these sequences along the specified `axis` in the output array. The output dimension at `axis` should be `n`."
    },
    {
        "instruction": "Write a function that takes two non-negative scalar values, `start` and `stop`, and a non-negative integer `n`. Return a 1D array of `n` numbers spaced geometrically between `start` and `stop` (inclusive). Handle `n=0` (empty array) and `n=1` (array with `start`)."
    },
    {
        "instruction": "Develop a function that takes a numerical array and a target shape tuple. It should return a new array with the target shape, created by broadcasting the input array according to standard rules (adding leading dimensions or expanding dimensions of size 1). If broadcasting is not possible according to the rules, the function should raise an error (e.g., ValueError)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array (e.g., shape `(N,)`) and a target 2D shape (e.g., `(M, N)`). Return a new 2D array where the input array data is repeated across the new dimension `M`. Assume the shapes are broadcast-compatible."
    },
    {
        "instruction": "Write a function that takes two tuples representing array shapes (e.g., `(3,)` and `(2, 1, 3)`) and returns `True` if the first shape can be broadcast to the second shape according to standard broadcasting rules, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes a numerical array (e.g., shape `(M, 1, N)`) and a target shape (e.g., `(M, K, N)`). Return a new array of the target shape where dimensions of size 1 in the input are expanded (tiled/repeated) to match the corresponding dimension in the target shape. Assume compatibility."
    },
    {
        "instruction": "Write a function to compute the numerical gradient of a 2D numerical array along both axes simultaneously. Allow for different, optional scalar spacing values for each axis (one for axis 0, one for axis 1; default to unit spacing if not provided). Input: 2D array, optional spacing for axis 0, optional spacing for axis 1. Output: A list/tuple containing two 2D arrays (gradient along axis 0, gradient along axis 1), both matching the input shape."
    },
    {
        "instruction": "Implement a function to compute the numerical gradient of a 1D numerical array, allowing for a custom scalar spacing value between points. Input: 1D array, scalar spacing value. Output: 1D array of the same shape."
    },
    {
        "instruction": "Develop a function that calculates the numerical gradient of an N-dimensional numerical array along multiple specified axes. Assume unit spacing. Input: N-D array, tuple/list of axis indices. Output: A list/tuple of N-D arrays, one for each specified axis, each having the same shape as the input array."
    },
    {
        "instruction": "Create a function that calculates the numerical gradient of a 2D numerical array along a single specified axis (0 or 1). Use central differences for interior points and one-sided differences for boundaries along that axis. Assume unit spacing. Input: 2D array, axis index. Output: 2D array of the same shape."
    },
    {
        "instruction": "Develop a function that simulates applying an indexing operation across slices of an array. It takes a multi-dimensional array, an index tuple (basic N-dimensional index), and an axis index. It should conceptually iterate through slices of the input array along the specified axis, apply the index tuple to each slice, and stack the results to form a new output array. Return the resulting array."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and a tuple representing a basic N-dimensional index (e.g., containing integers and full slices like `slice(None)`) and returns the resulting sub-array or element."
    },
    {
        "instruction": "Create a function that accepts an input array's shape (tuple of integers) and a basic N-dimensional index tuple (containing integers and full slices). Return the shape (tuple of integers) of the array that would result from applying that index."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array, an axis index (integer), and a simple element-wise function (e.g., square, add one). Apply the function to each 1D slice along the specified axis and return the modified array."
    },
    {
        "instruction": "Write a function that initializes a large 3D numerical array (e.g., 16x16x16) with zeros. It then takes a smaller 2D numerical array (e.g., 4x4) as input. Using a predefined sequence of chained slicing/indexing operations targeting a specific sub-volume within the 3D array (e.g., indices [0, 0:4, 0:4]), the function updates this sub-volume with the contents of the input 2D array. Return the modified 3D array."
    },
    {
        "instruction": "Create a function that takes a 3D numerical array (shape D1xD2xD3) and an index `i` for the first dimension. It should return the 2D slice of shape (D2, D3) located at index `i` along the first dimension."
    },
    {
        "instruction": "Implement a function that takes a 3D numerical array (destination) and a 2D numerical array (source). It also takes parameters defining a target 2D slice within the 3D array (e.g., an index for the first dimension, start/end indices for the second and third dimensions). The function should update the specified slice in the destination array with the values from the source array. Assume the source array shape matches the target slice shape."
    },
    {
        "instruction": "Write a function that creates a 3D numerical array of specified dimensions (e.g., D1xD2xD3) and fills it entirely with zeros. The function should take the dimensions as input and return the zero-filled array."
    },
    {
        "instruction": "Develop a function that updates a nested part of a multi-dimensional numerical array. The function takes the array, a list of indexers, and a value array. It should apply all indexers sequentially except the last one to identify a target sub-array, and then use the final indexer in the list to update that target sub-array with the provided value array."
    },
    {
        "instruction": "Create a function that accepts a shape tuple (e.g., (3, 4, 5)) and returns a new multi-dimensional numerical array of that shape filled entirely with zeros."
    },
    {
        "instruction": "Create a function to check indexer shape compatibility. It takes an initial numerical array, a list of indexers, and a target shape tuple. Determine the shape of the sub-array that results from applying the indexers sequentially to the initial array and return `True` if this shape matches the target shape, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and a single indexer (which could be an integer, a slice object, or a tuple representing indices/slices for multiple dimensions) and returns the sub-array selected by that indexer."
    },
    {
        "instruction": "Write a function that takes a list of indexers, where each indexer can be an integer, a slice, or a tuple. Apply these indexers sequentially to determine the shape of the final resulting subarray, given an initial array shape. Return the final shape tuple."
    },
    {
        "instruction": "Create a function that takes a multi-dimensional numerical array and a *list* of indexers. Apply each indexer in the list sequentially to the result of the previous indexing operation. Return the final resulting subarray."
    },
    {
        "instruction": "Develop a function that takes an input array's shape (e.g., a tuple of integers) and a single valid indexer (integer, slice, tuple). Return the shape (as a tuple of integers) of the subarray that would result from applying this indexer."
    },
    {
        "instruction": "Implement a function that takes an input multi-dimensional numerical array, a list of indexers, and an output array (pre-allocated with the correct final shape). The function should extract the data specified by sequentially applying the indexers to the input array and copy this extracted data into the provided output array."
    },
    {
        "instruction": "Implement a function to perform a multi-dimensional strided load. It takes a source multi-dimensional numerical array, a tuple of start indices, and a tuple of strides. Return a new, compact array containing only the elements retrieved from the source array by stepping through each dimension according to the specified start index and stride."
    },
    {
        "instruction": "Develop a function that generates slice parameters for strided access. Given tuples for start indices, dimension sizes (shape), and strides, return a structure (e.g., a list of tuples) where each element represents the (start, stop, step) for slicing one dimension of an array."
    },
    {
        "instruction": "Create a function to perform a multi-dimensional strided store. It accepts a target multi-dimensional numerical array, a tuple of start indices, a tuple of strides, and a source array containing the values to store. Modify the target array in-place by placing the elements from the source array into the target array at locations specified by the start indices and strides."
    },
    {
        "instruction": "Write a function that calculates the shape of a sub-array resulting from strided access. Inputs are the original array's shape (tuple of positive integers), start indices (tuple of non-negative integers), and strides (tuple of positive integers), all of the same length. Return a tuple of positive integers representing the shape of the extracted sub-array."
    },
    {
        "instruction": "Develop a function `select_specific_rows(matrix, row_indices)` that takes a 2D numerical array `matrix` (M x N) and a 1D array `row_indices`. Return a new 2D array containing only the full rows of `matrix` specified by the indices in `row_indices`. The order of rows in the output should match the order in `row_indices`."
    },
    {
        "instruction": "Create a function `get_index_from_array(index_array)` that takes a 1D numerical array containing exactly one integer and returns that integer."
    },
    {
        "instruction": "Implement `extract_row_slice(matrix, start_index_array, num_rows)`. Given a 2D numerical array `matrix` (M x N), a 1D array `start_index_array` holding one integer `start`, and an integer `num_rows`, return the sub-matrix corresponding to rows `start` up to (but not including) `start + num_rows` (output shape `num_rows` x N)."
    },
    {
        "instruction": "Write a function `create_sequential_matrix(rows, cols)` that returns a `rows` x `cols` 2D numerical array filled with integers 0, 1, 2, ... row by row."
    },
    {
        "instruction": "Write a validation function accepting three arguments: `operator`, `vector_b`, `vector_x`. It must return `True` if: (1) `operator` is a callable or a square 2D numerical array, AND (2) `vector_b` and `vector_x` are 1D numerical arrays with the exact same shape. Otherwise, return `False`."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and returns `True` if its dimensions are equal (i.e., it's a square matrix), and `False` otherwise."
    },
    {
        "instruction": "Develop a function that compares two inputs, which can be numerical arrays or dictionaries containing numerical arrays (possibly nested). Return `True` if both inputs possess the identical structure (e.g., both are arrays with the same shape, or both are dictionaries with the same keys mapping to values that recursively have the same structure), and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes one argument and returns `True` if it's either a callable (like a function or lambda) or a 2D numerical array, and `False` otherwise."
    },
    {
        "instruction": "Implement one step of an iterative orthogonalization process. Given an existing matrix Q (shape M x K) whose columns are orthonormal vectors, and a new vector V (shape M,), compute the projection coefficients of V onto each column of Q, subtract these projections from V to get a residual vector, normalize this residual vector, and append it as the (K+1)-th column to Q. Return the updated Q (M, K+1) and the computed projection coefficients (K,)."
    },
    {
        "instruction": "Implement a function that performs matrix-vector multiplication. It should take a 2D numerical array (matrix) of shape (M, N) and a 1D array (vector) of shape (N,) and return a 1D array (vector) of shape (M,). Ensure it works for both real and complex number types."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (vector) and returns a new 1D array representing the input vector normalized to unit L2 norm. Handle the case of a zero vector input (e.g., return the zero vector)."
    },
    {
        "instruction": "Develop a function that generates an identity-like matrix of size N x (N+1). It returns a 2D numerical array with 1s on the main diagonal (up to column N-1) and 0s elsewhere."
    },
    {
        "instruction": "Create a function that accepts a square numerical matrix `A` (which may contain complex numbers) and returns a positive definite matrix derived from it. A common method is to compute `A_conjugate_transpose * A`."
    },
    {
        "instruction": "Implement a function that performs matrix-vector multiplication. It should take a 2D numerical array (matrix) of shape `(M, N)` and a 1D array (vector) of shape `(N,)` and return a 1D array (vector) of shape `(M,)`."
    },
    {
        "instruction": "Implement a function `solve_positive_definite(A, b)` that finds the vector `x` solving the linear system `Ax = b`. The function should assume the input matrix `A` is square and positive definite. Handle both real and complex numerical inputs. Return the solution vector `x`."
    },
    {
        "instruction": "Write a function that takes a dimension `N` and returns a randomly generated `N x N` numerical matrix and a random `N`-element numerical vector. Allow for specification of data type (e.g., float or complex)."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array `A` (matrix) and a list containing exactly two 1D numerical arrays (vectors), `[v1, v2]`. The function should return a new list containing the results of `A` multiplied by `v1` and `A` multiplied by `v2`, respectively, maintaining the list structure `[result1, result2]`."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix `M`) and returns a new 2D array `A` which is the product of `M` and its transpose (`A = M * M_transpose`). Ensure the output matrix dimensions are correct based on the input."
    },
    {
        "instruction": "Develop a function that takes a single 1D numerical array `b` (vector) and returns a data structure (like a list or tuple) containing exactly two identical copies of the input vector `b`."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication. It should take two 2D numerical arrays, `M1` of shape (R, C) and `M2` of shape (C, K), and return their product, a 2D array of shape (R, K)."
    },
    {
        "instruction": "Write a function that sets up a simple linear system test case. Given a size `N` and a numerical data type specification, it should return a tuple containing: (1) an `N x N` identity matrix `A`, (2) a 1D array `x_true` of size `N` filled with ones, and (3) the corresponding right-hand side vector `b = A @ x_true`. Ensure all outputs match the specified data type."
    },
    {
        "instruction": "Develop a function that compares two 1D numerical arrays (vectors) `v1` and `v2` of the same size. It should return `True` if all corresponding elements are close within given absolute and relative tolerance thresholds, and `False` otherwise. The function should take `v1`, `v2`, `atol`, and `rtol` as input."
    },
    {
        "instruction": "Write a function that takes an integer `N` and a numerical data type specification (e.g., 'float32', 'complex64'), and returns an `N x N` identity matrix of that type."
    },
    {
        "instruction": "Create a function that accepts an integer `N` and a numerical data type specification, and returns a 1D array (vector) of length `N` containing only the value 1.0, cast to the specified data type."
    },
    {
        "instruction": "Create a function `are_close` that takes two 1D numerical arrays `v1`, `v2` of the same size, an absolute tolerance `atol`, and a relative tolerance `rtol`. It should return `True` if the absolute difference between corresponding elements is within the specified tolerances (i.e., `abs(v1[i] - v2[i]) <= atol + rtol * abs(v2[i])` for all `i`), and `False` otherwise. Handle complex numbers by using their magnitude."
    },
    {
        "instruction": "Develop a function to compute the L2 norm (Euclidean norm) of the residual vector for a proposed solution to a linear system. The function should accept a 2D numerical array `A` (N x N), a 1D array `b` (N), and a candidate solution 1D array `x` (N). It should calculate the residual `r = b - Ax` and return its L2 norm. Handle real and complex inputs."
    },
    {
        "instruction": "Write a function that takes an integer `N` and a string specifying data type ('float' or 'complex') and returns a randomly generated `N x N` 2D numerical array (matrix) and a random `N`-element 1D numerical array (vector) of the specified type."
    },
    {
        "instruction": "Write a function `apply_transform` that takes two arguments: a function `T` (representing some transformation, e.g., a preconditioner) and a 1D numerical array `v`. The function should return the result of applying `T` to `v`. Demonstrate its use with an example where `T` simply returns `v` unchanged (identity transformation)."
    },
    {
        "instruction": "Write a function that checks if a given 1D array `x` is an approximate solution to a linear system defined by a 2D array `A` and a 1D array `b`. The function should accept `A`, `b`, `x`, and a tolerance `tol`. Calculate the residual vector `r = b - Ax`. Return `True` if the magnitude (e.g., L2 norm) of the residual `r` is less than or equal to `tol`, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts an integer size `N` and a numerical data type (e.g., float, complex), returning a 1D array (vector) of length `N` where all elements are the value 1.0, matching the specified data type."
    },
    {
        "instruction": "Write a function that takes an integer size `N` and returns an `N x N` identity matrix (1s on the diagonal, 0s elsewhere) containing floating-point numbers."
    },
    {
        "instruction": "Develop a function to compare two 1D numerical arrays, `vec1` and `vec2`, of the same length. The function should take absolute tolerance `atol` and relative tolerance `rtol` as arguments and return `True` if the absolute difference between corresponding elements satisfies `abs(vec1[i] - vec2[i]) <= atol + rtol * abs(vec2[i])` for all elements `i`, and `False` otherwise."
    },
    {
        "instruction": "Write a function that determines an appropriate comparison tolerance based on the data type precision of a given numerical array. For 64-bit types (float or complex), return a smaller tolerance (e.g., 1e-8); for 32-bit types, return a larger tolerance (e.g., 1e-4)."
    },
    {
        "instruction": "Develop a function that generates a random square 2D numerical array (matrix) of a given size `N` and data type (e.g., float32, float64, complex64, complex128). The values should be within a standard range (e.g., [0, 1))."
    },
    {
        "instruction": "Create a function that compares two 1D numerical arrays (vectors) `v1` and `v2` of the same shape. It should return `True` if all corresponding elements are close within both a relative tolerance `rtol` and an absolute tolerance `atol`, and `False` otherwise. Handle potential complex numbers."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `A` (matrix, shape M x N) and a 1D numerical array `x` (vector, shape N) and computes their product `b` (vector, shape M). Ensure it handles various numerical types (floats, complex)."
    },
    {
        "instruction": "Implement a function that calculates the sum of elements in a 1D numerical array, but only includes elements where a corresponding boolean mask array (same shape) is True. If the mask is all False or the array is empty, return 0."
    },
    {
        "instruction": "Write a function that accepts two 1D arrays of the same shape: a data array and a mask array. The function should raise a TypeError if the mask array's elements are not boolean (True/False). If the mask is valid, it should return True."
    },
    {
        "instruction": "Write a function that takes a shape (e.g., an integer for a 1D array) and a data type indicator (e.g., 'float', 'int'), and returns a new 1D array of that shape filled entirely with zeros of the specified data type."
    },
    {
        "instruction": "Create a function that finds the maximum value in a 1D numerical array, considering only elements where a corresponding boolean mask array (same shape) is True. The function should also accept an initial scalar value; if the mask is all False or the array is empty after masking, return this initial value."
    },
    {
        "instruction": "Design a function that performs a specified reduction operation (e.g., 'sum', 'product', 'max') on a 1D numerical array. It must accept an optional `selector` argument. If `selector` is provided, it must be a 1D boolean array of the same size, and the reduction should only consider elements where the selector is True. The function must validate that any provided `selector` is strictly boolean, raising an appropriate error if not. The type of reduction should be specified by an input string argument."
    },
    {
        "instruction": "Create a function to find the minimum value in a 1D numerical array. Include an optional parameter `condition` which must be a 1D boolean array of the same size if provided. If `condition` is present, find the minimum only among elements where the condition is True. Raise a specific error (e.g., TypeError) if `condition` is provided but is not boolean. Consider how to handle cases where no elements satisfy the condition."
    },
    {
        "instruction": "Develop a function that takes two 1D arrays of the same length: a data array (numerical) and a filter array (boolean). Return a new 1D array containing only those elements from the data array for which the corresponding element in the filter array is True."
    },
    {
        "instruction": "Implement a function to calculate the sum of elements in a 1D numerical array. Add an optional parameter `mask` which, if provided, must be a 1D boolean array of the same size. If `mask` is given, only sum elements where the corresponding mask value is True. Raise a specific error (e.g., TypeError) if `mask` is provided but is not a boolean array."
    },
    {
        "instruction": "Implement a function that computes a specified quantile (0-1) for a 1D numerical array potentially containing special 'Not a Number' (NaN) values. The calculation should ignore any NaN values present in the input array. Use a simple interpolation method like 'nearest'."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and a quantile value (float between 0 and 1). Return the element corresponding to that quantile, assuming the quantile directly matches an index after sorting (e.g., use the 'lower' interpolation method). Ignore potential missing values."
    },
    {
        "instruction": "Write a function dispatcher that takes a string name ('quantile' or 'percentile') and returns the corresponding calculation function. Then, implement basic versions of the 'quantile' (input 0-1) and 'percentile' (input 0-100) functions for a 1D numerical array, using a simple interpolation method (e.g., 'lower'). The dispatcher should allow calling the selected function."
    },
    {
        "instruction": "Create a function that calculates a specified percentile (0-100) for a 1D numerical array. If the percentile falls between two data points after sorting, use linear interpolation to determine the result. Assume no missing values."
    },
    {
        "instruction": "Create a function `validate_reduction_initial(initial_value)` that checks if `initial_value` is a scalar number. If it is not a scalar, the function should raise a `ValueError` with a message like \"Initial value must be a scalar. Got <type/shape info>\". If it is a scalar, the function should return normally."
    },
    {
        "instruction": "Implement a function `reduce_array(array, axis)` that performs a sum reduction on a multi-dimensional numerical `array` along the specified integer `axis`. It should return the resulting array with reduced dimensions."
    },
    {
        "instruction": "Implement a function `apply_reduction(array, axis, initial_value)` that first validates if `initial_value` is a scalar number (raising a `ValueError` if not, as in Task 2). If it is valid, the function should then proceed to perform a sum reduction on the input `array` along the specified `axis`, using the `initial_value` in the reduction process, and return the result."
    },
    {
        "instruction": "Write a function `is_scalar(value)` that returns `True` if the input `value` is a single numerical value (integer or float) and `False` otherwise (e.g., for lists, arrays, strings)."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array and computes its cumulative sum, returning the result cast to a specific numerical data type provided as an argument. Input: 1D array, target output data type identifier. Output: 1D array of the specified data type."
    },
    {
        "instruction": "Write a function to compute the cumulative sum of a potentially complex-valued multi-dimensional array along a specified axis, allowing for a different output data type. Include an option to prepend an initial zero slice. If the specified output type is unsigned integer, ensure the computation effectively uses non-negative values from the input (e.g. operate on magnitudes or absolute values). Input: N-D array, axis index, output data type identifier, boolean flag for initial zero. Output: N-D array of the specified type."
    },
    {
        "instruction": "Create a function that computes the cumulative sum along a given axis of an N-D numerical array. Add an option (e.g., a boolean flag) to prepend an initial zero slice to the result along that axis. Input: N-D array, axis index, boolean flag. Output: N-D array (potentially larger by 1 along the specified axis if the flag is true)."
    },
    {
        "instruction": "Write a function that computes the cumulative sum of a 1D numerical array. Input: 1D array. Output: 1D array of the same size containing the cumulative sum."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is the product of all preceding elements (including itself) in the input array. Example: [2, 3, 4] -> [2, 6, 24]."
    },
    {
        "instruction": "Develop a function to compute the cumulative product of a numerical array (potentially multi-dimensional). The function should accept an optional axis argument. If the axis is not provided (or is None), flatten the array first before computing the cumulative product. Input: N-D array, optional axis index. Output: N-D or 1D array."
    },
    {
        "instruction": "Create a function that computes the cumulative product of elements along a specified axis of a 2D numerical array (matrix). Input: a 2D array and an integer axis index (0 or 1). Output: a 2D array of the same shape containing the cumulative products along the specified dimension."
    },
    {
        "instruction": "Implement a function that calculates the cumulative product for any given numerical N-dimensional array along a specified axis. Handle both positive and negative axis indices. Input: N-D array, axis index. Output: N-D array of the same shape."
    },
    {
        "instruction": "Implement a comprehensive function to calculate the variance of a numerical array (up to 2D) while ignoring NaN values. Allow calculation over the entire array (axis=None) or along a specific axis (axis=0 or axis=1). Accept `delta_degrees_of_freedom` (ddof) and a `keep_dimensions` flag. The function should return the variance result (scalar or array) according to the axis and keep_dimensions settings. Ensure correct handling of slices/arrays where the count of non-NaN elements is less than or equal to ddof (return NaN)."
    },
    {
        "instruction": "Implement a function to compute the variance of a 1D numerical array, ignoring any NaN values. The function should accept an integer `delta_degrees_of_freedom` (ddof) to adjust the divisor (N - ddof, where N is the count of non-NaN elements). Return the variance as a single numerical value. Handle the case where the count of non-NaN elements is less than or equal to ddof (e.g., return NaN)."
    },
    {
        "instruction": "Develop a function that calculates the variance along a specified axis of a 2D numerical array, ignoring NaNs. It should take the array, the axis index (0 or 1), and a `delta_degrees_of_freedom` (ddof) value. Return a 1D array containing the variance for each slice along the specified axis. Ignore NaN values in each slice's calculation. Handle cases where a slice has N <= ddof non-NaN elements by returning NaN for that slice."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array possibly containing NaN values. Return the total count of elements that are *not* NaN."
    },
    {
        "instruction": "Develop a function that computes the variance of an N-dimensional numerical array. It should accept parameters for the axis of computation (optional integer/tuple), delta degrees of freedom (ddof, integer >= 0), and whether to keep reduced dimensions (keepdims, boolean). Ensure the denominator used is N - ddof, where N is the count along the axis. Handle potential invalid ddof values (e.g., N - ddof <= 0)."
    },
    {
        "instruction": "Implement a function to compute the population variance (denominator N) of a 1D numerical array. Input: 1D array. Output: Non-negative scalar variance."
    },
    {
        "instruction": "Write a function that calculates the variance of a 1D numerical array, which may contain complex numbers, and returns the result cast to a specified numerical output type. Input: 1D array (real or complex), target output type (e.g., float32, float64). Output: Scalar variance cast to the target type. Raise a specific error (e.g., TypeError or ValueError) if the input array contains complex numbers but the target output type is real."
    },
    {
        "instruction": "Create a function to calculate the variance along a specified dimension (axis) of a 2D numerical array. Input: 2D array, axis index (0, 1, or None for flattened array). Output: Array or scalar variance (using N along the axis as denominator)."
    },
    {
        "instruction": "Write a function that calculates the minimum value in a numerical array along a specified axis. If no output data type is provided, the function should infer a suitable default output type based on the input array's data type (e.g., integer input might produce integer output, float input produces float output). Input: array, axis. Output: reduced array with original or inferred type."
    },
    {
        "instruction": "Implement a function that performs a reduction operation (e.g., mean) on a numerical array along a given axis, allowing the caller to specify the exact data type for the output array. Input: array, axis, output_datatype. Output: reduced array cast to output_datatype."
    },
    {
        "instruction": "Develop a function that computes a reduction (e.g., product) on a numerical array (potentially complex numbers) along multiple axes specified as a tuple. The function must include a boolean parameter `keep_dims`. If true, the output array retains all dimensions, with reduced ones having size 1. Input: array, tuple_of_axes, keep_dims. Output: reduced array."
    },
    {
        "instruction": "Write a function that computes the sum of elements in a numerical array along a specified integer axis. The function should take the array and the axis index as input and return a new array with the summed dimension removed."
    },
    {
        "instruction": "Implement a function that calculates the sum of elements within a multi-dimensional numerical array along a given integer axis. The function should accept the array and the axis index, returning a new array with the specified axis removed."
    },
    {
        "instruction": "Implement a function that finds the maximum value across all elements in a given multi-dimensional numerical array. The function should accept the array and return a single scalar value representing the overall maximum."
    },
    {
        "instruction": "Develop a function to compute the product of elements in a numerical array along a specified axis. The function must accept the array, the axis index, and a boolean flag. If the flag is true, the output array should retain the reduced dimension with size 1; otherwise, the dimension should be removed."
    },
    {
        "instruction": "Write a function to compute the arithmetic mean of elements in a numerical array along a given axis. The function should handle both integer and floating-point input arrays, ensuring the calculation and result are floating-point. It takes the array and axis index as input."
    },
    {
        "instruction": "Develop a function that performs a reduction operation (specified by a name like 'sum', 'product', 'min', 'max') on a numerical array. It takes the array, the operation name (string), an optional axis index (can be None for full reduction), and an optional initial value. Return the reduced array or scalar."
    },
    {
        "instruction": "Implement a function to compute the product of elements along a given axis of a numerical array. The function should accept the array, the axis index, and a boolean flag `keep_dims`. If `keep_dims` is true, the output array should retain the reduced dimension with size 1; otherwise, the dimension should be removed."
    },
    {
        "instruction": "Create a function that finds the maximum value in an entire numerical array. It should accept the array and an optional initial value. If the initial value is provided, the result should be the maximum of the array elements and the initial value. Return the single maximum value."
    },
    {
        "instruction": "Write a function that calculates the sum of elements in a numerical array, potentially containing various numeric types (integers, floats). It must accept the array, an optional axis, an optional initial value, and a `keep_dims` flag. Ensure the output type correctly accommodates the input array's type and the initial value's type, following standard type promotion rules (e.g., summing an integer array with a float initial value should result in a float output)."
    },
    {
        "instruction": "Create a function that calculates the product of elements in a numerical array along a given dimension. It must accept an initial value to use for the product calculation, which is particularly important when reducing over an empty slice. Inputs: array, dimension index (or None), initial value. Output: reduced array."
    },
    {
        "instruction": "Write a function that computes the sum of elements in a numerical array along a specified dimension. The function should take the array and an integer dimension index as input. If the dimension index is None, sum all elements. Return the resulting array."
    },
    {
        "instruction": "Develop a function that performs a reduction (e.g., sum) on an integer array. Add a boolean parameter `promote_integers`. If true, the function should return a result with a data type capable of holding the potentially larger outcome (e.g., summing int8 might require int32 or int64, or even float depending on standard promotion rules). If false, the result type should match the input integer type. Inputs: integer array, dimension index (or None), promote_integers flag. Output: reduced array with appropriate type."
    },
    {
        "instruction": "Implement a function that finds the minimum value in a numerical array along a specified dimension. Include a boolean flag `keep_dims` which, if true, ensures the output array retains the reduced dimension with size 1, preserving the number of dimensions of the input array. Inputs: array, dimension index (or None), keep_dims flag. Output: reduced array."
    },
    {
        "instruction": "Develop a function that calculates the arithmetic mean along a specified axis of a numerical array. The output should generally be a floating-point type. Handle inputs where non-reduction axes might have size zero, but the reduction axis itself has a size >= 1. Assume `keep_dims` is false."
    },
    {
        "instruction": "Implement a function to calculate the product of elements along a given axis for a numerical array. This function must correctly handle multi-dimensional input arrays where one or more dimensions might be zero, provided the specified reduction axis corresponds to a dimension of size 1 or greater. Return the resulting array, collapsing the reduced dimension."
    },
    {
        "instruction": "Create a function that finds the minimum element along a specified axis (which can be negative) of a numerical input array. Ensure correct behavior even if the input array has dimensions of size zero, as long as the dimension corresponding to the reduction axis is non-zero. The function should collapse the reduced dimension."
    },
    {
        "instruction": "Write a function that computes the sum of elements along a specified axis of a multi-dimensional numerical array. It should accept the array, axis index, and a boolean `keep_dims` flag. If `keep_dims` is true, the reduced axis should remain with size 1. Handle inputs where some dimensions might be zero, but the reduction axis size is >= 1."
    },
    {
        "instruction": "Develop a function to find the minimum value along a given axis of a numerical array, offering an option to retain the reduced dimension(s) in the output array (as size 1). It accepts the array, an axis index, and a boolean flag (`keep_dims`). Return the resulting array."
    },
    {
        "instruction": "Implement a function that finds the maximum value along a specified dimension (axis) of a multi-dimensional numerical array. The function accepts the array and an integer axis index, returning a new array with the specified dimension removed."
    },
    {
        "instruction": "Write a function that computes the product of elements in a numerical array along a specified axis (or all axes if axis is None), considering only elements where a corresponding boolean mask is True, and using a provided initial scalar value for the multiplicative identity and for empty slices. The function should also support optionally keeping the reduced dimensions. Inputs: numerical array, axis index (or None), boolean mask array, initial scalar value, `keep_dims` boolean flag. Return the resulting array."
    },
    {
        "instruction": "Create a function that calculates the sum of elements in a numerical array, but only includes elements where a corresponding boolean mask array is True. The function takes the numerical array and a boolean array (which must be broadcastable to the numerical array's shape) and returns the resulting sum (scalar if reducing over all dimensions, array otherwise)."
    },
    {
        "instruction": "Develop a function that accepts a shape tuple (e.g., (3, 4, 5)) and returns a boolean array of that shape filled with randomly generated true/false values."
    },
    {
        "instruction": "Implement a function that takes a numerical array, a boolean mask array (broadcastable to the first array's shape), and an axis identifier (can be an integer or None for all axes). Compute the product of the elements in the numerical array where the mask is true, performing the reduction along the specified axis. Return the result."
    },
    {
        "instruction": "Design a function to perform a conditional reduction. It takes a numerical array, a string specifying the reduction type ('sum', 'mean', 'max'), an axis identifier, a boolean `keepdims` flag, and a boolean mask array. Apply the specified reduction along the given axis, considering only elements where the mask is true. Ensure correct output shape based on `keepdims` and handle cases where the mask filters out all elements for a given reduction slice (e.g., return 0 for 'sum', NaN for 'mean')."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array, an axis index (0 or 1), and a boolean `keepdims` flag. Calculate the sum of elements along the specified axis. If `keepdims` is true, the output array should retain the reduced dimension with size 1; otherwise, the dimension should be removed. Return the resulting array."
    },
    {
        "instruction": "Develop a function that receives a non-negative integer `n` and returns the `n`-th Bernoulli number (Bn) as a single floating-point value. Handle the case `n=0` correctly (returning 1.0)."
    },
    {
        "instruction": "Implement a function that computes and returns the first `k` Bernoulli numbers (B0 to B(k-1)) as a 1D numerical array of floating-point numbers, where `k` is a positive integer input."
    },
    {
        "instruction": "Write a function that takes a non-negative integer `n` and returns a 1D numerical array initialized with zeros, having a length of exactly `n+1`."
    },
    {
        "instruction": "Create a function that accepts a non-negative integer `n` and returns a 1D numerical array of length `n+1` containing the sequence of the first `n+1` Bernoulli numbers (B0 to Bn). Ensure the output uses floating-point numbers."
    },
    {
        "instruction": "Implement a function that takes a 1D array of floating-point numbers. Return a new 1D array where the element is -1.0 if the corresponding input is exactly negative zero (-0.0), and 0.0 otherwise."
    },
    {
        "instruction": "Create a function that accepts a 1D array of floating-point numbers. Return a new 1D array of the same size. The output element should be NaN (Not a Number) if the corresponding input element is NaN or a negative integer (-1.0, -2.0, etc.). Otherwise, the output element should be 0.0."
    },
    {
        "instruction": "Write a function that takes a 1D array of floating-point numbers. Return a new 1D array where each element is 1.0 if the corresponding input element is positive (greater than zero), positive zero (0.0), or positive infinity, and 0.0 otherwise."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size and compares them element-wise for near equality. It should handle NaN values such that NaN is considered equal to NaN for this comparison. Return `True` if all corresponding elements are equal (considering NaN==NaN), `False` otherwise."
    },
    {
        "instruction": "Develop a function that computes the inverse standard normal CDF for each element in a 1D numerical input array. Ensure it handles edge cases appropriately: return negative infinity for input 0, positive infinity for input 1, and NaN (Not a Number) for any input outside the [0, 1] range."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array containing values and applies a given mathematical function (e.g., inverse normal CDF) element-wise. It should return a new array of the same shape and data type containing the results."
    },
    {
        "instruction": "Implement a function that calculates an approximation of the inverse standard normal cumulative distribution function (quantile function) for a single probability value `p` strictly between 0 and 1. Return the corresponding z-score."
    },
    {
        "instruction": "Write a function that compares two 1D numerical arrays element-wise. It should return a boolean array of the same shape, where each element is `True` if the absolute difference between corresponding elements in the input arrays is less than a specified tolerance, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that calculates element-wise relative entropy for two equal-length 1D numerical arrays, `x` and `y`. The i-th output element should follow these rules precisely: `x[i] * log(x[i] / y[i])` if `x[i] > 0` and `y[i] > 0`; `0` if `x[i] == 0` and `y[i] >= 0`; positive infinity if `x[i] > 0` and `y[i] <= 0`; and `NaN` (Not a Number) otherwise (e.g., if `x[i] < 0`). Return the resulting array."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays. Check if both arrays contain only non-negative numbers. Return `True` if all elements in both arrays are >= 0, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays, `x` and `y`, of the same length. Return a new array where the i-th element is 0 if `x[i]` is 0 and `y[i]` is non-negative. For all other input pairs, the element should be -1 (as a placeholder)."
    },
    {
        "instruction": "Write a function that takes two equal-length 1D numerical arrays, `x` and `y`. Return a new array where the i-th element is `x[i] * log(x[i] / y[i])` only if both `x[i]` and `y[i]` are strictly positive, otherwise the element should be 0."
    },
    {
        "instruction": "Write a function that takes a callable function `op` and a list or tuple of arguments `args`. The function should simply call `op` with the provided arguments unpacked (e.g., `op(*args)`) and return whatever `op` returns."
    },
    {
        "instruction": "Create a function that accepts a list of shape tuples (e.g., `[(2, 2), (3,)]`) and a list of data type identifiers (e.g., strings like 'float32', 'int64'). It should generate and return a list of numerical arrays, where each array corresponds to the shape and data type at the same index in the input lists, filled with random values."
    },
    {
        "instruction": "Write a function that takes two numerical arrays (potentially multi-dimensional) and two floating-point numbers representing absolute and relative tolerances. Return `True` if all corresponding elements in the arrays are close within these tolerances, `False` otherwise."
    },
    {
        "instruction": "Implement a function that receives two callable functions (func_a, func_b) and a list of input arguments. It should execute both functions with the *exact same* arguments and return `True` if their outputs are numerically close (using a predefined tolerance), `False` otherwise."
    },
    {
        "instruction": "Write a function that creates a 1D numerical array (vector) of a specified size `N`, filled entirely with a single given floating-point value. The function should return this new array."
    },
    {
        "instruction": "Develop a function that applies the logistic sigmoid function `f(x) = 1 / (1 + exp(-x))` element-wise to a 1D numerical array. Ensure the implementation is numerically stable, correctly handling very large negative inputs by returning values close to 0 without intermediate overflow/underflow issues. Return a new array of the same shape."
    },
    {
        "instruction": "Implement a function that computes the element-wise exponential of the negative of each element in a given 1D numerical array (i.e., calculates `exp(-x)` for each element `x`). Return a new array of the same shape containing the results."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and returns a new 1D array of the same size, where each element is the result of adding 1 to the corresponding input element."
    },
    {
        "instruction": "Create a function that checks if a given 2D numerical array (matrix) of shape (M, N) is unitary within a specified tolerance. It should compute `matrix.conj().T @ matrix` if M >= N or `matrix @ matrix.conj().T` if M < N and compare the result to the identity matrix of the appropriate size. Return `True` if unitary, `False` otherwise."
    },
    {
        "instruction": "Develop a function that reconstructs a matrix from two factor matrices using matrix multiplication. It takes two 2D numerical arrays, `factor1` and `factor2`, and a string `order` ('first_second' or 'second_first'). If `order` is 'first_second', it returns the product `factor1 @ factor2`. If `order` is 'second_first', it returns `factor2 @ factor1`."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and returns `True` if it is Hermitian (equal to its conjugate transpose) within a given tolerance, and `False` otherwise."
    },
    {
        "instruction": "Write a function to validate a potential polar decomposition. It accepts three 2D numerical arrays: the original matrix `A`, a candidate unitary factor `U`, and a candidate positive semi-definite factor `P`, along with a string `side` ('left' or 'right') indicating the multiplication order (`P @ U` or `U @ P`), and a tolerance value. The function should return `True` only if `U` is unitary, `P` is Hermitian and positive semi-definite, and `A` is correctly reconstructed from `U` and `P` according to `side`, all within the given tolerance. Otherwise, return `False`."
    },
    {
        "instruction": "Create a function that takes an initial integer seed and a shape tuple (e.g., `(rows, cols)`). Generate and return a 2D numerical array of the specified shape, filling it with values derived deterministically from the seed (e.g., `value = (seed + row_index * col_count + col_index) % 100`)."
    },
    {
        "instruction": "Implement a function that takes a state key (list of 4 integers) and a shape tuple (e.g., `(5, 7)`). Return a tuple containing two items: the *original* input state key and a 2D numerical array of the specified shape filled with a constant value derived from the key (e.g., the sum of the key elements)."
    },
    {
        "instruction": "Design a function that acts as a stateful pseudo-random generator. It accepts an initial state (list of 4 integers) and a shape tuple (e.g., `(5, 7)`). It should deterministically generate a 2D numerical array of the given shape based on the state, and compute a final state after generation. Return a tuple containing the final state (list of 4 integers) and the generated 2D array."
    },
    {
        "instruction": "Write a function that takes a desired shape tuple (e.g., `(5, 7)`) as input. Return a tuple containing two elements: a default state representation (e.g., a list `[0, 0, 0, 0]`) and a new numerical array initialized with zeros having the specified shape."
    },
    {
        "instruction": "Implement a function that performs conditional element replacement in a 2D numerical array. Given two arrays `A` and `B` of identical dimensions, and a scalar value `S`, create a new array `C` where `C[i,j] = S` if `B[i,j]` is zero, and `C[i,j] = A[i,j]` otherwise."
    },
    {
        "instruction": "Implement a function that pads a 2D numerical array along its second dimension (columns). It takes the array, a padding value, and the number of columns to add *after* the existing ones. Return the new, wider array."
    },
    {
        "instruction": "Develop a function that processes a 2D numerical array. It should: 1. Extract two column slices based on provided start/end indices. 2. Create a boolean mask from the second slice, indicating where elements are zero. 3. Construct a new array by selecting elements from the first slice or a given fill value based on the mask. 4. Pad the resulting array on the right with the fill value to reach a specified final column count. Return the final padded array."
    },
    {
        "instruction": "Write a function that extracts a specific range of columns from a 2D numerical array. It should accept the 2D array, a start column index, and an end column index (exclusive), returning the corresponding sub-array."
    },
    {
        "instruction": "Define a simple class `DataWrapper` that stores a list of numbers in an instance variable `data`. Write a function that captures an externally created `DataWrapper` instance and returns this instance."
    },
    {
        "instruction": "Implement a class `AttributeContainer` which stores a tuple representing a shape (e.g., `(5,)` or `(2, 2)`) in an attribute named `shape`. Write a function that captures an instance of this class from its outer scope and returns the instance. The caller should verify the returned object has the correct type and `shape` attribute."
    },
    {
        "instruction": "Create a function that performs an internal calculation (e.g., 5 * 10) but does not return the result. Instead, it should return a boolean value (`True`) defined outside the function's scope."
    },
    {
        "instruction": "Write a function that accepts an arbitrary object as input. Inside the function, perform a simple operation like creating a small list `[1, 2, 3]`. The function must return the original object that was passed as input, unmodified."
    },
    {
        "instruction": "Develop a function that accepts an instance of a user-defined class, say `CustomObject`. Inside the function, perform a simple, unrelated arithmetic operation (e.g., calculate 5 + 3), but ensure the function returns the original `CustomObject` instance unchanged."
    },
    {
        "instruction": "Write a function that takes one argument, an object assumed to possess a `shape` attribute which is an empty tuple `()`. The function must return this object without modification. The caller should be able to verify both the type and the `shape` attribute of the returned object remain unchanged."
    },
    {
        "instruction": "Write a function that takes a single argument of any type and returns that argument exactly as it was received (an identity function)."
    },
    {
        "instruction": "Implement a function that takes an object which is guaranteed to have a property named `shape`. The function should return the value of this `shape` property. Handle the case where the shape value is an empty tuple `()`."
    },
    {
        "instruction": "Develop a function that accepts an initial configuration object (e.g., a simple structure or dictionary) containing a key 'size' with a positive integer value `N`. Process this configuration and return a 1D numerical array of length `N` filled with the numerical value `N`."
    },
    {
        "instruction": "Implement a function that takes a positive integer `N`. The function should internally determine a result based on `N` and return a 1D numerical array of length `N`, where every element equals the numerical value `N`."
    },
    {
        "instruction": "Write a function that takes a positive integer `N`. Inside, simulate a two-step process: first, derive an intermediate value or structure based solely on `N`; second, use this intermediate result to generate and return a 1D numerical array of length `N`, filled with the numerical value `N`."
    },
    {
        "instruction": "Write a function that accepts a positive integer `N` and a numerical value `V`. Return a new 1D numerical array of length `N` where all elements are equal to `V`."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays of equal length. It should compute their element-wise product and then return a new 1D array containing the elements of the product in reversed order."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a new 1D array with the elements in reverse order."
    },
    {
        "instruction": "Write a function that accepts a single 1D numerical array of size 2. Inside the function, define a constant 1D array `[2, 5]`. Return a new 1D array representing the element-wise product of the input array and the internal constant array."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size and returns a new 1D array containing the element-wise product of the inputs."
    },
    {
        "instruction": "Implement a function that validates a padding configuration, provided as a list of `(low, high, interior)` tuples. Raise a `ValueError` with a specific message if any `interior` padding value within the tuples is negative."
    },
    {
        "instruction": "Create a function that verifies the compatibility between an N-dimensional input array and a padding configuration (represented as a list of tuples). Raise a `ValueError` with a specific message if the number of tuples in the configuration does not equal the number of dimensions (rank) of the array."
    },
    {
        "instruction": "Write a function to validate multiple aspects of padding inputs before an actual padding operation. It accepts an array, a padding value, and a padding configuration. Raise a `ValueError` for the first violation found: 1) padding value is not scalar, 2) configuration length does not match array dimensions, 3) any interior padding value is negative, 4) the resulting size for any dimension would be negative. Return `True` if all checks pass."
    },
    {
        "instruction": "Write a function that checks if a given `padding_value` is a single numerical value (scalar). Raise a `ValueError` with a specific message if it is not (e.g., if it is an array or list)."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array (with at least 2 dimensions) and merges its first two dimensions into a single one. For an input shape (D1, D2, D3, ..., Dn), the output shape should be (D1*D2, D3, ..., Dn)."
    },
    {
        "instruction": "Write a function that calculates the expected output shape of an array after collapsing a range of its dimensions. The function should take the input array's shape (as a sequence of positive integers), a starting dimension index `start`, and an ending dimension index `end` (exclusive), and return the resulting shape sequence."
    },
    {
        "instruction": "Write a function that takes a 3D numerical array with shape (D1, D2, D3) and returns a new 2D array by merging the first two dimensions. The output shape should be (D1*D2, D3)."
    },
    {
        "instruction": "Create a function that accepts a 4D numerical array of shape (D1, D2, D3, D4) and reshapes it into a 3D array by combining the first two dimensions. The resulting shape should be (D1*D2, D3, D4)."
    },
    {
        "instruction": "Implement a function that reshapes a multi-dimensional numerical array by collapsing a specified contiguous range of dimensions into a single dimension. The function should take the array and the start and end indices (inclusive) of the dimensions to collapse. For instance, collapsing dimensions 1 and 2 (0-indexed) of an array with shape (A, B, C, D) should yield shape (A, B*C, D)."
    },
    {
        "instruction": "Write a function that takes any multi-dimensional numerical array and returns a new 1D array containing all the elements of the original array in their standard flattened order."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array having at least two dimensions. It should return a new array where the first two dimensions are merged into one. An input shape like (A, B, C, D) should produce an output shape (A*B, C, D)."
    },
    {
        "instruction": "Develop a function that performs the inverse of collapsing: splitting the last dimension of a multi-dimensional numerical array into two new dimensions. The function should accept the array and the desired size of the *first* of the two new dimensions. The original last dimension size must be divisible by this desired size. E.g., input shape (A, B, C) and size X for the first new dimension (where C = X*Y) should result in output shape (A, B, X, Y)."
    },
    {
        "instruction": "Develop a function to validate a dimension mapping. It takes a list mapping source dimensions to target dimensions (`map_list`), the rank of the target array (`target_rank`), and the expected length of the mapping (`expected_len`). Return `True` if `map_list` has length `expected_len`, contains unique integer values within the range `[0, target_rank)`, and `False` otherwise."
    },
    {
        "instruction": "Create a function that validates array rank compatibility. It accepts the rank (number of dimensions) of an 'updates' array, the rank of a 'base' array, and two lists of dimension indices: 'update_window_dims' and 'inserted_window_dims'. Return `True` if the 'updates' rank equals the sum of the lengths of these two lists, `False` otherwise."
    },
    {
        "instruction": "Implement a function to check batch dimension compatibility. It receives the shape (tuple of sizes) of a 'base' array, the shape of an 'indices' array, a list of 'base' batch dimension indices, and a list of 'indices' batch dimension indices. Return `True` if the number of batch dimensions is equal for both and the corresponding batch dimension sizes (extracted using the indices) match, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a list of integers (representing dimension indices) and returns `True` if the list is sorted in ascending order and contains no duplicate values, `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes two multi-dimensional numerical arrays, 'original' and 'update', and a tuple of integer start indices. Return a *new* array representing the 'original' array where the slice starting at the given indices is replaced by the 'update' array. Assume valid inputs where the update fits."
    },
    {
        "instruction": "Develop a function that attempts to update a slice of a multi-dimensional numerical array. Inputs are the original array, an update array, and a tuple of start indices. First, validate that all start indices are integers of the exact same type. If validation fails, raise a `TypeError` with a descriptive message. If validation passes, return the new array with the slice updated. Assume the update fits if indices are valid."
    },
    {
        "instruction": "Create a function that accepts a sequence of values. It should return `True` only if all elements are integers *and* they all represent the exact same integer type (e.g., all standard 64-bit integers, or all 32-bit integers). Return `False` otherwise, including cases with non-integers or mixed integer types."
    },
    {
        "instruction": "Write a function that takes a sequence of values and returns `True` if all elements in the sequence are integers, and `False` otherwise. It does not need to check the specific type of integer."
    },
    {
        "instruction": "Write a function `is_valid_padding` that takes a string parameter representing a padding mode. It should return `True` if the string is exactly 'SAME' or 'VALID' (case-sensitive), and `False` otherwise."
    },
    {
        "instruction": "Create a function `get_dimensionality` that takes a multi-dimensional numerical array representation (e.g., a list of lists) and returns the number of dimensions it has. For a non-nested list (vector), return 1; for a list of lists (matrix), return 2, etc. Handle potentially empty or non-rectangular inputs gracefully (e.g., return 0 or raise an error)."
    },
    {
        "instruction": "Implement a function `validate_spatial_strides` that takes the number of dimensions of an input array (`input_rank`, an integer >= 2) and a list of integers (`strides`). Assuming the first two dimensions are non-spatial (e.g., batch and channel), it should raise a `ValueError` if `len(strides)` is not equal to `input_rank - 2`. Otherwise, return `None`."
    },
    {
        "instruction": "Design a function `validate_operation_params` that accepts an input array's rank (`input_rank` >= 2), a kernel array's rank (`kernel_rank` >= 2), a list/tuple of strides (`strides`), and a padding mode string (`padding_mode`). It must raise a `ValueError` with a specific message if `len(strides)` is not equal to `input_rank - 2` OR if `padding_mode` is not 'SAME' or 'VALID'. If all checks pass, it should return `True`."
    },
    {
        "instruction": "Write a function `validate_window_params(window_dims, stride_dims)` that checks if `window_dims` and `stride_dims` are tuples of the same length, containing only positive integers. Return `True` for valid parameters, `False` otherwise."
    },
    {
        "instruction": "Develop a function `reduce_window_2d(data, init_value, reduce_func, window_shape, strides)` that applies a reduction over sliding windows. Inputs: a 2D numerical array `data`, a scalar `init_value`, a binary reduction function `reduce_func` (like `lambda x, y: max(x, y)`), a tuple `window_shape` (height, width), and a tuple `strides` (row_stride, col_stride). Return the resulting 2D array after applying the reduction across valid windows. Ensure `init_value` is used correctly in the reduction."
    },
    {
        "instruction": "Implement a function `extract_blocks(matrix, block_height, block_width)` that takes a 2D numerical array `matrix` and block dimensions. It should return a collection (e.g., a list) of all non-overlapping blocks extracted from the matrix, assuming dimensions are compatible."
    },
    {
        "instruction": "Create a function `find_window_max(matrix, top_left_row, top_left_col, height, width)` that accepts a 2D numerical array `matrix` and coordinates/dimensions defining a rectangular window. Return the maximum value found within that window."
    },
    {
        "instruction": "Write a function `check_data_type(data_array, type_string)` that returns `True` if `data_array`'s elements match the data type specified by `type_string` (e.g., 'int32', 'float64'), and `False` otherwise."
    },
    {
        "instruction": "Implement a function `convert_array_type(input_array, target_type_string)` that takes a numerical array and returns a *new* array with the same values cast to the data type specified by `target_type_string`."
    },
    {
        "instruction": "Create a function `create_zero_array(shape_tuple, type_string)` that generates a new numerical array filled with zeros, having the dimensions specified by `shape_tuple` and element type given by `type_string`."
    },
    {
        "instruction": "Develop a function `are_types_equivalent(type_string1, type_string2)` which accepts two data type identifiers (strings like 'int16', 'float32') and returns `True` if they represent the exact same data type, `False` otherwise."
    },
    {
        "instruction": "Write a function that creates a 1D numerical array initialized to zeros. The function should accept the desired length and a specification for the integer data type (e.g., 8-bit signed, 32-bit signed) for the array elements."
    },
    {
        "instruction": "Write a function that accepts a string representing a standard integer data type (e.g., 'int8', 'uint16', 'int32') and returns the maximum possible value that can be stored using that data type."
    },
    {
        "instruction": "Develop a function for batched row-wise element selection. Input consists of a 2D data array (M rows, N columns) and a 1D index array of length M. For each row `i` (from 0 to M-1), the function should select the element located at the column specified by `index_array[i]`. Return a 1D array of length M containing the selected elements."
    },
    {
        "instruction": "Implement a function that performs an element selection (gather) operation. It takes a 1D data array and a 1D integer index array of the same length. For each position `i`, it selects the element from the data array located at the index specified by `index_array[i]`. Return a new 1D array containing the selected elements."
    },
    {
        "instruction": "Develop a function `generate_range_mask(length, start_index, end_index)`. This function should return a 1D boolean array of the specified `length`. Elements from `start_index` (inclusive) to `end_index` (exclusive) should be true, and all other elements should be false."
    },
    {
        "instruction": "Implement a function `logical_negate_array(input_boolean_array)`. It accepts a 1D boolean array and returns a new 1D boolean array of the same size where each element is the logical NOT (true becomes false, false becomes true) of the corresponding element in the input array."
    },
    {
        "instruction": "Create a function `elementwise_scalar_comparison(scalar, data_array)`. It takes a single value (`scalar`) and a 1D array (`data_array`). Return a boolean array of the same length where each element indicates if the corresponding element in `data_array` is equal to `scalar`."
    },
    {
        "instruction": "Implement two functions: `are_equal(item1, item2)` and `are_not_equal(item1, item2)`. They accept two comparable items. `are_equal` returns true if the items are identical, false otherwise. `are_not_equal` returns true if they differ, false otherwise. Ensure `are_equal(x, x)` is always true."
    },
    {
        "instruction": "Design a function that takes a computational function `op`, input data `data`, a string `name`, and a metadata dictionary `attrs`. It should execute `op(data)`, verify the result matches some expected output (passed as another argument), and also generate a string confirming that an operation named `name` was used with attributes formatted similarly to Task 3."
    },
    {
        "instruction": "Implement a function wrapper. It should take a calculation function `func` and a dictionary `metadata` (containing diverse value types like numbers, strings, or small arrays) as input. Return a *new* object or structure that bundles `func` and `metadata`, allowing both to be accessed later."
    },
    {
        "instruction": "Develop a function that accepts a dictionary representing metadata. Keys are strings, and values can be integers, floating-point numbers, strings, or simple 1D/2D numerical arrays. Return a formatted string representation where keys are sorted alphabetically, strings are quoted, and arrays might show their shape/type."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array `x` and returns a new 1D array where each element is the result of `sin(element) / cos(element)`. Assume valid inputs where `cos(element)` is not zero."
    },
    {
        "instruction": "Write a function that computes the element-wise sine of a 1D numerical array. Input: 1D array of numbers. Output: 1D array of the corresponding sine values."
    },
    {
        "instruction": "Implement a function that calculates the element-wise tangent of a 1D numerical array using the definition `tan(x) = sin(x) / cos(x)`. Input: 1D array of numbers. Output: 1D array of the corresponding tangent values. Specify behavior for inputs where cosine is zero (e.g., return infinity or NaN)."
    },
    {
        "instruction": "Develop a function that creates a 2D numerical array of specified dimensions (rows, columns) filled entirely with zeros. Input: two positive integers (rows, columns). Output: A 2D numerical array of shape (rows, columns) containing only zeros."
    },
    {
        "instruction": "Write a function that computes the element-wise cosine of a 1D numerical array. Input: 1D array of numbers. Output: 1D array of the corresponding cosine values."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array `Matrix` (shape M x K), a 1D array `GroupSizes` (length NumGroups, summing to M), and a group index `i` (0 <= i < NumGroups). Return the slice of `Matrix` corresponding to the rows of the i-th group (the slice should have shape `GroupSizes[i]` x K)."
    },
    {
        "instruction": "Develop a function that performs a 'grouped' matrix multiplication. It takes a 2D array `L` (shape M x K), a 3D array `R` (shape NumGroups x K x N), and a 1D array `GroupSizes` (length NumGroups, summing to M). For each group `i`, it multiplies the corresponding slice of `L` (rows defined by `GroupSizes[i]`) with the i-th matrix in `R` (`R[i]`). Concatenate these resulting matrices vertically to produce a final 2D array of shape M x N."
    },
    {
        "instruction": "Implement a function to compute the standard matrix multiplication of two 2D numerical arrays, `A` (shape P x Q) and `B` (shape Q x R). The function should return a new 2D array of shape P x R."
    },
    {
        "instruction": "Write a function that takes a total size `M` (a positive integer) and a number of groups `NumGroups` (a positive integer). It should return a 1D array of `NumGroups` positive integers that sum up exactly to `M`."
    },
    {
        "instruction": "Develop a function that takes two 2D numerical arrays of a specific low-precision floating-point type (e.g., 16-bit float) as input. Perform matrix multiplication and return the resulting 2D array, explicitly ensuring the output array maintains the *same* low-precision floating-point type as the inputs."
    },
    {
        "instruction": "Write a function that performs matrix multiplication for various numerical input types (e.g., 16-bit, 32-bit, 64-bit floats). The function must accept two matrices of the *same* numerical type, compute their product, and return the result, guaranteeing the output matrix precisely matches the data type of the input matrices."
    },
    {
        "instruction": "Write a function that accepts two numerical arrays and returns `True` if their data types are identical, and `False` otherwise."
    },
    {
        "instruction": "Create a function that checks if two matrices, represented by their shapes (e.g., tuples like `(rows_A, cols_A)` and `(rows_B, cols_B)`), are compatible for standard matrix multiplication (A times B). Return `True` if compatible, `False` otherwise."
    },
    {
        "instruction": "Create a function that computes the product of all elements in a 1D numerical array, using a provided initial scalar value as the starting point. It accepts the array and initial value, returning the final scalar product."
    },
    {
        "instruction": "Design a function that takes a 1D numerical array, an initial scalar value, a binary function (like add or multiply), and two boolean flags indicating a type property for the array and initial value. The function should apply the binary function cumulatively to reduce the array, starting with the initial value. It must return the final scalar result and a boolean indicating if the result possesses the type property (True only if both input flags were True)."
    },
    {
        "instruction": "Write a function that calculates the sum of all elements in a 1D numerical array, starting from a given initial scalar value. It takes the array and the initial value as input and returns the final scalar sum."
    },
    {
        "instruction": "Implement a function that performs a reduction (e.g., sum) on a 1D numerical array with an initial value. The function also accepts two boolean flags indicating if the input array and the initial value have a specific type property (e.g., 'is_weak'). It should return the scalar result of the reduction and a boolean indicating if the result should inherit this property (True only if *both* the array and initial value flags were True). Use addition for the reduction."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size and returns a new array containing the element-wise division of the first array by the second."
    },
    {
        "instruction": "Implement a function `outer_func` that takes a 1D numerical array `input_data`. Inside `outer_func`, define and call a nested function `inner_op` that performs an element-wise transformation (e.g., rounding) on `input_data`. `outer_func` should return the result from `inner_op`."
    },
    {
        "instruction": "Design a function factory `create_processor` that accepts a 1D numerical array `config_params`. This factory must return a *new* function. This new function should accept a single 1D numerical array `runtime_data` (compatible size with `config_params`) and return a result calculated using both `runtime_data` and the originally provided `config_params` (e.g., element-wise `round(runtime_data / config_params)`)."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays, `data` and `factors`, of the same size. It should return a new array where each element is the result of dividing the corresponding element in `data` by the element in `factors`, and then rounding the result to the nearest integer."
    },
    {
        "instruction": "Develop a function that simulates a state update. It accepts a 1D numerical array `current_state` (e.g., `[v1, v2]`). Apply a simple, deterministic transformation (e.g., `new_v1 = v1 + v2`, `new_v2 = v1 * v2`) and return a *new* 1D numerical array representing the `next_state`. The output array must have the same size as the input array."
    },
    {
        "instruction": "Implement a function that generates shaped data based on a seed. It takes a 1D numerical array `seed` (e.g., `[s1, s2]`) and a tuple `shape` (e.g., `(R, C)`). It should return a 2D numerical array of the given `shape`, where each element is initialized to a value derived deterministically from the `seed` (e.g., `s1 * s2`)."
    },
    {
        "instruction": "Write a function that validates an input key. It accepts a 1D numerical array and returns `True` if the array contains exactly two non-negative integer elements, and `False` otherwise."
    },
    {
        "instruction": "Design a function emulating one step of a stateful data generator. It takes an input `state` (a 1D numerical array of size 2) and a desired output `shape` (a tuple, e.g., `(R, C)`). Using a deterministic calculation based *only* on the input `state`, compute both a `new_state` (1D array, size 2) and an `output_data` array (with the specified `shape`). Return the `new_state` and `output_data` together as a tuple. Ensure the entire process is deterministic for identical inputs."
    },
    {
        "instruction": "Develop a function to validate inputs for an array splitting operation. It takes the shape (dimensions) of an N-dimensional array, an axis index, and a 1D array of desired split sizes along that axis. Return `True` if the sum of sizes equals the dimension length along the given axis and the axis is valid, `False` otherwise."
    },
    {
        "instruction": "Implement a function that splits a 2D numerical array (matrix) into multiple submatrices along a specified axis (0 for rows, 1 for columns). Inputs are the matrix, a 1D array of segment lengths for that axis, and the axis index. The sum of lengths must match the dimension size along the axis. Return a list of the resulting submatrices."
    },
    {
        "instruction": "Create a function that splits a 1D numerical array into multiple subarrays. It accepts the array and a 1D array of positive integers specifying the length of each desired subarray. The sum of these lengths must equal the total length of the input array. Return a list of the resulting subarrays."
    },
    {
        "instruction": "Write a generalized function that splits an N-dimensional numerical array along any specified valid axis into multiple subarrays. Inputs are the array, a 1D array of positive integer sizes for the segments along the split axis, and the axis index. Ensure the sum of sizes matches the dimension length. Return a list containing the resulting N-dimensional subarrays."
    },
    {
        "instruction": "Develop a function that compares two 1D numerical arrays. It should return `True` if both arrays have the same length and all corresponding elements are equal, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that computes the cumulative sum of a 1D numerical array. Given an input array `[x0, x1, x2, ...]`, the output should be a new array `[x0, x0+x1, x0+x1+x2, ...]`. Handle empty input arrays (return an empty array)."
    },
    {
        "instruction": "Write a function that calculates the cumulative sum of a 1D numerical array containing exactly one element. The function should return a new 1D array identical to the input array."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array. If the array contains only one element, return the array itself. Otherwise, compute and return the cumulative sum of the array."
    },
    {
        "instruction": "Develop a function that accepts a 2D numerical array (matrix) which may contain complex numbers. Return its conjugate transpose (Hermitian transpose). Input shape (M, N) should result in output shape (N, M)."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) `A`, potentially complex. Calculate and return the real part of the trace of the matrix product of `A`'s conjugate transpose with `A` itself. Ensure the output is a single real number."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `H` of shape (N, M). Construct an intermediate matrix by vertically stacking the first row of `H` (as a 1xM matrix) on top of `H`. Then, calculate the element-wise difference between the first N rows of this intermediate matrix and the original matrix `H`. Return the resulting (N, M) difference matrix."
    },
    {
        "instruction": "Write a function that computes the trace of a given square 2D numerical array (matrix). The trace is the sum of the elements on the main diagonal. The function should correctly handle arrays containing complex numbers, returning the complex sum of the diagonal elements."
    },
    {
        "instruction": "Write a function that analyzes a simplified computational graph representation (e.g., a dictionary with 'inputs': list, 'outputs': list, 'operations': list, where inputs/outputs have a 'shape' attribute). Verify the graph has exactly one input, one output, and one operation. Also, check that the input's shape matches the output's shape. Return True if all conditions are met, False otherwise."
    },
    {
        "instruction": "Write a function that accepts a description of a computational process (e.g., an object or dictionary with 'inputs' and 'outputs' attributes, which are lists) and verifies that it has exactly one input and one output. Return True if valid, False otherwise."
    },
    {
        "instruction": "Implement a function `transform_sequence(data_sequence, element_transformer)`. It takes a list `data_sequence` and a function `element_transformer`. Apply `element_transformer` to each element in `data_sequence` and return a new list containing the transformed elements, maintaining the original order and length."
    },
    {
        "instruction": "Create a function that takes two arguments representing data structures, each having a 'shape' attribute (e.g., a tuple like (3, 4)). The function should return True if the shapes are identical, and False otherwise."
    },
    {
        "instruction": "Implement a function representing a single processing stage. It accepts an input 2D numerical array (e.g., shape Batch x Features_in) and a weight 2D array (e.g., shape Features_in x Features_out). It should perform matrix multiplication of the input and weights, apply an element-wise hyperbolic tangent activation, and return the resulting 2D array (e.g., shape Batch x Features_out)."
    },
    {
        "instruction": "Implement a function that simulates accumulating contributions backward through a sequence. It takes a list of recorded intermediate states (from a forward pass) and an initial 'downstream contribution' array. It also requires a 'backward_stage' function which, given a recorded state and a downstream contribution, calculates the contribution for the *previous* step and the contribution related to the *input* of that stage. Iterate backward through the states, accumulating input contributions and propagating the downstream contribution. Return the final accumulated input contributions and the contribution corresponding to the very first state."
    },
    {
        "instruction": "Write a function that takes a numerical array of any shape and applies the hyperbolic tangent (tanh) function element-wise. Return the resulting array."
    },
    {
        "instruction": "Create a function that iteratively applies a given 'stage' function over a sequence of inputs. The function takes an initial state array, a list/sequence of input arrays, and the 'stage' function. The 'stage' function accepts the current state and one input array, returning the updated state. The main function should return the final state after processing all inputs in the sequence."
    },
    {
        "instruction": "Implement a function that takes a 2D array (e.g., M rows, N columns) and a transformation function `transform`. It should apply `transform` to each 1D sub-array (row) along the first dimension and return a new 2D array containing the transformed sub-arrays, maintaining the original (M, N) shape."
    },
    {
        "instruction": "Write a function that creates and returns a 2D numerical array initialized with default values, given desired dimensions (e.g., number of rows and columns)."
    },
    {
        "instruction": "Write a function that takes an array and returns its shape (e.g., a tuple representing the dimensions)."
    },
    {
        "instruction": "Design a function that processes an input array which belongs to a specific custom array class. The function should iterate through slices of the array along its first dimension, apply a given transformation to each slice, and return a new array of the *same custom class* and shape, containing the results."
    },
    {
        "instruction": "Write a function that splits a 1D numerical array into multiple sub-arrays based on a list of specified lengths. Input: a 1D array and a list of positive integers (lengths). First, validate if the sum of the lengths equals the total length of the input array. If validation passes, return a list containing the resulting sub-arrays. If validation fails (sum mismatch), return an empty list."
    },
    {
        "instruction": "Implement a function to validate the parameters for splitting a 1D array. It should accept the total length of the 1D array (an integer) and a list of integers representing the desired lengths of the segments. Return `True` only if *all* segment lengths are non-negative AND their sum is *exactly* equal to the total array length. Otherwise, return `False`."
    },
    {
        "instruction": "Write a function that accepts a list of integers representing desired segment lengths. Return `True` if all integers in the list are zero or positive, and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a list of integers (segment lengths) and a target integer (total dimension size). Return `True` if the sum of the integers in the list exactly equals the target integer, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and returns a new array of the same shape where each element is the maximum of the corresponding input element and zero."
    },
    {
        "instruction": "Implement a function that performs a 2D sliding window sum reduction. It accepts a 2D numerical array, window dimensions (height, width), strides (vertical, horizontal), and a padding mode ('VALID' or 'SAME'). Return the 2D array of window sums."
    },
    {
        "instruction": "Create a function to compute the minimum value within sliding windows of a multi-dimensional numerical array. It takes the array, window dimensions, strides, padding specification (e.g., 'VALID', 'SAME', or explicit pairs), and an initial value (like positive infinity for minimum). The reduction within each window should incorporate this initial value. Return the resulting array."
    },
    {
        "instruction": "Write a function that generates a multi-dimensional numerical array of a specified shape, filled with random floating-point values suitable for testing numerical algorithms (e.g., small range). Input is the desired shape tuple. Return the generated array."
    },
    {
        "instruction": "Write a function that determines the output shape when reinterpreting data between types of the *same* bit width. Input: `input_shape` (a tuple of positive integers). Output: The identical `input_shape`."
    },
    {
        "instruction": "Create a function that calculates the expected output shape after reinterpreting data from a type with fewer bits (`nbits_in`) to one with more bits (`nbits_out`). Input: `input_shape` (a tuple of positive integers), `nbits_in` (integer), `nbits_out` (integer, `nbits_out > nbits_in`). Assume the last dimension of the input shape is exactly `nbits_out // nbits_in`. Return the output shape (input shape excluding the last dimension). Raise an error if `nbits_out` is not divisible by `nbits_in` or if the last dimension size doesn't match the ratio."
    },
    {
        "instruction": "Write a function that accepts a string representing a common numeric data type (e.g., \"int8\", \"float32\", \"uint16\", \"int4\", \"float64\") and returns its corresponding bit width as an integer (e.g., 8, 32, 16, 4, 64). Handle at least five distinct type strings."
    },
    {
        "instruction": "Implement a function `calculate_bitcast_shape` that takes an input shape (tuple of integers), input bit width (`nbits_in`), and output bit width (`nbits_out`). It should return the expected output shape based on the rules: same shape if `nbits_in == nbits_out`; append dimension `nbits_in // nbits_out` if `nbits_in > nbits_out`; remove last dimension if `nbits_in < nbits_out`. Include error handling for non-integer bit ratios and incorrect last dimension size when `nbits_in < nbits_out` (assuming the last dimension must equal `nbits_out // nbits_in` in this case)."
    },
    {
        "instruction": "Write a function that takes two tuples, each representing the dimensions (rows, columns) of a matrix. Return `True` if the matrices represented by these shapes are compatible for standard matrix multiplication (A * B), and `False` otherwise."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication. It should accept two 2D numerical arrays (matrix A: M x K, matrix B: K x N) and return their product, a new 2D numerical array of shape M x N. Assume inputs contain standard floating-point numbers (e.g., 64-bit)."
    },
    {
        "instruction": "Develop a function that performs matrix multiplication on two input 2D numerical arrays (A: M x K, B: K x N). The function must ensure the resulting M x N matrix contains elements of a specific target numerical data type (e.g., float16, float32, float64) passed as an argument, regardless of the input types or intermediate calculation precision."
    },
    {
        "instruction": "Write a function that generates a 2D numerical array (matrix) of a specified shape (e.g., rows, columns) filled with random values. The function should accept the shape tuple and a parameter specifying the desired numerical data type (e.g., float32, float64) for the elements."
    },
    {
        "instruction": "Write a function that takes a 3D numerical array with shape (M, 1, N) and returns a 2D array with shape (M, N) by removing the middle dimension, assuming it is guaranteed to be of size 1."
    },
    {
        "instruction": "Develop a function that accepts a multi-dimensional numerical array and a tuple/list of dimension indices. It should return a new array with the dimensions specified in the tuple/list removed. Assume the specified dimensions are guaranteed to have size 1."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and a single integer representing a dimension index. If the dimension at that index has size 1, return a new array with that dimension removed. Otherwise, return the original array unchanged."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and a tuple/list of dimension indices (which may include negative indices). Return a new array with the specified dimensions removed. Validate that each specified dimension has a size of 1 before removal; if not, raise an error. Preserve the relative order of the remaining dimensions."
    },
    {
        "instruction": "Implement a function that applies a user-provided binary reduction operation (e.g., add, multiply) with an initial value over sliding windows of a 2D numerical array. Inputs: array, initial value, reduction function, window dimensions, strides. Implement 'SAME' padding logic. Return the resulting 2D array."
    },
    {
        "instruction": "Create a function that performs a sliding window maximum operation on a 2D numerical array. Inputs are the array, window dimensions (tuple like `(height, width)`), and strides (tuple like `(vertical_stride, horizontal_stride)`). Assume 'VALID' padding. Return the resulting 2D array."
    },
    {
        "instruction": "Extend the function from Task 4 to support base/input dilation. Inputs: array, initial value, reduction function, window dimensions, strides, padding ('VALID' or 'SAME'), window dilation factors, and base dilation factors (tuple like `(row_dilation, col_dilation)`). Return the resulting 2D array."
    },
    {
        "instruction": "Develop a function for generalized sliding window reduction on a 2D numerical array. Inputs: array, initial value, reduction function, window dimensions, strides, padding ('VALID' or 'SAME'), and window dilation factors (tuple like `(row_dilation, col_dilation)`). Return the resulting 2D array."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and an axis index (0 or 1). It should return a new 2D array of the same shape containing the cumulative product of elements along the specified axis."
    },
    {
        "instruction": "Write a function that reverses the order of elements along a specified axis of a given multi-dimensional numerical array. It takes the array and an axis index as input and returns a new array with the elements flipped along that dimension."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array containing the cumulative sum of its elements. For example, input `[1, 2, 3]` should produce `[1, 3, 6]`."
    },
    {
        "instruction": "Develop a function that computes the cumulative maximum along a specified axis of a multi-dimensional numerical array. The function should accept the array, an axis index, and a boolean flag. If the flag is true, the accumulation should happen in reverse order along that axis. Return a new array of the same shape."
    },
    {
        "instruction": "Write a robust function `safe_reshape(data, shape_spec)` that attempts to reshape the input numerical array `data`. First, validate `shape_spec` to ensure it is a 1D sequence containing only concrete positive integer values. If the shape is valid and the total number of elements in `data` matches the product of the dimensions in `shape_spec`, return the reshaped array. Otherwise, raise a descriptive error (e.g., TypeError or ValueError) indicating the specific validation failure."
    },
    {
        "instruction": "Implement a function that reshapes a 1D numerical array. The desired shape is provided as a sequence where elements might be the result of simple integer arithmetic (e.g., `(rows, cols + 1)`). The function should evaluate the final integer dimensions first and then perform the reshape. Assume the total number of elements remains compatible."
    },
    {
        "instruction": "Develop a function to validate a potential shape specification. It takes one argument. Return `True` only if the argument is a sequence (like a tuple or list) containing exclusively concrete integer values. Return `False` if it contains non-integers (like floats), nested sequences, or other non-primitive types."
    },
    {
        "instruction": "Create a function that accepts a sequence (e.g., a tuple or list) intended to represent array dimensions. Return `True` if all elements in the sequence are of integer type, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes two arguments. It attempts to add them. If a `TypeError` is raised, catch it and return the exception's message string. If no error occurs, return the sum."
    },
    {
        "instruction": "Write a function that accepts two arguments intended for addition. If adding them raises a `TypeError`, catch the exception. Analyze the error message to determine if it indicates that the *second* argument was the cause of the type mismatch. Return `True` if the error message suggests the second argument was problematic, and `False` otherwise (including if no `TypeError` occurred or the message doesn't implicate the second argument)."
    },
    {
        "instruction": "Implement a function that takes another function `op` and two arguments `arg1`, `arg2`. It should call `op(arg1, arg2)`. If this call raises *specifically* a `TypeError`, the function should return `True`. If it raises any other error or no error, it should return `False`."
    },
    {
        "instruction": "Write a function that takes two arguments. Check if both arguments are numerical (integer or float). Return `True` if both are numerical, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that finds the indices of the minimum values in a numerical array along a specified axis. The function must accept an additional parameter specifying the desired data type for the output index array. If the specified output type is *not* an integer type, the function must raise a `TypeError` with a descriptive message. Otherwise, it returns the array of indices with the specified integer type."
    },
    {
        "instruction": "Write a function that creates and returns a 2D numerical array of specified dimensions (rows, columns) where every element is initialized to the floating-point value 1.0."
    },
    {
        "instruction": "Write a function that accepts a data type identifier (e.g., a string name or a type object) and returns `True` if it represents any kind of integer type (signed or unsigned, any bit size), and `False` otherwise."
    },
    {
        "instruction": "Create a function that finds the index of the *first* occurrence of the minimum value in a 1D numerical array. Return the index as a standard integer."
    },
    {
        "instruction": "Write a function that validates input for a reduction operation. It takes a multi-dimensional numerical array and an axis index. If the dimension size along the given axis is zero, it must raise a `ValueError`. If the validation passes, it should return `True`."
    },
    {
        "instruction": "Create a function that finds the index of the minimum value along a specified axis of a multi-dimensional numerical array. If the dimension specified by the axis has size 0, the function must raise a `ValueError`. Otherwise, it returns an array of indices."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and an axis index. It should return `True` if the dimension specified by the axis index has size 0, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that accepts a multi-dimensional numerical array and returns `True` if the array contains zero elements (i.e., if any of its dimensions have size 0), and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a multi-dimensional numerical array and an integer `axis`. The function should raise a `ValueError` with a descriptive message if the provided `axis` is not valid for the array's dimensions (e.g., axis >= number of dimensions or axis < -number of dimensions). Otherwise, it should return `True`."
    },
    {
        "instruction": "Write a function that takes two integers, `num_dims` and `axis`. Return `True` if `axis` represents a valid dimension index for an array with `num_dims` dimensions (considering both positive and negative indexing), and `False` otherwise."
    },
    {
        "instruction": "Develop a function that accepts a multi-dimensional numerical array and an integer `axis`. First, validate the `axis`. If invalid, raise a `ValueError`. If valid, find the indices of the minimum elements along that specified axis. Return an array of these indices."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array and returns its number of dimensions (rank)."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and an axis identifier (e.g., 0 for columns, 1 for rows). It should return a 1D array containing the *indices* of the maximum values along the specified axis. The output indices must be 32-bit integers."
    },
    {
        "instruction": "Develop a function that takes a numerical array and returns `True` if its underlying data type is considered 'standard precision' (e.g., 32-bit or 64-bit float/integer), and `False` if it uses a 'less precise' representation."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns the *index* of the first occurrence of its minimum value. Ensure the returned index is a standard integer type."
    },
    {
        "instruction": "Write a function that finds the indices of either the minimum or maximum values (determined by a flag) along a specified axis (0 or 1) of a 2D numerical array. The function must return these indices as a 1D array of 32-bit integers. Ensure the output array's type precision characteristic is always 'standard', regardless of the input array's precision characteristic."
    },
    {
        "instruction": "Implement a function to extract non-overlapping 2D patches from a 2D numerical array (e.g., HxW). It takes the input array, a patch height `pH`, and a patch width `pW`. Assume the input dimensions `H` and `W` are exactly divisible by `pH` and `pW`, respectively. Return a 4D array where the first two dimensions represent the grid of patches (number of patches vertically and horizontally) and the last two dimensions are the patch dimensions (`pH`, `pW`). Example: Input (10, 12) with patch (5, 6) yields output (2, 2, 5, 6)."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array, a specific dimension index `C`, and a list of `filter_dims` (e.g., representing filter spatial dimensions [pH, pW]). Reshape the array such that the dimension at index `C` is replaced by `(original_C_size, pH, pW, ...)`, effectively inserting the `filter_dims` after the original dimension. The total number of elements must remain the same. Return the reshaped array."
    },
    {
        "instruction": "Write a function that takes a 4D numerical array (e.g., representing Batch, Height, Width, Channels) and a list of padding tuples `[(pad_h_before, pad_h_after), (pad_w_before, pad_w_after)]`. Assume the height and width dimensions are the 2nd and 3rd dimensions, respectively. Apply constant zero padding only to these spatial dimensions and return the padded array."
    },
    {
        "instruction": "Create a function that accepts a 4D numerical array and two dimension layout strings (e.g., 'NCHW' and 'NHWC'). Reorder the dimensions of the input array to match the target layout string. Return the array with permuted dimensions. Assume the input layout string correctly describes the input array's dimensions."
    },
    {
        "instruction": "Write a function that takes a numerical array and returns a string indicating its data type (e.g., \"float16\", \"float32\", \"int32\")."
    },
    {
        "instruction": "Create a function that generates a 2D array (matrix) of specified dimensions (rows, columns) filled with random 16-bit floating-point numbers."
    },
    {
        "instruction": "Implement matrix multiplication for two 16-bit float matrices. The function should prioritize returning a result matrix that is natively stored as 16-bit floats, even if intermediate calculations might use higher precision. The goal is to ensure the final output *storage* matches the specified 16-bit type without requiring an explicit final conversion step."
    },
    {
        "instruction": "Write a function that checks if two matrices, given their shapes (e.g., (M, K) and (K, N)), are compatible for standard matrix multiplication. Return `True` if compatible, `False` otherwise."
    },
    {
        "instruction": "Write a function that performs matrix multiplication specifically using single-precision floating-point arithmetic for all calculations. It takes two input matrices assumed to be single-precision and must return a result matrix also represented using single-precision floats."
    },
    {
        "instruction": "Write a function that checks if the shapes of two matrices, provided as tuples like (rows, columns), are compatible for standard matrix multiplication (inner dimensions must match). Return True if compatible, False otherwise."
    },
    {
        "instruction": "Develop a function that takes two 2D numerical arrays (matrices) as input and verifies that both contain only single-precision floating-point numbers. Return True if both exclusively contain single-precision floats, False otherwise."
    },
    {
        "instruction": "Implement a function to perform matrix multiplication. It should accept two 2D numerical arrays (matrices) with compatible shapes (M, K) and (K, N) and return their product, a 2D array of shape (M, N)."
    },
    {
        "instruction": "Write a function that takes a numerical value `base` and a non-negative integer `exponent` and returns `base` raised to the power of `exponent`."
    },
    {
        "instruction": "Create a function that takes a list of numerical values and returns a new list containing the square of each number in the original list."
    },
    {
        "instruction": "Implement a function `apply_func` that takes two arguments: a function `f` (which accepts one numerical input and returns one numerical output) and a single numerical value `x`. The `apply_func` should return the result of applying `f` to `x`."
    },
    {
        "instruction": "Write a function that accepts a single numerical value (integer or float) and returns its square."
    },
    {
        "instruction": "Design a function `wrap_with_metadata` that takes two arguments: a function `f` (e.g., one that squares its input) and a string `metadata_tag`. It should return a *new* function. When this new function is called with an argument `x`, it should execute `f(x)` and return a tuple containing both the result of `f(x)` and the original `metadata_tag`."
    },
    {
        "instruction": "Define a function named `calculate_power_two` that takes one numerical argument and returns the result of multiplying the argument by itself."
    },
    {
        "instruction": "Create a mechanism (e.g., using function attributes or a wrapper function) that allows associating a custom string name (metadata) with a given function without changing its core behavior (e.g., squaring a number). Provide a way to retrieve this associated name from the function."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number and returns its square. Ensure the output is also a floating-point number."
    },
    {
        "instruction": "Implement a function that takes two arguments: another function `func` (which accepts a single numerical input) and a numerical value `val`. Your function should call `func` with `val` and return the result."
    },
    {
        "instruction": "Write a function that takes two numerical inputs and returns `True` if they are exactly equal, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number and returns its square. The output must also be a floating-point number."
    },
    {
        "instruction": "Develop a function that accepts two strings, `text` and `substring`. It should return `True` if `text` contains `substring` anywhere within it, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that finds the `k` largest elements and their indices in a 1D numerical array. Ensure it correctly handles cases where `k` might be zero, negative, or larger than the array length (e.g., return all elements sorted if k exceeds length)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and an integer `k`. It should return a 1D array containing the original indices of the `k` largest values in the input array. The order of indices should correspond to the descending order of the values."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and an integer `k`. Return the `k` largest values and their original indices, but preserve the relative order among the selected top `k` elements as they appeared in the original input array (stable sort property for the top k)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and an integer `k`. It should return a new 1D array containing the `k` largest values from the input array, sorted in descending order."
    },
    {
        "instruction": "Write a function that takes a numerical input. If the input is non-negative, return its square. If the input is negative, return 0."
    },
    {
        "instruction": "Develop a function that squares its input. It must specifically handle floating-point numbers as input and ensure the output is also a floating-point number. If the input is not a number, it should indicate an error (e.g., return None or raise an exception)."
    },
    {
        "instruction": "Implement a higher-order function named `apply_and_record`. It should accept another function `f` and a value `x`. It should call `f(x)`, print a message like 'Applying function to value X, got result Y', and then return the result `Y`."
    },
    {
        "instruction": "Write a function that accepts a single numerical value (integer or float) and returns its square."
    },
    {
        "instruction": "Implement a function that accepts a single string as input. It should return `True` if the string contains *both* the substring `\"operation_name='my_op'\"` and the substring `\"result=1.0\"`, otherwise it should return `False`. The order of substrings doesn't matter."
    },
    {
        "instruction": "Write a function `create_constant_generator` that accepts a single numerical value `v`. This function should return *another function* which, when called with no arguments, produces the value `v`."
    },
    {
        "instruction": "Develop a function that takes no arguments and returns a data structure (like a dictionary or a simple object) containing two pieces of information: a 'name' (string, e.g., \"my_constant_op\") and a 'value' (float, e.g., 1.0)."
    },
    {
        "instruction": "Write a function that requires no input arguments and always returns the floating-point number `1.0`."
    },
    {
        "instruction": "Implement a function that takes a variable number of numerical arguments and returns them packaged together as a list, preserving the original order."
    },
    {
        "instruction": "Write a function that accepts exactly three numerical inputs and returns them unchanged in the same order."
    },
    {
        "instruction": "Write a function that accepts any number of numerical scalar arguments and returns a tuple containing those same arguments in the order they were received."
    },
    {
        "instruction": "Create a function that accepts any number of numerical arguments and returns the count of arguments received."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size, `data` and `divisors`. It should return a new 1D array where each element is the result of dividing the corresponding element in `data` by the element in `divisors`."
    },
    {
        "instruction": "Write a function that accepts exactly one positional argument (a 1D numerical array) and exactly one keyword argument (e.g., `factor`, a single number). The function should perform an element-wise operation (like multiplication or division) between the array elements and the `factor`, returning the resulting 1D array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a new 1D array of the same size, where each element is the original element rounded to the nearest whole number (standard rounding rules apply)."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array `input_values` and another 1D numerical array `scale_factors` of the same size, passed specifically via a keyword argument named `scale`. The function must return a new 1D array containing the element-wise division (`input_values` / `scale_factors`), with each result rounded to the nearest whole number."
    },
    {
        "instruction": "Develop a function that computes the sum of all elements within any given multi-dimensional numerical array and returns the resulting scalar value."
    },
    {
        "instruction": "Write a function that takes a numerical array `arr` and two broadcasting configurations: `config1 = (target_shape1, broadcast_dims1)` and `config2 = (target_shape2, broadcast_dims2)`. The function should perform the broadcasting specified by `config1`, sum the result, perform the broadcasting specified by `config2`, sum the result, and return `True` if the two sums are numerically close (within a small tolerance), `False` otherwise. Ensure the broadcasting logic handles mapping input dimensions to output dimensions as specified."
    },
    {
        "instruction": "Implement a function that takes a 3D numerical array of shape (A, B, C) and a target shape (X, Y, Z). It also takes a `broadcast_dimensions` tuple (e.g., (0, 1, 2)). The function should return a new array of shape (X, Y, Z) by placing the input array's dimensions into the output dimensions specified by `broadcast_dimensions` and replicating data along the unspecified dimensions. Assume input dimensions match the target dimensions they map to (e.g., if mapping dim 1 (B) to output dim 1 (Y), then B must equal Y)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array of shape (N,) and a target 3D shape (X, N, Y). It should return a new 3D array where the input array is replicated across the first and third dimensions, effectively mapping the input dimension to the middle dimension (index 1) of the output."
    },
    {
        "instruction": "Write a function that accepts two numerical arrays. It should return `True` if both arrays have a data type from a predefined list (e.g., ['float32', 'float16']), and `False` otherwise."
    },
    {
        "instruction": "Write a function that generates two 2D numerical arrays filled with random values. The function should accept two shape tuples (e.g., `(M, K)` and `(K, N)`) and two data type identifiers (e.g., 'type_X', 'type_Y') as input, and return the two generated arrays corresponding to these specifications."
    },
    {
        "instruction": "Develop a function that attempts a matrix multiplication between two input 2D numerical arrays, based on a provided configuration setting (string). If the data types of the input arrays are incompatible with the requirements specified by the configuration setting, the function must raise a `ValueError` indicating an \"Invalid input type configuration\". If compatible, it should return the resulting matrix product."
    },
    {
        "instruction": "Implement a function that receives two 2D numerical arrays and a configuration string (e.g., \"mode_A\", \"mode_B\"). Check if the arrays are shape-compatible for multiplication. Additionally, verify if the data types of *both* arrays match the types expected by the given configuration string. Return `True` only if both shape and type checks pass according to the configuration, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes two numerical arrays, A and B, and a target numerical data type T. Calculate the dot product of A and B. Then, calculate the dot product of A converted to type T and B converted to type T. Return `True` if these two results are numerically very close (within a small tolerance), and `False` otherwise. Ensure the function handles compatible shapes for dot products (e.g., vector-vector, matrix-vector, matrix-matrix)."
    },
    {
        "instruction": "Create a function that performs matrix-vector multiplication. It should take a 2D numerical array (matrix A, shape M x N) and a 1D numerical array (vector B, shape N) and return the resulting 1D numerical array (vector, shape M)."
    },
    {
        "instruction": "Implement a function to compute the dot product of two 1-dimensional numerical arrays (vectors) of compatible size. The function should return the resulting scalar value."
    },
    {
        "instruction": "Write a function that accepts a numerical array and a string representing a target numerical data type (e.g., 'float64', 'int32'). It should return a new array containing the same elements as the input, but converted to the specified data type."
    },
    {
        "instruction": "Implement a function to compute the matrix product of two 2D numerical arrays, A (shape M x K) and B (shape K x N). The function should return the resulting M x N matrix. Assume inputs have compatible data types for multiplication."
    },
    {
        "instruction": "Create a function that performs a generalized dot product between two numerical arrays, `a` and `b`. It should correctly handle vector-vector (returning a scalar), matrix-vector, vector-matrix, and matrix-matrix multiplication based on input shapes, returning the appropriate scalar or array result. Raise an error for incompatible shapes."
    },
    {
        "instruction": "Write a function that takes two numerical arrays, `a` and `b`, converts both to a specified standard precision format (e.g., 'float32'), performs a generalized dot product (as in Task 3) on these converted arrays, and returns the final result."
    },
    {
        "instruction": "Write a function that takes a numerical array and a target data type identifier (e.g., 'float32', 'float16') and returns a new array containing the elements of the input array converted to the specified target data type."
    },
    {
        "instruction": "Implement a function that computes the eigenvalues and eigenvectors of a square Hermitian matrix. Input: a square 2D numerical array guaranteed to be Hermitian. Output: a tuple containing a 1D array of eigenvalues and a 2D array where columns represent the corresponding eigenvectors."
    },
    {
        "instruction": "Write a function that takes a square 2D numerical array (which might contain complex numbers) and returns its Hermitian version. The Hermitian version H' is calculated as 0.5 * (H + H.conj().T), where H.conj().T is the conjugate transpose of the input H."
    },
    {
        "instruction": "Write a function that assesses the quality of computed eigenvalues (e) and eigenvectors (V) for a square matrix (H) using a dynamically calculated tolerance. Calculate the Frobenius norm of the residual matrix `R = H @ V - (e * V)` (using appropriate broadcasting for `e * V`). Compare this norm against a tolerance calculated as `C * ||H||_F * epsilon`, where `C` is a constant factor (e.g., 100), `||H||_F` is the Frobenius norm of H, and `epsilon` is the machine epsilon for the matrix's data type. Return true if the residual norm is within the tolerance."
    },
    {
        "instruction": "Develop a function that checks if two 1D numerical arrays contain approximately the same set of values, irrespective of order. It should sort both arrays and then compare them element-wise within a given absolute tolerance. Return true if they match after sorting, false otherwise."
    },
    {
        "instruction": "Develop a function that performs element-wise integer division, truncating the result towards zero (like standard C/Java integer division). The function should take a 1D numerical array and an integer scalar divisor, returning a new 1D array with the truncated results."
    },
    {
        "instruction": "Write a function that computes the element-wise remainder corresponding to floor division. It should accept a 1D numerical array and an integer scalar divisor, and return a new 1D array containing the remainders. The sign of the remainder should match the sign of the divisor."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and an integer scalar. It should return a new 1D array where each element is the result of floor division (integer division rounding towards negative infinity) of the corresponding input array element by the scalar."
    },
    {
        "instruction": "Write a function that takes two integers, a dividend and a divisor, and returns the result of their integer division, ensuring the result is rounded down towards negative infinity (floor division)."
    },
    {
        "instruction": "Create a function that filters a list of 'limitation' objects. Each object has `device` and `dtype` attributes. The function accepts the list, a target `device` string (e.g., 'CPU', 'GPU'), and a target `dtype` string (e.g., 'float32'). It should return a new list containing only the limitation objects whose attributes match the target device and data type."
    },
    {
        "instruction": "Create a function `compare_executions` that takes two functions (`f1`, `f2`), a list of arguments `args`, and a list of known ignorable error message substrings. Execute `result1 = f1(*args)` and `result2 = f2(*args)` within try-except blocks. If an exception occurs for either function, check if its message contains any of the known substrings. If yes, return 'IGNORE'. If no, return 'ERROR'. If both succeed, compare `result1` and `result2` using equality. Return 'MATCH' if equal, 'MISMATCH' otherwise."
    },
    {
        "instruction": "Create a function that generates a pair of numerical arrays. It takes a shape tuple (e.g., `(3, 4)`), a data type string (e.g., 'float64'), and a random number generator object (assume it has a `.random_array(shape, dtype)` method). The function should call the generator's method twice with the provided shape and dtype to produce two arrays and return them as a tuple `(array1, array2)`."
    },
    {
        "instruction": "Write a function that determines if a test should be skipped. It takes a test name (string), device ('CPU', 'GPU', 'TPU'), data type ('float32', 'complex64'), and a boolean flag ('native_mode'). Return `True` (skip) if: (name contains 'lu' AND device is 'GPU' AND native_mode is True) OR (name contains 'eigh' AND device is 'CPU') OR (name contains 'eigh' AND dtype is 'complex64' AND device is 'TPU'). Otherwise, return `False` (run)."
    },
    {
        "instruction": "Implement a function that performs element-wise binary operations on two 1D numerical arrays. The function should accept the two arrays and a string specifying the operation ('add', 'subtract', 'multiply', 'divide'). It must handle type promotion for integer and floating-point inputs and return the resulting numerical array."
    },
    {
        "instruction": "Develop a function that predicts the output data type resulting from a binary arithmetic operation between two values of given data types. Input two type identifiers (e.g., 'int32', 'float32', 'int64', 'bfloat16') and return the identifier of the promoted type according to common promotion rules (e.g., 'float32' for 'int32' and 'float32')."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays of the same length and returns a 1D boolean array indicating whether each element in the first array is strictly greater than the corresponding element in the second array. Handle potential differences in input data types."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays and a string representing a binary comparison or selection operation ('less', 'equal', 'not_equal', 'maximum', 'minimum'). The function should perform the specified element-wise operation, correctly handling type promotion for various input types (e.g., int32, int64, float32, bfloat16), and return the resulting array (boolean for comparisons, numerical for min/max)."
    },
    {
        "instruction": "Implement a function that takes a 2D array and a 1D array of integer indices. Return a new 2D array constructed by selecting the columns from the input 2D array specified by the given indices."
    },
    {
        "instruction": "Write a function that takes a 1D array and a 1D array of integer indices. Return a new 1D array containing the elements from the first array at the positions specified by the indices."
    },
    {
        "instruction": "Create a function that checks if a 1D array of integer indices are all valid for accessing elements along a specific dimension of a given 2D array. It takes the 2D array, the 1D index array, and the axis (0 or 1) as input. Return `True` if all indices are within the bounds for that axis, `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes a 2D array, a 1D array of integer indices, and an integer representing an axis (0 for rows, 1 for columns). The function should return a new 2D array formed by gathering the slices (rows or columns) along the specified axis using the provided indices. Ensure the function works correctly for boolean input arrays."
    },
    {
        "instruction": "Implement a function that validates indices. It takes a list-of-lists `index_matrix` containing integers and an integer `data_rows`. Return `True` if all integers in `index_matrix` are non-negative and strictly less than `data_rows`, otherwise return `False`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical list `data` and a 1D list of integer `indices`. Return a new 1D list containing elements from `data` selected by the `indices`. Example: `data=[10, 20, 30]`, `indices=[0, 2, 1]` -> `[10, 30, 20]`."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical list-of-lists `data_matrix` (shape M x N) and a 2D list-of-lists of integer `index_matrix` (shape P x Q). Return a 3D list-of-lists-of-lists (shape P x Q x N) where each element `[p][q]` corresponds to the row `data_matrix[index_matrix[p][q]]`."
    },
    {
        "instruction": "Write a function performing generalized array indexing. Input: a multi-dimensional numerical list `data` (rank R, first dimension size D) and a multi-dimensional integer list `indices` (rank S). Assume indices target the *first* dimension of `data` (i.e., are between 0 and D-1). Output: a new multi-dimensional list (rank S + R - 1) formed by replacing each index in `indices` with the corresponding slice from `data`."
    },
    {
        "instruction": "Develop a function to determine the maximum value present in a 1D numerical array. Input: 1D array of numbers. Output: The largest number present in the array. Assume the input array is non-empty."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns the count of elements greater than a specified threshold value. Input: 1D array of numbers, a threshold number. Output: An integer count."
    },
    {
        "instruction": "Write a function that calculates the sum of all elements in a 1D numerical array. Input: 1D array of numbers. Output: A single number representing the total sum."
    },
    {
        "instruction": "Create a function to compute the product of all elements in a 1D numerical array. Input: 1D array of numbers. Output: A single number representing the total product. Handle potential edge cases like an empty array (e.g., return 1)."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array and a scalar value. It should return a *new* array of the same shape where each element at indices selected by the slice `[::2, 3:]` is updated to be the *maximum* of its original value and the input scalar value. Elements outside this slice should be preserved."
    },
    {
        "instruction": "Design a function that performs indexed updates on a 2D numerical array. It should accept the array, parameters defining a slice (e.g., row start/stop/step, column start/stop/step), a scalar update value, and a string specifying the operation ('add', 'multiply', 'replace', 'maximum', 'minimum'). The function must return a *new* array with the updates applied according to the specified operation only at the sliced indices, leaving other elements untouched."
    },
    {
        "instruction": "Develop a function that creates a 2D numerical array of specified dimensions (rows, columns) filled entirely with the numerical value 1.0. The function should take the number of rows and columns as input and return the resulting array."
    },
    {
        "instruction": "Implement a function that accepts a 2D numerical array and a scalar value. It should return a *new* array of the same shape where the scalar value is *added* to each element located at indices selected by the slice `[::2, 3:]` (every second row, starting from the fourth column). Other elements must remain unchanged."
    },
    {
        "instruction": "Write a function that takes a 2D array (matrix) of boolean values with shape (M, N). It should perform a reduction along the rows (axis 1) and return a 1D boolean array of shape (M,) where the i-th element is `True` if *all* elements in the i-th row of the input matrix were `True`, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes a 1D array of boolean values. It should return the integer `1` if all elements are `True` and the integer `0` if any element is `False` (effectively a product where True=1, False=0)."
    },
    {
        "instruction": "Create a function that takes a 1D array of boolean values and returns `True` if all values in the array are `True`, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that receives a 1D array of boolean values and returns an integer representing the total count of `True` values in the array."
    },
    {
        "instruction": "Develop a function that simulates an interactive prompt reading from a text input stream. Attempt to read one line. If the end-of-file (EOF) is detected immediately (meaning the stream was empty or closed), the function must raise a `SystemExit` exception. Otherwise, it should return the line read."
    },
    {
        "instruction": "Implement a function that receives a text input stream. Check if the stream is immediately at its end (EOF). Return `True` if it's at EOF, and `False` otherwise. Do not consume any input if not at EOF."
    },
    {
        "instruction": "Write a function that accepts a text input stream object and reads and returns a single line from it. If the stream is already at the end, it should return an empty string or a designated marker for EOF."
    },
    {
        "instruction": "Write a function that takes a single floating-point number as input and returns the sine of that number."
    },
    {
        "instruction": "Develop a function that takes a command string as input. If the input string is exactly equal to \"c\", the function should return True. Otherwise, it should return False."
    },
    {
        "instruction": "Write a function that takes a string message and a text output stream object. The function should write the message followed by a newline character to the provided stream."
    },
    {
        "instruction": "Write a function that simulates a pause-and-continue mechanism. It takes an input stream and an output stream. It should print \"Paused. Enter 'c' to continue: \" to the output stream, then repeatedly read lines from the input stream until the line read is exactly \"c\". Once \"c\" is received, it should print \"Continuing...\" to the output stream and then terminate."
    },
    {
        "instruction": "Create a function that accepts a text input stream object. It should read and return a single line of text from the stream, removing any trailing newline characters."
    },
    {
        "instruction": "Implement a function that accepts a single floating-point number, calculates its sine using standard mathematical functions, and returns the floating-point result."
    },
    {
        "instruction": "Write a function `execute_step` that takes an initial numerical value and a list of debugger commands. Inside, it should compute the sine of the value. Then, it processes the commands: if it encounters \"print input\", it logs the *initial* value in a specific format (e.g., \"Input: <value>\"); if it sees \"continue\", it stops processing commands. The function should return the computed sine result and the accumulated log string."
    },
    {
        "instruction": "Create a function that simulates reading commands and capturing output. It takes a list of command strings. If a command is \"print_value\", it should record a predefined value string (e.g., \"Value: 2.0\") to an output log. If the command is \"continue\", it should stop processing commands. The function returns the complete output log as a single string."
    },
    {
        "instruction": "Write a function that takes a prompt string (e.g., \"(debug)> \") and a value representation string (e.g., \"Array(2.0, type=float)\") and returns a formatted string combining them, like \"(debug)> Array(2.0, type=float)\\n(debug)> \"."
    },
    {
        "instruction": "Create a function that simulates a basic command-line interaction. It should accept a command string. If the command starts with \"print \", it should return a formatted string representing a predefined value associated with the rest of the command string (e.g., \"Value: 123\"). If the command is \"continue\", it should return a specific signal string (e.g., \"CONTINUE\"). Handle unknown commands by returning an error message."
    },
    {
        "instruction": "Implement a function that takes a numerical input `x`. Inside the function, calculate an intermediate value (e.g., `y = x * x`). Then, simulate a breakpoint: use helper functions (assumed to be provided, similar to Task 2 & 3) to read a command from a simulated input stream. Process the command using logic similar to Task 4. If the command requires printing `x`, write its value representation to the simulated output stream. Only if the command signals to continue, proceed to return the calculated `y`."
    },
    {
        "instruction": "Write a function that takes a string as input and appends it to an internal buffer. Provide another function to retrieve the entire buffered content."
    },
    {
        "instruction": "Implement a function that simulates reading lines from an input stream. It should accept a list of strings (representing lines) and return them one by one when called repeatedly. It should signal when no more lines are available."
    },
    {
        "instruction": "Implement a function simulating command processing. It takes a list of command strings (e.g., `[\"show data\", \"next\"]`) and predefined float values `v1`, `v2`. It should iterate through commands: print a prompt `\"(debug) \"`. If the command is `\"show data\"`, print the formatted tuple string `\"(v1, v2)\"` (ensure floats have decimal points). If the command is `\"next\"`, stop. Capture all printed output (prompts and data) into a single string and return it."
    },
    {
        "instruction": "Create a function that takes two floating-point numbers, `val1` and `val2`, and returns a formatted string exactly like `\"(val1, val2)\"`. Ensure the numbers are represented with at least one decimal place (e.g., 2.0, 3.0)."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number `x` and returns the value `x + 1.0`."
    },
    {
        "instruction": "Develop a function that takes a string `data_output` and returns a multi-line string formatted precisely as: `\"\\n    Entering Context:\\n    (ctx) [data_output]\\n    (ctx) \"`, where `[data_output]` is replaced by the input string."
    },
    {
        "instruction": "Write a function that takes a multi-line string and an integer line index. Return the line at that index, prefixed with \"-> \". Handle cases where the index is out of bounds (e.g., return an empty string)."
    },
    {
        "instruction": "Create a function that accepts a multi-line string (e.g., source code) and a target line index. Return a new string containing the target line and up to two lines immediately preceding and succeeding it, if they exist within the string boundaries."
    },
    {
        "instruction": "Implement a function simulating a command interaction. It accepts two string arguments: `input_commands` (multi-line, one command per line) and `current_output`. Process only the *first* command from `input_commands`. If it's \"list\", append \"Code listing shown.\\n\" to `current_output`. If it's \"continue\", append \"Execution resumed.\\n\". Return the potentially modified `current_output` string."
    },
    {
        "instruction": "Write a function that takes a list of strings (representing lines) and returns a single multi-line string where each original line is prefixed by its 1-based line number and a space (e.g., \"1 line1\\n2 line2\\n...\")."
    },
    {
        "instruction": "Design a function that parses a block of text, potentially containing mixed program output and diagnostic messages. It should identify and extract all lines belonging to a 'Traceback:' section, typically starting after that keyword and ending before the next prompt or distinct section. Return the extracted traceback lines as a single formatted string."
    },
    {
        "instruction": "Write a higher-order function `run_interruptible` that accepts another function `func_to_run`, its arguments, and simulated input/output text streams. When `func_to_run` is called, simulate an interruption point. At this point, read a command from the input stream. If the command is 'proceed', let `func_to_run` complete and return its result. Any text sent to the output stream during this process should be captured and returned along with the function's result."
    },
    {
        "instruction": "Implement a function simulating a basic command-line interaction loop. It takes a list of predefined input commands and a predefined multi-line 'stack trace' string. The function should process commands one by one: if the command is 'bt', it should write the stack trace string to an output buffer; if the command is 'c', it should stop processing. Return the complete content written to the output buffer."
    },
    {
        "instruction": "Implement a function that checks if a given multi-line text block matches a specific pattern containing wildcards (e.g., '.*' representing any sequence of characters). The function should take the text block and the pattern string as input and return True if the text matches the pattern, False otherwise."
    },
    {
        "instruction": "Develop a function to simulate call stack navigation. Input consists of a list of strings representing function call frames, the current frame index (integer), and a direction command (\"up\" or \"down\"). Return the new valid frame index after moving one step, clamping the index within the bounds [0, stack_depth - 1]."
    },
    {
        "instruction": "Write a function that simulates processing a sequence of debugger commands for nested function calls. Given an initial numerical input, simulate calling an outer function `g` which calls an inner function `f`. Process a list of commands (like \"print var_in_f\", \"go up\", \"print var_in_g\", \"continue\"). Maintain a simple state (current function, local vars) and return a string concatenating all simulated output produced by the print commands."
    },
    {
        "instruction": "Implement a function that mimics a debugger's variable inspection. It should take a variable name (string) and a dictionary representing the current execution scope (mapping variable names to their values as strings). Return a formatted string \"name = value\" if the variable exists, otherwise return an error message string."
    },
    {
        "instruction": "Create a function that simulates reading a list of predefined command strings (e.g., [\"list\", \"up\", \"print x\", \"down\", \"continue\"]) one by one from a simulated input stream and writes them to a simulated output stream. Return the content written to the output stream."
    },
    {
        "instruction": "Create a function that takes a single numerical input `y`, calculates `z = y * 2.0`, and returns the result of applying the exponential function to `z`."
    },
    {
        "instruction": "Design a system with two processing functions, `step1` and `step2`, and a list to log values. `step1` takes a number `x`, calculates `y = x + 1.0`, appends `y` to the log list, and returns `y`. `step2` takes a number `x`, calls `step1(x)` to get `y1`, calculates `y2 = y1 * 2.0`, appends `y2` to the log list (after `y1`), calculates the exponential of `y2`, and returns this final result. Ensure the log list correctly reflects the order of calculations."
    },
    {
        "instruction": "Write a function that accepts a single numerical input `x` and returns the value of `x + 1.0`."
    },
    {
        "instruction": "Implement two functions, `func_f` and `func_g`. `func_f` should take a number `x` and return `x + 1.0`. `func_g` should take a number `x`, call `func_f(x)` to get an intermediate result, multiply that result by 2.0, apply the exponential function, and return the final value."
    },
    {
        "instruction": "Write a function that accepts a single numerical input `x` and returns the result of `2.0 * (x + 1.0)`."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array and a simple \"reporting\" function (callback) as input. For each element `x` in the array, calculate `y = x + 1.0`, call the reporting function with `y`, and then compute `z = 2.0 * y`. The main function should return a new 1D array containing all the `z` values."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical array. It should apply the transformation `y = 2.0 * (x + 1.0)` to each element `x` in the input array and then compute the exponential of each resulting `y`. Return the new 1D array containing the exponential values."
    },
    {
        "instruction": "Write a function that processes a 1D numerical array. For each element `x` sequentially: first, calculate an intermediate value `y = x + 1.0`; second, simulate printing or logging this intermediate value `y`; third, calculate the final value `z = 2.0 * y`. The function should return a new 1D array containing the computed `z` values for all elements in the original order. Ensure the \"printing/logging\" action happens for each element during processing."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and applies a given mathematical function (e.g., sine, cosine, exponential) element-wise, returning a new array of the results."
    },
    {
        "instruction": "Implement a function that simulates a basic command-line interaction loop. It accepts a list of input commands (strings) and an initial state (e.g., a dictionary mapping variable names to values). It should process commands like 'print <var>' (outputting the variable's string representation) and 'continue' (stopping processing for the current state). Return a single string concatenating all outputs."
    },
    {
        "instruction": "Develop a function that checks if a specific numerical resource count (e.g., available processing units) meets a minimum requirement (e.g., >= 2). If the requirement is not met, it should raise a custom 'SkipTestError'. If met, it should execute a provided callback function with no arguments and return its result."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and another function `func`. It should conceptually split the array into two equal halves (assuming even length), apply `func` to each half independently, and return a list containing the two resulting arrays."
    },
    {
        "instruction": "Write a function that processes a 1D numerical array through two sequential steps: first, adding 1 to each element, and second, calculating the element-wise exponential. The function also accepts a 'control_flag'. If the flag is set (e.g., True), the function should return the intermediate result (after adding 1). If the flag is not set (e.g., False), it should return the final result (after exponentiation)."
    },
    {
        "instruction": "Implement a function `outer_func` that takes a 1D numerical array `x`. Inside `outer_func`, it should call a helper function `inner_func`. `inner_func` should add 1 to each element of `x`. `outer_func` should then compute and return the element-wise exponential of the result produced by `inner_func`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is the corresponding input element incremented by 1."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a new 1D array containing the element-wise exponential of the input array."
    },
    {
        "instruction": "Write a function that takes a variable name (string), a dictionary representing a local scope, and a dictionary representing a global scope. It should return the value associated with the variable name, prioritizing the local scope over the global scope. If the variable is not found in either scope, indicate this (e.g., return None or raise an error)."
    },
    {
        "instruction": "Implement a function that demonstrates variable shadowing and deletion. The function should accept an initial value. Inside, define a local variable with the same name but a different value. Perform an operation using the *local* variable's value. Then, explicitly remove the local variable's binding before the function finishes."
    },
    {
        "instruction": "Develop a function that formats output lines. It should accept a prompt string (e.g., '(debug)') and a content string (e.g., 'variable value'). It should return a single formatted string like '\\nPrompt> Content\\nPrompt> '."
    },
    {
        "instruction": "Create a function that simulates processing commands from a list of input strings (e.g., ['print message', 'continue']). It should take this list and return a list of output strings. If it encounters 'print <varname>', it should output the value of <varname> (assume a predefined simple mapping like {'message': 'hello'}). If it sees 'continue', it should output 'Execution resumes.' and stop processing further commands."
    },
    {
        "instruction": "Simple Text Pattern Matching. Write a function that takes a multi-line string (`text`) and a pattern string (`pattern`). The pattern uses a simplified syntax where `...` matches any sequence of characters (including newlines). Return `True` if the `text` matches the `pattern` according to this rule, `False` otherwise."
    },
    {
        "instruction": "Input Stream Simulator. Write a function that takes a list of strings representing user commands. Each call to the function should return the next command from the list in order. Return a special value (e.g., None) when no more commands are available."
    },
    {
        "instruction": "Interactive Command Processor Stub. Design a function that simulates a simple interactive session. It takes an initial state (e.g., a dictionary with 'current_frame_index', 'frame_limit') and a list of commands ('up', 'print', 'continue'). Process the commands sequentially: 'up' should attempt to move the frame index up (respecting the top boundary), 'print' should yield a representation of the current state, and 'continue' should terminate the simulation. Return the final state after processing all commands or encountering 'continue'."
    },
    {
        "instruction": "Stack Frame Limiter. Create a function that accepts a list of strings (each representing a stack frame description) and an integer `N`. Return a new list containing only the first `N` strings from the input list. If the input list has fewer than `N` elements, return the original list."
    },
    {
        "instruction": "Write a function that accepts a nested data structure (e.g., a dictionary possibly containing other dictionaries). Traverse the structure. Generate a string representation where any element that cannot be easily represented (like a function object used as a key or value) is replaced by the placeholder string '<unrepresentable>'. Ensure the overall structure (nesting) is still discernible in the output string."
    },
    {
        "instruction": "Implement a function that takes an arbitrary Python object as input. It should return a string representation of the object. If the object contains elements (like functions) that cannot be easily serialized or represented as simple strings, return the placeholder string '<unrepresentable>' instead of raising an error."
    },
    {
        "instruction": "Create a function that simulates a basic command-line interpreter state. It should accept a dictionary representing the current variables and a command string. If the command is 'print <varname>', it should return the string representation of the variable from the dictionary (using logic similar to Task 2 if needed). If the command is 'delete <varname>', it should remove the variable from the dictionary. Handle unknown variables or commands gracefully."
    },
    {
        "instruction": "Develop a function that takes two strings, `text` and `pattern`, as input. The `pattern` string contains specific substrings that must appear in the `text` in the same order, potentially separated by other characters. Return `True` if the `text` matches the `pattern` according to this rule, and `False` otherwise."
    },
    {
        "instruction": "Write a function that creates and returns two objects simulating text-based input and output streams. The input stream should allow reading predefined lines of text sequentially. The output stream should capture all text written to it."
    },
    {
        "instruction": "Develop a function that orchestrates a simulated command-line interaction. It should accept a list of command strings and use simulated input/output streams (like those from Task 1). It processes commands sequentially (like in Task 2), capturing all output including prompts and error messages (like 'Error: Name ... not defined'). Finally, it returns the complete captured output as a single string."
    },
    {
        "instruction": "Create a function that takes two strings: `captured_output` and `regex_pattern`. Return `True` if the `captured_output` string fully matches the `regex_pattern`, considering potential multi-line content and special regex characters in the pattern. Return `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a template string containing placeholders (e.g., `Error: {} not found`) and a value (e.g., `my_var`), and returns a formatted string with the placeholder replaced by the value (e.g., `Error: my_var not found`)."
    },
    {
        "instruction": "Write a function that accepts a single numerical input `x` and returns its square (`x * x`)."
    },
    {
        "instruction": "Develop a function `select_and_compute(use_square, value)`. If the boolean `use_square` is true, the function should return `value * value`. If `use_square` is false, it should return the original `value`. The input `value` is numerical."
    },
    {
        "instruction": "Implement a function `conditional_apply(condition, input_val, func_true, func_false)` that takes a boolean `condition`, a numerical `input_val`, and two functions (`func_true`, `func_false`). If `condition` is true, it returns the result of `func_true(input_val)`; otherwise, it returns the result of `func_false(input_val)`."
    },
    {
        "instruction": "Create two functions. The first function, `compute_value(x)`, should calculate `x * x`. The second function, `compute_custom_derivative(x, x_dot)`, should calculate `3.0 * x * x_dot`, representing a non-standard rate of change for the first function. Both functions take numerical inputs and return a numerical output."
    },
    {
        "instruction": "Create a function that simulates conditional custom gradient calculation. It accepts a boolean `use_special_rule`, an input number `x`, and an incoming 'gradient' `g_in`. If `use_special_rule` is true, return a tuple `(x*x, (3*x) * g_in)`. Otherwise, return a tuple `(x, 1.0 * g_in)`."
    },
    {
        "instruction": "Implement a function that calculates the square of a numerical input (`x*x`). Create a *second* function that computes the standard derivative of the squaring function (`2*x`). Both functions take a single numerical input and return a single numerical output."
    },
    {
        "instruction": "Define two functions. `forward_compute` takes a number `x`, returns its square (`x*x`) and an intermediate value (`3*x`). `backward_compute` takes this intermediate value (`res`) and another number (`g`), returning their product (`res * g`)."
    },
    {
        "instruction": "Write a function that accepts a single numerical input and returns its square."
    },
    {
        "instruction": "Create a function that takes one floating-point number as input. It should return `True` if the input number is strictly less than 10.0, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a single floating-point number as input and returns its square."
    },
    {
        "instruction": "Implement a function that accepts a starting floating-point number `initial_value`. Inside the function, simulate a loop that continues as long as an internal counter (initialized to 0.0) is less than 10.0. In each iteration, increment the counter by 1.0 and update a running value (initialized to `initial_value`) by squaring the running value. Return the final running value after the loop terminates."
    },
    {
        "instruction": "Define two related functions. The first function, `calculate_value(x)`, should take a single floating-point number `x` and return `x * x`. The second function, `calculate_rate(x, x_dot)`, should take two floating-point numbers, `x` and `x_dot`, and return the result of `3.0 * x * x_dot`."
    },
    {
        "instruction": "Develop a function that takes a sequence of numerical values. It should iterate through the sequence, maintaining an accumulator (initialized to zero). In each step, it calculates the square of the current value from the sequence and adds this squared result to the accumulator. Return the final accumulated value."
    },
    {
        "instruction": "Write a function that accepts a single numerical value and returns its square."
    },
    {
        "instruction": "Create a function that processes a sequence (e.g., a list or 1D array) of numerical values. It should maintain an accumulator, initialized to zero. For each value in the sequence, it adds the value to the accumulator. The function returns the final accumulated sum."
    },
    {
        "instruction": "Design a function that takes two numerical inputs: a primary value `x` and a corresponding directional derivative value `x_dot`. The function must return exactly two outputs: the primary result calculated as `x * x`, and a secondary derivative result calculated using the specific formula `3.0 * x * x_dot`."
    },
    {
        "instruction": "Define two functions simulating a forward and backward calculation pass. The `forward` function takes a numerical input `x`, computes a primary result `y` (e.g., `y=x*x`), and also returns some `saved_data` derived during the computation (e.g., `saved_data=3*x`). The `backward` function takes this `saved_data` and an incoming value `gradient_signal`, and computes an output gradient using only `saved_data` and `gradient_signal` (e.g., `output_gradient = saved_data * gradient_signal`). Input (forward): number. Output (forward): number, auxiliary data. Input (backward): auxiliary data, number. Output (backward): number."
    },
    {
        "instruction": "Create a function that iterates through a 1D numerical array. In each step, it applies a transformation (e.g., square the element) and accumulates the result into a running total, starting from a provided initial scalar value. Return the final accumulated total. Input: 1D array, scalar. Output: scalar."
    },
    {
        "instruction": "Implement a function that performs a cumulative computation over a sequence. It takes a 1D numerical array and an initial scalar value. For each element in the array, it applies a specified update rule (e.g., add the element's square to the current value) to the scalar. Return the final scalar value. Input: 1D array, scalar. Output: scalar."
    },
    {
        "instruction": "Write a function that accepts a single numerical input `x` and returns exactly two values: the result of a primary calculation (e.g., `x` squared) and an auxiliary value derived from the input (e.g., `3` times `x`). Input: number. Output: pair of numbers."
    },
    {
        "instruction": "Create a function that accepts a boolean flag and two numbers, `a` and `b`. If the flag is true, return `a`. If the flag is false, return `b`."
    },
    {
        "instruction": "Write a function that takes a boolean value and a number. If the boolean is true, return the number plus one. If the boolean is false, return the number unchanged."
    },
    {
        "instruction": "Write a function that accepts a boolean condition, two functions (`op_true`, `op_false` - each taking a single number and returning a number), and a list of numbers. Return a *new* list where each element is the result of applying `op_true` (if the condition is true) or `op_false` (if the condition is false) to the corresponding number in the input list."
    },
    {
        "instruction": "Develop a function that receives a boolean switch and a list of strings. If the switch is true, return the first element of the list. If the switch is false, return the last element of the list. Handle potential empty list inputs gracefully (e.g., return None or raise an error)."
    },
    {
        "instruction": "Create a higher-order function that takes a boolean predicate, two functions (`true_func`, `false_func`), and an input value `x`. Both `true_func` and `false_func` accept `x` and return a tuple of values. The higher-order function should execute `true_func(x)` if the predicate is true, and `false_func(x)` otherwise, returning the result from the executed function."
    },
    {
        "instruction": "Implement a function that takes a boolean condition and a numerical input. Based on the condition, it applies one of two predefined transformations, each yielding two numerical results. The function must return these two results as a tuple, ensuring the output structure is the same regardless of the condition."
    },
    {
        "instruction": "Create a function that accepts a boolean value and a floating-point number. If the boolean is true, return a tuple containing the number plus 1.0 and the fixed value 1.0. Otherwise, return a tuple containing the number plus 2.0 and the fixed value 2.0."
    },
    {
        "instruction": "Write a function that takes a boolean flag. If the flag is true, it returns the integer 1, otherwise it returns the integer 2."
    },
    {
        "instruction": "Create a function that calculates the *analytical* derivative of the function `g(y) = y * y`. This new function should take a numerical input `x` and return the value of the derivative of `g` evaluated at `x` (which is `2*x`)."
    },
    {
        "instruction": "Implement a function that takes a single numerical input `x` and returns its square (`x * x`)."
    },
    {
        "instruction": "Implement a function that takes a single numerical input `x` and returns its double (`x + x`)."
    },
    {
        "instruction": "Implement a function that performs numerical differentiation using the central difference formula: `(f(x+h) - f(x-h)) / (2*h)`. The function should accept another function `f` (which takes one numerical argument and returns a numerical value), a point `x` at which to estimate the derivative, and a small step size `h`. Return the estimated derivative as a numerical value."
    },
    {
        "instruction": "Develop a higher-order function that takes a boolean condition. If the condition is true, it returns a function that performs the identity operation (returns its input). If the condition is false, it returns a different function that also performs the identity operation. The returned function should accept one numerical argument."
    },
    {
        "instruction": "Write a function to compute the numerical gradient of a given single-variable function `f(x)` at a point `x` using the central difference formula: `(f(x + epsilon) - f(x - epsilon)) / (2 * epsilon)` for a small `epsilon` (e.g., 1e-5). Test this gradient function on a target function `g(x)` which is defined conditionally: `g(x) = x` if a boolean parameter `use_identity` is true, otherwise `g(x) = 0`. Calculate the gradient at `x=2.0` for both `use_identity=True` and `use_identity=False`."
    },
    {
        "instruction": "Implement a function that accepts a boolean flag and a numerical input `x`. If the flag is true, the function returns `x`. If the flag is false, the function returns `x * x`."
    },
    {
        "instruction": "Create a function named `identity_transform` that accepts a single numerical input (integer or float) and returns the exact same value without any modification."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same length and returns a new 1D array where each element is the element-wise product of the inputs."
    },
    {
        "instruction": "Develop a function that takes an initial scalar value and two 1D numerical arrays of the same length. Iterate through the arrays, and in each step, multiply the corresponding elements from the two arrays and add the result to an accumulator initialized with the initial scalar value. Return the final accumulated value."
    },
    {
        "instruction": "Implement a function that performs a 'scan' operation. It takes an initial scalar state and a 1D numerical input array. For each element in the input array, it applies a function that uses the current state and the input element to compute a new state. The function applied at each step also returns a fixed secondary value (e.g., a constant number). The main function should return two things: the final state after processing all elements, and a collection (e.g., list or array) of all the secondary values returned at each step."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns the sum of its elements."
    },
    {
        "instruction": "Write a function that iterates through a 1D numerical array, accumulating the sum of its elements. It takes the array and an initial scalar numerical value, returning the final accumulated sum."
    },
    {
        "instruction": "Develop a function that simulates a cumulative process over two parallel 1D numerical arrays. It takes an initial scalar numerical value and two 1D arrays (of equal length). For each corresponding pair of elements `(x, y)` from the arrays, it updates the scalar using the rule `scalar = scalar + x * y`. The function should return the final scalar value after processing all element pairs."
    },
    {
        "instruction": "Create a function that takes an integer size `N` and a numerical value `V`, and returns a 1D numerical array of length `N` where every element is `V`."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same length and returns a new 1D array containing the element-wise product of the inputs."
    },
    {
        "instruction": "Implement a function that performs a cumulative product scan. It accepts an initial scalar value and a 1D numerical array. It iterates through the array, updating a running product (initial value times first element, result times second element, etc.). Return a 1D array containing the sequence of these running products after each step."
    },
    {
        "instruction": "Write a function that takes an initial scalar value (e.g., 0.0) and a 1D numerical array. It should iteratively update a state according to the rule `new_state = old_state * (current_element + 1.0)` for each element in the input array. The function must return the sum of all the state values computed during the iteration (i.e., the state after processing the first element, plus the state after processing the second, and so on)."
    },
    {
        "instruction": "Develop a function that calculates the sum of all elements in a 2D numerical array (matrix) and returns the resulting single scalar value."
    },
    {
        "instruction": "Create a function that iterates over a 1D numerical input array using an initial scalar carry value. In each step, update the carry by multiplying it with the current array element. The function should return two outputs: (1) a 1D array containing the updated carry value after each step, and (2) a 2D array where each row is a copy of the original 1D input array."
    },
    {
        "instruction": "Write a function that calculates the sum of all elements in a given 1D numerical array and returns the scalar sum."
    },
    {
        "instruction": "Implement a function that takes an integer counter and a threshold value. It should return `True` if the counter is strictly less than the threshold, and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes two 1D numerical arrays of the same size and returns a new 1D array where each element is the sum of the corresponding elements from the input arrays."
    },
    {
        "instruction": "Develop a function that simulates a loop. It accepts an initial integer value `i` and an initial 1D numerical array `c`. Inside the loop, increment `i` by 1 and update `c` by adding two predefined constant 1D arrays (e.g., `[1.0, 1.0, ...]` and `[2.0, 2.0, ...]`) element-wise. The loop continues as long as `i` is less than a given limit (e.g., 3). Return the final `i` and final `c` as a pair."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array. Return a new 1D array with all leading zeros removed. If the input consists entirely of zeros, return an array containing a single zero."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array representing polynomial coefficients, which might include leading or trailing zeros. The function should determine and return the effective degree of the polynomial represented by the significant coefficients (ignore leading/trailing zeros). Return -1 if the input represents the zero polynomial."
    },
    {
        "instruction": "Implement a function that finds all roots of a polynomial given its coefficients as a 1D numerical array (e.g., [c, b, a] for ax^2 + bx + c). The input array may have leading or trailing zeros which should be handled appropriately. The function must return a 1D array containing all roots as complex numbers. The order of roots in the output array does not matter."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (potentially containing real or complex numbers) and returns a new 1D array where all elements are explicitly represented as complex numbers."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array `data` and a target integer `length`. If the number of elements in `data` is less than `length`, return a new 1D array of size `length` containing the original `data` followed by padding elements representing complex Not-a-Number (NaN). If `len(data)` is already `length`, return the original `data`."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array (potentially real or complex) and returns a new 1D array where all elements are converted to the corresponding complex data type."
    },
    {
        "instruction": "Write a function that generates a 1D numerical array for testing purposes. It should accept a desired core `length`, a numerical data type, and counts for `num_leading_zeros` and `num_trailing_zeros`. The function should create a random array of the specified data type and `length` (potentially including internal zeros), and then return a new array with the specified number of leading and trailing zeros added."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `p`, and two non-negative integers `leading` and `trailing`. It should return a new 1D array formed by prepending `leading` zeros and appending `trailing` zeros to `p`. Preserve the original data type."
    },
    {
        "instruction": "Write a function that takes a 4D numerical array with dimensions (Batch, Height, Width, Channels) and target dimensions (e.g., merging Batch and Height). Return the reshaped array. Ensure the total number of elements remains constant."
    },
    {
        "instruction": "Implement a function that performs a basic 2D convolution. It takes a 2D numerical array (Input Image, HxW) and a smaller 2D numerical array (Kernel, KxK) where K <= H and K <= W. Use a stride of (1, 1) and 'valid' padding (output size (H-K+1) x (W-K+1)). Return the resulting 2D numerical array."
    },
    {
        "instruction": "Write a function that takes another function `op` and a 4D numerical array `data` (Batch, Dim1, Dim2, Dim3). The `op` function accepts a 3D array (Dim1, Dim2, Dim3) and returns a 3D array (Out1, Out2, Out3). Your function should apply `op` to each 3D slice along the Batch dimension of `data` and return a new 4D array (Batch, Out1, Out2, Out3) stacking the results."
    },
    {
        "instruction": "Implement a function to estimate the gradient of a scalar-output function `f(W, x)` with respect to its first argument `W` using central differences. `W` and `x` are numerical arrays, and `f` returns a scalar. For each element `W[i]`, estimate the gradient component as `(f(W_plus_eps, x) - f(W_minus_eps, x)) / (2 * epsilon)`, where `W_plus_eps` (or `W_minus_eps`) is `W` with a small `epsilon` added to (or subtracted from) only the element `W[i]`. Return an array with the same shape as `W` containing the estimated gradients."
    },
    {
        "instruction": "Develop a function that rearranges the dimensions of a given multi-dimensional numerical array based on named axes. Input: the array, a string defining its current axis layout (e.g., 'HNWC' for Height, Batch, Width, Channels), and a target layout string (e.g., 'NCHW'). Output: a new array with dimensions permuted to match the target layout."
    },
    {
        "instruction": "Create a function that accepts a numerical multi-dimensional array and a tuple representing a permutation of its dimension indices (e.g., (1, 0, 2)). Return a new array view or copy with the dimensions reordered according to the permutation."
    },
    {
        "instruction": "Write a function that simulates applying the same operation (e.g., a simple transformation like scaling) to slices of a multi-dimensional array along a specified dimension, and then combines the results. Compare this slice-wise application followed by recombination (potentially involving transposing/reshaping) with applying the operation directly to a rearranged version of the original array (where the sliced dimension is merged with another). Verify that both approaches yield the same final result."
    },
    {
        "instruction": "Implement a function to perform a basic 2D convolution with 'SAME' padding. Input: a 4D numerical array (e.g., Batch, Height, Width, InputChannels), a 4D kernel (e.g., KernelH, KernelW, InputChannels, OutputChannels), and stride (assume 1x1). Output: a 4D array where Height and Width match the input, achieved by calculating and applying appropriate padding before convolution."
    },
    {
        "instruction": "Write a function that reshapes a 4D numerical array with shape (B, H, W, C) into a 5D array with shape (B, 1, H, W, C) by adding a new dimension of size 1 at the second axis (axis index 1)."
    },
    {
        "instruction": "Implement a function that performs 2D max pooling on a 4D numerical array representing a batch of images (e.g., Batch-Height-Width-Channel). The function should accept the input array, a 2D window size (e.g., (2, 2)), 2D strides (e.g., (1, 1)), and a padding mode ('SAME' or 'VALID'). It should return the resulting 4D pooled array."
    },
    {
        "instruction": "Develop a function `check_vectorization` that takes another function `op`, a weight array `W`, and a batch input array `X` (where the first dimension represents the batch). `check_vectorization` should call `op(W, X)` once. Then, it should iterate through the batch dimension of `X`, call `op(W, X_i)` for each slice `X_i`, stack the results, and compare this stacked result to the direct batch result. Return `True` if they are numerically close (within a small tolerance), `False` otherwise."
    },
    {
        "instruction": "Write a function to perform a 2D convolution. It should take a 4D numerical input array (e.g., Batch-Height-Width-InputChannels), a 4D filter array (e.g., FilterHeight-FilterWidth-InputChannels-OutputChannels), 2D strides, and a padding mode ('SAME' or 'VALID'). Return the 4D output feature map."
    },
    {
        "instruction": "Implement a function to perform 2D sum pooling on a 4-dimensional numerical array (e.g., shape N, H, W, C). It should accept the input array, a 2D window size (e.g., height, width), and 2D strides (e.g., vertical, horizontal). Apply sum pooling over the spatial dimensions (H, W) using 'SAME' padding logic (output spatial size matches input) and return the resulting 4D array."
    },
    {
        "instruction": "Write a function `apply_to_batch` that takes two arguments: a processing function `func` and a list of data items (e.g., each item being a 3D numerical array HxWxC). The `apply_to_batch` function should iterate through the list, apply `func` to each data item individually, collect the results, and return them as a new list."
    },
    {
        "instruction": "Write a function that reshapes a 4-dimensional numerical array from an input shape like (N, H, W, C) to an output shape like (N, 1, H, W, C). The function takes the 4D array and returns the corresponding 5D array."
    },
    {
        "instruction": "Create a function for basic 2D convolution. Input consists of a 4D numerical array (N, H, W, C_in) and a 4D kernel (KH, KW, C_in, C_out). Perform the convolution using strides of (1, 1) for height and width, and apply 'SAME' padding. Return the resulting 4D output array (N, H, W, C_out)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `data` (shape M x N) and a 1D integer array `indices` (shape K). Return a new 2D array (shape M x K) by selecting columns from `data` specified by `indices`."
    },
    {
        "instruction": "Implement a function that takes a 3D numerical array `data` (shape D1 x D2 x D3) and a 2D integer array `index_matrix` (shape N x K). Using iteration, apply the slicing logic from Task 2 for each row in `index_matrix` and stack the N resulting 3D arrays (each of shape D1 x K x D3) along a new leading dimension. The final output should have shape (N x D1 x K x D3)."
    },
    {
        "instruction": "Write a function that generates a 3D numerical array of a specified shape (D1, D2, D3) containing sequential integers starting from 0 (i.e., 0, 1, 2, ...)."
    },
    {
        "instruction": "Develop a function that achieves the same result as Task 3 but *without* explicit iteration. It should take a 3D numerical array `data` (shape D1 x D2 x D3) and a 2D integer array `index_matrix` (shape N x K) and directly produce the output array (shape N x D1 x K x D3) representing the vectorized application of indexing along the second dimension of `data` based on the rows of `index_matrix`."
    },
    {
        "instruction": "Develop a function that takes a list of K 2D numerical arrays, where each array has the shape (M, N). The function should combine these arrays into a single 3D array of shape (M, K, N). The original arrays should form slices along the second dimension (axis=1) of the output array."
    },
    {
        "instruction": "Implement a function that takes a 3D numerical array (shape D1 x D2 x D3). For each index `j` from 0 to D2-1, extract the 2D slice corresponding to that index along the second dimension (shape D1 x D3). Apply an operation to each extracted slice that selects only the columns at indices `[0, 2]`. Return a list containing these resulting 2D arrays (each of shape D1 x 2)."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) and a 1D array of integer column indices. It should return a new 2D array containing only the columns specified by the indices, preserving the original row order."
    },
    {
        "instruction": "Write a function that takes three positive integers (D1, D2, D3) and returns a new 3D numerical array of shape (D1, D2, D3) filled with consecutive integers starting from 0."
    },
    {
        "instruction": "Implement a function that finds the maximum value within a multi-dimensional numerical array along specified axes. Input: the array and a tuple of axis indices. Output: an array with the same number of dimensions as the input, containing the maximum values along the specified axes."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array and a list of axis indices. It should compute the sum of elements along the specified axes, returning an array of the same number of dimensions as the input, where the summed axes have size 1."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a target shape (tuple of integers). Return a new array with the elements reshaped according to the target shape. Ensure the total number of elements is preserved."
    },
    {
        "instruction": "Develop a function that takes two lists of strings: `all_axis_names` and `reduction_axis_names`. Return a list of integer indices corresponding to the positions of `reduction_axis_names` within `all_axis_names`."
    },
    {
        "instruction": "Write a function that accepts a tuple representing a shape (e.g., (2, 3, 4)) and returns a new multi-dimensional numerical array of this shape, filled with consecutive integers starting from 0."
    },
    {
        "instruction": "Create a function that takes a 3D numerical array and two distinct axis indices, `axis1` and `axis2`. Return a new array where the data along `axis1` and `axis2` of the input array have been swapped."
    },
    {
        "instruction": "Write a function that performs a specific axis rearrangement on a 4D numerical array. It takes the array and three axis indices: `v_axis`, `s_axis`, `c_axis`. First, calculate an adjusted `s_axis` (it's `s_axis + 1` if `v_axis <= s_axis`, else `s_axis`). Then, move the original `v_axis` to position `c_axis + 1` and the adjusted `s_axis` to position 0. Return the resulting array."
    },
    {
        "instruction": "Develop a function that rearranges the dimensions of a given multi-dimensional numerical array. It should accept the array, a tuple of source axis indices, and a tuple of destination axis indices. Return the array with the specified source axes moved to the destination positions."
    },
    {
        "instruction": "Implement a function that rearranges a multi-dimensional numerical array by moving a specified source axis to a specified destination axis index. The function should take the array, the source axis index, and the destination axis index as input and return the modified array."
    },
    {
        "instruction": "Write a function that takes a shape tuple (e.g., (2, 3, 4)) and returns a new multi-dimensional numerical array of that shape filled with sequential integers starting from 0."
    },
    {
        "instruction": "Develop a function that takes a shape tuple, an axis index, and a new sub-shape tuple (e.g., (2, 2)). It should return a new shape tuple where the dimension at the given axis index is replaced by the dimensions in the sub-shape tuple. For example, input shape `(4, 4, 4)`, `axis=0`, `sub_shape=(2, 2)` should result in `(2, 2, 4, 4)`."
    },
    {
        "instruction": "Write a function that rearranges a multi-dimensional numerical array based on three axis indices: `axis_A`, `axis_B`, and `axis_C`. The function should move the data originally along `axis_A` to be along the axis at position `axis_C + 1`, and move the data originally along `axis_B` to be along the axis at position 0. Return the rearranged array. Consider how the relative positions of `axis_A` and `axis_B` might affect the final positions after the move."
    },
    {
        "instruction": "Implement a function that calculates the sum of all elements in a 1D numerical array. Input: 1D array. Output: A single scalar numerical value representing the sum."
    },
    {
        "instruction": "Write a function that computes the gradient of the total sum of a 1D numerical array with respect to each element of the array. Input: 1D array. Output: A 1D array of the same shape, where each element represents the partial derivative of the sum with respect to the corresponding input element."
    },
    {
        "instruction": "Create a function that applies a given simple mathematical operation (e.g., doubling) to each element of a 1D numerical array independently. The function should accept the array and the operation (as a callable). Input: 1D array, a function mapping scalar->scalar. Output: 1D array of the same shape with the operation applied element-wise."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array where each element is the negation of the corresponding input element. Input: 1D array. Output: 1D array of the same shape."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `batch_input` of shape (B, N). It should apply a specific transformation (e.g., `y = a * x + b`, where `a` and `b` are fixed constants and `x` is an element of the input) to each element within every 1D sub-array (row) of shape (N,). The function must return a 2D numerical array of shape (B, N) where the transformations have been applied row-wise, preserving the original batch dimension B."
    },
    {
        "instruction": "Create a function that accepts a numerical array of any shape and returns its shape as a tuple of integers."
    },
    {
        "instruction": "Write a function `apply_to_rows(func, matrix)`. `matrix` is a 2D numerical array (e.g., shape (R, C)). `func` is a function that takes a 1D array of shape (C,) and returns a 1D array of shape (C,). `apply_to_rows` should apply `func` independently to each row of the `matrix` and return a new 2D numerical array of shape (R, C) containing the results."
    },
    {
        "instruction": "Implement a function that takes three numerical arguments: `param_a`, `param_b`, and `input_array`. `input_array` is a 1D numerical array. `param_a` and `param_b` can be single numbers or arrays that are broadcastable to the shape of `input_array`. The function should apply a hypothetical element-wise operation `op(a, b, x)` using the corresponding elements from `param_a`, `param_b`, and `input_array`. Return a 1D numerical array with the same shape as `input_array`."
    },
    {
        "instruction": "Create a function that accepts a variable and returns `True` if the variable holds a numerical value whose type is considered 'flexible' or not yet fully determined (like a plain integer literal before it's used in calculations that force a specific type like float32/64), and `False` otherwise."
    },
    {
        "instruction": "Implement an identity function that takes a single numerical array as input and returns the exact same array."
    },
    {
        "instruction": "Create a higher-order function or decorator that takes an element-wise function `h` (which accepts and returns a single element) as input. It should return a *new* function that accepts a numerical array. This new function, when called, should apply `h` to each element of the input array and return a new array of the results. Crucially, if the input array had a 'flexible' numerical type, the output array must also have a 'flexible' numerical type."
    },
    {
        "instruction": "Develop a function that takes another function `g` and an array `arr` as input. It should apply `g` to each element of `arr`. Inside the application process for each element, it must first verify that the element has a 'flexible' numerical type (as described in Task 2). The function should return a new array containing the results."
    },
    {
        "instruction": "Design a function that determines the expected shapes of per-example gradients for a list of network parameters. Input: a list of parameter tuples (each containing a weight matrix shape (M, N) and a bias vector shape (M,)) and an integer `batch_size`. Output: a list of tuples, mirroring the input structure, where each shape is replaced by the expected gradient shape, which is `(batch_size,) + original_parameter_shape`."
    },
    {
        "instruction": "Implement a function representing the forward pass of a multi-layer perceptron for a single input vector. Input: a list of parameter tuples (each tuple containing a weight matrix W and bias vector b), and an initial input vector. The function should sequentially apply each layer's transformation (matrix multiply, add bias, apply tanh activation) using the output of the previous layer as input for the next. Return the final output vector after the last layer."
    },
    {
        "instruction": "Implement a function simulating a single dense layer's forward pass for a single input vector. It takes a weight matrix (M x N), a bias vector (M,), and an input vector (N,). It should compute `tanh(W * input + b)` using matrix-vector multiplication and vector addition, returning the resulting vector (M,)."
    },
    {
        "instruction": "Write a function that applies the hyperbolic tangent (tanh) activation function element-wise to a numerical array of any shape. Input: numerical array. Output: numerical array of the same shape."
    },
    {
        "instruction": "Write a function that calculates the dot product of two 1D numerical arrays (vectors) of the same size. It should take two 1D arrays as input and return a single scalar value."
    },
    {
        "instruction": "Develop a function that computes a generalized dot product between two numerical arrays, `A` and `B`. The dot product should be performed along the last dimension. The function must handle cases where `A` and `B` have different numbers of dimensions by iterating through matching leading dimensions. For example, if `A` has shape (X, Y, Z) and `B` has shape (Z,), the output should have shape (X, Y). Assume the last dimensions are compatible for the dot product."
    },
    {
        "instruction": "Create a function that computes the dot product between a 2D numerical array (representing a batch of vectors, shape M x N) and a single 1D array (vector, shape N). The function should return a 1D array of shape M, where each element is the dot product of the corresponding row from the 2D array and the 1D array."
    },
    {
        "instruction": "Implement a function that performs element-wise dot products between two 2D numerical arrays of the same shape (M x N). It should compute the dot product for each corresponding pair of rows (vectors of size N) and return a 1D array of M scalar results."
    },
    {
        "instruction": "Create a function that accepts a positive integer `N` and returns a 1D numerical array of size `N` containing only zeros."
    },
    {
        "instruction": "Implement a function that takes a positive integer `N`, an integer index `i` (where `0 <= i < N`), and a numerical value `v`. The function should return a 1D numerical array of size `N` containing zeros everywhere except at index `i`, where the value should be `v`."
    },
    {
        "instruction": "Write a function that takes a positive integer `N` and a numerical value `v`. It should generate and return a 2D numerical array (matrix) of shape `N x N`. Each row `i` (from 0 to N-1) of this matrix should be constructed by starting with a zero vector of size `N` and setting the element at index `i` to the value `v`."
    },
    {
        "instruction": "Develop a function that accepts a 1D numerical array `arr`, a list of integer indices `indices`, and a numerical value `val`. The function should return a *new* 1D array where the elements at each index specified in `indices` have been incremented by `val`. Assume indices are valid."
    },
    {
        "instruction": "Implement a function that computes the dot product between two numerical tensors (multi-dimensional arrays) by contracting specified dimensions. The function should accept two tensors and two tuples of integers indicating the dimensions to contract in each tensor. For example, given tensors X of shape (A, B, C) and Y of shape (D, C, E), contracting dimensions (2,) of X and (1,) of Y should result in a tensor of shape (A, B, D, E)."
    },
    {
        "instruction": "Create a function that performs a generalized dot product between two numerical tensors, supporting both contracting and batch dimensions. It should take two tensors and specifications for which dimensions to contract and which to treat as batch dimensions. For instance, given X of shape (B, M, K) and Y of shape (B, K, N), contracting dimension 2 of X with dimension 1 of Y, while treating dimension 0 as a batch dimension, should yield an output of shape (B, M, N)."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays (matrices) A and B, where the number of columns in A equals the number of rows in B. Return their standard matrix product A @ B."
    },
    {
        "instruction": "Write a function that calculates the trace of the product of two square matrices along specified batch dimensions. Input tensors have shape (..., N, N). The function should compute the matrix product for each corresponding NxN slice along the leading dimensions (...) and then find the trace (sum of diagonal elements) for each resulting product matrix. The output shape should be (...)."
    },
    {
        "instruction": "Write a function to compute the matrix of second partial derivatives for the scalar function described in Task 3, evaluated at a specific input 1D array. The output should be a 2D numerical array (matrix) where the element at index (i, j) represents the second partial derivative with respect to the i-th and j-th input elements. Pay attention to how the second derivatives behave around input values of zero."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array where each element is replaced by zero if it's negative, otherwise the element's value is kept. Input: 1D array, Output: 1D array of the same size."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a new array containing the square of each element from the input array. Input: 1D array, Output: 1D array of the same size."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array. First, it should apply an element-wise 'rectification' (replace negative values with zero). Second, it should square each element of the rectified array. Finally, it should return the sum of all elements in the resulting array. Input: 1D array, Output: Scalar number."
    },
    {
        "instruction": "Write a higher-order function `apply_batchwise`. It accepts a multi-dimensional numerical array `input_data`, an integer `batch_axis`, and a function `operation`. `apply_batchwise` should iterate through slices of `input_data` along `batch_axis`, apply `operation` to each slice (assuming `operation` accepts such slices), collect the results, and stack them into a single output array along the `batch_axis`."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and an integer axis index. Return a list where each element is a slice of the original array along the specified axis."
    },
    {
        "instruction": "Develop a function that takes a 3D numerical array `tensor` (Depth x Height x Width), a 1D integer array `start_indices` (length Depth), and an integer `slice_height`. For each depth plane `d`, extract a slice of shape (`slice_height`, Width) starting from row `start_indices[d]`. Stack these extracted slices along a new first dimension to form the output array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array `data` and a 1D integer array `indices`. Return a new 1D array containing elements from `data` at the positions specified by `indices`."
    },
    {
        "instruction": "Write a function that calculates a value derived from applying a sequence of operations: first, extract slices from an input array based on indices (similar to Task 2); second, apply an element-wise function (e.g., sine) to the gathered data; third, sum the results. The function should take the input array, indices, and slice definition parameters, and return the final sum."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array. It should apply the trigonometric sine function to each element and then compute the sum of all elements in the resulting array, returning a single scalar value."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array, an axis index, and a single slice index. Return the sub-array (slice) located at the given slice index along the specified axis."
    },
    {
        "instruction": "Implement a function that extracts multiple slices from a source array based on a 2D array of starting indices. Given a source N-D array, a 2D index array (e.g., shape `(num_indices, index_dims)`), parameters defining the size of each slice to extract, and parameters specifying which dimensions of the source array correspond to the indices and slice dimensions, return a new array containing the gathered slices."
    },
    {
        "instruction": "Implement a function to extract a single multi-dimensional slice from a larger numerical array. Inputs are the array, a tuple/list representing the starting indices for the slice in each dimension, and a tuple/list representing the size of the slice in each dimension. Return the extracted sub-array."
    },
    {
        "instruction": "Create a higher-order function that applies a given 'processing function' repeatedly based on batched inputs. It takes a data array ('operand'), an index array ('indices'), an integer specifying the 'batch dimension' within the 'indices' array, and the 'processing function'. The 'processing function' itself takes the 'operand' and a *single* index set (obtained by slicing 'indices' along the 'batch dimension'). Your function should iterate through the batch dimension, call the 'processing function' for each index set, and collect/stack the results into a single output array."
    },
    {
        "instruction": "Create a function that accepts a list of numerical arrays, all having the exact same shape. It should return a *new* array formed by stacking the input arrays along a new initial dimension (axis 0)."
    },
    {
        "instruction": "Develop a function that performs a generalized gather operation. It takes a numerical data array ('operand'), an integer array of indices ('indices'), a mapping indicating which dimensions of the operand the indices refer to, and the desired size of slices to extract along those dimensions. For each index coordinate in 'indices', calculate the start position in 'operand' and extract a slice of the specified size. Combine these extracted slices into the output array."
    },
    {
        "instruction": "Write a function that first gathers slices from a numerical data array based on an index array and dimension specifications. Then, it applies a simple mathematical function (e.g., sine) element-wise to the gathered result, and finally computes the sum of all elements in the transformed array. Inputs: data array, index array, dimension mapping rules, slice sizes. Output: a single scalar value (the sum)."
    },
    {
        "instruction": "Develop a function that iterates over a specified dimension (axis) of an input index array. For each index slice along this axis, it calls a provided 'process' function (which takes the full data array and the current index slice) and stacks the results into a single output array. Inputs: data array, index array, axis to iterate over, 'process' function. Output: stacked results array."
    },
    {
        "instruction": "Write a function that extracts a single slice of a specified size from a 1D numerical array starting at a given index. Input: 1D data array, scalar integer index, integer slice size. Output: 1D array slice."
    },
    {
        "instruction": "Create a function that gathers slices from a multi-dimensional numerical array according to specified dimension mappings. Inputs: a data array, an index array, rules defining index-to-data dimension mapping, which data dimensions are sliced, and the size of each slice. Output: the resulting array containing gathered slices."
    },
    {
        "instruction": "Write a function that implements a batched gather operation. It receives a data array, an index array, a data batch axis index, and an index batch axis index. Assume the sizes of these batch axes are equal. For each corresponding slice along the batch axes of the data and index arrays, perform a simple gather operation (e.g., gathering full slices along the first dimension based on indices) and stack the results."
    },
    {
        "instruction": "Create a function that extracts elements from a data array based on an index array. Given a 2D data array (e.g., shape M x N) and a 1D index array (shape K), return a new 2D array (shape K x N) where the i-th row is the `index[i]`-th row of the data array."
    },
    {
        "instruction": "Implement a function that applies a given transformation function to corresponding slices of two input arrays along specified axes. Inputs are array A, axis `ax_A`, array B, axis `ax_B`, and the transformation function `func`. Assume `A.shape[ax_A] == B.shape[ax_B]`. The function should iterate from `i = 0` to `A.shape[ax_A] - 1`, extract the i-th slice from A along `ax_A` and the i-th slice from B along `ax_B`, apply `func` to these slices, and stack the results into a new array."
    },
    {
        "instruction": "Develop a function to perform a gather operation with specified slice sizes. It takes a data array, an index array, the dimension to gather along in the data array, and the desired output slice shape. For each index in the index array, it should extract a slice of the specified shape starting at that index in the gather dimension of the data array. Return an array containing all extracted slices."
    },
    {
        "instruction": "Create a function that simulates a batched row selection. It accepts a 3D numerical array `data` (Batch, H, W) and a 2D array of integer indices `idxs` (Batch, K). For each batch item `b` (from 0 to Batch-1), select `K` rows from `data[b, :, :]` using the indices specified in `idxs[b, :]`. Return a 3D array of shape (Batch, K, W) containing the selected rows."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `data` (M rows, N columns) and a 1D array of starting row indices `starts`. For each index in `starts`, extract a slice of `k` consecutive rows from `data`. Return a 3D array where the first dimension corresponds to the indices in `starts`, containing the extracted slices. Assume `k` is a fixed positive integer smaller than M."
    },
    {
        "instruction": "Write a function to compute the 'influence' or 'sensitivity' of each element in a 1D input numerical array `data` on a final scalar sum. This sum is calculated by: (1) selecting elements from `data` based on a 1D integer array `indices`, (2) applying a simple differentiable function (like squaring) to the selected elements, (3) summing the results. The function should return an array of the same size as `data`, where `output[i]` approximates the derivative of the final sum with respect to `data[i]`. Account for indices appearing multiple times."
    },
    {
        "instruction": "Develop a function that takes a numerical array of any dimension, applies a standard element-wise mathematical function (e.g., square, sine, or cosine), and then computes the sum of all elements in the resulting array, returning a single scalar value."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array. This function should perform an element-wise operation (e.g., doubling each element) to produce a result array. Additionally, it must trigger a specific side effect (like printing a message 'Processing started' or appending a value to an external list) exactly once *each time* the function is called, regardless of the input array's size. Return the result array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is the sum of the original element with itself (i.e., doubled)."
    },
    {
        "instruction": "Create a function that accepts two arguments: a function `op` (which takes one number and returns one number) and a 1D numerical array `arr`. The function should return a new 1D array of the same size, where each element is the result of applying `op` to the corresponding element in `arr`."
    },
    {
        "instruction": "Create a function `apply_to_batches` that takes a list of 1D numerical arrays and a simple element-wise function `op`. It should apply `op` to every element in every array in the list. The function must also ensure that a specific initialization or setup step related to `op` (simulated by printing a message like 'Initializing operation') happens only once during the entire execution of `apply_to_batches`, even though `op` is applied potentially many times across all batches. Return a list of the resulting arrays."
    },
    {
        "instruction": "Develop a function that takes a pre-existing 2D numerical array and two 1D numerical arrays (row_indices, col_indices). The function should return a 1D array containing the elements from the 2D array specified by the pairs of indices from row_indices and col_indices. Handle cases where the index arrays contain only a single index."
    },
    {
        "instruction": "Implement a function that accepts a 2D numerical array (matrix) and two 1D numerical arrays of the same length, L. The first 1D array holds row indices, and the second holds column indices. Return a new 1D array of length L containing elements selected from the input matrix using the corresponding row and column index pairs."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array and two integer indices (a row index and a column index) and returns the single element located at that specific position in the array."
    },
    {
        "instruction": "Write a function that first generates a 6x6 2D numerical array filled with integers 0 through 35 (row-major order). The function should then accept two 1D numerical index arrays as input. Validate that these index arrays are indeed 1D and have the same number of elements. If valid, extract and return the corresponding elements from the generated 6x6 array based on the index pairs; otherwise, indicate an error (e.g., return None or raise an exception)."
    },
    {
        "instruction": "Write a function that simulates applying an operation along a specific dimension and rearranging the output. It takes a 2D numerical array (M x N) and applies a given element-wise function (e.g., squaring) to each row (slice along the first dimension). It should return a new 2D array (N x M) where the i-th column of the output corresponds to the transformed i-th row of the input."
    },
    {
        "instruction": "Create a function that accepts a structure containing a 2D numerical array (M x N) and its dimension names (e.g., ['name1', 'name2']). The function should return a new structure where the numerical array is the element-wise square of the input array, and the dimension names are swapped (e.g., ['name2', 'name1'])."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (M x N) and swaps its dimensions, returning a new N x M array (transpose)."
    },
    {
        "instruction": "Define a simple structure or class to encapsulate a 2D numerical array along with a list of two strings representing names for its dimensions (e.g., 'rows', 'columns'). Provide a way to initialize and retrieve both the array and the names."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (e.g., list of lists) and calculates the cumulative product along each column independently. The output should be a 2D array with the same shape as the input. Example: `[[1, 2], [3, 4], [5, 6]]` -> `[[1, 2], [3, 8], [15, 48]]`."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (e.g., list of lists) and computes the cumulative product along each row independently. The output should be a 2D array of the same dimensions. Example: `[[1, 2, 3], [4, 5, 6]]` -> `[[1, 2, 6], [4, 20, 120]]`."
    },
    {
        "instruction": "Write a function that computes the cumulative product of elements in a 2D numerical array along a specified axis (0 for columns, 1 for rows). The function should take the 2D array and the axis index as input and return a new 2D array of the same shape with the cumulative products."
    },
    {
        "instruction": "Develop a function that takes a sequence of numbers and two integers, `rows` and `cols`, and returns a 2D numerical array (list of lists) with the specified dimensions, filled row-by-row with the numbers from the sequence. Assume the sequence length equals `rows * cols`. Example: `sequence=[1,2,3,4,5,6], rows=2, cols=3` -> `[[1, 2, 3], [4, 5, 6]]`."
    },
    {
        "instruction": "Dynamic Slice Sum: Implement a function `dynamic_slice_sum(data, axis, index)` that takes a 2D numerical array `data`, an integer `axis` (0 or 1), and an integer `index`. It should first clamp the `index` to the valid range `[0, data.shape[axis] - 1]`. Then, it should select the 1D slice along the specified `axis` at the clamped `index`. Finally, it should return the sum of the elements in this slice as a single scalar value."
    },
    {
        "instruction": "Gradient of Clamped 1D Selection: Consider a function `f(data, index)` that selects an element from a 1D numerical array `data` at a potentially out-of-bounds `index` (which is clamped internally). Write a function `gradient_of_select_clamped_1d(data, index)` that returns the gradient of `f` with respect to `data`. The output should be a 1D array of the same size as `data`, containing zeros everywhere except for a '1' at the position corresponding to the *clamped* index that was actually selected."
    },
    {
        "instruction": "Index Clamping Function: Create a function `clamp_index(index, size)` that takes an integer `index` and a positive integer `size`. It should return the `index` clamped to the range `[0, size - 1]`. For example, `clamp_index(-2, 5)` should return `0`, `clamp_index(7, 5)` should return `4`, and `clamp_index(3, 5)` should return `3`."
    },
    {
        "instruction": "Array Sum: Write a function `sum_all_elements(data)` that accepts a numerical array of any dimension (e.g., 1D, 2D) and returns the sum of all its elements as a single scalar number."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `A`, an axis index (0 or 1), an element index `i`, and a 1D numerical array `V`. First, create a *new* 2D array `A'` where the slice at index `i` along the specified axis is replaced by `V`. Then, return the sum of all elements in the modified array `A'`. Assume `V` has the correct length and the index `i` is non-negative and valid."
    },
    {
        "instruction": "Write a function that computes and returns the sum of all elements in a given multi-dimensional numerical array."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `A`, an axis index (0 or 1), an element index `i`, and a 1D numerical array `V`. Return a *new* 2D array where the slice (row or column) at index `i` along the specified axis is replaced by `V`. Assume `V` has the correct length matching the dimension perpendicular to the specified axis, and the index `i` is non-negative and valid."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array `A`, an axis index (0 or 1), and an element index `i`. Return the 1D sub-array (row if axis=0, column if axis=1) at index `i`. Assume the index is non-negative and valid."
    },
    {
        "instruction": "Develop a function that splits a multi-dimensional numerical array along a specified axis into multiple chunks. It should accept the array, an integer `axis`, and a 1D array of positive integers (`sizes`) indicating the size of each chunk along that axis. Assume the sum of `sizes` matches the array's dimension size along `axis`. Return a list containing the resulting multi-dimensional sub-arrays."
    },
    {
        "instruction": "Write a function that generates a 1D array containing a specified number (`k`) of positive integers that sum exactly to a given `total`. The function should take `k` (number of integers) and `total` (the target sum) as input and return the 1D array of `k` positive integers."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array, an integer `axis`, and a 1D array of positive integers `sizes`. It should return `True` if the size of the array's dimension specified by `axis` is equal to the sum of the elements in `sizes`, and `False` otherwise. Handle invalid axis inputs."
    },
    {
        "instruction": "Write a function that takes a 1D array of positive integers and returns their sum."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays of the same length, `keys` and `values`. It should return two new 1D arrays: the `keys` sorted in ascending order, and the `values` rearranged according to the original positions of the sorted keys."
    },
    {
        "instruction": "Write a function that performs a stable key-value sort on 1D numerical arrays. It takes `keys` and `values` arrays and returns sorted versions. If multiple keys are identical, the corresponding values in the output should maintain their original relative order from the input `values` array."
    },
    {
        "instruction": "Develop a function that accepts two multi-dimensional numerical arrays, `keys` and `values` (with identical shapes), and an integer `axis`. Sort the key-value pairs along the specified `axis`. Return the two resulting arrays (sorted keys, sorted values) maintaining the original shape."
    },
    {
        "instruction": "Write a function that takes an integer N and returns a 1D numerical array containing the integers from 0 to N-1 in a random order."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number `x` and returns its reciprocal `1/x`."
    },
    {
        "instruction": "Write a function that accepts a function `f` and a positive integer `n`. It should return a *new function* that represents the nth numerical derivative of `f`. This can be achieved by repeatedly applying the process described in Task 3, `n` times."
    },
    {
        "instruction": "Create a function that takes a single-variable function `f` as input and returns a *new function*, let's call it `derivative_f`. When `derivative_f` is called with a value `x`, it should compute and return the numerical approximation of the first derivative of `f` at `x` (e.g., using the method from Task 2 with a predefined small `h`)."
    },
    {
        "instruction": "Develop a function that takes two arguments: a function `g` (assumed to be the result of some calculations, like a higher-order derivative) and a floating-point value `v`. The function should execute `g(v)` and return the resulting floating-point number."
    },
    {
        "instruction": "Create a function named `ensure_numeric` that accepts one argument. If the argument is an integer or a float, the function should return it. If the argument is a function or any other callable type, it must raise a `TypeError`."
    },
    {
        "instruction": "Implement a function that takes a dictionary containing a single key-value pair where the value is a number (e.g., {'data': 3.0}). The function should extract and return the numerical value. Write a conceptual check demonstrating that the derivative of the *returned value* with respect to the *original input number* (before it was placed in the dictionary) should be considered zero."
    },
    {
        "instruction": "Write a function that computes both the first and second derivatives of g(x) = sin(x) * cos(x) with respect to x. The function should accept a floating-point number x and return a tuple containing the first and second derivative values evaluated at x."
    },
    {
        "instruction": "Consider the function h(x) = sin(x) * cos(x). Write a function that computes the derivative of h(x) with respect to x, but modifies the calculation such that the x inside cos(x) is treated as a constant during differentiation (i.e., d(cos(x))/dx is treated as 0 for this specific calculation). Return the resulting derivative value evaluated at a given numerical input x."
    },
    {
        "instruction": "Create a function `apply_operation` that takes two arguments: a mathematical operation `op` (a function that accepts one or more numerical arrays) and a tuple of input numerical arrays `args`. It should execute `op(*args)` and return the resulting numerical array."
    },
    {
        "instruction": "Write a function `approximate_gradient` that estimates the gradient of a function `func` which takes multiple numerical array arguments. For a specific argument index `i`, approximate the partial derivative using finite differences (e.g., central difference) by slightly perturbing the `i`-th input array. The function should take `func`, a tuple of input arrays `args`, the index `i`, and a small step `delta`."
    },
    {
        "instruction": "Implement a function `check_closeness` that takes two numerical arrays `arr1`, `arr2` of the same shape, and a tolerance value `tol`. Return `True` if the absolute difference between all corresponding elements is less than or equal to `tol`, and `False` otherwise."
    },
    {
        "instruction": "Write a function `create_random_array` that accepts a shape (e.g., `(2, 3)`) and a numeric type name (e.g., 'float', 'complex'). It should return a new array of that shape and type filled with random numbers."
    },
    {
        "instruction": "Write a function that takes a single numerical scalar input and applies a specific mathematical operation (e.g., hyperbolic sine). Return the numerical scalar result."
    },
    {
        "instruction": "Write a function that takes a mathematical function `f`, its known analytical derivative function `f_prime`, an input value `x`, and tolerance parameters (`rtol`, `atol`). It should numerically estimate the derivative of `f` at `x` (e.g., using central differences) and compare this estimate to the value of `f_prime(x)`. Return `True` if the estimated and analytical derivatives are close within the given tolerances (using the logic from Task 3), `False` otherwise."
    },
    {
        "instruction": "Create a function that checks if two floating-point numbers are close within specified tolerances. It should take two numbers (`a`, `b`), a relative tolerance (`rtol`), and an absolute tolerance (`atol`) as input. Return `True` if `abs(a - b) <= (atol + rtol * abs(b))`, and `False` otherwise."
    },
    {
        "instruction": "Implement a function to numerically approximate the first derivative of a given single-variable function `f` at a point `x` using the central difference formula: `(f(x + h) - f(x - h)) / (2 * h)`. The function should accept the function `f`, the point `x`, and a small step size `h` as input."
    },
    {
        "instruction": "Write a function that takes a 2D array containing complex numbers. Convert this array to a floating-point type (e.g., convert complex64 to float32). Specify how the conversion should handle the imaginary part (e.g., discard it) and return the resulting floating-point array."
    },
    {
        "instruction": "Implement a function that compares two numerical arrays element-wise for approximate equality. The function should accept the two arrays and a tolerance value. Return `True` if the absolute difference between corresponding elements is always less than or equal to the tolerance, `False` otherwise. Handle potential differences in the input arrays' data types."
    },
    {
        "instruction": "Create a function that generates a 2D array of a specified shape (M rows, N columns) filled with random numerical values of a given floating-point or complex data type."
    },
    {
        "instruction": "Write a function that takes a numerical array (of any dimension) and a target numerical data type identifier (e.g., 'float32', 'complex64'). It should return a new array with the same shape and values, but with each element cast to the target data type."
    },
    {
        "instruction": "Create a function that accepts a numerical array `arr`, a minimum value `min_val`, and a maximum value `max_val`. It should return a new array of the same shape where each element is clamped between `min_val` and `max_val`. Handle cases where `min_val` or `max_val` might be single numbers or arrays of the same shape as `arr`."
    },
    {
        "instruction": "Implement a function that takes two numerical arrays of the same shape, `arr1` and `arr2`, and returns a new array of the same shape containing the element-wise maximum of the two input arrays."
    },
    {
        "instruction": "Write a function that takes a numerical array `arr`, a lower bound `low`, and an upper bound `high`. Return a new array of the same shape containing boolean values, where an element is `True` if the corresponding element in `arr` is strictly between `low` and `high`, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes a shape tuple (e.g., `()`, `(2, 3)`) and a numerical data type specification. It should generate and return three numerical arrays of the specified shape and type: `data`, `lower_bound`, `upper_bound`, ensuring that for every element index `i`, `lower_bound[i] <= data[i] <= upper_bound[i]`."
    },
    {
        "instruction": "Develop a function that takes a base shape (tuple), a dimension index, and a list of sizes for that dimension. First, generate a list of shapes by varying the size at the specified dimension according to the list of sizes. Then, create placeholder numerical arrays (e.g., filled with zeros) for each generated shape. Finally, concatenate these arrays along the specified dimension and return the resulting array."
    },
    {
        "instruction": "Write a function that takes a base shape (tuple of integers), a dimension index (integer), and a list of sizes (list of integers). It should return a list of new shapes, where each new shape is derived from the base shape by replacing the size at the given dimension index with a size from the list."
    },
    {
        "instruction": "Create a function that takes a list of numerical arrays and an axis index. Verify if all arrays in the list are suitable for joining along the given axis (i.e., all dimensions except the specified axis match). Return `True` if compatible, `False` otherwise."
    },
    {
        "instruction": "Write a function `check_sensitivity` that takes three arguments: `func` (a function that operates on a list of numerical arrays and returns a single numerical array), `inputs` (a list of numerical input arrays), and `input_idx` (the index of the input array to test). The function should slightly perturb a single element in `inputs[input_idx]`, call `func` with the perturbed inputs, and return the difference between the sum of elements in the original output and the sum of elements in the perturbed output. This measures the output's sensitivity to a small change in one input."
    },
    {
        "instruction": "Write a function that takes a shape tuple (e.g., `()`, `(2, 3)`) and returns a new numerical array of that shape filled entirely with zeros. Ensure it correctly handles the scalar case represented by an empty tuple `()`."
    },
    {
        "instruction": "Create a function `check_broadcast_compatibility(shape1, shape2)` that takes two shape tuples. Return `True` if an array with `shape1` can be broadcast to `shape2` using standard rules (aligning right, dimensions must match or one must be 1), and `False` otherwise."
    },
    {
        "instruction": "Implement a function `broadcast_array(input_array, target_shape)` that expands a given numerical `input_array` to match the `target_shape` according to standard array broadcasting rules (dimensions match, one is 1, or dimension missing from input). Return the resulting broadcasted array."
    },
    {
        "instruction": "Implement a function `compute_broadcast_contribution(original_shape, broadcasted_shape)`. Given an `original_shape` and the `broadcasted_shape` it was expanded to, return an array matching the `original_shape`. Each element in the output array should represent the total number of elements in the `broadcasted_shape` array that originated from (or map back to) the corresponding element in the `original_shape` array."
    },
    {
        "instruction": "Write a function that takes a single numerical scalar value and a target shape (represented as a list or tuple of positive integers). Return a new numerical array filled with the scalar value, having the specified target shape."
    },
    {
        "instruction": "Develop a function that takes an input numerical array, a target output shape (list/tuple of integers), and a mapping (list/tuple of integers) indicating which output dimension corresponds to each input dimension. Return a new array with the target shape, where the input array's data is replicated across the dimensions not specified in the mapping. Ensure the mapping is valid for the given shapes."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array of size M and broadcasts it into a 2D array of shape (M, N). The original 1D array should align with the first dimension (rows) of the output 2D array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array of size N and broadcasts it into a 2D array of shape (M, N). The original 1D array should align with the second dimension (columns) of the output 2D array."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and a target shape tuple. It should return a new array containing the same elements but rearranged into the target shape. Assume the total number of elements is compatible."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array, a target shape tuple, and a dimension permutation tuple. It should first logically reorder the dimensions of the input array according to the permutation, and then reshape the result into the target shape. Return the new array. Assume shapes and permutation are valid and compatible."
    },
    {
        "instruction": "Create a function that accepts a shape tuple (e.g., (2, 3, 4)) representing array dimensions and returns the total number of elements defined by that shape (e.g., 2*3*4 = 24)."
    },
    {
        "instruction": "Develop a function that validates parameters for a permuted reshape. It takes an input shape tuple, a target shape tuple, and an optional dimension permutation tuple. Return `True` if the total element count matches AND if the permutation tuple (if provided) is a valid permutation of the input dimensions (correct length, contains all indices 0 to N-1 exactly once), `False` otherwise."
    },
    {
        "instruction": "Create a function to pad a 2D numerical array (matrix). Input includes the matrix, a list of two tuples `[(pad_before_dim0, pad_after_dim0), (pad_before_dim1, pad_after_dim1)]` containing non-negative integers, and a scalar padding value. Return the padded 2D array."
    },
    {
        "instruction": "Implement a function that adds interior padding to a 1D numerical array. It accepts the array, a non-negative integer specifying the number of padding elements to insert between each original element, and a scalar padding value. Return the new 1D array with interior padding."
    },
    {
        "instruction": "Write a function that pads a 1D numerical array. It takes the array, two non-negative integers (padding before, padding after), and a scalar padding value. Return a new 1D array with the specified padding applied at the beginning and end using the given value."
    },
    {
        "instruction": "Extend the multi-dimensional padding function (similar to Task 4) to handle potentially *negative* `pad_low` and `pad_high` values in the configuration tuples `(pad_low, pad_high, pad_interior)`. Negative values indicate cropping the array from the respective ends of that dimension *before* applying any non-negative interior padding. Accept the array, the configuration, and a scalar padding value. Return the modified array."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) and returns a new matrix where the order of rows is reversed. Example: Input `[[1, 2], [3, 4]]`, Output `[[3, 4], [1, 2]]`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array with the elements in reverse order. Example: Input `[10, 20, 30]`, Output `[30, 20, 10]`."
    },
    {
        "instruction": "Develop a function that accepts a 2D numerical array (matrix) and reverses the order of *both* its rows and columns. Example: Input `[[1, 2], [3, 4]]`, Output `[[4, 3], [2, 1]]`."
    },
    {
        "instruction": "Write a function that takes an N-dimensional numerical array and a list of dimension indices (e.g., `[0]`, `[0, 1]`). It should return a new array of the same shape where the order of elements along each specified dimension index is reversed independently."
    },
    {
        "instruction": "Implement a function `scalar_select(condition, value_if_true, value_if_false)` that takes a single boolean `condition` and two numerical scalars. It should return `value_if_true` if `condition` is true, and `value_if_false` otherwise."
    },
    {
        "instruction": "Write a function `array_select(predicate_array, array_if_true, array_if_false)` where all inputs are numerical arrays of the exact same shape, and `predicate_array` contains boolean-like values (e.g., 0s and 1s, or true/false). Return a new array where elements are chosen from `array_if_true` or `array_if_false` based on the corresponding element in `predicate_array`."
    },
    {
        "instruction": "Create a function `choose_array(condition, array_a, array_b)` that takes a single boolean `condition` and two numerical arrays `array_a` and `array_b` (guaranteed to have the same shape and data type). Return `array_a` if `condition` is true, otherwise return `array_b`."
    },
    {
        "instruction": "Develop a function `broadcast_select(predicate, array_if_true, array_if_false)` that takes a boolean `predicate` (which can be a scalar or an array) and two numerical arrays `array_if_true`, `array_if_false` (which have the same shape and data type). The `predicate` shape must be broadcastable to the shape of the other arrays according to standard broadcasting rules. Return a new array resulting from an element-wise selection based on the (potentially broadcasted) `predicate`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array, a start index, and an end index (exclusive). It should return a new 1D array containing the elements from the start index up to (but not including) the end index. Handle potential edge cases like empty slices."
    },
    {
        "instruction": "Create a function that extracts a rectangular sub-region from a 2D numerical array (matrix). It should accept the input matrix, starting row/column indices (inclusive), and ending row/column indices (exclusive). Return the extracted 2D sub-array."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array and extracts elements using a start index, an end index (exclusive), and a step (stride). Return a new 1D array containing the selected elements. Ensure it works correctly for positive strides."
    },
    {
        "instruction": "Write a function that calculates the shape of the output array resulting from a slicing operation. The function should take the input array's shape (tuple), start indices (tuple), limit indices (tuple), and strides (tuple) as arguments and return the shape (tuple) of the sliced array."
    },
    {
        "instruction": "Generalize the slicing function to work with multi-dimensional numerical arrays of any rank (1D, 2D, 3D, etc.). Inputs: the multi-dimensional array, a tuple `start_indices` (one index per dimension), and a tuple `slice_sizes` (one size per dimension). Output: the extracted multi-dimensional sub-array."
    },
    {
        "instruction": "Write a function that creates a multi-dimensional array of a given shape, filled with random floating-point numbers. Input: a tuple representing the desired shape. Output: the generated multi-dimensional array."
    },
    {
        "instruction": "Create a function that validates slice parameters against an array's shape. It should accept the array's shape (tuple), the starting indices for the slice (tuple), and the size of the slice (tuple). Return True if `start_indices[i] + slice_sizes[i] <= array_shape[i]` for all dimensions `i`, and False otherwise."
    },
    {
        "instruction": "Implement a function to extract a rectangular sub-array (slice) from a given 2D numerical array. Inputs: the 2D array, a tuple `(start_row, start_col)` for the top-left corner of the slice, and a tuple `(slice_height, slice_width)` for the dimensions of the slice. Output: the extracted 2D sub-array."
    },
    {
        "instruction": "Write a function that takes the shape of a multi-dimensional array (e.g., `(7, 5, 3)`), a tuple of starting indices (e.g., `(4, 1, 0)`), and the shape of an update array (e.g., `(2, 3, 1)`). Return a tuple representing the ending indices (exclusive) for the slice defined by the start indices and update shape. For example, inputs `(7, 5, 3)`, `(4, 1, 0)`, `(2, 3, 1)` should return `(6, 4, 1)`."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array, a starting index (integer), and a smaller 1D numerical array (update). Return a *new* 1D array which is a copy of the original, but with the elements starting at the given index replaced by the update array. Assume the update fits within the original array's bounds."
    },
    {
        "instruction": "Write a function that validates parameters for an array slice update. It takes the shape of the main array (tuple of dimensions), the shape of the update array (tuple of dimensions), and the starting indices (tuple of integers). Return `True` if the update slice fits entirely within the main array boundaries starting from the given indices, and `False` otherwise. Ensure the number of dimensions matches for all inputs."
    },
    {
        "instruction": "Develop a function that takes a multi-dimensional numerical array, a tuple of starting indices (one index per dimension), and an update array of the same rank but potentially smaller dimensions. Return a *new* array which is a copy of the original, but with the slice specified by the start indices and the update array's shape replaced by the update array. Handle arrays of arbitrary dimensions (e.g., 1D, 2D, 3D)."
    },
    {
        "instruction": "Write a function that creates a multi-dimensional numerical array filled with random floating-point values, given a shape tuple (e.g., (3, 4) or (3, 4, 5)). Return the created array."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and a list of dimension permutation tuples. For each permutation tuple in the list, it should transpose the original array according to that permutation. Return a list containing all the resulting transposed arrays. Ensure the function handles permutations appropriate for the input array's dimensionality."
    },
    {
        "instruction": "Create a function that rearranges the dimensions of a multi-dimensional numerical array based on a given permutation tuple. For an input array with N dimensions and a permutation tuple `p` of length N, the i-th dimension of the output should correspond to the `p[i]`-th dimension of the input."
    },
    {
        "instruction": "Implement a function that specifically swaps the first two dimensions of a 2D numerical array (matrix). Input shape (M, N) should result in output shape (N, M)."
    },
    {
        "instruction": "Implement a function to find the maximum element along specified dimensions of a numerical array, starting the comparison with a given initial value. The function accepts the array, the initial value, and the dimensions to reduce. Return the array containing the maximum values."
    },
    {
        "instruction": "Create a function that calculates the product of elements across specified axes of a multi-dimensional numerical array. It receives the array, an initial value for the product, and the axes for reduction. Return the resulting array."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array, an initial value, and a tuple of dimensions. It should compute the maximum reduction along the specified dimensions using the initial value. Then, determine if increasing a single element (at given indices) in the input array by a small positive value 'epsilon' would change the resulting maximum value(s). Return True if the result changes, False otherwise."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and a tuple of dimensions. It should compute the sum reduction along the specified dimensions. Then, determine how much the sum changes if a single element (at given indices) in the input array is increased by a small value 'epsilon'. Return this change in sum."
    },
    {
        "instruction": "Create a function that takes two 1D numerical arrays of the same length, `arr_A` and `arr_B`. Compute the sum of all elements in `arr_A` (starting from 0) and the product of all elements in `arr_B` (starting from 1). Return the results as a pair `(sum_A, product_B)`."
    },
    {
        "instruction": "Write a function that takes two pairs of numbers, `pair1 = (a, b)` and `pair2 = (c, d)`, and returns a new pair where the first element is the sum of the first elements (`a+c`) and the second element is the product of the second elements (`b*d`)."
    },
    {
        "instruction": "Write a function that accepts a tuple representing a desired shape (e.g., `(3, 4, 5)`) and returns two distinct multi-dimensional numerical arrays, both having exactly that shape and filled with arbitrary floating-point values."
    },
    {
        "instruction": "Develop a function that performs a custom reduction on two input multi-dimensional numerical arrays (`array1`, `array2`) of identical shape along a specified set of dimensions. Use an initial state of `(0, 1)`. For each step combining an accumulated pair `(acc_sum, acc_prod)` with an input pair `(elem1, elem2)` from corresponding positions in the arrays, the new state should be `(acc_sum + elem1, acc_prod * elem2)`. The function should return the final pair of reduced arrays after iterating through the specified dimensions."
    },
    {
        "instruction": "Write a function that computes a moving sum over a 1D numerical array. It should accept the array, a window size, and a stride step. Return the resulting 1D array."
    },
    {
        "instruction": "Create a function to apply a reduction operation (e.g., maximum) over sliding windows on a 2D numerical array using \"VALID\" padding. Inputs are the 2D array, window dimensions (height, width), and strides (vertical, horizontal). Return the reduced 2D array."
    },
    {
        "instruction": "Develop a function that performs a generalized sliding window reduction on an N-dimensional numerical array. It should take the array, window dimensions, strides, a reduction function (like sum, max, min), and an initial value for the reduction. Return the N-dimensional reduced array."
    },
    {
        "instruction": "Implement a function to apply a reduction operation (e.g., minimum) over sliding windows on a 2D numerical array using \"SAME\" padding. Inputs are the 2D array, window dimensions (height, width), and strides (vertical, horizontal). Return the reduced 2D array, ensuring output dimensions match input dimensions when strides are 1."
    },
    {
        "instruction": "Develop a function that computes the cumulative sum of a 1D numerical array, with an option to perform the summation in reverse order. Input: a 1D array and a boolean flag 'reverse'. Output: a 1D array containing the cumulative sum (forward if reverse=False, backward if reverse=True)."
    },
    {
        "instruction": "Implement a function to calculate the cumulative product of elements in a 1D numerical array. Input: a 1D array of numbers. Output: a 1D array of the same size containing the cumulative products."
    },
    {
        "instruction": "Write a function that computes the cumulative sum of a 1D numerical array. Input: a 1D array of numbers. Output: a 1D array of the same size containing the cumulative sums."
    },
    {
        "instruction": "Write a function to compute the cumulative product along a specified axis of a multi-dimensional numerical array, supporting both forward and reverse calculation. Input: an N-dimensional array, an integer axis index, and a boolean 'reverse' flag. Output: an N-dimensional array of the same shape containing the cumulative products along the specified axis, respecting the reverse flag."
    },
    {
        "instruction": "Implement a *stable* sorting function for a 1D numerical array containing potentially duplicate values. Equal elements must retain their original relative order. Input: 1D array. Output: Stably sorted 1D array."
    },
    {
        "instruction": "Given a 3D numerical array, sort the elements along the last dimension for each \"slice\" defined by the first two dimensions. Input: 3D array (Depth, Height, Width). Output: 3D array sorted along the Width dimension."
    },
    {
        "instruction": "Create a function that sorts a 2D numerical array (matrix) along a specified dimension (0 for columns, 1 for rows). Input: 2D array, dimension index. Output: 2D array sorted along the specified dimension."
    },
    {
        "instruction": "Write a function that sorts a 1D numerical array in ascending order. Input: 1D array. Output: Sorted 1D array."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix) and an integer `k`. For each row, find the `k` largest values. Return a new 2D array where each row contains these `k` largest values from the corresponding input row, sorted descendingly."
    },
    {
        "instruction": "Develop a function that receives a numerical array (potentially multi-dimensional) and an integer `k`. It should return a boolean array of the same shape, where `True` indicates the element is among the top `k` largest values in the *entire* flattened array, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and an integer `k`. It should return a new 1D array containing the `k` largest values from the input, sorted in descending order."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns the single largest value within it."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array, a 1D array of integer indices, and an integer representing an axis. It should return a new array formed by selecting elements along the specified axis using the provided indices, keeping other dimensions intact."
    },
    {
        "instruction": "Create a function that takes an integer representing the size of an array dimension and a 1D array of integer indices. It should return `True` if all provided indices (considering positive and negative indexing rules) are valid for accessing elements within that dimension size, and `False` otherwise."
    },
    {
        "instruction": "Develop a function similar to Task 2, but ensure it correctly handles negative indices within the 1D index array (e.g., -1 refers to the last element along the specified axis)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a 1D array of integer indices. It should return a new 1D array containing the elements of the input array at the specified indices."
    },
    {
        "instruction": "Simple 1D Array Gathering (Fill Mode): Create a function that takes a 1D numerical array `data`, a 1D integer array `indices`, and a numerical `fill_value`. It should return a new 1D array where each element corresponds to `data[i]` if index `i` from `indices` is within the bounds of `data`, otherwise the element should be `fill_value`."
    },
    {
        "instruction": "Multi-axis Array Element Selection: Write a function that takes a 2D numerical array `data` (shape M x N) and a 2D integer array `indices` (shape K x 2). Each row `[r, c]` in `indices` specifies the row and column of an element to select from `data`. Return a 1D array of length K containing the selected elements `data[r, c]`. Implement bounds checking: if an index `[r, c]` is out of bounds for `data`, use a default fill value (e.g., 0) for that position in the output array."
    },
    {
        "instruction": "Bounded Random Integer Array Generation: Develop a function that generates a 1D integer array of a specified size. The function should accept `low` and `high` bounds (inclusive `low`, exclusive `high`) and fill the array with random integers within this range."
    },
    {
        "instruction": "Simple 1D Array Gathering (Clip Mode): Create a function that takes a 1D numerical array `data` and a 1D integer array `indices`. It should return a new 1D array where each element corresponds to `data[i]` for each index `i` in `indices`. Handle out-of-bounds indices by clipping them to the valid range of `data`'s indices before access."
    },
    {
        "instruction": "Write a function that creates and returns a new multi-dimensional numerical array of a given shape, initialized with random floating-point values within the range [0.0, 1.0)."
    },
    {
        "instruction": "Create a function that performs index clipping. It accepts an array of integer indices and a maximum valid index value. It should return a new array of the same shape where any index less than 0 is replaced by 0, and any index greater than the maximum valid index is replaced by that maximum value."
    },
    {
        "instruction": "Implement a function for a basic 1D scatter-add operation. It takes three 1D numerical arrays: `data`, `indices`, and `updates`. For each element `i`, it should add `updates[i]` to the element `data[indices[i]]`. Assume `indices` contains valid indices within the bounds of `data`, and `indices` and `updates` have the same length. The function should return a modified copy of `data`."
    },
    {
        "instruction": "Develop a function that performs a scatter-add operation on a target array. It takes a target numerical array `operand`, an `indices` array specifying coordinates within the `operand`, and an `updates` array. For each index coordinate in `indices`, the corresponding value (or slice) from `updates` is added to the value (or slice) at that position in the `operand`. Specify how `indices` map to `operand` dimensions (e.g., each row of `indices` is a coordinate tuple for the first dimension) and how `updates` correspond to `indices` (e.g., `updates[i]` is added at `operand[indices[i]]`). Handle potential duplicate indices by summing updates. Return the modified `operand`."
    },
    {
        "instruction": "Write a function that generates a specified number (`N`) of unique random coordinate tuples valid for a given array shape (e.g., `(50, 20)`). The function should take the shape tuple and `N` as input and return a list containing `N` unique coordinate tuples, where each coordinate is a valid index for the given shape."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional array's shape (e.g., a tuple like `(10, 5)`) and a list of index tuples (e.g., `[(0, 1), (9, 4), (5, 0)]`). Return `True` if all index tuples represent valid coordinates within the bounds defined by the shape, and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array (operand), a 1D array of integer indices, and a 1D array of update values (same length as indices). It should return a *new* 1D array where the elements of the operand at the specified indices are replaced by the corresponding update values. If an index appears multiple times, the last corresponding update value should be used."
    },
    {
        "instruction": "Implement a function that updates slices of a 2D numerical array (matrix). It should accept the original matrix, a 1D array of row indices, and a 2D array containing the update rows. The number of rows in the update array must match the number of indices provided. Return a *new* matrix where the rows specified by the indices in the original matrix are replaced by the corresponding rows from the update array."
    },
    {
        "instruction": "Implement a function that takes a square 2D numerical array (matrix) and a 1D numerical array (vector) of the same dimension `n`. It should return a *new* matrix identical to the input matrix, except that its main diagonal elements are replaced by the elements of the input vector."
    },
    {
        "instruction": "Write a function that takes a positive integer `n` and returns a 1D numerical array containing the integers from 0 up to (but not including) `n`."
    },
    {
        "instruction": "Create a function that accepts a square 2D numerical array (matrix) and returns a 1D array containing its main diagonal elements."
    },
    {
        "instruction": "Write a function that takes the dimension `n` of a square matrix as input. It should return a 2D numerical array of shape `(n, n)` where all diagonal elements are 0.0 and all off-diagonal elements are 1.0. This represents a mask indicating which input elements directly influence corresponding output elements in a diagonal overwrite operation."
    },
    {
        "instruction": "Write a function that generates a 1D array of random integers. It should take the desired array size and an upper bound (exclusive) as input. Each integer in the output array should be between 0 (inclusive) and the upper bound (exclusive)."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size and returns a new array where each element is the maximum of the corresponding elements from the input arrays."
    },
    {
        "instruction": "Develop a function to perform a generalized 'scatter max' operation on a target multi-dimensional numerical array. It takes the target array, an index array specifying coordinates, and an update array. It also requires configuration parameters defining: (a) which dimensions of the update array correspond to slices being written, (b) which dimensions of the target array the indices refer to, and (c) which dimensions of the target array correspond to the update slices. For each specified location, update the target value with the maximum of its current value and the corresponding update value. Return the modified target array."
    },
    {
        "instruction": "Create a function that takes a multi-dimensional numerical array and an array of indices. It should return a new array containing the values from the input array at the specified indices. The structure of the index array determines how elements are selected."
    },
    {
        "instruction": "Write a function to generate a 2D integer array representing scatter indices. The function should accept the number of index entries `k`, the number of dimensions for each index `d` (e.g., `d=1` for 1D indexing), and a list or tuple `highs` of length `d` specifying the exclusive upper bound for the random index in each dimension. Return a `k x d` array where each element `[r, c]` is a random integer `0 <= value < highs[c]`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array, a list of integer indices, and a list of corresponding numerical update values. It should return a *new* 1D array where the elements at the specified indices are replaced by the update values. Assume index list and value list have the same length, and indices are valid."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array `operand`, a 1D array of integer indices `scatter_indices`, and a 1D numerical array `updates`. It should return a *new* array of the same size as `operand`, where for each `i`, the value `updates[i]` is placed at index `scatter_indices[i]` in the new array. For simplicity in this task, assume there are no duplicate indices in `scatter_indices`."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array `operand`, a 1D array of integer indices `scatter_indices`, and a 1D numerical array `updates`. Return a *new* array based on `operand` where for each `i`, the element at `operand[scatter_indices[i]]` is updated by taking the minimum of its current value and `updates[i]`. Ensure correct handling of potential duplicate indices (the final value should be the minimum of the original value and all updates corresponding to that index)."
    },
    {
        "instruction": "Develop a function that takes two numerical arrays, `dividend` and `divisor`. It should check if any element in the `divisor` array is zero. Return `True` if all elements are non-zero, and `False` otherwise."
    },
    {
        "instruction": "Write a function to compute the finite difference approximation of the partial derivative of the element-wise remainder operation (`a % b`) with respect to `a`. The function should accept two numerical arrays `a` and `b` (assume `b` has no zeros) and a small positive number `h`. Return a new array containing the element-wise result of `((a + h) % b - (a % b)) / h`."
    },
    {
        "instruction": "Write a function that takes a shape tuple (e.g., (rows, cols)) and returns a numerical array of that shape. Each element should be a random floating-point number chosen uniformly from either the range [-5.0, -0.1] or [0.1, 5.0]."
    },
    {
        "instruction": "Create a function that accepts a shape tuple and generates a numerical array of that shape filled with random floating-point numbers uniformly distributed in the interval [-9.0, 9.0]."
    },
    {
        "instruction": "Create a function that calculates and returns the sum of all elements in a given multi-dimensional numerical array as a single scalar value."
    },
    {
        "instruction": "Develop a function that simulates precision reduction. It takes a numerical array and a target low-precision floating-point type (e.g., representing 16-bit float) as input. It should convert the input array's elements to the target type and then back to a standard precision float type (e.g., 32-bit float), returning the modified array."
    },
    {
        "instruction": "Write a function that creates a multi-dimensional numerical array filled with random floating-point numbers uniformly distributed between -1.0 and 1.0. The function should accept the desired shape (as a tuple of integers) and return the generated array."
    },
    {
        "instruction": "Write a function that computes both a primary output array and two auxiliary arrays representing the sensitivity of the sum of the primary output with respect to the two input arrays. The primary computation involves a generalized dot product between the two input numerical arrays based on dimension configuration. Return the primary output array and the two sensitivity arrays."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array. It should apply the hyperbolic tangent function (tanh) to each element and then return the sum of all elements in the resulting array."
    },
    {
        "instruction": "Implement a function that simulates simple data scaling. It takes a numerical array and a positive scalar `scale_factor`. The function should divide the array elements by the `scale_factor`, potentially round or truncate the result to simulate reduced precision (e.g., round to nearest integer, then convert back to float), and then multiply by the `scale_factor`. Return the modified array."
    },
    {
        "instruction": "Write a function that computes the gradient of a specific dot product operation with respect to one of its inputs. Given three 3D numerical arrays: `A` (shape `B, M, K`), `B` (shape `B, N, K`), and `dY` (shape `B, M, N`), where `dY` represents the gradient of some final loss with respect to the output `Y` of the dot product `Y = dot_general(A, B, contracting_dims=([2],[2]), batch_dims=([0],[0]))`. Calculate and return the gradient with respect to input `A` (`dA`), which should have the same shape as `A`. You'll need the rule: `dA = dot_general(dY, B_transposed, contracting_dims=([2],[1]), batch_dims=([0],[0]))` where `B_transposed` has shape `(B, K, N)`."
    },
    {
        "instruction": "Develop a function that takes two 3D numerical arrays, `A` (shape `B, M, K`) and `B` (shape `B, N, K`). It first computes their generalized dot product (contracting `K`, batching `B` to get shape `B, M, N`), then applies the element-wise hyperbolic tangent (tanh) to the result, and finally returns the sum of all elements in the tanh-transformed array as a single scalar value."
    },
    {
        "instruction": "Create a function `vectorize(func, A, B, axis_A, axis_B, axis_out)`. It applies the function `func` (which takes two array arguments) element-wise along the specified `axis_A` of `A` and `axis_B` of `B`. The results should be stacked along `axis_out` in the output array. Assume `func` operates on slices of `A` and `B`. Return the combined result."
    },
    {
        "instruction": "Implement `compute_value_and_gradient(func, A, B)`. `func` is a function that takes two numerical arrays (`A`, `B`) and returns a scalar. Your function should execute `func(A, B)` to get the scalar value, and also compute the gradient arrays representing how the output scalar changes with respect to each element in `A` and `B`. Return the scalar value and the two gradient arrays (shapes matching `A` and `B`)."
    },
    {
        "instruction": "Write a function `sum_all_elements(tensor)` that takes a multi-dimensional numerical array and returns a single scalar value representing the sum of all its elements."
    },
    {
        "instruction": "Implement `generalized_dot_product(A, B, contract_dims_A, contract_dims_B, batch_dims_A, batch_dims_B)`. It takes two numerical arrays `A`, `B` and lists of dimension indices. It performs a dot product by contracting specified dimensions (`contract_dims_A` with `contract_dims_B`) while treating specified dimensions as batch dimensions (`batch_dims_A`, `batch_dims_B`). Return the resulting array."
    },
    {
        "instruction": "Develop a function that takes two numerical arrays (tensors) of the same shape and two floating-point numbers representing relative tolerance (`rtol`) and absolute tolerance (`atol`). The function should return `True` if all corresponding elements of the two arrays are close within the given tolerances (using the check `absolute(a - b) <= (atol + rtol * absolute(b))`), and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a 3D numerical array (tensor) with shape (B, M, K) and a 2D array of scaling factors with shape (B, M). The function should scale each K-dimensional vector `tensor[i, j, :]` by the corresponding scaling factor `scales[i, j]`. Return the resulting scaled 3D array."
    },
    {
        "instruction": "Write a function that simulates a scaled matrix multiplication. It accepts two 3D numerical arrays, A (shape B, M, K) and B (shape B, N, K), and two corresponding scaling factor arrays, `scale_A` (shape B, M) and `scale_B` (shape B, N). First, create scaled versions where each vector `A[i, m, :]` is multiplied by `scale_A[i, m]` and each vector `B[i, n, :]` is multiplied by `scale_B[i, n]`. Then, compute the batched matrix product C (shape B, M, N) using these scaled arrays according to the pattern `BMK, BNK -> BMN`. Return the final array C."
    },
    {
        "instruction": "Write a function that takes three positive integers B, M, N representing batch size, rows of the first matrix, and rows of the second matrix (which becomes columns of the output). Return the expected shape tuple (B, M, N) resulting from a batched matrix multiplication following the pattern `BMK * BNK -> BMN`."
    },
    {
        "instruction": "Write a function that compares two numerical arrays (potentially multi-dimensional) for approximate equality. It should take the two arrays and relative (`rtol`) and absolute (`atol`) tolerance values as input, returning `True` if all element-wise differences satisfy `abs(a - b) <= atol + rtol * abs(b)`, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that performs scaled batch matrix multiplication. It accepts two 3D numerical arrays, A (Batch, M, K) and B (Batch, K, N), and two corresponding scalar scale factors, `scale_a` and `scale_b`. The function should compute and return the batch matrix product C (Batch, M, N), where C[i] = (A[i] * scale_a) @ (B[i] * scale_b)."
    },
    {
        "instruction": "Develop a function that takes two 2D numerical arrays (matrices) A (shape M x K) and B (shape K x N) and returns their standard matrix product C (shape M x N)."
    },
    {
        "instruction": "Create a function that takes a 3D numerical array `C` (shape B x M x N) and a 1D array of scaling factors `s` (shape B). Return a new 3D array where each matrix `C[i]` is multiplied element-wise by the corresponding scalar `s[i]`."
    },
    {
        "instruction": "Write a function that checks if the execution environment meets specific criteria: a required hardware type (string) and a minimum number of available units (integer). It should return `True` if criteria are met, `False` otherwise."
    },
    {
        "instruction": "Implement a function that accepts a list of strings. It should construct and return a regular expression *pattern string* that matches these strings in the given order, allowing any characters (including newlines) between them. Ensure any special regular expression characters within the input strings are properly escaped."
    },
    {
        "instruction": "Write a function that takes a text string and a list of sequential string fragments. The function should determine if all fragments appear within the text string *in the specified order*, separated by any number of arbitrary characters (including newlines). Return `True` if the ordered sequence is found, `False` otherwise. Ensure the check correctly handles any special regular expression characters within the fragments."
    },
    {
        "instruction": "Create a function that takes a configuration map (dictionary) where keys are strings and values are lists of strings, and a specific key string. Return the first string from the list associated with the given key. Handle potential errors like the key not being found or the list being empty."
    },
    {
        "instruction": "Write a function that accepts a non-negative integer `n` and returns a sequence containing integers from 0 up to (but not including) `n`."
    },
    {
        "instruction": "Implement a function that takes a non-negative integer `n` and calculates the sum of all integers from 0 up to (but not including) `n`."
    },
    {
        "instruction": "Develop a function that takes a non-negative integer `n`, calculates the sum of integers from 0 to `n-1`, and ensures the final result is returned specifically as a 32-bit integer."
    },
    {
        "instruction": "Write a function that calculates the arithmetic mean (average) of the integers from 0 up to (but not including) a given positive integer `n`. Return the result as a floating-point number."
    },
    {
        "instruction": "Implement a function to compute the conjugate transpose of a 2D numerical array (matrix). If the input matrix has dimensions M x N and contains complex numbers, the output should be N x M, where each element `(i, j)` is the complex conjugate of the input element `(j, i)`."
    },
    {
        "instruction": "Write a function that accepts a square 2D numerical array (matrix) potentially containing complex numbers. Return a new matrix representing the Hermitian part, calculated as `(Matrix + ConjugateTranspose(Matrix)) / 2`."
    },
    {
        "instruction": "Given two square Hermitian matrices `A1` and `A2` (where `A2` represents a slightly perturbed version of `A1`), and their corresponding real eigenvalues `w1` and `w2` (assumed to be sorted), write a function to verify the stability of eigenvalues. Return `True` if the maximum absolute difference between corresponding elements of `w1` and `w2` is less than a predefined small tolerance (e.g., 0.01), `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a square 2D numerical array and a string parameter ('lower' or 'upper'). Return a new 2D array containing only the specified triangle (including the main diagonal) of the input matrix, with zeros in the other triangle."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and returns `True` if the array has zero elements (i.e., at least one dimension is of size 0), and `False` otherwise."
    },
    {
        "instruction": "Implement a function to calculate the Frobenius norm for a given 2D numerical array (matrix). This norm is defined as the square root of the sum of the squares of the absolute values of all elements. Ensure it works for arrays containing real or complex numbers."
    },
    {
        "instruction": "Design a function that computes the norm of a 2D numerical array based on a provided type string (e.g., 'frobenius', 'max_row_sum'). Crucially, if the input array has a dimension of size zero, the function must return 0.0, regardless of the specified norm type."
    },
    {
        "instruction": "Develop a function that calculates a matrix norm related to its singular values (like the largest singular value or the sum of singular values). The function should accept a 2D numerical array (real or complex) and return a non-negative scalar result. Ensure correct handling (return 0.0) for matrices with a zero dimension."
    },
    {
        "instruction": "Develop a function that finds the infinity norm (maximum absolute value among elements) for a non-empty 1D numerical array (vector). The input is guaranteed to have at least one element."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array (vector) and an order parameter (1, 2, or infinity). The function must return 0.0 if the input array is empty (contains zero elements), regardless of the order parameter."
    },
    {
        "instruction": "Create a function that calculates the Euclidean (L2) norm for a non-empty 1D numerical array (vector). The input is guaranteed to have at least one element."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (vector) which can be empty or non-empty, and an order parameter (1, 2, or infinity). It should return the calculated norm according to the order if the vector is non-empty, and 0.0 if the vector is empty."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) which may contain complex numbers, and returns its conjugate transpose (Hermitian transpose). Input shape (M, N) should result in output shape (N, M)."
    },
    {
        "instruction": "Design a function that compares two 2D numerical arrays, Q1 and Q2, assumed to be orthogonal/unitary matrices of the same shape (M, K). Return `True` if they are equivalent up to column-wise phase differences (i.e., Q1 is close to Q2 multiplied by a diagonal matrix of phase factors) within a given tolerance, `False` otherwise. Use a suitable matrix norm for comparison."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `Q` (potentially complex-valued) and a small tolerance value `tol`. Calculate the product of the conjugate transpose of `Q` and `Q`. Return `True` if the Frobenius norm of the difference between this product and the identity matrix of the appropriate size is less than `tol`, otherwise return `False`."
    },
    {
        "instruction": "Write a function that performs batched matrix multiplication. It should accept two 3D numerical arrays, A (shape BxMxN) and B (shape BxNxP), where B is the batch size. The function should return a 3D array C (shape BxMxP) where each C[i, :, :] is the result of multiplying A[i, :, :] and B[i, :, :]."
    },
    {
        "instruction": "Write a function that attempts a simplified LU decomposition step for a 2x2 matrix `[[a, b], [c, d]]` without pivoting. If the element `a` is zero, return a predefined value or signal indicating failure (e.g., return `None`). Otherwise, calculate the multiplier `m = c / a` and the updated bottom-right element `d_new = d - m * b`, then return the resulting upper triangular structure `[[a, b], [0, d_new]]`."
    },
    {
        "instruction": "Create a function that accepts two 2D numerical arrays (matrices) with identical dimensions. The function should return `True` if all corresponding elements in the two matrices are equal, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array (matrix) of shape (`rows`, `cols`) filled entirely with zeros."
    },
    {
        "instruction": "Implement a function that checks if a given 2D numerical array (matrix) consists entirely of zeros. It should take the matrix as input and return `True` if all its elements are zero, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes two square matrices of the same size (`n x n`) and data type (float or complex) as input. It should return `True` if the two matrices are element-wise equal within a small tolerance (e.g., 1e-5), and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts an integer `n` and a data type specification (e.g., 'float', 'complex') and returns the `n x n` identity matrix (1s on the diagonal, 0s elsewhere) of the specified data type."
    },
    {
        "instruction": "Write a function that takes an integer `n` and a data type specification (e.g., 'float', 'complex') and returns an `n x n` matrix filled entirely with zeros of the specified data type."
    },
    {
        "instruction": "Write a function that accepts a square matrix, which can contain either floating-point or complex numbers. The function should return a new matrix of the same dimensions and data type, representing the element-wise absolute value of the input matrix."
    },
    {
        "instruction": "Create a function that accepts a 3D numerical array representing a batch of matrices (shape B x M x N). For each matrix in the batch, compute the product of the matrix and its transpose. Return a 3D array (shape B x M x M) containing the results for the entire batch."
    },
    {
        "instruction": "Implement a function that takes a square 2D numerical array (matrix S of shape M x M) and returns a new matrix containing only the lower triangular part of S, including the main diagonal. Elements above the main diagonal should be zero."
    },
    {
        "instruction": "Write a function that takes a single 2D numerical array (matrix A of shape M x N) and computes the matrix product of A multiplied by its transpose (A.T). Return the resulting square matrix of shape M x M."
    },
    {
        "instruction": "Develop a function that takes a 3D numerical array (a batch of matrices A, shape B x M x N) and a boolean flag `only_lower`. If `only_lower` is false, compute the product `A @ A.T` for each matrix in the batch and return the full results (shape B x M x M). If `only_lower` is true, compute the same product but return only the lower triangular part (including the diagonal) of each resulting matrix, with elements above the diagonal set to zero (still shape B x M x M)."
    },
    {
        "instruction": "Implement a function that takes a square 2D numerical array (matrix) `A`, potentially complex, and returns a new Hermitian matrix `H` by computing `A + A*`, where `A*` is the conjugate transpose of `A`."
    },
    {
        "instruction": "Write a function to calculate the maximum relative reconstruction error over a potential batch of matrices. It takes two numerical arrays, `original` and `reconstructed`, with shapes `B + (M, N)` where `B` represents optional batch dimensions (can be empty). For each corresponding matrix pair, compute the Frobenius norm of their difference and divide it by the Frobenius norm of the `original` matrix. Return the maximum ratio found across all pairs in the batch. Handle potential division by zero (e.g., return 0 if the original matrix norm is zero)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) which might contain complex numbers. Return `True` if the matrix is unitary (i.e., its conjugate transpose multiplied by the original matrix is close to the identity matrix within a small tolerance), and `False` otherwise."
    },
    {
        "instruction": "Develop a function that computes the singular value decomposition of a given 2D numerical array (matrix) `A` of shape M x N. The function should accept two boolean flags: `full_matrices` and `compute_uv`. If `compute_uv` is `True`, return three arrays (U, S, Vh). If `full_matrices` is `True`, U should have shape M x M and Vh shape N x N. If `full_matrices` is `False`, U should have shape M x K and Vh shape K x N, where K = min(M, N). S is always a 1D array of size K containing singular values. If `compute_uv` is `False`, return only the 1D array S."
    },
    {
        "instruction": "Write a function that checks if a given matrix `VR` (N,N) contains the right eigenvectors corresponding to a given square matrix `A` (N,N) and its eigenvalues `w` (N,). It should compute the matrix product `A @ VR` and compare it to the element-wise product `w * VR` (where `w` might need broadcasting). Return true if the norm of the difference matrix is below a specified tolerance."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix), potentially containing complex numbers, and returns its conjugate transpose (Hermitian transpose). An input shape (M, N) should result in an output shape (N, M)."
    },
    {
        "instruction": "Implement a function to calculate a specific error metric used in eigenvector verification. Input: A 2D numerical array `ErrorMatrix` (N, N), representing the difference (e.g., `A@V - w*V`). Output: A scalar value representing the matrix norm (like Frobenius) of `ErrorMatrix`, normalized by dividing by `(N + 1) * machine_epsilon` (where `N` is the matrix dimension and `machine_epsilon` is the smallest representable number for the data type such that 1.0 + epsilon != 1.0)."
    },
    {
        "instruction": "Write a function that takes a 1D array of numerical values, potentially complex, and returns a new 1D array containing the complex conjugate of each element."
    },
    {
        "instruction": "Develop a function that calculates the L2 norm (Euclidean norm) of a 1D numerical array (vector). Ensure it works correctly for arrays containing complex numbers. Input: `vector` (1D array). Output: A non-negative scalar float."
    },
    {
        "instruction": "Implement a function that takes a batch of square matrices `As` (shape `B, N, N`), a batch of eigenvalue sets `Ws` (shape `B, N`), and a batch of eigenvector sets `Vs` (shape `B, N, N`). Verify that for every matrix `A` in `As`, *all* its corresponding eigenvalue/eigenvector pairs (`lambda` from `Ws`, `v` from `Vs`) satisfy the eigenvalue equation `A @ v = lambda * v` within a given tolerance `tol`. Return `True` if all pairs across the entire batch satisfy the condition, `False` otherwise. Inputs: `As`, `Ws`, `Vs`, `tol`. Output: Boolean."
    },
    {
        "instruction": "Create a function that verifies the eigenvalue equation `A @ v = lambda * v` for a single square matrix `A`, a potential eigenvector `v`, and its corresponding potential eigenvalue `lambda`. Return `True` if the L2 norm of the residual vector `(A @ v) - (lambda * v)` is below a given tolerance `tol`, and `False` otherwise. Handle complex numbers. Inputs: `A` (2D array), `v` (1D array), `lambda` (scalar), `tol` (scalar). Output: Boolean."
    },
    {
        "instruction": "Write a function that generates a batch of `B` random square matrices, each of size `N x N`, with elements of a specified numerical type (e.g., float or complex). Input: batch size `B`, matrix dimension `N`, data type. Output: A 3D numerical array of shape `(B, N, N)`."
    },
    {
        "instruction": "Create a function that checks if the columns of a given square 2D numerical array (matrix) V form an orthonormal set. It should compute the product of the conjugate transpose of V with V, and return `True` if the result is close to the identity matrix within a small tolerance, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a square 2D numerical array (matrix) which may contain complex numbers, and returns its Hermitian part, calculated as (matrix + conjugate_transpose(matrix)) / 2."
    },
    {
        "instruction": "Write a function that accepts a square Hermitian 2D numerical array A, a 1D array W, and a 2D numerical array V. It should verify if W contains the eigenvalues and V contains the corresponding orthonormal eigenvectors of A. Return `True` only if *both* V's columns are orthonormal *and* the equation A*v_i = w_i*v_i holds for all columns v_i in V and corresponding elements w_i in W (within reasonable numerical tolerances). Otherwise, return `False`."
    },
    {
        "instruction": "Develop a function that takes a square 2D numerical array and a string parameter ('upper' or 'lower'). It should return a new matrix containing only the elements from the specified triangle (including the diagonal) of the input matrix, with all other elements set to zero."
    },
    {
        "instruction": "Develop a function that checks if the columns of a given numerical matrix `V` (N x K) are orthonormal. It should compute the product of the conjugate transpose of `V` with `V` and return `True` if the result is close to the `K x K` identity matrix within a small numerical tolerance, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a square numerical 2D array and returns its symmetric/Hermitian part. The symmetric/Hermitian part is obtained by averaging the array with its conjugate transpose."
    },
    {
        "instruction": "Write a function that computes eigenvalues for a symmetric/Hermitian square matrix `A`. The function should accept the matrix `A` and an integer index range (`start`, `end`). It should return a 1D array containing only the eigenvalues corresponding to this index range (i.e., the `start`-th smallest eigenvalue up to, but not including, the `end`-th smallest eigenvalue), sorted in ascending order."
    },
    {
        "instruction": "Implement a function to verify the eigenvalue equation for multiple eigenvectors. It takes a square matrix `A` (N x N), a matrix `V` (N x K) whose columns are eigenvectors, and a 1D array `W` (K,) of corresponding eigenvalues. Calculate the matrix `A @ V` and the matrix resulting from element-wise multiplication of `V` by `W` (broadcasted). Return the norm (e.g., Frobenius) of the difference between these two resulting matrices."
    },
    {
        "instruction": "Implement a function to perform matrix multiplication. It should accept two 2D numerical arrays, A (size N x N) and V (size N x N), and return their product, a new N x N matrix."
    },
    {
        "instruction": "Write a function to verify the eigenvalue equation AV = WV for a given square matrix A (N x N), a 1D array of eigenvalues W (N,), and a 2D array of corresponding eigenvectors V (N x N). Compute the difference matrix D = A @ V - W * V (where '*' involves scaling each column of V by the corresponding element in W). Return True if the Frobenius norm of D is less than a small tolerance (e.g., 2 * machine_epsilon * norm(A)), False otherwise."
    },
    {
        "instruction": "Create a function that calculates the Frobenius norm of a given 2D numerical array (matrix). The function should sum the square of the absolute value of each element and return the square root of that sum."
    },
    {
        "instruction": "Write a function that creates and returns a specific 4x4 numerical matrix. The matrix should have 0.0 on the diagonal. Off-diagonal elements at indices (0,1), (1,0), (0,2), (2,0), (1,3), (3,1), (2,3), (3,2) should be -1.0. Elements at indices (0,3), (3,0), (1,2), (2,1) should be 1.0."
    },
    {
        "instruction": "Develop a function that computes the eigenvalues and eigenvectors of a real, symmetric square matrix. Input is an N x N symmetric matrix. Output should be a 1D array of N eigenvalues and a 2D N x N matrix where columns are the corresponding eigenvectors."
    },
    {
        "instruction": "Write a function to check the accuracy of an eigenvalue decomposition. It takes a square matrix `A` (N x N), a 1D array of eigenvalues `w` (length N), and a matrix `V` (N x N) whose columns are eigenvectors. Calculate the result matrix `R = A @ V` and the scaled eigenvector matrix `S` where the k-th column of `V` is scaled by the k-th eigenvalue in `w`. Return the Frobenius norm of the difference `R - S`."
    },
    {
        "instruction": "Create a function that scales all elements of a 2D numerical array (matrix) by a given floating-point scalar value. The function should take the matrix and the scalar as input and return the scaled matrix."
    },
    {
        "instruction": "Implement a function that performs matrix-vector multiplication for each column of a second matrix. It takes a square matrix `A` (N x N) and a matrix `V` (N x N) where columns represent vectors. It should return a matrix `R` (N x N) where the k-th column is the result of `A` multiplied by the k-th column of `V`."
    },
    {
        "instruction": "Create a function that takes a square 2D numerical array (matrix) `A` and a 1D numerical array (vector) `v` of compatible size. Return the 1D array (vector) resulting from multiplying the matrix `A` by the vector `v`."
    },
    {
        "instruction": "Write a function that computes the Frobenius norm of a 2D numerical array (matrix). The Frobenius norm is the square root of the sum of the absolute squares of its elements."
    },
    {
        "instruction": "Develop a function that takes a square 2D numerical array (matrix) `A`, a 1D numerical array (vector) `v`, and a scalar numerical value `w`. The function should return `True` if `A` multiplied by `v` is approximately equal to `w` multiplied by `v`, and `False` otherwise. Use a fixed small tolerance for the comparison."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array (matrix) and returns a square matrix by multiplying the input matrix by its conjugate transpose."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix), potentially containing complex numbers, and returns its conjugate transpose (Hermitian transpose). An input of shape (M, N) should produce an output of shape (N, M)."
    },
    {
        "instruction": "Develop a function that calculates the Frobenius norm of the difference between two matrices of the same shape. The function should accept two 2D numerical arrays and return a single non-negative floating-point number. Handle complex numbers."
    },
    {
        "instruction": "Create a function that accepts a square 2D numerical array (matrix), potentially containing complex numbers. Determine if the columns of the matrix form an orthonormal set by checking if the product of its conjugate transpose with itself is close to the identity matrix within a small tolerance (e.g., 1e-6). Return `True` if orthonormal, `False` otherwise."
    },
    {
        "instruction": "Implement a function that verifies the eigenvalue relationship for a matrix and its alleged eigenvalues/eigenvectors. It takes a square matrix `A` (N x N), a 1D array of eigenvalues `w` (length N), and a 2D array of eigenvectors `V` (N x N, eigenvectors as columns). Calculate the norm of the difference between `A @ V` and `w * V` (element-wise multiplication appropriately broadcasted). Return `True` if the norm is below a small tolerance, `False` otherwise. Handle complex numbers."
    },
    {
        "instruction": "Create a function that takes a batch of square matrices represented as a 3D numerical array (shape B, N, N) and returns a new 3D array where each matrix in the batch has been made Hermitian using the formula H = (M + conjugate_transpose(M)) / 2."
    },
    {
        "instruction": "Write a function that takes a single square 2D numerical array (matrix), potentially containing complex numbers, and returns its Hermitian representation. The Hermitian representation H of a matrix M is calculated as H = (M + conjugate_transpose(M)) / 2."
    },
    {
        "instruction": "Develop a function to calculate the maximum verification error for a batch of eigenvalue decompositions. Input: a 3D array `A_batch` (shape B, N, N) of Hermitian matrices, a 2D array `w_batch` (shape B, N) of eigenvalues, and a 3D array `v_batch` (shape B, N, N) of eigenvectors. For each item `i` in the batch, calculate the norm of the residual `A_batch[i] @ v_batch[i] - w_batch[i] * v_batch[i]`. Return the maximum norm found across the entire batch."
    },
    {
        "instruction": "Implement a function to compute the residual error for the eigenvalue equation of a single matrix. Inputs are a square 2D numerical array `A` (N, N), a 1D array `w` (N) of eigenvalues, and a 2D array `v` (N, N) where columns are eigenvectors. Calculate `A @ v` and `w * v` (element-wise, broadcasted), compute the difference matrix, and return the Frobenius norm of this difference."
    },
    {
        "instruction": "Write a function that accepts a single argument. Check if the argument's type is a string. Return `True` if it is a string, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that attempts a generic calculation (you don't need to perform the calculation itself). It should accept a numerical array and a configuration string. Validate the configuration string: if it equals 'invalid_config', raise a `ValueError`. If valid, return `True`."
    },
    {
        "instruction": "Develop a function that receives two arguments: a data input (e.g., a list of numbers) and an 'order' parameter. If the 'order' parameter is a string, raise a `ValueError` with the specific message: \"Invalid order type: string provided.\". Otherwise, return the data input unchanged."
    },
    {
        "instruction": "Write a function `compute_norm_checked` that takes a 1D numerical array and an `order` parameter. The function should first validate the `order`. If `order` is a number (int or float), return a placeholder value like 0.0. If `order` is a string, raise a `ValueError` indicating that string orders are invalid inputs for this operation."
    },
    {
        "instruction": "Write a function that verifies the quality of QR decomposition for a batch of matrices. It takes three 3D numerical arrays as input: the original batch `A` (shape `B x M x N`), the `Q` batch (shape `B x M x K`), and the `R` batch (shape `B x K x N`). The function should return `True` if the norm of the difference `A[i] - Q[i] @ R[i]` is below a small tolerance (e.g., 0.001) for *all* matrices `i` in the batch, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that calculates the Frobenius norm for each matrix in a batch. Input is a 3D numerical array (shape `B x M x N`). Output should be a 1D array of size `B`, where each element is the Frobenius norm of the corresponding `M x N` matrix."
    },
    {
        "instruction": "Develop a function that performs QR decomposition on a *single* 2D numerical matrix (shape `M x N`, potentially complex). It should return two matrices: `Q` (shape `M x K`, with orthonormal columns) and `R` (shape `K x N`, upper triangular), where `K = min(M, N)`, such that the input matrix is approximately equal to `Q` multiplied by `R`."
    },
    {
        "instruction": "Create a function that performs batch matrix multiplication. It should accept two 3D numerical arrays, `A` (shape `B x M x K`) and `B` (shape `B x K x N`), and return a 3D array (shape `B x M x N`) where each matrix `C[i]` is the product of `A[i]` and `B[i]`."
    },
    {
        "instruction": "Implement a function to calculate the L1 norm of a given 2D numerical array (matrix). The L1 norm is defined as the maximum absolute column sum."
    },
    {
        "instruction": "Create a function that generates a square matrix of size N x N filled with random numerical values (float or complex) drawn from a distribution suitable for small values (e.g., centered around zero). The function should take the size N and the desired data type (float or complex) as input."
    },
    {
        "instruction": "Develop a function that computes the exponential of a given square numerical matrix (N x N). The input is the matrix, and the output should be another N x N matrix representing its exponential."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and a target scalar value. It should return a new matrix scaled such that its L1 norm equals the target value. Handle potential division by zero if the input matrix norm is zero."
    },
    {
        "instruction": "Implement a function to calculate the matrix exponential of a square (N x N) 2D numerical array. Use a method like Taylor series expansion. The function should handle both real and complex floating-point inputs and return a matrix of the same shape and type."
    },
    {
        "instruction": "Write a function that accepts any numerical array (e.g., 1D vector, 2D matrix) and returns `True` if its elements are complex numbers, and `False` otherwise."
    },
    {
        "instruction": "Create a function that generates a square 2D numerical array (matrix) of size N x N with a specified numerical data type (e.g., float32, complex64). Fill the matrix with random numbers."
    },
    {
        "instruction": "Write a function that computes the L1 norm (maximum absolute column sum) of a given 2D numerical array (matrix). Input is an M x N matrix, output is a single non-negative number."
    },
    {
        "instruction": "Write a function that sorts a 1D array of real eigenvalues in ascending order and reorders the columns of a corresponding 2D array of eigenvectors (potentially complex) to match the sorted eigenvalues. Input: eigenvalues W (N,), eigenvectors V (N, N). Output: sorted eigenvalues W_sorted (N,), reordered eigenvectors V_sorted (N, N)."
    },
    {
        "instruction": "Write a function that takes a square 2D numerical array (matrix) which might contain complex numbers, and returns its Hermitian version (average of the matrix and its conjugate transpose). Input shape (N, N) should result in output shape (N, N)."
    },
    {
        "instruction": "Create a function that checks if the columns of a given square 2D numerical array (matrix V, potentially complex) form an orthonormal set. It should return `True` if the matrix product of the conjugate transpose of V with V is close to the identity matrix within a given tolerance, `False` otherwise."
    },
    {
        "instruction": "Implement a function that verifies the eigenvalue equation for a given matrix, eigenvalues, and eigenvectors. It takes a square matrix A (N, N), a 1D array of eigenvalues W (N,), and a 2D array of eigenvectors V (N, N). It should return `True` if the norm of the difference between (A multiplied by V) and (V multiplied by W along columns) is below a specified tolerance relative to the norm of A, `False` otherwise."
    },
    {
        "instruction": "Implement a function to compute the Frobenius norm of a given 2D numerical array (matrix), which may contain complex numbers. The Frobenius norm is the square root of the sum of the absolute squares of its elements."
    },
    {
        "instruction": "Create a function that calculates the inverse of a given square 2D numerical array (matrix). If the matrix is singular (non-invertible), the function should indicate this failure (e.g., return None or raise an error)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and returns `True` if it's square (number of rows equals number of columns) and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array (matrix) and a string indicating a norm type (e.g., 'infinity-norm', '1-norm'). The function should first check if the requested norm type is applicable only to square matrices. If it is, and the input matrix is not square, the function should raise a value error. Otherwise, it should proceed (or simulate proceeding) with the norm calculation (actual calculation not required for this task, focus on the validation)."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) which may contain complex numbers, and returns its conjugate transpose (Hermitian transpose). Input shape (M, N) should result in output shape (N, M)."
    },
    {
        "instruction": "Given a lower triangular matrix `L` (shape N x N) potentially containing complex numbers, write a function that computes and returns the corresponding upper triangular Cholesky factor `U`. Hint: `U` is the conjugate transpose of `L`."
    },
    {
        "instruction": "Implement a function to compute the lower Cholesky decomposition of a square, Hermitian positive-definite matrix. Input is a 2D numerical array `A` (shape N x N), output should be a lower triangular 2D array `L` (shape N x N) such that `A` is approximately equal to `L @ L.conj().T`. The function should handle potential errors if the input is not positive-definite."
    },
    {
        "instruction": "Develop a function that checks if a given square 2D numerical array (matrix, shape N x N) is lower triangular. It should return `True` if all elements strictly above the main diagonal are zero (within a small tolerance), and `False` otherwise."
    },
    {
        "instruction": "Develop a function to validate shapes for a tensor equation `a * x = b`. It takes three tuples: `shape_a`, `shape_b`, and `shape_x`. Return `True` if `shape_a` is exactly the concatenation of `shape_b` and `shape_x`, and `False` otherwise."
    },
    {
        "instruction": "Write a function that solves a tensor equation `a * x = b` for `x`. Input `a` has shape `ShapeB + ShapeX`, and input `b` has shape `ShapeB`. The function should return tensor `x` with shape `ShapeX`. Assume `ShapeB` and `ShapeX` are tuples representing dimensions, and the necessary linear algebra operations are possible."
    },
    {
        "instruction": "Create a function that generates a multi-dimensional array (tensor) filled with random floating-point numbers. The function should accept a tuple defining the desired shape and return the generated tensor."
    },
    {
        "instruction": "Write a function that takes two tuples representing tensor shapes, `shape1` and `shape2`, and returns a new tuple representing their concatenation."
    },
    {
        "instruction": "Implement a function to calculate the eigenvalues for a given square input matrix (size `N x N`). The matrix can contain real or complex numbers. Return a 1D array of length `N` holding the computed eigenvalues."
    },
    {
        "instruction": "Develop a function that numerically estimates the sensitivity of a scalar output `s = f(M)` to changes in each element of the input square matrix `M`. Given the function `f` (which takes an `N x N` matrix and returns a scalar) and an input matrix `M`, approximate the derivative `dS/dM_ij` for all `i, j` using a central difference formula with a small step size `h`. Return the resulting `N x N` sensitivity matrix."
    },
    {
        "instruction": "Write a function that creates a square numerical matrix of size `N x N`. The function should accept `N` and a type specifier ('real' or 'complex') and return the matrix filled with random values of the specified type."
    },
    {
        "instruction": "Create a function that accepts a square numerical matrix (size `N x N`) potentially containing complex numbers. Compute its eigenvalues and return a 1D array containing only the imaginary parts of these eigenvalues."
    },
    {
        "instruction": "Implement a function that accepts a square `N x N` numerical input matrix (can be real or complex). It should return a 1D array containing the `N` eigenvalues of the input matrix. Note that eigenvalues may be complex even for a real matrix."
    },
    {
        "instruction": "Create a function that compares two 1D numerical arrays (vectors) element-wise for approximate equality. It should accept two 1D arrays of the same size and a tolerance value. Return `True` if all corresponding elements (a[i], b[i]) are close within the given tolerance, and `False` otherwise. Ensure it handles complex numbers correctly."
    },
    {
        "instruction": "Write a function that takes an integer `N` and returns a square `N x N` 2D numerical array initialized with arbitrary numerical values (the specific values do not matter)."
    },
    {
        "instruction": "Write a function that checks if a given scalar value `lambda` is an eigenvalue of a given square `N x N` numerical matrix `A`. It should compute the determinant of the matrix `(A - lambda * I)`, where `I` is the `N x N` identity matrix. Return `True` if the absolute value of the determinant is close to zero (within a small tolerance), indicating singularity and thus that `lambda` is likely an eigenvalue, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array (matrix) and a boolean flag `assume_hermitian`. If `assume_hermitian` is `True`, verify the matrix is square and compute the pseudoinverse assuming the input is Hermitian. If `False`, compute the pseudoinverse without this assumption. Return the resulting pseudoinverse matrix."
    },
    {
        "instruction": "Create a function that takes a square 2D numerical array (matrix) `A`, potentially containing complex numbers, and returns its Hermitian part, calculated as `(A + A*) / 2`, where `A*` is the conjugate transpose of `A`."
    },
    {
        "instruction": "Implement a function to compute the Moore-Penrose pseudoinverse of a given 2D numerical array (matrix). The function should handle various matrix shapes (M x N, including M=0 or N=0) and work for both real and complex inputs."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array and returns `True` if the last two dimensions are equal (indicating square matrices in the inner dimensions), and `False` otherwise. Handle inputs with fewer than 2 dimensions by returning `False`."
    },
    {
        "instruction": "Create a function that checks if a given square 2D numerical array (matrix) is full rank. It should take the matrix and a tolerance value as input. Return `True` if the rank equals the dimension of the matrix (number of rows/columns), and `False` otherwise."
    },
    {
        "instruction": "Develop a function to calculate the rank of a 2D numerical array (matrix) that may contain complex numbers. Ensure your implementation correctly handles complex arithmetic and uses a tolerance threshold for determining linear independence."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (vector) and returns its rank. The rank should be 1 if the vector contains at least one non-zero element (considering a small tolerance for floating-point numbers), and 0 otherwise."
    },
    {
        "instruction": "Write a function that accepts a numerical array with 3 or more dimensions. Treat this array as a stack of 2D matrices based on the last two dimensions. Calculate the rank for each 2D matrix slice and return an array containing these ranks. Use a tolerance for calculations."
    },
    {
        "instruction": "Create a function that determines if a given square 2D numerical array represents a valid permutation matrix (contains only 0s and 1s, with exactly one 1 in each row and column)."
    },
    {
        "instruction": "Implement a function that takes three 2D numerical arrays (matrices A, B, C) of compatible shapes for multiplication and returns their product (A @ B @ C)."
    },
    {
        "instruction": "Write a function that checks if a given square 2D numerical array is upper triangular (all elements below the main diagonal are zero)."
    },
    {
        "instruction": "Write a function that accepts four 2D numerical arrays (potentially non-square): an original matrix `M`, a permutation matrix `P`, a lower triangular matrix `L`, and an upper triangular matrix `U`. Verify if the product `P @ L @ U` is approximately equal to `M` within specified relative and absolute tolerances. Return `True` if close, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a square 2D numerical array (matrix) and returns a new matrix containing only the elements on and above the main diagonal (the upper triangle), with zeros elsewhere. Input shape (N, N) -> Output shape (N, N)."
    },
    {
        "instruction": "Develop a function that performs matrix multiplication of two square 2D numerical arrays (matrices), L and U, both of shape (N, N). Assume L is lower triangular with potentially non-unit diagonal, and U is upper triangular. Return the resulting product matrix of shape (N, N)."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix) of shape (N, N) and a 1D array (vector) of N integers representing row indices. The function should return a new matrix where, for each index `i` from 0 to N-1, the row `i` of the input matrix has been swapped with the row specified by the `i`-th element of the index vector."
    },
    {
        "instruction": "Create a function that accepts a square 2D numerical array (matrix). It should return a new matrix representing the strictly lower triangular part (elements below the main diagonal) of the input, but with 1s placed on the main diagonal. Input shape (N, N) -> Output shape (N, N)."
    },
    {
        "instruction": "Write a function that performs QR decomposition *with column pivoting* on an M x N numerical matrix. Return three items: an orthogonal/unitary matrix Q (shape M x K), an upper-triangular matrix R (shape K x N) where K = min(M, N), and a 1D integer array P representing the column permutation applied to the original matrix A, such that A[:, P] is approximately equal to Q @ R."
    },
    {
        "instruction": "Develop a function that performs QR decomposition on a given M x N numerical matrix. Return the orthogonal/unitary matrix Q (shape M x K) and the upper-triangular matrix R (shape K x N), where K = min(M, N). Do not implement column pivoting. Ensure Q has orthonormal columns."
    },
    {
        "instruction": "Create a function that accepts two 2D numerical arrays, Q (shape M x K) and R (shape K x N), and computes their matrix product, returning a new 2D array of shape M x N. Handle both real and complex number types."
    },
    {
        "instruction": "Implement a function that takes a 1D integer array (permutation vector of length N) and returns its inverse permutation as a 1D integer array. For example, if the input is `[1, 2, 0]`, the output should be `[2, 0, 1]`."
    },
    {
        "instruction": "Develop a function to verify a Hessenberg decomposition. It accepts three square 2D numerical arrays (A, Q, H) of the same dimensions. Return `True` if H is upper Hessenberg, Q is unitary (i.e., `Q @ Q.conj().T` is close to the identity matrix), and `A` is approximately equal to `Q @ H @ Q.conj().T` (all checks within a reasonable numerical tolerance), and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a square 2D numerical array (matrix) containing potentially complex numbers, and returns a new 2D array of the same shape and type representing its upper Hessenberg form. The output matrix must have entries below the first subdiagonal that are close to zero."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and returns `True` if it is an upper Hessenberg matrix (all entries below the first subdiagonal are zero within a small tolerance), and `False` otherwise. Handle non-square matrices by returning `False`."
    },
    {
        "instruction": "Write a function that checks if a given square 2D numerical array (matrix M, potentially complex) is unitary. Return `True` if the product of the matrix and its conjugate transpose is close to the identity matrix (within a small tolerance), and `False` otherwise. If the input is not square, return `False`."
    },
    {
        "instruction": "Write a function that accepts a square 2D numerical array (matrix) and returns two 1D arrays: one containing the elements of the main diagonal, and the other containing the elements of the first super-diagonal (elements at index `(i, i+1)`)."
    },
    {
        "instruction": "Write a function that accepts a 3D numerical array, where each slice along the first dimension represents a square matrix (e.g., shape BxNxN), and another function `matrix_op` that operates on a single NxN matrix. Apply `matrix_op` independently to each NxN matrix in the input batch and return the collected results (e.g., if `matrix_op` returns a tuple of arrays, return a tuple of batched arrays)."
    },
    {
        "instruction": "Implement a function to verify if a given square 2D numerical array is 'Hermitian-like'. For real arrays, it checks for symmetry (A equals A transpose). For complex arrays, it checks for Hermiticity (A equals its conjugate transpose). Return `True` or `False`. Account for potential small numerical differences."
    },
    {
        "instruction": "Create a function that takes a square 2D numerical array and a boolean flag `use_lower`. If `use_lower` is true, return a new matrix where all elements above the main diagonal are set to zero. If `use_lower` is false, return a new matrix where all elements below the main diagonal are set to zero."
    },
    {
        "instruction": "Write a function that accepts two arguments: a string and a single number. The function should check if the string argument is exactly equal to 'foo'. If it is, the function should return the number argument; otherwise, it might raise an error or return a default value (specify behavior)."
    },
    {
        "instruction": "Develop a function that takes a specific constant string (e.g., 'config_value') and a 1D numerical array. This function should apply an internal operation for each element of the array. The internal operation receives the constant string and the current element (as a single number). The operation should simply return the element. The main function returns a new 1D array containing the results, which should be identical to the input array."
    },
    {
        "instruction": "Create a function that takes a positive integer N and returns a 1D numerical array containing the sequence of integers from 0 up to N-1."
    },
    {
        "instruction": "Implement a function that takes two arguments: a processing function `func` and a 1D numerical array `arr`. The processing function `func` accepts a single number and returns a single number. Your function should apply `func` to every element in `arr` and return a new 1D numerical array containing the results."
    },
    {
        "instruction": "Implement a function `process_array_with_fixed_param`. It should take three arguments: a 1D numerical array `input_array`, a fixed parameter `param` (which could be a string or number), and a function `element_func`. `element_func` accepts two arguments: a single number and the fixed parameter `param`. Apply `element_func` to each number in `input_array`, always passing the same `param`. Return a 1D array containing the results."
    },
    {
        "instruction": "Write a function that accepts two arguments, a number `val` and a string `key`. It should check if `key` is exactly equal to 'expected_key'. If it is, return `val`, otherwise return None or raise an error."
    },
    {
        "instruction": "Develop a function `check_scalar_and_string`. It takes two arguments. Return `True` if the first argument is a single number (0-dimensional) and the second argument is the specific string 'control_signal'. Otherwise, return `False`."
    },
    {
        "instruction": "Design a higher-order function `create_vectorized_processor`. This function accepts another function `scalar_processor` as input. `scalar_processor` is assumed to take two arguments: a number and a string. `create_vectorized_processor` should return a *new* function. This new function accepts a 1D numerical array `nums` and a string `label`. When called, it must apply `scalar_processor` to each number in `nums`, pairing each number with the *same* `label`. It should return a 1D numerical array of the results."
    },
    {
        "instruction": "Implement a function `apply_with_output_check`. This function accepts another function `target_func`, a list of input arguments `args`, and an expected output structure description (e.g., 'tuple_of_two_arrays'). It calls `target_func(*args)`. It then checks if the output matches the structure description (e.g., is it a tuple? does it have two elements? are they arrays?). If it matches, return the output. If not, raise a `TypeError` with a descriptive message."
    },
    {
        "instruction": "Write a function that accepts a single argument and returns `True` if the argument is a tuple, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays as input and returns a tuple containing these two arrays."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication. It should accept two 2D numerical arrays, `A` (shape N x M) and `B` (shape M x K), and return their product, a 2D array of shape N x K. Include error handling for incompatible shapes."
    },
    {
        "instruction": "Implement a higher-order function (a function that takes another function as input). This wrapper function should also take an integer `expected_outputs`. When the wrapped function is called, the wrapper should execute it, check if the number of returned values (assuming the return value is a sequence or the function returns multiple values) matches `expected_outputs`, and raise a `TypeError` if they don't match. Otherwise, it should return the original function's result."
    },
    {
        "instruction": "Write a function that takes any number of positional arguments and returns a collection (e.g., list or tuple) containing all the arguments it received."
    },
    {
        "instruction": "Design a function `validate_outputs(func, expected_output_count)` that takes a function `func` and an integer `expected_output_count`. It should return a *new* function. When this new function is called with some arguments, it should first call the original `func` with those arguments. If `func` returns a single value and `expected_output_count` is 1, it returns the value. If `func` returns a collection (like a tuple or list) and the number of items in the collection matches `expected_output_count`, it returns the collection. In all other cases (e.g., mismatch in count, unexpected return type for count > 1), it should raise a `TypeError` with a descriptive message."
    },
    {
        "instruction": "Write a function that accepts exactly two numerical inputs and returns them as a pair (e.g., a tuple or list)."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication on two compatible 2D numerical arrays (matrices) of shapes (N, M) and (M, K), returning a new 2D array of shape (N, K). Assume compatibility is already checked."
    },
    {
        "instruction": "Develop a function that takes two 2D numerical arrays (matrices) and a signature string like `'(n,m),(m,k)->(n,k)'`. Parse the signature to determine expected input and output shapes based on the actual input dimensions. Perform matrix multiplication. If the actual output shape doesn't match the shape derived from the signature's output part, raise a `ValueError`. Otherwise, return the result. Handle basic signature parsing errors."
    },
    {
        "instruction": "Write a function that creates and returns a 2D numerical array (matrix) filled with zeros, given desired dimensions (rows, columns) as input."
    },
    {
        "instruction": "Create a function that takes two 2D numerical arrays (matrices) and an expected output shape tuple. It should attempt to multiply the matrices. If the actual output shape of the multiplication does not match the expected output shape, raise a `ValueError` with a message indicating the mismatch (e.g., \"Output shape {actual} does not match expected {expected}\"). Otherwise, return the result."
    },
    {
        "instruction": "Write a function that checks if the result of multiplying two matrices (given as 2D numerical arrays) would produce an output matrix of a specific, required shape. The function takes the two input matrices and the required output shape (e.g., a tuple `(R, C)`) and returns `True` if the multiplication result has that shape, `False` otherwise. Assume the matrices are compatible for multiplication."
    },
    {
        "instruction": "Design a function that validates matrix multiplication against a symbolic shape rule. It takes two input matrices (e.g., A with shape `(N, M)` and B with shape `(M, K)`) and a rule for the output shape that requires it to be square based on the first dimension of the first matrix (i.e., `(N, N)`). The function should return `True` if the actual multiplication result shape matches this rule `(N, N)`, and raise a ValueError indicating an inconsistent dimension if it does not (e.g., 'inconsistent size for dimension N')."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication on two 2D numerical arrays. The function should first check if the inner dimensions are compatible for multiplication and return the resulting 2D array. Raise a ValueError if they are incompatible."
    },
    {
        "instruction": "Write a function that takes the shapes of two matrices (e.g., as tuples like `(N, M)` and `(M, K)`) and returns the shape of their product if they are compatible for multiplication. If they are not compatible, indicate an error (e.g., return None or raise an error)."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array as input. It should apply a transformation to each element, where the transformation duplicates the element (e.g., element `e` becomes `(e, e)`). The function must return a tuple containing two identical copies of the original input array."
    },
    {
        "instruction": "Design a function that applies an element-wise operation to a 1D numerical array. This operation is defined by a separate function that takes one number and returns a tuple of *k* numbers. The main function should return a tuple of *k* 1D arrays, where the *i*-th array holds the *i*-th output of the element-wise function applied to each input element."
    },
    {
        "instruction": "Write a function that checks if a given object is a tuple containing exactly two elements, and if both of these elements are numerically equivalent to a provided 1D reference array. Return `True` if all conditions are met, `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a positive integer `n` and returns a 1D numerical array containing the sequence of integers from 0 up to `n-1`."
    },
    {
        "instruction": "Implement a function that performs element-wise addition on two numerical arrays of the same shape. It takes `array1` and `array2` as input and returns a new array containing the sums of corresponding elements."
    },
    {
        "instruction": "Create a function that generates a 1D numerical array containing a sequence of integers starting from 0 up to, but not including, a given positive integer `N`."
    },
    {
        "instruction": "Develop a function that takes two arguments: `data_array` (a numerical array) and `optional_array` (which can be either a \"missing\" value like `None` or another numerical array of the same shape as `data_array`). The function must return `data_array` unchanged if `optional_array` is missing. If `optional_array` is provided, return a new array representing the element-wise sum of `data_array` and `optional_array`."
    },
    {
        "instruction": "Write a function that takes two arguments, `val1` and `val2`. If `val2` has a special \"missing\" or \"null\" value (like `None`), the function should return `val1`. Otherwise, assuming `val1` and `val2` are numbers, it should return their sum."
    },
    {
        "instruction": "Write a function that takes two arguments, `a` and `b`. If `b` is `None`, return `a`. Otherwise, assume `a` and `b` are 1D numerical arrays of the same size and return their element-wise sum."
    },
    {
        "instruction": "Implement a function validator. Write a function that takes another function `func` (expected to accept two 1D numerical arrays) and a descriptive string `sig_desc` as input. It should return a *new* function. This new function, when called with two arguments `arg1` and `arg2`, must first check if `arg2` is `None`. If `arg2` is `None`, it must raise a `ValueError` incorporating the index (1) and the `sig_desc` string into the error message. If `arg2` is not `None`, it should proceed to call `func(arg1, arg2)` and return its result."
    },
    {
        "instruction": "Create a function that accepts exactly two arguments. It must check if the second argument is `None`. If it is, the function should raise a `ValueError` with a message clearly stating that the second argument cannot be `None`. Otherwise, the function should return `True`."
    },
    {
        "instruction": "Develop a function that receives a list or tuple of arguments. It must specifically check if the argument at index 1 (the second argument) is `None`. If it is `None`, raise a `ValueError` with a precise message like 'Argument at index 1 cannot be None.' If the argument is not `None`, the function should return `True`."
    },
    {
        "instruction": "Write a function that takes a numerical array and a scalar value. Return a new array of the same shape where the scalar has been added to each element of the input array."
    },
    {
        "instruction": "Create a function that accepts two numerical arrays and a mode string ('strict' or 'permissive'). If the arrays have different numbers of dimensions (rank), raise a value error if mode is 'strict', or print a warning message and return `None` if mode is 'permissive'. If they have the same number of dimensions, return the result of element-wise addition (assuming shapes are compatible for addition)."
    },
    {
        "instruction": "Develop a function that accepts two tuples representing the shapes of numerical arrays. Return `True` if the shapes are compatible for element-wise operations according to standard broadcasting rules (dimensions compared right-to-left must match or one must be 1), and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix M x N) and a 1D numerical array (vector N,). Perform element-wise addition by broadcasting the vector along the first dimension (rows) of the matrix. Return the resulting 2D array (M x N)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array `arr` and a numerical scalar `scalar`. It should apply a specific binary operation (e.g., addition) element-wise, combining each element of `arr` with the `scalar`. Return a new 1D array of the same size containing the results."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array `arr`, a numerical scalar `scalar`, and a callable `binary_func`. Apply `binary_func` element-wise such that for each element `x` in `arr`, the result is `binary_func(x, scalar)`. Return a new 1D array containing these results."
    },
    {
        "instruction": "Write a function `apply_binary_op` that takes two numerical scalars (scalar1, scalar2) and a callable `operation` (e.g., addition, power). The function should return the result of `operation(scalar1, scalar2)`."
    },
    {
        "instruction": "Implement a higher-order function `create_vectorized_func`. This function takes a `base_function` (which operates on scalar inputs) and an index `scalar_arg_index`. It returns a *new* function. This new function should accept a 1D numerical array for its first argument and a scalar for the argument at `scalar_arg_index`. It should then apply the `base_function` element-wise, using each element from the input array as the first argument and the *same* input scalar as the argument at `scalar_arg_index` for every call to `base_function`. Return the results as a new 1D array."
    },
    {
        "instruction": "Develop a function that multiplies two multi-dimensional numerical arrays representing batches of matrices. Input: `Array1` (shape `...Batch1, N, M`), `Array2` (shape `...Batch2, M, K`). The leading batch dimensions (`...Batch1`, `...Batch2`) must be broadcastable. Output: An array `Result` (shape `...BroadcastedBatch, N, K`) containing the matrix products."
    },
    {
        "instruction": "Create a function to calculate the expected output shape after multiplying two multi-dimensional arrays representing batches of matrices. Inputs: shape tuple 1 (e.g., `(B1, B2, N, M)`), shape tuple 2 (e.g., `(B3, M, K)`). Assume standard broadcasting rules for leading batch dimensions (B1, B2 vs B3) and matrix multiplication for the last two. Return the resulting shape tuple."
    },
    {
        "instruction": "Write a function that takes two tuples representing the shapes of two 2D matrices (e.g., `(N, M)` and `(M, K)`) and returns the shape tuple of their product `(N, K)`. If the inner dimensions are incompatible for multiplication, indicate failure (e.g., return None)."
    },
    {
        "instruction": "Write a function that accepts a tuple describing dimensions (e.g., `(5, 2, 3)`) and returns a new multi-dimensional numerical array of that shape, initialized entirely with zeros."
    },
    {
        "instruction": "Create a function that handles matrix-vector multiplication where the 'vector' might have a leading singleton dimension. Input: a 2D numerical array (matrix) of shape (N, M) and a 2D array (vector) of shape (1, M). Output: a 2D array of shape (1, N)."
    },
    {
        "instruction": "Implement a function that multiplies a batch of matrices by a single vector. Input: a 3D numerical array of shape (B, N, M) and a 1D array of shape (M,). Output: a 2D array of shape (B, N), where each row `i` is the result of multiplying the i-th matrix (shape N, M) by the vector."
    },
    {
        "instruction": "Develop a function that calculates the expected output shape when applying a matrix-vector multiplication (`(N, M) x (M,) -> (N,)`) across leading dimensions of two input arrays. Given the shapes of the two input arrays (e.g., `(B1, B2, N, M)` and `(B3, M)`), determine the resulting shape by considering broadcasting rules for the leading dimensions (B1, B2) and (B3)."
    },
    {
        "instruction": "Write a function that performs matrix-vector multiplication generalized for batches. It takes a numerical array `A` with shape `(..., N, M)` and a numerical array `B` with shape `(..., M)`, where `...` denotes zero or more matching leading batch dimensions. The function should compute the product for each corresponding matrix and vector in the batches, returning an array with shape `(..., N)`."
    },
    {
        "instruction": "Write a function that computes the dot product of two 1D numerical arrays (vectors) of the same size M. It should take two 1D arrays of shape (M,) and return a single scalar value (0D array)."
    },
    {
        "instruction": "Implement a function that calculates the product between a multi-dimensional numerical array A with shape (..., M) and a 1D numerical array B with shape (M,). The function should compute the dot product along the last dimension, resulting in an output array with shape (...)."
    },
    {
        "instruction": "Write a function that performs a generalized dot product. It accepts two numerical arrays, A and B. If A has shape (d1, ..., dk, M) and B has shape (M,), it computes the dot product along the last axis, returning an array of shape (d1, ..., dk). If A and B both have shape (M,), it returns a scalar. Include basic validation to ensure the contracting dimension M matches between the two inputs."
    },
    {
        "instruction": "Develop a function that predicts the output shape resulting from a specific array operation. Given the shape tuple of a first multi-dimensional array (d1, d2, ..., dk, M) and the shape tuple of a second 1D array (M,), the function should return the expected output shape tuple (d1, d2, ..., dk). Handle the case where the first input is also 1D (M,), returning an empty tuple () for a scalar result."
    },
    {
        "instruction": "Write a function that takes a 3D numerical array with shape (X, Y, Z) and returns a 2D array of shape (X, Y) where each element `[i][j]` is the average of the values along the Z-dimension of the input array at `[i][j][:]`."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array (matrix) and returns a 1D array where each element is the mean of the corresponding row in the input matrix. Input: 2D array, shape (R, C). Output: 1D array, shape (R,)."
    },
    {
        "instruction": "Write a function that computes the arithmetic mean of all elements in a 1D numerical array. Input: 1D array of numbers. Output: a single number."
    },
    {
        "instruction": "Develop a function that accepts a tuple representing the dimensions (shape) of an array and returns a new tuple representing the shape after removing the last dimension. If the input tuple has only one element (e.g., (n,)), return an empty tuple (). Input: tuple of positive integers. Output: tuple of positive integers."
    },
    {
        "instruction": "Write a function that accepts a single numerical value and returns a 2-element sequence (like a list or tuple) containing the original value and its negation."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array (e.g., a list of numbers) and returns a 2D array (e.g., a list of lists) where each inner element `i` corresponds to `[input_array[i], -input_array[i]]`. The output shape should be (N, 2) if the input shape is (N,)."
    },
    {
        "instruction": "Create a function that takes a numerical array of any dimension and returns a new array of the same shape where each element is the negative of the corresponding input element."
    },
    {
        "instruction": "Develop a function that accepts a numerical array of shape `(S1, S2, ..., Sk)`. It should produce a new array of shape `(S1, S2, ..., Sk, 2)` such that for any index `(i1, i2, ..., ik)`, the output at `(i1, i2, ..., ik, 0)` is the input element `input[i1, i2, ..., ik]` and the output at `(i1, i2, ..., ik, 1)` is its negation."
    },
    {
        "instruction": "Create a function that takes one numerical array as input. It should check if the array has at least two dimensions. If the array has fewer than two dimensions (e.g., shape (N,) or is a scalar), raise a specific error stating that the input 'does not have enough dimensions'. Otherwise, return True."
    },
    {
        "instruction": "Write a function that attempts matrix multiplication between two input numerical arrays. It must first validate that: a) exactly two arguments are provided, b) both arguments are 2D arrays, and c) their shapes are compatible for multiplication. If any check fails, raise an appropriate, descriptive error (like those in Tasks 1, 2, and 4). If all checks pass, return the resulting product matrix (you can use placeholder logic for the actual multiplication if needed)."
    },
    {
        "instruction": "Develop a function that takes two arguments intended to be 2D numerical arrays (matrices). Verify if the inner dimension of the first matrix matches the outer dimension of the second matrix (i.e., columns of the first match rows of the second). If they don't match, raise a specific error indicating an 'inconsistent size for core dimension'. Otherwise, return True."
    },
    {
        "instruction": "Implement a function that checks the compatibility of two matrices for multiplication. It should accept two tuples, each representing the shape of a 2D array (e.g., (rows1, cols1) and (rows2, cols2)). Return True if the inner dimensions match (cols1 == rows2), and False otherwise."
    },
    {
        "instruction": "Define a function named `log_value` that takes one input parameter `item`. Inside the function, it should print the `item` directly to the standard output."
    },
    {
        "instruction": "Create a function that takes a template string with a single placeholder (like '{}') and a value. Return a new string where the placeholder has been replaced by the string representation of the value."
    },
    {
        "instruction": "Write a function that performs the following steps: 1. Define an inner function that takes one argument and prints it in the format \"Result: [argument]\\n\". 2. Call this inner function with a specific input (e.g., the number 42). 3. Capture the standard output produced by the inner function call. 4. Return `True` if the captured output exactly matches the expected string (e.g., \"Result: 42\\n\"), and `False` otherwise."
    },
    {
        "instruction": "Implement a mechanism (e.g., using context managers or temporary stream redirection) to capture text printed to standard output within a specific scope. Write code that executes a provided function (assume this function prints text) using this mechanism and returns the captured text as a single string."
    },
    {
        "instruction": "Write a function that takes a simple 1D numerical array (e.g., containing `1.0, 2.0, 3.0`) and returns its string representation suitable for printing, including brackets and spaces between elements (e.g., `[1.0 2.0 3.0]`)."
    },
    {
        "instruction": "Create a function that accepts any variable as input and returns a string representation of its fundamental data type (e.g., 'integer', 'float', 'string', 'list')."
    },
    {
        "instruction": "Write a function that takes a template string with named placeholders (e.g., `{name}`, `{value}`) and a dictionary of key-value pairs. It should return a new string with the placeholders replaced by their corresponding values from the dictionary."
    },
    {
        "instruction": "Develop a function that accepts a 1D numerical array containing floating-point numbers. It must return a formatted string exactly like: `arr [element1 element2 ...], dtype: float_type_name, arr [element1 element2 ...]` where `elementX` are the array elements (separated by spaces) and `float_type_name` is the specific name of the floating-point data type. Ensure spacing and format match the example precisely."
    },
    {
        "instruction": "Develop a function that takes a single argument. This function should internally generate a string by substituting the argument's value into a predefined template string that uses a named placeholder (like 'Input: {data}\\n'). The function must return this generated string exactly as it would appear if printed, including the newline."
    },
    {
        "instruction": "Write a function that takes two arguments, a label (string) and a value (any basic type like number, string, boolean). The function should print a string to standard output formatted as '{label}: {value}\\n', substituting the provided label and value."
    },
    {
        "instruction": "Write a function that takes a single numerical value as input and prints it to the standard output, preceded by the label 'Data: ' and followed by a newline character."
    },
    {
        "instruction": "Implement a function that accepts an arbitrary value. Inside this function, format a string using a named placeholder 'item' to embed the value (e.g., 'Processing item: {item}\\n'). The function should then print this formatted string to the standard output stream."
    },
    {
        "instruction": "Implement a mechanism (e.g., a function or a context manager) that executes a provided function `func`. This mechanism should capture any output `func` prints to standard output and return it as a single string, preserving all original formatting including newlines."
    },
    {
        "instruction": "Create a function that accepts an integer `n`. Inside the function, calculate `m = n + 1`. Print the value of `n` on one line (e.g., \"Original: n\") and the value of `m` on the next line (e.g., \"Incremented: m\")."
    },
    {
        "instruction": "Write a function that takes a string label and a numerical value. It should print a single line to the standard output formatted as \"label: value\" followed by a newline."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x`. Inside the function, it should print the value of `x` labelled as \"Input: \" on one line, and then print the value of `x + 5` labelled as \"Processed: \" on the next line."
    },
    {
        "instruction": "Write a function that takes a label (string) and a value (any type convertible to string). It should print the string `\"{label}: {value}\\n\"` to the standard output."
    },
    {
        "instruction": "Write a function that receives a single numerical value. It should print this value to standard output, enclosed in square brackets and followed by a newline, like `\"[value]\\n\"`."
    },
    {
        "instruction": "Implement a utility function that accepts another function `func` as input. When called, this utility should execute `func` (assuming `func` prints to standard output) and return all the text printed by `func` as a single string."
    },
    {
        "instruction": "Create a function that accepts a single input value. Inside this function, trigger a mechanism to print the value prefixed with \"Data: \" and followed by a newline to standard output. The function's primary goal is to capture and return this exact printed string."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number. The function should print the number formatted to exactly two decimal places, prefixed with \"Data: \", followed by a newline character. For example, input `3.14159` should print `Data: 3.14\\n`."
    },
    {
        "instruction": "Implement a function that takes a template string containing exactly one placeholder `{}` and a numerical value. The function should return a new string where the placeholder is replaced by the numerical value, formatted as a float with exactly two decimal places. Example: `(\"Value is {}\", 7)` should return `\"Value is 7.00\"`."
    },
    {
        "instruction": "Create a function that takes a floating-point number and a positive integer representing the desired number of decimal places. It should return a string representation of the number formatted to that specific precision, without any extra text. For example, input `(10.12345, 3)` should return `\"10.123\"`."
    },
    {
        "instruction": "Write a function that takes a single string as input and prints it directly to the standard output, ensuring that a single newline character is automatically appended at the end."
    },
    {
        "instruction": "Create a function that takes one numerical input and prints it to the standard output, formatted as 'data: <value>\\n' (where <value> is the input number). The function should not return any value."
    },
    {
        "instruction": "Write a helper function that takes another function (which accepts no arguments but produces output to standard console) as input. The helper should execute the input function, capture all text printed to the standard output during its execution, and return the captured text as a single string."
    },
    {
        "instruction": "Design a function that takes three arguments: a function `target_func`, a tuple `func_args`, and a string `expected_print`. Your function should execute `target_func` with the arguments from `func_args`, capture any text `target_func` prints to standard output, and return a tuple containing two elements: (1) the value returned by `target_func`, and (2) a boolean indicating whether the captured printed text exactly matches the `expected_print` string."
    },
    {
        "instruction": "Write a function that accepts two numerical inputs and returns their sum."
    },
    {
        "instruction": "Create a function that accepts a list of items. For each item in the list, it must print a formatted string 'Data: {item}\\n' to standard output. The printed lines must appear in the exact same order as the items in the input list."
    },
    {
        "instruction": "Write a function that accepts a value and a descriptive label (string). It should print a string to standard output formatted as '{label}: {value}\\n'."
    },
    {
        "instruction": "Write a function `capture_print(func, *args)` that calls `func(*args)`, captures any text printed to standard output during the call, and returns the captured text as a single string."
    },
    {
        "instruction": "Develop a function that takes a dictionary. For each key-value pair, it should print a line formatted as '{key}: {value}\\n'. Write separate code that calls this function with `{'item': 10, 'status': 'done'}` and captures the complete output string."
    },
    {
        "instruction": "Write a function that accepts two numerical inputs and returns their sum."
    },
    {
        "instruction": "Create a function that takes one argument (any data type) and prints it to the standard output, preceded by the label \"Data: \"."
    },
    {
        "instruction": "Write a function that takes a list of numbers. It must print each number sequentially in the format \"Processing: {number}\". After printing all numbers in the original list order, the function should return the sum of all numbers in the list."
    },
    {
        "instruction": "Develop a mechanism (e.g., a function or a context manager) that can execute another function and capture any text printed to standard output by that function during its execution. The captured text should be returned as a single string."
    },
    {
        "instruction": "Design a function that receives a sequence (e.g., a list) of values. It must print each value to standard output on a new line, prefixed with \"Processing: \", ensuring the output order strictly matches the input sequence order."
    },
    {
        "instruction": "Create a function that takes one argument and prints it to standard output, formatted as \"data: [argument_value]\". It should not return a value."
    },
    {
        "instruction": "Write a function that accepts two numerical arguments and returns their sum."
    },
    {
        "instruction": "Write a utility (e.g., a function or context manager) that executes a provided zero-argument function and captures any text printed to standard output during its execution. Return the captured text as a single string."
    },
    {
        "instruction": "Write a function that accepts a single numerical value. Inside the function, print a string to standard output formatted as \"data: [input_value]\\n\", where [input_value] is the received number."
    },
    {
        "instruction": "Implement a utility function that takes another function (which prints to standard output) as input. The utility should execute the input function, capture all text printed to standard output during its execution, and return the captured text as a single string."
    },
    {
        "instruction": "Develop a function that accepts any single primitive value (e.g., integer, float, boolean, string). The function must print this value to standard output, ensuring the output format is exactly \"value: [input_value]\\n\"."
    },
    {
        "instruction": "Write a function that takes an integer identifier. The function should print a status message to standard output formatted precisely as \"Processing ID: [identifier]\\n\"."
    },
    {
        "instruction": "Develop a function that takes a numerical scalar. Inside the function, it should create a simple dictionary containing this scalar (e.g., {'content': scalar}). Then, it must print a formatted string to standard output, like \"Processed: [dictionary representation]\"."
    },
    {
        "instruction": "Write a function that takes a single value (e.g., a number). It should construct a dictionary mapping a fixed key (e.g., \"key1\") to this value. The function must then determine the *exact* standard string representation of this dictionary and compare it against a predefined expected string format. Return `True` if they match, `False` otherwise."
    },
    {
        "instruction": "Implement a utility function or context manager that executes a given function (known to print to standard output) and captures all text printed by it, returning the captured text as a single string."
    },
    {
        "instruction": "Create a function that accepts a single numerical value and returns a dictionary where the key is a predefined string (e.g., \"payload\") and the value is the input number."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (list of lists) and returns a multi-line string representation. Each inner list should be on a new line, enclosed in square brackets, with elements right-aligned within columns and separated by spaces. The entire output should also be enclosed in square brackets."
    },
    {
        "instruction": "Write a function that takes two multi-line strings as input. Compare them line by line, ignoring leading/trailing whitespace on each line. Return `True` if the core content of corresponding lines is identical for all lines, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that formats a 2D numerical array into a multi-line string. It must calculate the required width for each column based on the widest element in that column across all rows, ensuring all elements are right-aligned within their calculated column width. Use standard bracket notation for rows and the overall array."
    },
    {
        "instruction": "Write a function that creates and returns a 2D numerical array (e.g., list of lists) with given row and column counts. Initialize each row with the same sequence of integers starting from 1 up to the column count."
    },
    {
        "instruction": "Create a function that accepts a 1D array of floats and an integer specifying precision. Return a string representation where each number is rounded to the given number of decimal places."
    },
    {
        "instruction": "Develop a function that takes a 1D array of floats, a precision value (integer), and a boolean flag indicating whether to suppress small numbers. Return a formatted string representation applying both the specified precision and suppressing small numbers (representing them as zero)."
    },
    {
        "instruction": "Implement a function that takes a 1D array of floats and returns its string representation. In the output string, numbers smaller in magnitude than a predefined small threshold (e.g., 1e-5) should be represented as exactly zero (e.g., \"0.\" or \"0.0\" depending on other formatting)."
    },
    {
        "instruction": "Write a function that takes a 1D array of floating-point numbers and returns its string representation using default scientific notation formatting for applicable values."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical array and applies a simple transformation (e.g., adding 1) to each element. The function should then print the *original* element and the *transformed* element for each entry, like 'Original: x, Transformed: y'."
    },
    {
        "instruction": "Create a function that accepts a 1D array (e.g., of numbers or strings). It should return a new list where each element is a string formatted as 'Processing: {}', with the corresponding item from the input array filling the placeholder."
    },
    {
        "instruction": "Write a function that takes a 1D array of numbers. For each number in the array, it should print a message to the console in the format 'Item: <number>', followed by a newline."
    },
    {
        "instruction": "Write a function that accepts two arguments: a 1D array and a simple function `element_processor`. The main function should iterate through the 1D array, call `element_processor` on each element, and print whatever `element_processor` prints for every element in the input array."
    },
    {
        "instruction": "Write a function that takes a format string (like \"Data: {} and {}\") and two arguments (e.g., a number and a list/array). It should return a new string with the arguments substituted into the format string's placeholders. Example: `format_data(\"Item: {}, Values: {}\", 5, [10])` should return `\"Item: 5, Values: [10]\"`."
    },
    {
        "instruction": "Develop a function that generates a sequence of integers starting from 0 up to (but not including) a given positive integer `N`. Return the result as a 1D array or list."
    },
    {
        "instruction": "Write a function that takes a 1D array (e.g., `[0, 1, 2]`) and converts it into a 2D array containing a single row and multiple columns. Example: Input `[0, 1, 2]` (size 3) should result in a 2D array of shape `(1, 3)` like `[[0, 1, 2]]`."
    },
    {
        "instruction": "Create a function that pairs elements from a 1D array with corresponding column slices from a 2D array. Given `array1` (1D, size N) and `array2` (2D, shape MxN), the function should yield N pairs. The i-th pair should consist of `array1[i]` and the i-th column of `array2` (as a 1D array of size M)."
    },
    {
        "instruction": "Implement a function that takes one numerical input. Inside the function, it should perform a side effect by printing the input value using the format \"Input value: {input}\". The function must return the input value unchanged."
    },
    {
        "instruction": "Define a function `process(value, mode)` that takes a numerical `value` and a string `mode` ('direct' or 'derived'). If `mode` is 'direct', print \"Direct: {value}\" and return `value`. If `mode` is 'derived', assume an associated 'delta' value exists (e.g., `value + 1`), print \"Derived: {value} with delta {delta}\", and return both `value` and `delta`."
    },
    {
        "instruction": "Create a function that takes two numerical values, `val1` and `val2`. It should print a string formatted as \"Pair: {val1} {val2}\" to the console. The function does not need to return anything."
    },
    {
        "instruction": "Design a function that accepts two numerical arguments, `base_val` and `change_val`. It must print these values to the console in the format \"Update values: {base_val} {change_val}\". The function should then return both the `base_val` and `change_val` values, perhaps as a tuple or list."
    },
    {
        "instruction": "Create a function `outer_func` that takes a scalar input. Inside `outer_func`, define and immediately call an `inner_func` which also takes the scalar input. `inner_func` should print the input value with a specific label (e.g., 'Inner execution with: <value>') and return the input value. `outer_func` should return the value it received from calling `inner_func`."
    },
    {
        "instruction": "Define two functions. The first function ('forward_pass') takes a scalar `x`. It should print a message including `x` (e.g., 'Forward input: <x>') and return a tuple containing `x` (as the result) and `x` again (as intermediate data). The second function ('backward_pass') takes two scalars: the intermediate data from the first function and an incoming 'sensitivity' value. It should print a message including both values (e.g., 'Backward inputs: <data>, <sensitivity>') and return the incoming 'sensitivity' value."
    },
    {
        "instruction": "Create a function that accepts a single scalar value. Inside the function, print a message displaying this value (e.g., 'Input value: <value>'). The function should then return the original scalar value."
    },
    {
        "instruction": "Implement a utility function that executes a given function (passed as an argument) with a specific scalar input value (also passed as an argument). This utility must capture any text printed to the standard output during the execution of the given function and return this captured text as a string."
    },
    {
        "instruction": "Write a function that takes a list of numbers. For each number in the list, print the number itself to the console."
    },
    {
        "instruction": "Develop a function that receives a starting count (integer) and a sequence of elements (e.g., a list). Iterate through the sequence. For each element, print the current count and the element. After printing, increment the count. Ensure the output for each step appears on a new line."
    },
    {
        "instruction": "Create a function that accepts an initial integer 'carry' value and a list of integers 'items'. Iterate through 'items'. In each step, print the current 'carry' value and the current item using the format 'carry: {c}, item: {i}'. Then, update the carry by adding 1 to it. The function doesn't need to return anything."
    },
    {
        "instruction": "Implement a function that takes an initial integer state and a list of input integers. It should process the list sequentially. For each input integer, calculate a result integer by adding 1 to the input. Also, update the state by adding 1 to its current value. The function should return a tuple containing the final state and a new list containing all the calculated result integers."
    },
    {
        "instruction": "Write a function that takes an initial integer `start_val` and a count `n`. It should loop `n` times (index `i` from 0 to `n-1`). In each loop, it prints \"Loop: {i}\" and \"State: {current_val}\" on separate lines, then increments `current_val` (starting from `start_val`). Also, create a testing mechanism that runs this function, captures its output, and confirms that the captured output contains *exactly* the expected lines (e.g., \"Loop: 0\", \"State: start_val\", \"Loop: 1\", \"State: start_val+1\", etc.), even if the lines appear out of order in the captured output. The testing mechanism should return `True` for a match, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes an initial integer `start_value` and a positive integer `num_iterations`. The function should simulate a loop running `num_iterations` times, where a value, initially `start_value`, is incremented by 1 in each iteration. Return the final value after all iterations."
    },
    {
        "instruction": "Create a function that accepts a positive integer `count`. Inside the function, loop from 0 up to (but not including) `count`. In each iteration `i`, print the string \"Processing item: {i}\" to the console, replacing `{i}` with the current loop index."
    },
    {
        "instruction": "Develop a utility function that accepts another function `target_func` (which takes no arguments and prints to standard output) as input. Your utility function should execute `target_func`, capture everything it prints to standard output, and return the captured output as a single string."
    },
    {
        "instruction": "Create a function that accepts an integer `current_value` and an integer `threshold`. It should return `True` if `current_value` is strictly less than `threshold`, and `False` otherwise."
    },
    {
        "instruction": "Implement a generic loop function `custom_while`. It takes an initial `state`, a `condition_checker` function (input: state, output: boolean), and a `body_processor` function (input: state, output: new_state). The loop should start with `initial_state`. In each step, it first checks `condition_checker(current_state)`. If true, it computes `new_state = body_processor(current_state)`, updates the current state to `new_state`, and continues. If false, the loop terminates, and the function returns the final state."
    },
    {
        "instruction": "Write a function that takes an integer `start_value` and an integer `limit`. The function should return the first integer value, starting from `start_value` and incrementing by 1, that is *not* less than `limit`."
    },
    {
        "instruction": "Develop a utility that executes a given function `target_func` with a specific input `initial_input`. The `target_func` is expected to print messages to standard output during its execution. The utility should capture all printed output generated by `target_func` and return it as a single string, preserving the order and formatting of the prints."
    },
    {
        "instruction": "Create a function that takes a single number and returns `True` if the number is strictly less than 10, and `False` otherwise."
    },
    {
        "instruction": "Design a function that takes an initial numerical state and two helper functions: a 'condition' function (evaluates the state and returns True/False) and a 'body' function (transforms the state). The function should repeatedly evaluate the condition; if True, it executes the body function to update the state and repeats. It must also collect a record (e.g., in a list) of the state *each time* the condition function is evaluated. Return both the final state and the list of recorded states from condition checks."
    },
    {
        "instruction": "Implement a function that accepts a starting integer. It should repeatedly increment the integer by 1 as long as its value remains less than 10. The function should return the final value of the integer after this process stops."
    },
    {
        "instruction": "Write a function that takes a starting integer. It should simulate a loop that increments the integer by 1 in each step, continuing as long as the integer is less than 10. The function must return a list containing all the integer values that were evaluated against the 'less than 10' condition, including the first value that failed the condition."
    },
    {
        "instruction": "Create a function that accepts two arguments: a string label and a value. The function should print a formatted string to the standard output in the format 'label: value\\n'."
    },
    {
        "instruction": "Develop a function that takes a number. If the number is less than 5, it must print 'Action A: [number]' to standard output. If the number is 5 or greater, it must print 'Action B: [number]' to standard output. The function should return the original number."
    },
    {
        "instruction": "Write a function that takes a single number as input. If the number is strictly less than 5, return the string 'True Path'. Otherwise, return the string 'False Path'."
    },
    {
        "instruction": "Create a function that accepts a boolean value, two callable functions (func_a, func_b), and an argument. If the boolean is true, execute func_a with the argument. Otherwise, execute func_b with the argument. Ensure any side effects (like printing) within the executed function occur, and return the value produced by the executed function."
    },
    {
        "instruction": "Design a function that takes an integer index, a list of functions, and an initial value. Each function in the list accepts the value, prints a unique message identifying itself along with the value, and returns the value. Your main function should select the correct function based on the index, execute it with the value, capture the printed output, and return both the final value and the captured output string."
    },
    {
        "instruction": "Write a function that takes an integer index and a list of functions (each accepting a single argument). The function should execute the function at the specified index using a provided argument and return the result. Assume the index is always valid."
    },
    {
        "instruction": "Develop a utility function that executes a target function (which takes no arguments but may print to standard output). This utility must capture any text printed to standard output during the target function's execution and return the captured text as a single string."
    },
    {
        "instruction": "Implement a function that simulates conditional execution. It takes an integer index, a tuple of functions (each taking one argument), and an argument value. It should execute the function from the tuple corresponding to the index, passing the argument value to it, and return whatever the executed function returns. Handle the case where the index might be out of bounds for the tuple (e.g., return None or raise an appropriate error)."
    },
    {
        "instruction": "Execution Mode Validation. Develop a function `validate_execution_settings` that accepts two boolean parameters: `parallel_mode` and `ordered_output_required`. If both parameters are `True`, the function must raise a `ValueError` stating that ordered output cannot be guaranteed in parallel mode. Otherwise, the function should return `None`."
    },
    {
        "instruction": "Conditional Ordered Operation. Write a function `perform_ordered_task` that takes a list `data` and a boolean `is_parallel_context`. The function simulates a task requiring strict sequential order (like appending data to a shared log in order). If `is_parallel_context` is `True`, the function must raise a `ValueError` indicating that ordered tasks are not supported in this context. If `is_parallel_context` is `False`, it should simulate the ordered task successfully and return `True`."
    },
    {
        "instruction": "Error Detection. Write a function `check_value_error` that accepts another function `func` and a list of arguments `args`. Call `func(*args)`. Return `True` if a `ValueError` is raised during the call, and `False` otherwise."
    },
    {
        "instruction": "Sequentially Numbered Output. Implement a function `display_numbered_items` that takes a list of strings. It should print each string to the console, prefixed by its 1-based sequential number and a period (e.g., \"1. First item\", \"2. Second item\"). The output must strictly follow the input list order."
    },
    {
        "instruction": "Simulate ordered, sequential output generation based on an input array. Given a 1D numerical array (e.g., `[0, 1, 2]`), process each element `x` strictly in array order. For each `x`, first generate string `S1` using format 'Value: {}' and `x`, then immediately generate string `S2` using format 'Value+Offset: {}' and `x+2`. Concatenate all generated strings (`S1` then `S2` for the first element, then `S1` then `S2` for the second, etc.) into a single string, with each part separated by a newline character."
    },
    {
        "instruction": "Simulate collecting output from multiple independent workers. Write a function that takes a list of input values. For each value, create a formatted string (e.g., 'Result: {}'). Return a collection (like a list or set) containing all the generated strings. The order of strings in the output collection is not guaranteed or specified."
    },
    {
        "instruction": "Write a function that takes a template string containing one placeholder (like \"{}\") and a single value (number or string), returning the formatted string by replacing the placeholder with the value."
    },
    {
        "instruction": "Create a function that accepts a non-negative integer `N` and returns a 1D numerical array containing the sequence of integers from 0 up to `N-1`."
    },
    {
        "instruction": "Develop a function that receives a 1D numerical array as input. The function should first print the array's representation (e.g., `[0 1 2 3]`) followed by a newline, and then return the original, unmodified input array."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array, calculates the sum of the squares of its elements (equivalent to the dot product of the vector with itself), prints the resulting scalar value followed by a newline, and finally returns the calculated scalar value."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and prints its elements separated by spaces, enclosed in square brackets, followed by a newline. Example: input `[1, 2, 3]` should result in the string `[1 2 3]\\n` being printed."
    },
    {
        "instruction": "Create a function that accepts a single numerical scalar value and prints its string representation followed by a newline character. Example: input `140` should result in the string `140\\n` being printed."
    },
    {
        "instruction": "Write a function that simulates a loop running exactly 5 times. Inside the loop, it should simply increment a counter starting from 0. The function should return the final value of the counter (which should be 5)."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and an integer `n` (e.g., 5). The function should repeatedly apply an element-wise increment-by-one operation to the array `n` times and return the final modified array."
    },
    {
        "instruction": "Write a function that accepts an initial 1D numerical array. The function should perform the following steps exactly 5 times: 1. Print the current array's contents to the console. 2. Update the array by adding 1 to each of its elements. After the 5 iterations are complete, the function should return the *final* state of the array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a new array where each element is the corresponding input element incremented by 1."
    },
    {
        "instruction": "Develop a function that accepts a list or array of initial numbers. For each number in the input collection, it should execute a loop that continues as long as the number is less than a specific limit (e.g., 3). Inside the loop, it should print a status message containing the current number and then increment it. The function doesn't need to return anything, but it must perform the described print actions for each initial number."
    },
    {
        "instruction": "Simulate the execution of multiple independent counting tasks. Write a function that takes a list of starting numbers. For each starting number, simulate a task that increments the number in a loop as long as it's below a threshold (e.g., 4), printing the task identifier (e.g., its initial value or index) and the current number at each step. Collect all printed messages into a single list or string. The key requirement is that messages from different tasks can be interleaved in the final output, reflecting potential concurrency, but all messages for each task must be present. Return the collected log of messages."
    },
    {
        "instruction": "Write a function that takes a single number as input. Inside the function, print a message containing this number (e.g., \"Current value: {number}\"). The function should then return the input number incremented by one."
    },
    {
        "instruction": "Implement a function that takes a starting number. It should repeatedly check if the number is less than a fixed threshold (e.g., 5). In each iteration where the condition is true, it should print a message including the current number and then increment the number. The function should stop when the number is no longer less than the threshold and return the final number."
    },
    {
        "instruction": "Write a function that accepts a format string containing a single named placeholder (e.g., 'User: {name}') and a dictionary providing the value for that placeholder (e.g., {'name': 'Alice'}). Return the fully formatted string."
    },
    {
        "instruction": "Develop a function that tries to format a string containing positional placeholders (e.g., 'Coordinates: {}, {}') but receives fewer arguments than placeholders. The function should catch the specific error related to insufficient arguments and return the boolean value False. If formatting is successful, return True."
    },
    {
        "instruction": "Write a function `process_message` that takes a message template string, an optional data value, and an optional data name string. If both `data_value` and `data_name` are provided, format the template assuming it has one named placeholder corresponding to `data_name` (e.g., 'Record {id}: {value}'). If only `data_value` is provided, format the template assuming it has one positional placeholder (e.g., 'Data: {}'). If formatting fails due to incorrect placeholder type or missing arguments/keys, return 'Formatting Error'. Otherwise, return the formatted string."
    },
    {
        "instruction": "Implement a function that attempts to format a string using a named placeholder (e.g., 'Input: {value}'). The function receives the format string and a dictionary. If the dictionary is missing the key required by the placeholder, the function should catch the specific error related to the missing key and return the boolean value False. Otherwise, it should return True."
    },
    {
        "instruction": "Implement a function that takes a format string with positional placeholders and a variable number of positional arguments. The function should format the string but MUST raise a custom error (e.g., 'ArgumentError') if the number of provided positional arguments exceeds the number of placeholders in the format string. Otherwise, return the formatted string."
    },
    {
        "instruction": "Write a function that takes a format string containing unnamed, positional placeholders (e.g., 'Coordinates: ({}, {})') and a list or tuple of values. Return the string formatted with the values in the order they appear."
    },
    {
        "instruction": "Write a function that takes a format string containing named placeholders (e.g., 'User: {name}, Age: {age}') and a dictionary of key-value pairs. Return the string formatted with the values from the dictionary corresponding to the placeholders."
    },
    {
        "instruction": "Create a function that accepts a format string with named placeholders and keyword arguments. The function should format the string but MUST raise a custom error (e.g., 'ArgumentError') if any provided keyword argument does not correspond to a placeholder in the format string. Otherwise, return the formatted string."
    },
    {
        "instruction": "Write a function `restricted_operation(data)` that simulates a restricted environment. If the input `data` is a sequence type (like a list or tuple), the function must raise a `ValueError` with a message including the phrase 'Invalid dynamic formatting'. If the input `data` is not a sequence type (e.g., number, string), the function should complete successfully without raising an error."
    },
    {
        "instruction": "Develop a function `validate_error_text` that accepts a function `action`, its arguments, and an `expected_message_part` string. Call `action` with its arguments. If a `ValueError` is raised, return `True` if its error message contains `expected_message_part`, otherwise return `False`. If no `ValueError` is raised, return `False`."
    },
    {
        "instruction": "Write a function that takes a single argument of any type and returns a formatted string 'Processing item: [item representation]'."
    },
    {
        "instruction": "Implement a function `check_for_value_error` that takes a function `func` and its arguments. Execute `func` with the arguments. Return `True` if and only if a `ValueError` is raised during the execution, otherwise return `False`."
    },
    {
        "instruction": "Create a function `elementwise_square(input_array)` that accepts a 1D numerical array and returns a new 1D array containing the square of each element from the input."
    },
    {
        "instruction": "Develop a function `map_resources(resource_ids)` that takes a list of unique resource identifiers (e.g., strings like 'unit_A', 'unit_B'). It should return a dictionary mapping each resource identifier to a unique integer index starting from 0."
    },
    {
        "instruction": "Implement a function `verify_configuration(config_details, check_function)` that takes a dictionary `config_details` representing configuration settings and a function `check_function`. It should call `check_function(config_details)`. Return `True` if `check_function` returns `True` (or executes without error), and `False` otherwise. The `check_function` might verify specific keys or expected properties within the configuration."
    },
    {
        "instruction": "Write a function `apply_callback(data, callback)` that takes any data structure `data` and a function `callback`. It should execute `callback(data)` and return `True` if the callback executes successfully (doesn't raise an error), `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a numerical array and a callback function as input. The function must invoke the callback, passing the original input array to it, and then return."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical array and a callback function. It should compute the element-wise square of the input. Crucially, *before* returning the result, it must call the provided callback, passing some descriptive information about the *input* array (like its size or the array itself) to the callback. The function should finally return the squared array."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new 1D array containing the element-wise square of the input."
    },
    {
        "instruction": "Develop a higher-order function `run_and_check_callback`. This function accepts another function `func_to_run` and an `input_value`. Assume there's a mechanism (like a mutable state or global variable) that `func_to_run` might modify if a specific internal callback is triggered. `run_and_check_callback` should reset this state, execute `func_to_run(input_value)`, and return `True` if the state indicates the callback was triggered, `False` otherwise."
    },
    {
        "instruction": "Implement a function that accepts any multi-dimensional numerical array and returns a new array of the same shape, where each element is the square of the corresponding element in the input array."
    },
    {
        "instruction": "Create a function that simulates checking the layout properties of a distributed array representation. It takes an object describing the layout (e.g., containing attributes like `partition_dimension: 0`, `partition_count: 2`). The function should return `True` if the layout indicates partitioning along the first dimension (index 0) using exactly 2 partitions, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes a numerical array and a callback function. This function should extract predefined layout information associated with the array (assume this information exists, e.g., how it's conceptually partitioned) and pass this layout information to the provided callback function for processing or validation."
    },
    {
        "instruction": "Write a function that creates and returns a 3D numerical array with dimensions (2, 2, 2), initializing its elements with consecutive integers starting from 0 (i.e., 0, 1, 2, ...)."
    },
    {
        "instruction": "Develop a function that accepts a metadata object (e.g., a dictionary or simple object) containing expected properties like 'distribution_type' (string) and 'partition_count' (integer). The function should validate if the object's properties match predefined expected values (e.g., 'distribution_type' is 'Named' and 'partition_count' is 2). Return True if all checks pass, False otherwise."
    },
    {
        "instruction": "Write a function that simulates splitting a multi-dimensional numerical array along a specified axis into a given number of partitions. It should take the array, the axis index, and the number of partitions as input. Return a list containing the resulting sub-arrays (partitions). Assume the dimension size along the specified axis is evenly divisible by the number of partitions."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array and returns a new array of the same shape where each element is the square of the corresponding element in the input array."
    },
    {
        "instruction": "Create a function that takes an integer `N` and a tuple representing a target shape. The function should generate a 1D array containing integers from 0 to `N-1` and then reshape it into the specified target shape. Ensure the total number of elements `N` matches the product of the dimensions in the target shape."
    },
    {
        "instruction": "Write a function `validate_callback` that takes one argument. It must raise a `TypeError` with a message containing the phrase \"callable expected\" if the provided argument is not callable. If the argument is callable, return `True`."
    },
    {
        "instruction": "Create a function that accepts a single argument. Raise a `TypeError` if the argument is *not* callable. If it is callable, the function should return `None`."
    },
    {
        "instruction": "Implement a function `attempt_call` that takes one argument `target`. If `target` is callable, call it with no arguments and return the result. If `target` is not callable, raise a `TypeError`."
    },
    {
        "instruction": "Write a function that takes one argument. Return `True` if the argument is callable (e.g., a function), and `False` otherwise."
    },
    {
        "instruction": "Develop a function that generates a specified number (`n`) of 2D numerical arrays, each with a given `height` and `width`. Fill these arrays with pseudo-random floating-point numbers (e.g., scaled values from a standard distribution). Return a list containing the `n` generated arrays."
    },
    {
        "instruction": "Write a function that takes an initial integer counter and a maximum integer value. The function should simulate a loop, incrementing the counter in each step, until the counter equals the maximum value. It should return the final counter value."
    },
    {
        "instruction": "Write a function that processes a list of input numerical arrays. For each input array, apply an iterative update function (like the one described in Task 2) for a fixed number of steps (or until a condition is met). Collect the final state (the updated array) from each process. Finally, compute and return the element-wise average of all collected final arrays."
    },
    {
        "instruction": "Implement a function that takes a list of numerical arrays (all with identical shapes) and computes their element-wise mean. Return the resulting array, which should have the same shape as the input arrays."
    },
    {
        "instruction": "Implement a function that calculates and returns the mathematical cosine of a single floating-point number input."
    },
    {
        "instruction": "Write a function that accepts a string message and prints it directly to the standard output console. The function should not return any value."
    },
    {
        "instruction": "Write a function `capture_print_output`. This function accepts another function `target_func` (which takes no arguments) as input. `capture_print_output` should execute `target_func`, capture any text `target_func` prints to standard output, and return this captured text as a single string."
    },
    {
        "instruction": "Implement a function `create_linear_approximation`. It accepts two arguments: a function `f` (which maps a single numerical scalar to a single numerical scalar) and a numerical scalar `x`. `create_linear_approximation` should return two results: first, the value `y = f(x)`, and second, a *new* function `df`. This `df` function must accept a single numerical scalar `t` and return the result of `t` multiplied by the derivative of `f` evaluated at the original point `x`."
    },
    {
        "instruction": "Create a function `check_dimension_type` that accepts one argument. It should raise a `TypeError` with a descriptive message if the argument is a numerical array that is *not* a 0-dimensional integer scalar (i.e., not effectively a single integer). The function should pass silently otherwise (e.g., for integer scalars or potentially other allowed types like a symbolic placeholder)."
    },
    {
        "instruction": "Implement a function `get_maximum_dimension` that takes two integer scalar arguments representing dimension sizes and returns the larger of the two."
    },
    {
        "instruction": "Write a function `compare_dimensions` that takes two arguments, `dim1` and `dim2`. If both are integer scalars, return their maximum. If one argument is a special object `SymbolicDim` (assume this class exists) and the other is an integer scalar, return `SymbolicDim`. Raise a `TypeError` if either argument is a non-scalar numerical array."
    },
    {
        "instruction": "Define a simple placeholder class `SymbolicDimension`. Implement two functions, `safe_max_dim(a, b)` and `safe_min_dim(a, b)`. Both functions accept two arguments which can be integer scalars or instances of `SymbolicDimension`. If both arguments are integers, return the respective max or min. If either argument is `SymbolicDimension`, return a `SymbolicDimension` instance. Crucially, both functions must first validate that neither input is a numerical array containing more than one element; if this validation fails, they must raise a `TypeError`."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array `matrix`. If the sum of its elements is positive, return the `matrix` itself. Otherwise, return a new matrix of the same shape as `matrix` but filled with zeros."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns `True` if the sum of all its elements is strictly greater than zero, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts two numerical arrays: `matrix_a` (2D, shape M, N) and `vector_b` (1D, shape N,). Check if the sum of all elements in `matrix_a` is greater than 0. If true, reshape `vector_b` to be compatible for element-wise addition with `matrix_a` (e.g., shape 1, N, allowing broadcasting), perform the addition, and return the resulting (M, N) array. If false, return a new 2D array of shape (M, N) filled with zeros."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `A` (shape M, N) and a 1D array `B` (shape N,). It should reshape `B` into a compatible 2D array (e.g., shape 1, N) and then add it element-wise (potentially using broadcasting) to `A`. Return the resulting (M, N) array."
    },
    {
        "instruction": "Create a function that accepts a positive integer `n` and returns a 1D numerical array containing the integer sequence from 0 up to `n-1` (inclusive)."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array `arr` and an integer limit `N`. Initialize a counter to 0. While the counter is less than `N`, update the array by adding a sequence `[0, 1, ..., len(arr)-1]` to it element-wise, and increment the counter. Return the final modified array after the loop finishes."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays of the same length. It should return a new 1D array where each element is the sum of the corresponding elements from the input arrays."
    },
    {
        "instruction": "Write a function that takes an integer limit `N`. The function should simulate a counter starting at 0 and incrementing by 1 until it reaches `N`. Return the final count (`N`)."
    },
    {
        "instruction": "Write a function `apply_batch(func, data, axis)` where `func` is a function operating on arrays, `data` is a 3D numerical array, and `axis` is an integer (0, 1, or 2). The function should iterate through slices of `data` along the specified `axis`, apply `func` to each slice (assuming `func` takes a 2D slice and returns a 1D array), and return a new array formed by stacking these 1D results together."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array `A`. It should compute the sum of elements along the first axis (axis 0). Then, multiply this resulting 1D array element-wise by the number of rows in the original array `A`. Return the final 1D array."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array `x`. It should return a single scalar value equal to the sum of all elements in `x` multiplied by the number of elements in `x`."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays of the same length, `values` and `directions`. It should return a tuple containing two scalar values: the sum of elements in `values`, and the sum of elements in `directions`."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array of any shape and returns the sum of all its elements as a single scalar value."
    },
    {
        "instruction": "Implement a function that performs batch matrix multiplication. It takes two 4-dimensional numerical arrays, `A` (shape B1, B2, M, K) and `B` (shape B1, B2, K, N), and returns their product computed along the last two dimensions, resulting in an array of shape (B1, B2, M, N)."
    },
    {
        "instruction": "Write a function that takes a 4-dimensional numerical array (e.g., dimensions B1, B2, D1, D2) and returns a new array where the last two dimensions are swapped (output shape B1, B2, D2, D1)."
    },
    {
        "instruction": "Define a pair of functions simulating a custom differentiation rule. The forward function `fwd(X)` should compute `Y = X @ transpose(X)` (using the operation from Task 3) and return both `Y` and `X` (as a 'residual'). The backward function `bwd(residual, grad_Y)` should take the saved `X` (residual) and the incoming gradient `grad_Y` (shape B1, B2, D1, D1) and compute the gradient `grad_X` (shape B1, B2, D1, D2) using the appropriate matrix multiplications based on the chain rule for the forward operation."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns `True` if the sum of its elements is strictly positive, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes two numerical arrays, `arr2d` (shape M, N) and `arr1d` (shape N,). If the sum of all elements in `arr2d` is greater than zero, the function should return the result of element-wise addition of `arr2d` and `arr1d` (with broadcasting). Otherwise, it should return a new 2D array of the same shape as `arr2d` filled with zeros."
    },
    {
        "instruction": "Implement a function that performs element-wise addition between a 2D array (shape M, N) and a 1D array (shape N,). The 1D array should be effectively broadcast across the rows of the 2D array. Return the resulting 2D array (shape M, N)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns the sum of all its elements."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and an integer representing an original length. Assume the input array's length is greater than or equal to the original length. Return a new 1D array containing only the first 'original length' elements of the input array."
    },
    {
        "instruction": "Create a function that accepts a numerical array (of any dimension) and a scalar number. Return a new array of the same shape where the scalar has been added element-wise to the input array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and pads it with zeros at the end so its total length is the smallest even number greater than or equal to its original length. Return the padded array."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array guaranteed to have an even number of elements, say 2N. Reshape this array into a 2D array with 2 rows and N columns. Return the 2D array."
    },
    {
        "instruction": "Write a function that takes a numerical array of any dimension containing only integers. Return a new array of the exact same shape but where every element has been converted to a floating-point type."
    },
    {
        "instruction": "Develop a function that takes two arguments: 1) a tuple containing a 3D integer array (`int_arr`) and a 3D float array (`float_arr`) of the same shape, and 2) a 1D boolean array (`bool_arr`). The function must return a tuple containing exactly three items in this order: the original `int_arr`, the original `bool_arr`, and a new 3D float array calculated as `int_arr * 2.0 * float_arr` (perform element-wise)."
    },
    {
        "instruction": "Write a function that takes a 3D integer array and a 3D float array of the same shape. It should return a new 3D float array where each element is the product of the corresponding integer element (converted to float), the float element, and the constant 2.0."
    },
    {
        "instruction": "Write a function that processes three input arrays: a 3D integer array `I`, a 3D float array `F` (same shape as `I`), and a 1D boolean array `B`. It should return a tuple of three 'sensitivity' arrays corresponding to the inputs. The sensitivity for `I` must be a 3D integer array of zeros (same shape as `I`). The sensitivity for `F` must be a 3D float array calculated as `I * 2.0` (element-wise, shape like `F`). The sensitivity for `B` must be a 1D boolean array of all False values (same shape as `B`)."
    },
    {
        "instruction": "Develop a function that calculates the output shape after concatenating two 2D arrays column-wise. Input shapes are given as tuples, possibly containing a symbolic dimension represented by a string (e.g., `('a', 5)` and `('a', 10)`). Return the resulting shape tuple (e.g., `('a', 15)`)."
    },
    {
        "instruction": "Write a function to determine the shape of a 2D array after slicing columns. Input is the original shape tuple (e.g., `(M, N)` or `('a', N)`), the starting column index, and the number of columns to keep. Return the resulting shape tuple (e.g., `(M, num_cols)` or `('a', num_cols)`)."
    },
    {
        "instruction": "Implement a function that takes two 2D numerical arrays, `X` (shape M x N) and `Y` (shape M x P). It should return a new 2D array formed by concatenating `X` side-by-side with the first `k` columns of `Y`. Assume `k` is less than or equal to `P`. The output shape should be M x (N + k)."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays, A (shape M x N1) and B (shape M x N2), and returns a new 2D array by concatenating them column-wise (side-by-side), resulting in shape M x (N1 + N2)."
    },
    {
        "instruction": "Develop a function that generates a 2D numerical array of specified dimensions (`rows`, `cols`). The array should be filled with sequential floating-point numbers starting from 0.0, arranged row by row."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays, `arr1` (shape M, N) and `arr2` (shape K, N), and returns a new 2D array by stacking `arr2` below `arr1` (vertical concatenation). The output shape should be (M+K, N)."
    },
    {
        "instruction": "Design a function that takes symbolic shape representations for two 2D arrays (e.g., 'rows1, cols' and 'rows2, cols') and returns the symbolic shape representation of the array resulting from their vertical concatenation (e.g., '(rows1 + rows2), cols'). Assume the number of columns is identical."
    },
    {
        "instruction": "Implement two array processing functions: `process_pair` takes two 2D arrays (A, B) and returns a tuple `(A, vertical_concat(A, B))`. `combine_pair` takes two 2D arrays (C, D) and returns `vertical_concat(C, D)`. Write code to demonstrate that applying `combine_pair` to the results of `process_pair(X, Y)` yields the same numerical result as directly computing `combine_pair(*process_pair(X, Y))`, using sample input arrays X and Y."
    },
    {
        "instruction": "Define a function that accepts one positional numerical array argument (`main_data`) and one keyword-only numerical array argument (`adjustment`). The function must return the element-wise sum of `main_data` and `adjustment`. Ensure the function signature strictly enforces that `adjustment` is passed using its name."
    },
    {
        "instruction": "Implement a function that accepts two numerical arrays, `arr1` and `arr2`. It should return a new array representing the element-wise sum of `arr1` and `arr2`. Assume the arrays are compatible for element-wise addition (e.g., same shape or broadcastable)."
    },
    {
        "instruction": "Create a function that takes two 1D numerical arrays, `vec_a` (size N) and `vec_b` (size M, where M could be 1 or N). Calculate the element-wise sine of `vec_b`. Then, add this result element-wise to `vec_a`, applying broadcasting rules if M=1 and N>1. Return the final 1D array of size N."
    },
    {
        "instruction": "Write a function that takes a single numerical array as input and returns a new array where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical array. If its length is between 2 and 4 (inclusive), return the slice containing elements from index 1 up to index 3. Otherwise, raise a `ValueError`."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and two integers representing a minimum and maximum length. Return `True` if the array's length falls within this range (inclusive), `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new array containing the elements from index 1 up to (but not including) index 3. Assume the input array is always long enough."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array. Check if its length `L` satisfies `L >= 2` and `L <= 4`. If yes, return the slice from index 1 with a size of 2 (elements at indices 1 and 2). If no, raise a `ValueError`. Handle potential errors if the slice indices are out of bounds for the given array length (e.g., raise `IndexError`)."
    },
    {
        "instruction": "Design a function that accepts a description of expected 2D array dimensions using two symbolic variable names (e.g., 'a', 'b') and a constraint string involving these variables (e.g., 'max(a, b) == b'). This function should return *another function* (a checker). The checker function takes a concrete 2D array. When called, it verifies if the concrete array's dimensions satisfy the constraint (substituting dimensions for 'a' and 'b'). If satisfied, it returns `True`; otherwise, it raises a `ValueError` indicating the constraint violation and the differing values."
    },
    {
        "instruction": "Develop a function that receives a 2D numerical array. It should verify if the first dimension (e.g., rows) is less than or equal to the second dimension (e.g., columns). Return `True` if this condition holds, `False` otherwise."
    },
    {
        "instruction": "Implement a function that compares an expected outcome with an actual outcome based on a descriptive string. It takes `description` (string), `expected_value`, and `actual_value`. If `expected_value` is not equal to `actual_value`, raise a `ValueError` with a message like: \"Constraint check failed: '[description]' evaluated to [actual_value], expected [expected_value].\" Otherwise, do nothing."
    },
    {
        "instruction": "Write a function that takes two positive integers, `dim1` and `dim2`. Return `True` if `dim1` is less than or equal to `dim2`, and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a positive integer `N` and returns a 2D numerical array of shape `N x N` containing only the value 1."
    },
    {
        "instruction": "Write a function that takes two inputs: 1) a 2D numerical array, and 2) a string representing a shape constraint (e.g., \"rows == columns\"). The function should verify if the dimensions of the input array satisfy the given constraint. Return `True` if the constraint is met, `False` otherwise. Assume the constraint string only involves comparing the two dimensions for equality."
    },
    {
        "instruction": "Develop a function that accepts a 2D numerical array. If the array's dimensions are equal (it's square), the function should return the array itself. If the dimensions are not equal, it should return an empty 1D array."
    },
    {
        "instruction": "Write a function that accepts one argument, a numerical array, and returns the same array without modification."
    },
    {
        "instruction": "Write a function that compares an actual numerical result against an expected numerical result for a specific check. If they differ, raise a value error including a description of the check, the expected value, and the actual value found (e.g., \"Constraint check 'max(a, b) == 4' failed: expected 0, found -1\"). If they match, the function should complete without error."
    },
    {
        "instruction": "Implement a function that validates input dimensions against symbolic constraints. It takes a dictionary mapping symbolic dimension names (e.g., 'a', 'b') to their concrete integer values, and a list of constraint strings (e.g., `'max(a, b) == 4'`, `'a == b'`). Evaluate each constraint. Return `True` if all constraints hold true for the given values, `False` otherwise. Support basic comparisons (`==`) and the `max` function."
    },
    {
        "instruction": "Create a function that takes two positive integers, `val1` and `val2`. Evaluate a predefined mathematical expression involving these values (e.g., `max(val1, val2) - 4`). Return the integer result."
    },
    {
        "instruction": "Develop a function that receives two positive integers, `dim1` and `dim2`. Check if they simultaneously satisfy two conditions: `max(dim1, dim2) == 4` AND `dim1 == dim2`. Return `True` if both hold, `False` otherwise."
    },
    {
        "instruction": "Implement a function that modifies a 1D numerical array in-place. It takes the array, a slice object, and a second 1D array (updater) as input. The updater array must have the same length as the number of elements specified by the slice. The function should add the elements of the updater array to the corresponding elements in the specified slice of the first array."
    },
    {
        "instruction": "Develop a function that takes three arguments: a 1D numerical array to be modified, a slice object, and a second 1D array containing new values. The array of new values must have a length matching the number of elements specified by the slice. The function should overwrite the elements in the specified slice of the first array with the elements from the second array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a slice object. It should return a new 1D array containing only the value 1.0, with a length matching the number of elements selected by the slice from the input array."
    },
    {
        "instruction": "Write a function that performs a specific stateful update sequence on a slice of a 1D numerical array. The function accepts the array and a slice object. It should: 1. Create an array of ones matching the slice's shape. 2. Add these ones to the elements of the input array specified by the slice (update in-place). 3. Read the *updated* values from the slice. 4. Add the array of ones (created in step 1) to these *read* values. 5. Write the final result back into the *original* input array at the location specified by the slice. The function should modify the input array directly."
    },
    {
        "instruction": "Write a function that reshapes a given multi-dimensional numerical array into a 2D array. The function should take the input array and preserve the size of the first dimension, collapsing all remaining dimensions into the second dimension. It must correctly handle input arrays where only the first dimension's size varies between calls (e.g., (4, 2, 3) -> (4, 6) and (6, 2, 3) -> (6, 6))."
    },
    {
        "instruction": "Develop a function that first computes the element-wise sine of a 3D numerical input array (shape D1, D2, D3) and then reshapes the result into a 2D array where the first dimension is preserved (output shape D1, D2*D3)."
    },
    {
        "instruction": "Implement a function that takes a 3D numerical array with shape (D1, D2, D3) and reshapes it into a 2D array with shape (D1, D2*D3)."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and returns a new array where each element is the sine of the corresponding element in the input array."
    },
    {
        "instruction": "Write a function that accepts one positional numerical argument `a` and one keyword numerical argument `b`. Return the sum `a + b`."
    },
    {
        "instruction": "Develop a function that accepts a 1D numerical array `x` (shape N) and a single numerical value `y`. Calculate the sine of `y` and add it to every element of `x`. Return the resulting 1D array (shape N)."
    },
    {
        "instruction": "Design a function that takes one positional 1D numerical array `vec1` (shape N) and one keyword 1D numerical array `vec2` (shape M, where M is 1 or N). Compute the element-wise sine of `vec2`. Add the result to `vec1`, applying broadcasting if M=1. Return the final 1D array (shape N)."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and returns a new 1D array containing the element-wise sine of the input array."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of identical size and returns a new 1D array containing their element-wise sum."
    },
    {
        "instruction": "Implement a function that takes a specific nested structure `( ( [arr1, arr2], [arr3] ), { 'key1': arr4, 'key2': arr5 } )` containing 1D numerical arrays of identical size and returns a single 1D array representing the element-wise sum of all contained arrays."
    },
    {
        "instruction": "Create a function that accepts a specific nested structure `( ( [arr1, arr2], [arr3] ), { 'key1': arr4, 'key2': arr5 } )` containing 1D numerical arrays and returns a flat list `[arr1, arr2, arr3, arr4, arr5]`. Assume all arrays have the same size."
    },
    {
        "instruction": "Develop a function that recursively traverses an arbitrarily nested structure (composed of lists, tuples, dictionaries) and extracts all leaf elements that are 1D numerical arrays into a single flat list. Ensure a consistent traversal order."
    },
    {
        "instruction": "Write a function that takes a dictionary containing one key 'data' mapped to a numerical array. The function should return a new dictionary with one key 'result' mapped to an array where each element is double the corresponding element in the input 'data' array."
    },
    {
        "instruction": "Develop a function that accepts a dictionary {'input_val': array} where 'array' is a numerical array. The function should compute an output dictionary {'output_val': array * 2.0}. Additionally, implement the capability to compute the gradient of the sum of 'output_val' with respect to 'input_val', returning this gradient array which should have the same shape as the input array."
    },
    {
        "instruction": "Design a function that takes a dictionary {'data': array} where 'array' is a 3D numerical array with shape (B, H, W) (B is variable, H, W fixed). The function returns a dictionary {'result': array * 2.0}. Ensure this function can be used within a system that calculates gradients, such that the gradient of sum(result['result']) with respect to input['data'] can be computed and correctly reflects the variable dimension B in its shape (B, H, W)."
    },
    {
        "instruction": "Create a function that accepts a 3D numerical array with shape (B, H, W) where B is a variable dimension, and H, W are fixed integers (e.g., H=3, W=4). The function should return a new array of the same shape (B, H, W), where each element is multiplied by a constant factor (e.g., 2.0)."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and returns a new 1D array containing all the elements of the input array in their original order (flattening). The function should handle inputs of varying dimensions."
    },
    {
        "instruction": "Develop a function that receives a multi-dimensional numerical array. It should calculate and return the total number of elements in the array, regardless of its shape."
    },
    {
        "instruction": "Create a function that accepts desired dimensions (e.g., as a tuple like (rows, columns)) and returns a new numerical array of those dimensions filled entirely with the floating-point value 1.0."
    },
    {
        "instruction": "Implement a function that takes two numerical arrays as input. It should return `True` if both arrays have the exact same shape and `False` otherwise."
    },
    {
        "instruction": "Simulate saving and loading a function's behavior. Create a mechanism that can represent a simple element-wise mathematical function (like sine) and its ability to handle 1D numerical arrays of variable length. Implement a way to 'load' this representation and verify that applying it to different length input arrays (e.g., length N and length 2N) produces results consistent with applying the original mathematical function directly."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (e.g., a list of floats) and returns a new 1D array of the same size, where each element is the sine of the corresponding element in the input array."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array as input. This function should be designed to apply a specific mathematical operation (e.g., sine) element-wise and work correctly even if called sequentially with input arrays of different lengths. Return the resulting 1D array."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays and returns a new 1D array formed by appending the second array to the end of the first array."
    },
    {
        "instruction": "Create a function that accepts a tuple representing the dimensions of an array and returns the total number of elements that an array with this shape would contain."
    },
    {
        "instruction": "Develop a function to check if two numerical arrays are identical. It should return true if and only if both arrays have the same dimensions and all corresponding element values are equal, otherwise false."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and returns a new 1D array containing all the elements of the input array in their original order (flattening)."
    },
    {
        "instruction": "Implement a function that generates a multi-dimensional numerical array of a given shape, filled sequentially with integers starting from 0. Input: a tuple describing the shape. Output: the populated array."
    },
    {
        "instruction": "Implement a function that accepts a numerical array of any dimension (e.g., 1D, 2D, 3D) and returns an identical array with the same shape and values."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array as input and returns the exact same array."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays of the same shape and returns `True` if all corresponding elements are numerically close (within a predefined small tolerance), and `False` otherwise."
    },
    {
        "instruction": "Develop a function that creates and returns a 1D numerical array containing predefined floating-point values, such as `[0.7, 0.8]`."
    },
    {
        "instruction": "Write a function that takes two numerical arrays, A and B, as input. Determine if array B can be broadcast to the shape of array A according to standard array broadcasting rules (comparing dimensions from right to left, dimensions must match or one must be 1). Return True if B can be broadcast to A's shape, False otherwise."
    },
    {
        "instruction": "Develop a function that attempts to reshape a given multi-dimensional numerical array into a 2-column matrix. Input is the array. If the total number of elements is positive and evenly divisible by 2, return the reshaped 2D array. Otherwise, signal an error (e.g., return None or raise an exception)."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and returns a new 1D array containing all the elements of the input array in their original order (flattening)."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix). It should return the scalar value 1.0 if the matrix is square (number of rows equals number of columns) and 0.0 otherwise."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and reshapes it into a new 2D array with exactly 2 rows, inferring the number of columns. Ensure the total number of elements remains the same."
    },
    {
        "instruction": "Develop a function that creates a 3D numerical array of specified dimensions (e.g., D1, D2, D3) filled entirely with the floating-point value 1.0."
    },
    {
        "instruction": "Create a function that accepts a 3D numerical array (e.g., shape BxMxN) and applies a transformation to each 2D slice (MxN) along the first dimension (B). The transformation should reshape each slice into a 2-row matrix. Return the resulting 3D array (e.g., shape Bx2x(M*N/2))."
    },
    {
        "instruction": "Write a higher-order function called `apply_to_slices`. It should accept two arguments: a 3D numerical array (Input Array) and another function (Slice Function). The `Slice Function` must take a 2D array (a slice of the Input Array) and return a 2D array. `apply_to_slices` should iterate through the slices of the Input Array along its first dimension, apply the `Slice Function` to each slice, and collect the results into a new 3D array."
    },
    {
        "instruction": "Write a function that takes two numerical arrays of the same shape and returns a new array representing their element-wise sum."
    },
    {
        "instruction": "Write a function that receives a list of numerical arrays and a parallel list of axis specifications (where each specification is either an integer axis index or a special marker like 'skip'). The function must validate that for all arrays where an axis index is specified (i.e., not 'skip'), the size of that specified axis is the same across all those arrays. Return `True` if the sizes are consistent or if no axes are specified, and `False` if there's any inconsistency among the specified axes."
    },
    {
        "instruction": "Create a function that checks if two input numerical arrays have identical shapes. It should return `True` if they do, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes a numerical array and an integer representing an axis index. Return the size (length) of that specific axis in the array. Handle potential errors if the axis index is invalid (e.g., out of bounds)."
    },
    {
        "instruction": "Design a way to represent dimensions that can be either 'concrete' (holding a positive integer) or 'symbolic' (holding a string name). Implement a function `check_equality(dim_a, dim_b)` that takes two such dimension representations. It should return `True` only if both are concrete with the same integer value, OR both are symbolic with the same string name. Otherwise, it must return `False`."
    },
    {
        "instruction": "Create a function `compare_items(item1, item2)` that determines if two items representing dimensions are *definitely* equal. Inputs can be positive integers or string variables. Return `True` only if they are the same integer or the same string variable. Return `False` if they are different integers, different string variables, or if one is an integer and the other is a string variable."
    },
    {
        "instruction": "Develop a function `is_dimension_present(target_dim, potential_dims)` where `target_dim` is a dimension representation (positive integer or string variable) and `potential_dims` is a list of such representations. Using the *definite* comparison logic (Task 2), return `True` if `target_dim` is definitely equal to at least one dimension in `potential_dims`. Return `False` otherwise, including for an empty list."
    },
    {
        "instruction": "Write a function `are_strictly_equal(val1, val2)` that takes two inputs, which can be either integers or string identifiers. Return `True` only if both inputs are the exact same integer or the exact same string identifier. Return `False` in all other cases (different integers, different strings, or mixed types)."
    },
    {
        "instruction": "Create a function that takes a numerical array and another function (which operates on single numbers). Apply the provided function to each element of the input array and return a new array containing the results. The output array must have the same shape as the input array."
    },
    {
        "instruction": "Implement a function that accepts a numerical array. It should compute the sine of each element and then add it back to the original element. Return the resulting array, which must have the same shape as the input."
    },
    {
        "instruction": "Write a function that takes a numerical array and a scalar number. Return a new array of the same shape where each element is the sum of the corresponding input element and the scalar."
    },
    {
        "instruction": "Write a function that takes a numerical array and returns a new array of the same shape where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array. Return the integer result of dividing the size of the array by 2 using integer division (discarding any remainder)."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array. Compute and return the remainder when the size of the array is divided by 2 (modulo operation). The result should always be non-negative."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array. Calculate and return the remainder when the size of the array is divided by -2 using the modulo operation. Ensure the result conforms to the standard mathematical definition of modulo with negative divisors (result usually has the same sign as the divisor)."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical array. Calculate and return the integer result of dividing the size of the array by -2 using integer division. Ensure the result follows standard integer division rules for negative divisors."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns its size (number of elements) as an integer."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and a numerical exponent `p`. Let N be the size of the array. Calculate N raised to the power `p`. Before calculating, validate `p`: if `p` is negative OR `p` is not a whole number (has a fractional part), raise a ValueError. Otherwise, return the result of the exponentiation."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array. Let N be its size. The function should attempt to calculate N raised to the power of -2. If raising a size-derived value to a negative power is invalid, the function must raise a ValueError. Otherwise, return the calculated result."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array. Let N be its size. Return the value of N raised to the power of 3 (N cubed)."
    },
    {
        "instruction": "Create a function that accepts two numerical arrays of the *same shape* and returns a new array of that same shape, where each element is the sum of the corresponding elements from the input arrays."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array (matrix) and returns a 1D array (vector) representing the sum of the elements along the first dimension (summing down the columns). For an input shape (M, N), the output shape should be (N,)."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array `X`. It should compute the sine of each element in `X`, add the result element-wise back to `X`, and return the final array, which will have the same shape as `X`."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array (matrix) `X` with shape (M, N). The function should first calculate a new matrix `Y` where each element `Y[i, j] = X[i, j] + sin(X[i, j])`. Then, it should compute and return a 1D array (vector) by summing the elements of `Y` along the first axis (axis 0). The output vector should have shape (N,)."
    },
    {
        "instruction": "Implement a function that takes a concrete shape (tuple of positive integers, e.g., (4, 6)) and a symbolic shape specification string with one variable used potentially multiple times (e.g., 'a, a + 2'). Determine if there's a single positive integer value for the variable 'a' that satisfies all parts of the specification. Return the value of 'a' if consistent, otherwise indicate failure."
    },
    {
        "instruction": "Write a function that takes a shape pattern string containing comma-separated dimension specifications (e.g., 'a, b * 2, 5') and parses it into a list of individual dimension specification strings (e.g., ['a', 'b * 2', '5']). Ensure basic validation, like handling empty strings or invalid characters."
    },
    {
        "instruction": "Create a function that attempts to match a single concrete dimension size (a positive integer, e.g., 12) against a simple symbolic dimension specification involving one variable and multiplication (e.g., 'k * 3'). If a unique positive integer solution for the variable 'k' exists, return the value of 'k'. Otherwise, indicate failure (e.g., return None or raise an error)."
    },
    {
        "instruction": "Write a function that checks constraints when matching a concrete dimension size `D` to a symbolic specification involving addition or multiplication (e.g., '3 * b + 10' or 'k * 5'). Verify that any solved variable is a positive integer and that operations like division result in no remainder where implied. Return the solved variable's value on success, otherwise signal a specific error (e.g., 'non-integer result', 'remainder detected', 'non-positive result')."
    },
    {
        "instruction": "Implement a function that takes two arguments: `data_structure` (a nested structure containing any type of leaf elements) and `spec_structure` (a similarly nested structure). The function should return `True` if the two structures have the exact same nesting pattern (types of containers, list lengths, dictionary keys match at all levels), and `False` otherwise. Do not compare the leaf elements themselves."
    },
    {
        "instruction": "Develop a function that takes three 1D numerical arrays (vec1, vec2, vec3) and returns a specific nested data structure: a tuple where the first element is a list `[vec1, vec2]` and the second element is a dictionary `{'a': vec3, 'b': vec1}`."
    },
    {
        "instruction": "Write a function that takes a nested data structure (potentially containing lists and dictionaries) holding numerical arrays and returns a flat list containing all the numerical arrays found within it, preserving their order of appearance during traversal."
    },
    {
        "instruction": "Write a function that accepts two arguments: a nested data structure containing numerical arrays (all of the same shape) and a binary element-wise function `op`. The function should traverse the structure, collect all arrays, and apply the `op` function cumulatively (like a reduction) to produce a single resulting array. For example, for arrays A, B, C, it should compute `op(op(A, B), C)`. If the structure contains only one array, return that array."
    },
    {
        "instruction": "Implement a function that takes two arguments: a nested data structure (lists/dictionaries) containing numerical arrays, and a single numerical array. Return a new nested structure with the same layout as the first argument, but where every leaf array is replaced by the second argument (the single numerical array)."
    },
    {
        "instruction": "Write a function that takes a nested data structure (lists/dictionaries) containing numerical arrays. The function should return a flat list containing all the numerical arrays found at the leaves of the input structure, preserving the order encountered during a depth-first traversal."
    },
    {
        "instruction": "Create a function that accepts an arbitrarily nested data structure (composed of lists and dictionaries) containing 1D numerical arrays at the leaves. The function should traverse the structure, collect all the arrays, and return their element-wise sum. Assume all leaf arrays have the same, compatible shape."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array 'arr' and returns a specific nested data structure: a tuple where the first element is a list containing two references to 'arr', and the second element is another list containing one reference to 'arr'. Example output: `([arr, arr], [arr])`."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `A`. It should generate a sequence of numbers from 0 up to `rows*cols - 1` (where `rows`, `cols` are the dimensions of `A`), reshape this sequence into the same shape as `A`, and return the reshaped array. Ensure the data type matches `A`."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array `M`. It should compute the element-wise sine of `M`. Separately, it should generate a sequence from 0 to `rows*cols-1` (based on `M`'s shape), reshape it to match `M`'s shape, and then add this reshaped array element-wise to the sine result. Return the final 2D array."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `X`. Define an inner operation that calculates `sin(X)` element-wise, adds it to a reshaped sequence `0..N-1` (where N is the total number of elements in `X`), and returns the result `Y`. The main function should then compute and return `X + Y`. Ensure all arrays have the same shape and data type."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and a numerical data type. It should return a 2D numerical array of shape (`rows`, `cols`) filled with sequential numbers starting from 0, cast to the specified data type."
    },
    {
        "instruction": "Write a function that accepts a 3D numerical array and returns an integer calculated as `2 * dimension0 + 3 * dimension1 + 4 * dimension2`, where `dimension0`, `dimension1`, and `dimension2` are the sizes of the array's dimensions."
    },
    {
        "instruction": "Write a function that receives a tuple representing the dimensions of an array (e.g., `(16, 24, 32)`) and a list of symbolic names (e.g., `['dim_a', 'dim_b', 'dim_c']`). Return a dictionary mapping each name to the corresponding dimension size. Ensure the number of names matches the number of dimensions."
    },
    {
        "instruction": "Develop a function that takes a string containing comma-separated elements (e.g., 'expr1, expr2, expr3') and returns a list containing each element as a separate string, removing any leading/trailing whitespace from each element."
    },
    {
        "instruction": "Implement a function that parses a string representing a shape specification with symbolic variables and basic arithmetic (e.g., '2*b1, 4*b2, b1+b2+18'). It should take the string and a dictionary mapping variables like 'b1', 'b2' to integer values. Return a tuple of integers representing the calculated dimensions based on the input string and variable values. Handle simple addition and multiplication by integer constants."
    },
    {
        "instruction": "Design a function that receives a list of symbolic constraint strings, where each constraint involves a single, distinct variable name and a simple lower bound (e.g., `['a >= 8', 'b >= 5', 'c >= 10']`). The function should return a dictionary mapping each variable name to the smallest possible non-negative integer value that satisfies its corresponding constraint (e.g., `{'a': 8, 'b': 5, 'c': 10}`)."
    },
    {
        "instruction": "Implement a function `wrap_checker` that takes two arguments: a function `inner_func` and a minimum size `min_size`. `wrap_checker` should return a *new* function. This new function accepts a 1D numerical array; it first checks if the array's length is greater than or equal to `min_size`. If not, it raises an error. If it is, it calls `inner_func` with the array and returns its result."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and an integer `min_length`. Return `True` if the array's length is greater than or equal to `min_length`, and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a multi-dimensional numerical array, a dimension index (integer), and a minimum size (integer). It should raise a specific error (e.g., `ValueError`) with a descriptive message if the size of the specified dimension of the array is less than the minimum size. Otherwise, it should return `True`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array containing the first 8 elements. Assume the input array always has at least 8 elements."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array, a starting index `s`, and a slice length `l`. Return a new 1D array representing the slice `array[s:s+l]`. Add a check to ensure the input array's length is sufficient for the requested slice (i.e., length >= s + l)."
    },
    {
        "instruction": "Develop a function that extracts a sub-sequence from a 1D numerical array. It takes the array and a slice length `L` as input. Return a new 1D array containing the elements from index 0 up to (but not including) index `L`. Assume the input array's length is always greater than or equal to `L`."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and returns a slice starting from index 0 with a fixed length of 8. The function should verify that the input array's length is greater than or equal to 8 before attempting the slice."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `arr1` and an integer `n`. Return a new 1D array containing the first `n` elements of `arr1`. If `n` is greater than the length of `arr1`, return all elements of `arr1`."
    },
    {
        "instruction": "Develop a function that accepts two 1D numerical arrays, `input1` and `input2`. Let their lengths be `len1` and `len2`. Check if `len2 >= 2` AND `min(len1, len2) == len2 - 2`. If true, return the element-wise sum of `input1` sliced up to `len2` elements and `input2` sliced from index 2 onwards. Otherwise, return an empty array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array `arr` and a non-negative integer index `k`. Return a new 1D array containing elements of `arr` starting from index `k` to the end. If `k` is greater than or equal to the array length, return an empty array."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays, `data_a` and `data_b`. Let their lengths be `len_a` and `len_b`. Verify that `len_b >= 2` and `min(len_a, len_b) == len_b - 2`. If these constraints hold, compute and return the element-wise sum of two derived arrays: one created from the first `len_b` elements of `data_a`, and the other from elements of `data_b` starting at index 2. If constraints are not met, raise a value error indicating incompatible input shapes."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and an integer `k`. Return `True` if the length of the array is exactly divisible by `k`, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array `X` whose length is guaranteed to be a multiple of 4. Return a new 1D array containing only the elements from the first quarter of `X`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `X` of length `N`, where `N` is guaranteed to be a multiple of 4. Perform the following steps:\n    1. Create a constant 4D array `C` of shape `(1, 3, 4, N // 4)` filled with ones.\n    2. Reshape `C` to a 3D array `C_reshaped` of shape `(1, 3, N)`.\n    3. Reshape `X` to a 3D array `X_reshaped` of shape `(1, 1, N)`.\n    4. Add `X_reshaped` and `C_reshaped` element-wise (using broadcasting) to get `Y`.\n    5. Calculate the sum of all elements in `Y`.\n    6. Divide `X` into four equal contiguous slices. Calculate the sum of elements in each slice.\n    7. Return the sum of `Y` plus the sums of the four slices."
    },
    {
        "instruction": "Develop a function that accepts a 1D numerical array `X` whose length `N` is guaranteed to be a multiple of 4. Divide `X` into four equal, non-overlapping, contiguous sub-arrays. Return a list or tuple containing the sum of elements for each of these four sub-arrays."
    },
    {
        "instruction": "Write a function that takes two numerical arrays, `control_arr` and `target_arr`. It should ignore `control_arr` entirely and simply return `target_arr` unchanged. The function signature must accept both arguments."
    },
    {
        "instruction": "Implement a function that takes two numerical arrays, `info_arr` (e.g., shape (M,) or (M, N)) and `data_arr` (e.g., shape (K,) or (P, Q)). It should return a new array mathematically equivalent to `data_arr` plus the size of the first dimension of `info_arr` (i.e., add M to every element of `data_arr`). The content of `info_arr` is not used, only its first dimension's size."
    },
    {
        "instruction": "Write a function that accepts two numerical arrays, `arr1` and `arr2`, but only uses `arr2`. It should return a new array where each element of `arr2` is multiplied by a constant factor of 2.0."
    },
    {
        "instruction": "Develop a function that accepts three numerical arrays: `unused_arr`, `data_arr1`, `data_arr2`. The function should ignore `unused_arr` and return the element-wise sum of `data_arr1` and `data_arr2`. Assume `data_arr1` and `data_arr2` have compatible shapes for addition."
    },
    {
        "instruction": "Create a function that extracts a rectangular sub-array from a given 2D numerical array. It should accept the input array, starting indices (row, col), and slice dimensions (height, width) as input. Handle cases where start indices might be provided dynamically."
    },
    {
        "instruction": "Write a function that takes a scalar value and a target multi-dimensional shape. Return a new numerical array of the target shape where the input scalar value is replicated across all elements."
    },
    {
        "instruction": "Implement a function that accepts a positive integer `N` and returns a 1D numerical array containing the integer sequence 0, 1, 2, ..., N-1."
    },
    {
        "instruction": "Write a function that processes a 2D numerical array row by row based on a corresponding 1D integer array of counts. For the i-th row of the 2D array, it should simulate performing a simple pass-through operation 'count[i]' times. The function should take the 2D array (M rows, N cols) and the 1D count array (M elements) and return the processed 2D array (which will be identical to the input 2D array)."
    },
    {
        "instruction": "Write a function that takes a 3D numerical array and reshapes it into a 2D array where the first dimension has a size of 2. The function should return the new 2D array. Ensure it only works if the total number of elements is divisible by 2."
    },
    {
        "instruction": "Develop a function that takes a list of data items and a separate 'identifier' function. The identifier function produces a potentially non-unique key (like a hash) for each item. Return a structure (e.g., a dictionary or map) that groups the original items based on the keys produced by the identifier function."
    },
    {
        "instruction": "Create a function that accepts a list of 3D numerical arrays and applies a specific reshaping function (like the one from Task 1) to each array individually. Return a list containing the corresponding reshaped 2D arrays."
    },
    {
        "instruction": "Implement a function that compares two numerical arrays (potentially multi-dimensional) and returns `True` if they are element-wise identical, `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes two arguments: a 1D numerical array and a function `func`. The function should calculate an integer value by doubling the length of the input array. It should then apply `func` to this integer value and return a tuple containing the result of `func` and the original input array. Input: (1D array, function), Output: tuple (result of func, 1D array)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns an integer that is double the size (number of elements) of the array. Input: 1D array, Output: integer."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical array. It should calculate a value equal to twice the length of the array and return a tuple containing this calculated value and the original array. Input: 1D array, Output: tuple (integer, 1D array)."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array and a function `transform_func`. The function should determine the size of the *first* dimension of the input array, calculate a new value by multiplying this size by 2. Then, it must apply the `transform_func` to this new value. Finally, it should return a tuple containing the transformed value and the original multi-dimensional array. Input: (N-D array, function), Output: tuple (transformed value, N-D array)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `X`, a numerical value `Y` (which can be a scalar or a 1D array of the same size as `X`), a string representing a binary operation ('add', 'mul', 'sub', 'div'), and a boolean `swap_order`. First, calculate an integer `P = 2 * size(X)`. Then, based on `swap_order`, perform the specified binary operation between `P` and `Y` (either `P op Y` or `Y op P`). If `Y` is an array, the operation should be element-wise. Return the final result (scalar or array), ensuring it is represented using a standard floating-point type."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array. Calculate an integer value `P` as twice the size (number of elements) of the array. Then, add a given scalar integer `S` to `P`. Return the integer result."
    },
    {
        "instruction": "Implement a function that takes an integer `I` and a second argument `V` which can be either a numerical scalar or a 1D numerical array. Multiply `I` by `V`. If `V` is a scalar, return the scalar result. If `V` is an array, return a new array where each element is the original element multiplied by `I`."
    },
    {
        "instruction": "Develop a function that takes an integer `A` and another value `B` which is guaranteed to be an integer type (e.g., standard integer, 32-bit integer). Perform floor division (`A // B`). The function must return an integer result. Handle potential division by zero appropriately (e.g., raise an error)."
    },
    {
        "instruction": "Create a function that takes a list of integers and returns their sum as a single integer value."
    },
    {
        "instruction": "Develop a function that takes a numerical array and an integer scalar, and returns a new array where the scalar has been added to every element of the input array. The output array must have the same dimensions as the input array."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array and returns a list or tuple containing the size of each dimension."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array. It should calculate the sum of its dimension sizes, treat this sum as an integer scalar, and then add this scalar to every element of the original array. The function should return the resulting array, maintaining the original shape."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array. It should return the sum of the array's size (as an integer) and its first element. The return type should follow standard promotion rules based on the element type (e.g., int + float -> float)."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns the size (number of elements) of that array as an integer."
    },
    {
        "instruction": "Create a function that takes an integer and a floating-point number as input and returns their sum. Ensure the result is a floating-point number according to standard type promotion rules."
    },
    {
        "instruction": "Develop a function that accepts an integer (e.g., representing a dimension size). Add a second integer constant (e.g., 4) to it, then add a floating-point constant (e.g., 5.0) to that intermediate sum. Return the final floating-point result."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a new array where each element is the corresponding input element minus 1.0."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array (e.g., shape BxN). It should apply a simple transformation (subtract 1.0 from each element) independently to each row (vector of size N) and return a new 2D array of the same shape containing the results."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array as initial state. It repeatedly checks if the sum of the array's elements is non-negative. If it is, it subtracts 1.0 from each element and repeats the check. The loop stops when the sum becomes negative. The function should return the final state of the array."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array (e.g., shape BxN). For each row (vector of size N) independently, it should perform the following iterative process: while the sum of the row's elements is non-negative, subtract 1.0 from each element in that row. The function should return a new 2D array of the same shape containing the final state of each row after its respective loop terminates."
    },
    {
        "instruction": "Develop a function that accepts a list containing multiple 2D numerical arrays. Return `True` if all arrays in the list have the same number of rows (i.e., the size of their first dimension is identical), and `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (M rows, N columns). Return a 1D array of size M where each element is the sum of the elements in the corresponding row of the input array."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays (matrices) with identical shapes and returns a new 2D array representing their element-wise sum."
    },
    {
        "instruction": "Create a function that accepts two numerical arrays (potentially multi-dimensional) and returns `True` if they have exactly the same shape, `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a numerical array and a mathematical function (e.g., sine, cosine, exponential). The function should apply the provided mathematical function element-wise to the input array and return a new array with the results, preserving the original shape."
    },
    {
        "instruction": "Develop a function that receives a 2D numerical array and two values representing expected height and width. Return `True` if the array's dimensions exactly match the provided height and width, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a numerical array (1D or 2D) and returns a new array of the same shape where each element `y` is calculated as `y = x + sin(x)`, with `x` being the corresponding element from the input array."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix) as input. Calculate the element-wise sine of the matrix, then add the resulting matrix to the original input matrix. Return the final matrix, ensuring its dimensions are identical to the input matrix."
    },
    {
        "instruction": "Create a function that accepts two numerical arrays of the exact same shape and returns a new array representing their element-wise sum. Ensure the output array has the same shape as the inputs."
    },
    {
        "instruction": "Implement a function that takes two numerical arrays of the same shape. It should compute the element-wise sine of the second array and then add the result element-wise to the first array. Return the final array, maintaining the original shape."
    },
    {
        "instruction": "Write a function `predict_output_shape` that takes two shape tuples, potentially containing `None` for dynamic dimensions. Assuming these shapes represent inputs to a binary element-wise operation (like addition), determine and return the resulting output shape tuple. If a dimension is fixed in one shape and dynamic (`None`) in the other, the output dimension should be the fixed one. If both are `None`, the output is `None`. If dimensions mismatch and neither is `None`, raise an error indicating incompatibility."
    },
    {
        "instruction": "Develop a function `check_shape_compatibility` that takes two shape tuples (e.g., `(2, 3)`, `(None, 3)`) as input. A dimension can be a positive integer or `None` (representing dynamic size). The function should return `True` if the shapes are compatible for element-wise operations (identical dimensions or one is `None`), and `False` otherwise. For example, `(2, None)` and `(2, 3)` are compatible, but `(2, 3)` and `(4, 3)` are not."
    },
    {
        "instruction": "Implement a function that takes integer arguments `start`, `stop`, and `step` to define a sequence. Validate that the `step` argument is not equal to zero. If `step` is zero, raise a `ValueError` with the message 'Step cannot be zero'. Otherwise, return True."
    },
    {
        "instruction": "Write a function to generate an integer sequence. It accepts `start`, `stop`, and `step`. First, check if all inputs are integers; if not, raise `TypeError` ('All arguments must be integers'). Second, check if `step` is zero; if it is, raise `ValueError` ('Step cannot be zero'). If both checks pass, generate and return the integer sequence as a list or 1D array."
    },
    {
        "instruction": "Write a function that generates a sequence of integers starting from `start`, up to (but not including) `stop`, with a given integer `step`. Assume `start`, `stop`, and `step` are integers and `step` is non-zero. Return the sequence as a list or 1D array."
    },
    {
        "instruction": "Develop a function that takes a single number (scalar) and a 1D numerical array (list or similar). Return a new 1D array where the scalar value has been added to each element of the input array."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array. Calculate `element + sin(element)` for each entry. Return the resulting 2D array with the same shape as the input."
    },
    {
        "instruction": "Write a function accepting a 2D numerical array of shape (M, N). First, compute a new 2D array where each element is `original_element + sin(original_element)`. Then, sum this new array along its first dimension (axis 0). Return the resulting 1D array of shape (N,)."
    },
    {
        "instruction": "Create a function to perform element-wise addition of two numerical arrays with identical shapes, returning a new array of the same shape."
    },
    {
        "instruction": "Implement a function that sums a 2D numerical array along a specified axis (0 or 1). Given an input array of shape (M, N), summing along axis 0 results in shape (N,), and along axis 1 results in shape (M,). Return the resulting 1D array."
    },
    {
        "instruction": "Write a function that accepts a tuple representing a data shape (e.g., `(2, 5)`). It should return `True` if all elements in the tuple are positive integers, and `False` otherwise (e.g., if it contains zero, negative numbers, or non-integers)."
    },
    {
        "instruction": "Write a function `validate_operation(operation_func, input_spec, output_pattern_spec)`. `input_spec` is a tuple describing the shape of valid input data (e.g., `(5, 2)`). `output_pattern_spec` is a tuple potentially containing positive integers and a special marker (e.g., -1) for dynamic dimensions (e.g., `(5, -1)`). The function should: 1. Generate sample numerical data matching `input_spec`. 2. Execute `operation_func` with the sample data. 3. Get the shape of the result. 4. Return `True` if the result's shape matches `output_pattern_spec` (using logic similar to Task 2), `False` otherwise. If `operation_func` raises any error during execution, return `False`."
    },
    {
        "instruction": "Create a function that takes two shape tuples: `actual_shape` (containing only positive integers, e.g., `(3, 10)`) and `pattern_shape` (which can contain positive integers or a special marker like `None` or -1 representing a dynamic dimension, e.g., `(3, None)`). Return `True` if the `actual_shape` matches the `pattern_shape` (same length, integers match, marker matches any positive integer), `False` otherwise."
    },
    {
        "instruction": "Implement a function `assert_raises_with_message(callable_func, expected_exception_type, message_substring)`. This function should call `callable_func()`. If `callable_func` raises an exception of the `expected_exception_type` and its message contains the `message_substring`, the function should return `True`. In all other cases (no exception, wrong exception type, wrong message), it should return `False`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and an integer `slice_length`. It should return the first `slice_length` elements as a new 1D array. Ensure the input array has at least `slice_length` elements."
    },
    {
        "instruction": "Develop a function that accepts a 2D numerical array (matrix), a `start_col_index`, and a `num_cols`. Return a new 2D array containing `num_cols` columns starting from `start_col_index`. Validate that the input matrix has sufficient columns (`start_col_index + num_cols <= total_cols`)."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix), a `start_row_index`, and a `num_rows`. Return a new 2D array containing `num_rows` rows starting from `start_row_index`. Ensure the input matrix has enough rows (`start_row_index + num_rows <= total_rows`)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array, a `start_index`, and a `slice_length`. Return a new 1D array containing elements from `start_index` up to (but not including) `start_index + slice_length`. Validate that the requested slice fits within the input array bounds."
    },
    {
        "instruction": "Implement a function that takes a concrete shape tuple (e.g., `(4, 36, 3)`) and a polymorphic shape string involving multiple variables and arithmetic (e.g., `'b * b, b * d * d, d'`). Solve for all dimension variables (e.g., 'b', 'd'). Return a dictionary mapping variable names to their positive integer values if a consistent solution exists for all variables and constraints (like integer results of multiplications). If no solution exists or constraints are violated (e.g., non-integer result, non-positive variable value, inconsistency), raise an appropriate ValueError."
    },
    {
        "instruction": "Develop a function that validates the format of a polymorphic shape specification. It takes one argument. Return `True` if the argument is a string representing a shape (e.g., `\"a, b\"`, `\"3*n, ...\"`, `\"(c, c)\"`), and `False` otherwise (e.g., if it's a number or a list)."
    },
    {
        "instruction": "Write a function that takes a tuple representing dimensions (e.g., `(2, 3, 4)`) and returns a new multi-dimensional numerical array initialized with sequential integers starting from 0, matching the given dimensions."
    },
    {
        "instruction": "Write a function that checks for inconsistencies in polymorphic shape specifications. It takes a concrete shape tuple (e.g., `(2, 3)`) and a polymorphic shape string where a variable might be used multiple times (e.g., `'(a, a)'`). If the concrete dimensions corresponding to the same variable are different, raise a ValueError indicating the inconsistency (e.g., 'Inconsistent value for variable a: expected 2, got 3'). Otherwise, return True."
    },
    {
        "instruction": "Implement a function that checks if an actual shape (list of integers) is consistent with a symbolic specification involving only one variable across multiple dimensions (e.g., shape `[4, 8]` and spec `['a', '2*a']`). Find the non-negative integer value for the variable that satisfies all dimensions, or return an indicator of inconsistency."
    },
    {
        "instruction": "Write a function that takes an integer dimension size and a simple symbolic string expression involving one variable (e.g., 'a + 5' or '3*b'). Solve for the non-negative integer value of the variable. Return the value or indicate if no valid solution exists (e.g., non-integer result)."
    },
    {
        "instruction": "Write a function that validates proposed integer values for dimension variables against an actual shape and a symbolic specification. Input: shape (list of integers), spec (list of symbolic strings), and variable values (dictionary like `{'a': 3, 'b': 1}`). Return `True` if substituting the values into the spec yields the actual shape, `False` otherwise."
    },
    {
        "instruction": "Create a function that parses a symbolic shape specification string like '(a, 2*b + a, c)'. It should extract the variable names (a, b, c) and their linear coefficients/constants for each dimension. Return a structured representation (e.g., list of tuples/dicts) or raise an error for invalid syntax."
    },
    {
        "instruction": "Write a function that takes a list containing several 1D numerical arrays of the same length and returns a single 1D array representing their element-wise sum."
    },
    {
        "instruction": "Develop a function that takes a tuple containing two lists, where each list holds 1D numerical arrays. Return a single list containing all arrays from both input lists."
    },
    {
        "instruction": "Create a function that accepts a nested data structure (potentially containing lists, tuples, and dictionaries) and returns a flat list of all the 1D numerical arrays found within it, regardless of the nesting level."
    },
    {
        "instruction": "Write a function that accepts a complex nested data structure (like a tuple containing lists and a dictionary, all holding 1D numerical arrays of compatible shapes for addition). The function must traverse the structure, extract all arrays, and compute their element-wise sum, returning a single 1D array result."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (shape M, N). It should compute the element-wise sine of the input array and add a 1D array `[0.0, 1.0, ..., N-1.0]` to it using broadcasting rules (the 1D array should effectively be added to each row). Return the resulting 2D array (shape M, N)."
    },
    {
        "instruction": "Write a function that performs element-wise addition of two 2D numerical arrays that have the exact same shape (M, N). It should take the two arrays as input and return a new 2D array of shape (M, N) containing their sum."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns a new 2D array where each element is the sine of the corresponding input element. Maintain the input shape and data type."
    },
    {
        "instruction": "Create a function that accepts a positive integer `N` and returns a 1D numerical array containing the sequence `0, 1, ..., N-1` as floating-point numbers."
    },
    {
        "instruction": "Implement a function that extracts a slice of a specified size from a 2D numerical array, starting at potentially variable indices. Inputs are the main array, a tuple `(start_row, start_col)` indicating the starting position, and a tuple `(slice_height, slice_width)` defining the size of the slice to extract. Return the extracted sub-array."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a target shape. Broadcast the input array to the target shape according to standard broadcasting rules (e.g., matching dimensions from right-to-left, expanding dimensions of size 1). Return the broadcasted array."
    },
    {
        "instruction": "Write a function that processes each row of a 2D numerical array based on a corresponding count. Inputs are a 2D array `data` (shape M, N) and a 1D array `counts` (shape M, integer type). For each row `i` in `data`, the function should conceptually perform an identity operation `counts[i]` times (effectively just returning the original row). The function should operate row-wise and return a new 2D array identical to the input `data` array, simulating a vectorized operation over variable-iteration loops."
    },
    {
        "instruction": "Develop a function that updates a rectangular region within a 2D numerical array using values from a second (smaller) 2D array. Inputs are the target array, the update array (whose dimensions define the size of the update region), and a tuple `(start_row, start_col)` indicating the top-left position in the target array where the update should begin. Return the modified target array."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns an integer value equal to twice the number of elements in the array."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array. It should calculate a scalar value equal to twice the array's length. The function must return a tuple containing this calculated scalar and the original input array."
    },
    {
        "instruction": "Create a function that takes a scalar value and a 1D numerical array as input. It should return a tuple containing the scalar as the first element and the original 1D array as the second element."
    },
    {
        "instruction": "Develop a function that accepts two arguments: a 1D numerical array and another function (let's call it `unary_op`) which takes a single numerical input. The main function should first calculate a scalar value equal to twice the length of the input array. Then, it should apply the `unary_op` function to this scalar and return only the result of this application."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and computes the sum of its elements along the first axis (column sums). It should return a 1D array containing the sums for each column."
    },
    {
        "instruction": "Write a robust function to calculate the mean of a 2D numerical array along the first axis. Handle the edge case where the input array might have zero rows, ensuring it returns an appropriately shaped empty array or raises a specific error."
    },
    {
        "instruction": "Implement a function that calculates the mean of a 2D numerical array along its first axis (column means). It should take a 2D array (M rows, N columns) and return a 1D array of size N."
    },
    {
        "instruction": "Develop a function that computes the mean of a numerical array along a specified axis. The function should accept the array and an integer representing the axis (e.g., 0 for columns, 1 for rows in a 2D array), returning an array with the mean values."
    },
    {
        "instruction": "Write a function that takes a numerical array and returns the total number of elements in it (i.e., the product of its dimensions) as an integer."
    },
    {
        "instruction": "Develop a function that accepts a numerical array and an integer index `i`. It should return the size of the `i`-th dimension of the array as an integer. Handle cases where the index might be invalid for the given array."
    },
    {
        "instruction": "Write a function that takes a numerical array of any rank and returns the sum of its dimensions as an integer."
    },
    {
        "instruction": "Implement a function that takes a numerical array as input. It should calculate the sum of the array's dimensions and add this sum (as an integer) to each element of the original array. Return the resulting array."
    },
    {
        "instruction": "Create a function that takes an integer and a floating-point number as input and returns their sum. Ensure the result is a floating-point number."
    },
    {
        "instruction": "Develop a function that accepts a 1D numerical array. It should calculate a value by adding the array's length, a fixed integer (e.g., 4), a fixed floating-point number (e.g., 5.0), and the first element of the array. Return the final floating-point result."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and an integer constant. It should return the sum of the array's length and the constant."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns its length (number of elements) as an integer."
    },
    {
        "instruction": "Implement a function that simulates a conditional loop. It takes an initial 1D numerical array, a condition function (input: array, output: boolean), and a body function (input: array, output: array). The function repeatedly applies the body function to the array as long as the condition function returns `True`. Return the final array state."
    },
    {
        "instruction": "Write a function that processes a batch (e.g., a list or 2D array) of 1D numerical arrays. For each array in the batch, it should repeatedly subtract 1.0 from every element as long as the sum of the array's elements remains non-negative. The function should return the batch of resulting arrays after the loops complete for each one. Ensure the operation is applied independently to each array in the batch."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns `True` if the sum of its elements is greater than or equal to zero, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a new array where each element is the corresponding input element minus 1.0."
    },
    {
        "instruction": "Create a function `should_skip_operation` that takes an operation name (string), a device type (string), and a boolean flag `is_experimental_enabled`. The function should return `True` (indicating skip) if the operation is 'op_A' on 'GPU', or if it's 'op_B' and `is_experimental_enabled` is `False`. Return `False` otherwise."
    },
    {
        "instruction": "Implement a function `run_with_temp_settings` that accepts a dictionary of temporary settings (e.g., {'precision': 'high', 'logging': False}) and another function `target_func` (which takes no arguments). It should execute `target_func`, ensuring the temporary settings are conceptually active only during its execution (you can simulate this by modifying a global-like state or passing settings if needed). It should return the result of `target_func` and ensure original settings are restored afterwards."
    },
    {
        "instruction": "Develop a function `get_execution_strategy` that receives task details (as a dictionary with 'name', 'type', and 'size' keys) and the execution environment (string, e.g., 'local_cpu', 'cloud_gpu'). Based on predefined rules (e.g., skip type 'complex_math' on 'local_cpu', run type 'simple_io' normally, run tasks with 'size' > 1000 with modification 'use_batching' on 'cloud_gpu'), return a string indicating the strategy: \"run\", \"skip\", or \"run_modified:use_batching\"."
    },
    {
        "instruction": "Write a function `check_device_support` that takes a feature name (string) and a device name (string, e.g., \"CPU\", \"GPU\"). It should return `True` if the feature is supported on the device according to a predefined internal list (e.g., 'feature_X' supported only on 'CPU', 'feature_Y' supported on 'GPU' and 'CPU'), and `False` otherwise."
    },
    {
        "instruction": "Create a function `check_element_type` that accepts an array and a string representing a conceptual type (e.g., \"prng_state\"). Return `True` if all elements in the array conform to this conceptual type, `False` otherwise. (Assume a helper function `is_conceptual_type(element, type_string)` exists)."
    },
    {
        "instruction": "Implement a function that takes a 2D array of integer seeds and a transformation function `seed_to_state`. Apply `seed_to_state` to every seed in the input array to produce a corresponding state object. Return a new 2D array of the same dimensions containing these state objects."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and two integers, `rows` and `cols`. Reshape the 1D array into a 2D array of shape (`rows`, `cols`) and return it. Assume the number of elements is compatible."
    },
    {
        "instruction": "Develop a function that generates a sequence of `N * M` consecutive unsigned integers starting from 0. Reshape this sequence into a 2D array of shape (`N`, `M`). Return this 2D array."
    },
    {
        "instruction": "Write a function that takes a single unsigned 32-bit integer (seed) and converts it into a 'key' structure using a simple, deterministic process (e.g., returning a tuple like `(seed, seed + 1)`). This 'key' structure represents the output type expected in other related tasks."
    },
    {
        "instruction": "Implement a function that takes a 2D array of unsigned 32-bit integers (seeds). Return a new 2D array of the exact same shape, where each element is a 'key' structure generated deterministically from the corresponding input seed. Ensure the output elements represent a distinct key type."
    },
    {
        "instruction": "Write a function that creates a 2D array with a given shape (e.g., M rows, N columns) and fills it with sequential unsigned 32-bit integers starting from 0."
    },
    {
        "instruction": "Create a function that accepts two arrays (e.g., an input array and an output array) and verifies if the output array has the exact same shape as the input array. Return `True` if shapes match, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns a new 2D array of the exact same dimensions. The content of the new array doesn't matter, only the shape preservation."
    },
    {
        "instruction": "Implement a function that takes a 2D array of seed values (e.g., positive integers). It should return a 2D array of the same shape where each element is a 'key' generated by applying a fixed, simple, deterministic transformation (e.g., `key = (seed + 1) * 3`) to the corresponding seed value."
    },
    {
        "instruction": "Write a function that takes a 2D array of seed values (unsigned integers). It must produce a 2D array of the exact same shape containing generated 'key' structures. Each key must be derived from its corresponding seed using a predefined, deterministic pseudo-random generation algorithm (e.g., a simple linear congruential generator step based on the seed). The function must ensure the output shape matches the input shape."
    },
    {
        "instruction": "Develop a function that accepts a 2D array where each element represents a 'key' (e.g., represented as a tuple or small list of numbers). The function should return a new 2D array of the same dimensions containing only the first numerical value from each 'key' representation."
    },
    {
        "instruction": "Develop a function that accepts a 2D numerical array of shape (M, N) and returns a 3D array of shape (N, M, 2). Populate the output array such that `output[j, i, 0]` gets the value from `input[i, j]` and `output[j, i, 1]` gets a value derived from `input[i, j]` (e.g., `input[i, j] + 1`)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array of shape (M, N) and returns its transpose, which will have the shape (N, M)."
    },
    {
        "instruction": "Create a function that accepts two positive integers, M and N, and generates a 2D array of shape (M, N) filled with sequential unsigned integer values starting from 0."
    },
    {
        "instruction": "Write a function that simulates rearranging data based on a transposed logical partitioning. Input is a 2D array (shape M, N) and two divisor factors P and Q (M divisible by P, N divisible by Q), implying a PxQ grid of blocks. Return a new 2D array of shape (N, M) where the data that was conceptually in block (p, q) of the input is now located in the region corresponding to block (q, p) in the output's conceptual grid. Specify the exact mapping of elements."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array of shape (M, N) as input. It should return a 3D array of shape (K, M, N), where K is a fixed small integer (e.g., 2), and the data along the first dimension is derived from the input array (e.g., K copies or simple transformations)."
    },
    {
        "instruction": "Create a function that generates a 2D numerical array of a given shape (rows, columns) filled with a specified unsigned integer value."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array and returns its transpose. For an input array of shape (M, N), the output should have shape (N, M)."
    },
    {
        "instruction": "Implement a function `outer_func` that takes a 2D numerical array. Inside `outer_func`, define and call an `inner_func` that processes the input array (e.g., multiplies elements by a constant). `outer_func` should then return the result produced by `inner_func` after transposing it."
    },
    {
        "instruction": "Create a higher-order function that takes a base function `f(x, y)` and a fixed value `val_y`. It should return a new function `g(x)` that behaves like `f(x, val_y)`."
    },
    {
        "instruction": "Develop a function that accepts a 3D numerical array (e.g., shape (D1, D2, D3)) representing data distributed according to some rule. The function should rearrange the data and return a new 3D array with a permuted shape (e.g., (D3, D2, D1)) reflecting a change in the distribution rule."
    },
    {
        "instruction": "Write a function that verifies if a given 4D numerical array (e.g., shape (W, X, Y, Z)) conforms to an expected data layout rule. The rule specifies how the dimensions should conceptually map to logical partitions (e.g., dimension Y maps to partition 'p1', dimension Z maps to partition 'p2', W and X are unpartitioned). The function should return True if the array's shape matches the expectation derived from the rule, False otherwise. (Focus only on shape check based on the rule)."
    },
    {
        "instruction": "Implement a function that takes a 3D numerical array with shape (A, B, C) and returns a new array where the first and third dimensions are swapped, resulting in a shape (C, B, A)."
    },
    {
        "instruction": "Write a function that takes a single numerical array (of any dimension) as input and returns the exact same array as output."
    },
    {
        "instruction": "Implement a function that compares two numerical arrays of the same shape. It should return `True` if the arrays are element-wise numerically close (allowing for small floating-point differences), and `False` otherwise. The function should take the two arrays and a tolerance value as input."
    },
    {
        "instruction": "Create a function that accepts two positive integers, `rows` and `cols`. It should generate a 1D sequence of numbers from 0 up to `rows * cols - 1` and then reshape this sequence into a 2D numerical array of shape (`rows`, `cols`). Return the resulting 2D array."
    },
    {
        "instruction": "Design a function that simulates checking the structure of a data object representing a potentially partitioned array. The function takes this object as input. Assume the object has a property or method to access its constituent data partitions (e.g., a list of arrays). The function should return `True` if the object contains exactly one partition, and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array containing `R * C` elements and reshapes it into a 2D array of shape (`R`, `C`). The function should accept the 1D array and the desired number of rows `R` and columns `C` as input."
    },
    {
        "instruction": "Implement a function that takes `rows` and `cols` as input. It should generate a 2D array `M` of shape (`rows`, `cols`) with sequential floats (0.0, 1.0, ...). The function should then return the element-wise sum of `M` and `M + 1`."
    },
    {
        "instruction": "Develop a function that compares two 2D numerical arrays of the same shape. It should return `True` if all corresponding elements are numerically equal within a small tolerance (e.g., absolute difference < 1e-5), and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array of shape (`rows`, `cols`) filled with sequential floating-point numbers starting from 0.0."
    },
    {
        "instruction": "Develop a function that takes two 1D numerical arrays (arr1, arr2) and an integer N. Extract the first N elements from both arr1 and arr2. Compute the element-wise sum of these extracted portions. Append exactly one zero element to the end of the resulting sum array and return this final array. Assume both input arrays have at least N elements."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays of the same size and returns a new array where each element is the sum of the corresponding elements from the input arrays."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a positive integer N, and returns a new array containing only the first N elements of the input array. Handle cases where N might be greater than the array length (return the original array slice)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and a non-negative integer P. It should return a new array formed by appending P zero elements to the end of the input array."
    },
    {
        "instruction": "Develop a function that accepts two 2D numerical arrays, `A` and `B`, of identical shape. The function should return `True` if `A` and `B` are element-wise equal within a small tolerance (e.g., absolute difference less than 1e-5), and `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes a shape tuple (e.g., `(rows, cols)`) as input. Inside the function, generate a 2D numerical array `A` of that shape with sequential float values starting from 0. Then, compute and return the element-wise sum of `A` and `A + 1`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (vector) of length N and reshapes it into a 2D numerical array (matrix) with a specified number of `rows` and `cols`, where `rows * cols == N`. Return the reshaped 2D array."
    },
    {
        "instruction": "Create a function that accepts two positive integers, `rows` and `cols`, and generates a 2D numerical array (matrix) of shape (`rows`, `cols`) filled with sequential floating-point numbers starting from 0."
    },
    {
        "instruction": "Develop a function that compares two numerical arrays for near-equality. It should return `True` if all corresponding elements are within a small tolerance (e.g., 1e-5) of each other, and `False` otherwise. The function should disregard minor differences in data types (e.g., float32 vs float64)."
    },
    {
        "instruction": "Write a function that takes a total count `N` and a shape tuple (e.g., `(dim1, dim2, ...)`). It should return a new numerical array of the specified shape containing integers from 0 to `N-1`. Ensure the product of dimensions in the shape tuple equals `N`."
    },
    {
        "instruction": "Write a function that simulates a distributed matrix multiplication check. Given shapes for input arrays `A` and `B` (compatible for matrix multiplication like `(d1, d2, d3)` and `(d3, d4)`) and a split count `k`, the function should: 1. Generate `A` and `B` with sequential integer values. 2. Calculate the full matrix product `C = A @ B`. 3. Split `C` into `k` equal parts along the first dimension (`d1`). 4. Return these `k` parts. Ensure `d1` is divisible by `k`."
    },
    {
        "instruction": "Implement a function to perform matrix multiplication on two multi-dimensional numerical arrays, `A` and `B`. Assume `A` has shape `(..., M, N)` and `B` has shape `(..., N, P)`. The function should return the resulting array `C` with shape `(..., M, P)`, handling potential broadcasting in the leading dimensions (`...`)."
    },
    {
        "instruction": "Write a function that performs matrix multiplication. It should accept two 2D numerical arrays (matrices) A and B, where the number of columns in A equals the number of rows in B, and return their product C = A @ B."
    },
    {
        "instruction": "Write a function that first computes the matrix product C of two input 2D numerical arrays A and B (C = A @ B). Then, it splits the resulting matrix C into exactly 4 equal sub-arrays along the first dimension. Return these 4 sub-arrays as a list. Assume dimensions are compatible for multiplication and the number of rows in C is divisible by 4."
    },
    {
        "instruction": "Implement a function that takes two 2D numerical arrays (matrices) of the *same* shape and returns a new matrix representing their element-wise sum."
    },
    {
        "instruction": "Create a function that generates a 2D numerical array (matrix) of a given shape (rows, cols) filled with sequential integers starting from 0."
    },
    {
        "instruction": "Implement a function that takes two 2D numerical arrays, `input1` and `input2`, of the same shape. It calculates their element-wise sum. The function contract specifies that `input2` must remain valid and unchanged after the call, while `input1` might be modified or become invalid. Return the sum array."
    },
    {
        "instruction": "Design a function `add_and_potentially_consume(data_a, data_b)` that takes two 2D numerical arrays `data_a` and `data_b` of identical shape. It must return their element-wise sum. The implementation should simulate a scenario where the memory associated with `data_a` could be reused or invalidated during the process, making `data_a` potentially unusable after the function call. `data_b` must remain valid. Clearly document this behavior in the function's description."
    },
    {
        "instruction": "Write a function that accepts two 2D numerical arrays with identical dimensions and computes their element-wise sum, returning the resulting array."
    },
    {
        "instruction": "Create a function that accepts three arguments: a binary operation function `op` (which works element-wise on two numbers), and two 2D numerical arrays `arr1` and `arr2` of the same shape. The function should apply `op` element-wise to `arr1` and `arr2` and return a new 2D array containing the results."
    },
    {
        "instruction": "Implement a function that performs element-wise addition of two identically shaped 2D numerical arrays, `input1` and `input2`. Include a parameter `reuse_input_name` (either 'input1' or 'input2') to signal which input's memory *could* theoretically be reused for the output. Return the resulting sum array."
    },
    {
        "instruction": "Write a function that accepts two 2D numerical arrays with identical dimensions and returns a new 2D array containing their element-wise sum."
    },
    {
        "instruction": "Create a function that takes two 2D numerical arrays. It should first verify they have exactly the same shape. If they do, return their element-wise sum; otherwise, raise a shape mismatch error."
    },
    {
        "instruction": "Develop a function that creates a 2D numerical array of given `rows` and `cols`, filled uniformly with a specified `value`."
    },
    {
        "instruction": "Implement a function that accepts three numerical 2D arrays of identical shape. It should compute their element-wise sum and return *both* the sum and the third input array as a pair (e.g., a tuple)."
    },
    {
        "instruction": "Develop a function that takes one positional numerical 2D array argument and two keyword numerical 2D array arguments (e.g., `func(arr1, kw_arr1=..., kw_arr2=...)`). Assume all arrays have the same shape. The function should return the element-wise sum of all three arrays."
    },
    {
        "instruction": "Create a function that generates a 2D numerical array of a given shape (e.g., M rows, N columns) filled with a specified constant numerical value."
    },
    {
        "instruction": "Design a function that accepts three numerical 2D arrays with identical shapes. The function should perform element-wise addition of the three arrays. It must return two values: the resulting sum array, and a copy of the third input array."
    },
    {
        "instruction": "Write a function that accepts three arguments intended to be identically structured nested data structures (containing numerical arrays): `struct1`, `struct2`, `struct3`. The function must be callable using positional and keyword arguments (e.g., `func(s1, struct2=s2, struct3=s3)`). It performs element-wise addition of corresponding arrays across the three structures and returns a new structure containing the results."
    },
    {
        "instruction": "Create a function that accepts three identically structured nested data structures (containing dictionaries/lists with numerical arrays at the leaves). It should traverse these structures simultaneously and return a *new* structure of the same shape, where each leaf array is the element-wise sum of the corresponding leaf arrays from the three inputs."
    },
    {
        "instruction": "Develop a function that takes a nested data structure (potentially containing dictionaries and lists) with numerical arrays at its leaves. The function should return a *new* structure with the same nesting, where each leaf array's elements have been doubled."
    },
    {
        "instruction": "Implement a function that accepts three 2D numerical arrays of identical shape and returns a new 2D array where each element is the sum of the corresponding elements from the three input arrays."
    },
    {
        "instruction": "Design a function `process_data_with_donation` that takes three nested dictionary structures (`data1`, `data2`, `data3`) and a list of names indicating which inputs are 'donated' (e.g., `['data2', 'data3']`). Inside the function, apply a conceptual 'tagging' operation (like Task 3, using a tag like 'PROCESSED') to all arrays within all three input structures. The function should return a tuple containing six items: (tagged `data1`, original `data1`, tagged `data2`, original `data2`, tagged `data3`, original `data3`)."
    },
    {
        "instruction": "Create a function `tag_data` that takes a numerical array and a tag (e.g., a string identifier). It should return a representation (e.g., a tuple or simple object) containing both the original array and the associated tag."
    },
    {
        "instruction": "Write a function `check_structure_validity` that takes an original data structure (e.g., a nested dictionary) and a status dictionary (mapping structure identifiers/names to 'valid' or 'invalidated' statuses). The function should traverse the original structure and verify that all its components are accessible if its status is 'valid', and raise an error or return `False` if accessed when the status is 'invalidated'. Return `True` if the check passes according to the status."
    },
    {
        "instruction": "Write a function `create_nested_data` that takes a 2D numerical array and returns a nested dictionary structure: `{'a': {'b': array_copy}, 'c': array_copy}`, where `array_copy` is a distinct copy of the input array."
    },
    {
        "instruction": "Create a function that accepts two positive integers representing rows and columns, and a numerical value. It should return a 2D numerical array with the specified dimensions, filled entirely with the provided value."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array and an `action_callback` function. This function should first execute the `action_callback` function twice using the input array, and subsequently compute and return a new 2D array representing the element-wise square of the input array."
    },
    {
        "instruction": "Implement a function that accepts a 2D numerical array and another function (let's call it `action_callback`). The main function must call `action_callback` exactly twice, passing the input 2D array to it each time. The main function itself doesn't need to return a value."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns a new 2D array of the same dimensions where each element is the square of the corresponding element in the input array."
    },
    {
        "instruction": "Implement a function that calculates the product of a 2D numerical array `A` (shape M x N) with its transpose (`A @ A.T`). The function must return the resulting M x M matrix. Crucially, guarantee that the input array `A` is not altered or invalidated by the function's execution."
    },
    {
        "instruction": "Write a function that performs matrix multiplication. It should take two compatible 2D numerical arrays, `A` (shape M x K) and `B` (shape K x N), and return their product `C` (shape M x N)."
    },
    {
        "instruction": "Implement a function that accepts a 2D numerical array (matrix) of shape M x N and returns its transpose, which will have the shape N x M."
    },
    {
        "instruction": "Write a function that takes two integers, M and N, and returns a 2D numerical array of shape M x N containing sequential integers starting from 0."
    },
    {
        "instruction": "Implement a function executor wrapper. It should accept: (a) a target function (e.g., one that takes two arrays and returns two arrays), (b) two input numerical arrays, (c) a list indicating which input array indices are eligible for memory reuse (e.g., `[0, 1]` means both inputs), and (d) a list of two output layout specifications (from Task 4). The wrapper should conceptually apply these configurations during execution and return the results produced by the target function."
    },
    {
        "instruction": "Create a function that takes two numerical arrays, `A` and `B`, of identical shape. It should return a tuple containing two new arrays: the first being `A` with each element multiplied by 2, and the second being `B` with each element multiplied by 2."
    },
    {
        "instruction": "Develop a function that accepts a list of unique identifiers (e.g., integers or strings) representing computational devices. Return a structure (like a set or a custom object) that encapsulates this group of devices, representing a 'computation mesh'."
    },
    {
        "instruction": "Write a function that takes the dimensions of a 2D array (e.g., rows=8, cols=2) and a 'computation mesh' structure (from Task 3). Return a data structure describing a layout strategy, specifying for each dimension whether it should be partitioned across the mesh or remain unpartitioned (replicated)."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array and returns a new 2D array where each element is the corresponding input element incremented by 1."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array as input. It should compute an intermediate array by adding 1 to each element of the input, and then compute a final array by multiplying each element of the intermediate array by 2. Return the final 2D array."
    },
    {
        "instruction": "Create a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array of shape (`rows`, `cols`) populated with consecutive integers starting from 0 (i.e., 0, 1, 2,...)."
    },
    {
        "instruction": "Design a function that takes a 2D numerical array. It calculates a final result using the formula `result = (input_array + 1) * 2`. Assume that conceptually, the intermediate result `(input_array + 1)` is associated with a specific data layout hint intended to split it into exactly 2 logical partitions. The function should return the final `result` array and also verify internally (e.g., by checking array dimensions or metadata) that the intermediate data could indeed be represented by exactly 2 partitions, returning a status (e.g., True/False) along with the result array."
    },
    {
        "instruction": "Write a function to verify a sequence of array operations. It takes an initial 2D numerical array, a list of operations (like 'add 1', 'multiply 2'), and a list of checks. Each check specifies an operation index and an expected conceptual data layout string for the result of that operation. The function should perform the calculations and return `True` if the final numerical result is correct AND all layout checks conceptually pass (i.e., the layout string matches at the specified index), `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array, performs an element-wise addition of 1, conceptually applies a specified layout preference (passed as a string) to this intermediate result, and then performs an element-wise multiplication by 2 on it. Return the final 2D numerical array. The layout preference should not alter the final numerical values."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns a new 2D array of the same shape where each element is the original element plus one."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array and a descriptive string representing a desired data layout (e.g., 'partitioned', 'replicated'). The function should return the original array numerically unchanged, but conceptually associate the layout string with the array (e.g., return a tuple `(array, layout_string)` or an object containing both)."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array and a \"partitioning specification\" (e.g., a tuple like `(num_partitions, dimension_to_split)` where `dimension_to_split` is 0 or 1, or `None` for replication). Return a list of strings describing the logical segments of the array based on the specification. For example, for an (8,8) array and `(2, 0)`, it might return `[\"segment 0: rows 0-3, cols 0-7\", \"segment 1: rows 4-7, cols 0-7\"]`. If the spec is `(2, None)`, it might return `[\"segment 0: full array replicated\", \"segment 1: full array replicated\"]`."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array as input. It should first create an intermediate array where each element is the corresponding input element plus 1. Then, it should create the final output array where each element is the corresponding intermediate element multiplied by 2. Return the final 2D array."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array `data` and a \"target layout rule\" (e.g., a string like 'partition_dim_0' or 'replicated'). The function must perform a sequence of operations: first, compute an intermediate array by adding 1 to each element of `data`; second, conceptually enforce the `target layout rule` on this intermediate array (the function should proceed as if this constraint is met); third, compute the final result by multiplying each element of the (conceptually constrained) intermediate array by 2. Return the final numerically correct 2D array."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar value. Return a new 2D array where the scalar value has been added to every element of the input array."
    },
    {
        "instruction": "Design a function that takes a 2D numerical array and a layout hint (e.g., a tuple like `(rows_split, cols_split)` indicating how the array might be conceptually partitioned). The function should return a representation that bundles the original array data with this layout hint, without modifying the array values."
    },
    {
        "instruction": "Implement a function that takes a list containing two numerical arrays and returns a new list containing exact copies of these two arrays in the same order."
    },
    {
        "instruction": "Develop a function that compares two lists of numerical arrays. It should return `True` if the lists have the same number of arrays and each corresponding pair of arrays (at the same index in both lists) are identical element-wise, otherwise return `False`."
    },
    {
        "instruction": "Create a function that accepts a list of numerical arrays and a 'constraint' function. It should apply the constraint function to each array in the list *without* altering the array's numerical values, returning a new list of the constrained arrays. Assume the constraint function conceptually marks the array."
    },
    {
        "instruction": "Develop a function that accesses and returns a specific numerical array located deep within a nested data structure, identified by a sequence of indices and keys (e.g., accessing element 0, then key 'a'). The function should handle potential errors if the path is invalid for the given structure."
    },
    {
        "instruction": "Write a function that constructs and returns a specific nested data structure: a list containing exactly two elements. The first element should be a dictionary with string keys ('a', 'b') mapping to 3D numerical arrays of a given shape. The second element should be another 3D numerical array of the same shape. Initialize arrays with sequential integer values."
    },
    {
        "instruction": "Create a function that takes a nested data structure (like [{'a': array1, 'b': array2}, array3]) and a scalar value. It should return a *new* copy of the structure where the array associated with the key 'a' in the first element (the dictionary) has all its elements multiplied by the scalar value."
    },
    {
        "instruction": "Write a function that simulates applying dimension-specific constraints to a numerical array within a nested structure. The function takes the structure, a path to an array, and a list of constraints (one per dimension, e.g., 'process', 'ignore'). It should apply a dummy processing step (like summing elements) only along dimensions marked 'process', effectively treating 'ignore' dimensions differently. Return the result of this selective processing."
    },
    {
        "instruction": "Write a function that takes two integers `R` and `C`, and returns a 2D numerical array of shape `(R, C)` containing floating-point numbers starting from 0.0 and incrementing sequentially row by row."
    },
    {
        "instruction": "Implement a function that takes a numerical array (1D or 2D) and returns a single scalar value representing the sum of all its elements."
    },
    {
        "instruction": "Develop a function that takes two inputs: a 2D numerical array `A` and a scalar value `S`. The function should first compute a new 2D array `B` where each element is the sine of the corresponding element in `A`. Then, it should calculate the sum of all elements in `B` and add the scalar `S` to it. Return the final scalar result."
    },
    {
        "instruction": "Write a function that takes an integer `N` and returns a 1D numerical array containing floating-point numbers from 0.0 up to (but not including) `N`."
    },
    {
        "instruction": "Develop a function that takes two inputs: a 2D numerical array `A` (M x N) and a 1D numerical array `h` (P elements). The function should compute the sum of `A` along axis 1 (result shape M) and multiply this result by the total sum of `h`. Return the final 1D array of shape M."
    },
    {
        "instruction": "Write a function that numerically approximates the gradient of a composite function `g(x) = f(transform(x))` at a given input point `x`. `x` is a 2D numerical array. `transform(x)` applies an element-wise operation (e.g., `sin(value * 4 + 2)`). `f(y)` performs an array reduction (e.g., sum along an axis) and possibly scales the result. Use the finite difference method to estimate the gradient, returning a 2D array with the same shape as `x`."
    },
    {
        "instruction": "Implement a function that receives a 2D numerical array (M rows, N columns). It should calculate the sum of elements along the second dimension (axis 1), producing a 1D array of size M. Return this 1D array."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array and returns a new 2D array of the same dimensions where each element is the result of `sin(original_element * 4 + 2)`."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and returns a new 1D array of the same size, where each element is the cosine of the corresponding element in the input array."
    },
    {
        "instruction": "Develop a function that accepts a 1D numerical array, applies the sine function element-wise, and then returns the sum of all elements in the resulting array as a single scalar value."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new 1D array of the same size, where each element is the sine of the corresponding element in the input array."
    },
    {
        "instruction": "Write a function that numerically approximates the element-wise gradient of a scalar function f(x) = sum(sin(x)) applied to a 1D numerical input array x. The function should take x and return a 1D array of the same shape, where each element i approximates df/dx[i]. Use a small step epsilon for finite differencing."
    },
    {
        "instruction": "Create a function that takes two numerical inputs, `x` and `y`. Return their sum `x + y`."
    },
    {
        "instruction": "Develop a function that accepts a number `base` and a string `modifier`. If `modifier` is `\"increase\"`, return `base + 3`. If `modifier` is `\"decrease\"`, return `base - 4`. Otherwise, return `base`."
    },
    {
        "instruction": "Implement a function that takes a number `value` and a string `key`. If `key` is `\"action1\"`, return `value + 3`. For any other `key`, return `value + 4`."
    },
    {
        "instruction": "Write a function that accepts a single string argument. Return the integer `3` if the string is exactly `\"hi\"`, otherwise return the integer `4`."
    },
    {
        "instruction": "Write a function that takes a 2D array of 32-bit unsigned integers. For each integer `s` in the input array, apply a fixed, deterministic transformation (e.g., `(s * 1103515245 + 12345) % (2**31)`) to produce a new integer. Return a 2D array of the same shape containing these transformed integers."
    },
    {
        "instruction": "Develop a function that receives a 2D array. It must verify and return whether the shape of the input array exactly matches a target shape, say (8, 4). The function should return True if the shapes match, False otherwise."
    },
    {
        "instruction": "Write a function that takes two positive integers, M and N. It should generate a 1D array containing integers from 0 up to (M*N - 1), and then reshape this into a 2D array of shape (M, N). Return the resulting 2D array."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array. It should return a new 2D array of the exact same dimensions (shape) where each element is simply the original element incremented by 1."
    },
    {
        "instruction": "Implement a function that takes a single numerical input, calculates its square, and returns the result of adding this squared value to itself."
    },
    {
        "instruction": "Write a function that generates a structured string representation for a nested computation. The computation involves an outer function that calls an inner function (which performs squaring) twice on the same input variable, then adds the results. The output string must use indentation and specific keywords (e.g., 'let', 'call', 'add') to clearly show the sequence of operations and dependencies, including intermediate results."
    },
    {
        "instruction": "Develop a function that takes the name of a simple operation (e.g., 'square'), an input variable name (e.g., 'a'), and an output variable name (e.g., 'b'). It should return a formatted string representing the assignment, like 'let b = square a'."
    },
    {
        "instruction": "Write a function that accepts a single number as input and returns the square of that number."
    },
    {
        "instruction": "Write a function that accepts two arguments of any type and returns the first argument unchanged."
    },
    {
        "instruction": "Implement a function that takes details of a simple binary operation (e.g., operation name like 'add', two input variable names like 'a' and 'a', an output variable name like 'c', and a type string like 'f32[1]') and returns a formatted string representing the assignment, such as 'c:f32[1] = add a a'."
    },
    {
        "instruction": "Create a function that takes a single numerical 1D array (vector) as input and returns a new 1D array where each element is the sum of the corresponding input element with itself."
    },
    {
        "instruction": "Develop a function to generate a formatted string representing a simple computation block. Input includes input variable details (e.g., 'a:f32[1]'), a list of operation strings (formatted as in Task 3), and the final output variable tuple string (e.g., '(c,)'). The output string should follow the pattern: '{ lambda ; input_vars. let\\n  operation1\\n  operation2\\nin output_vars }', ensuring correct indentation and spacing, without using color codes."
    },
    {
        "instruction": "Implement a function that generates a string representation of a simple function call. It should take a function name (string), an input variable name (string), and a constant value (numeric). Return a formatted string like 'output = function_name(variable_name, constant_value)'."
    },
    {
        "instruction": "Develop a function that takes a string representing a block of text and removes leading whitespace from each line. Ensure the entire block's indentation relative to itself is preserved, but the leftmost indentation is removed."
    },
    {
        "instruction": "Create a function that accepts a numerical array and a single scalar number. Return a new array where each element of the input array has been multiplied by the scalar."
    },
    {
        "instruction": "Write a function that takes two numerical arrays of the same shape and returns a new array where each element is the product of the corresponding elements from the input arrays."
    },
    {
        "instruction": "Implement a function that accepts a single 1D numerical array `v`. This function should compute the element-wise product `v * v * v` and return the resulting 1D array."
    },
    {
        "instruction": "Develop a function that generates a multi-line string representation for a computation equivalent to `result = input * input * input`. It takes one input variable name (string, e.g., 'x'). The output string should show two distinct multiplication steps using temporary names, clearly indicating how the initial input is used repeatedly. For example:\nlet temp1 = multiply x x\nlet result = multiply temp1 x"
    },
    {
        "instruction": "Write a function that takes three 1D numerical arrays of the same size and returns a new 1D array where each element is the product of the corresponding elements from the three input arrays."
    },
    {
        "instruction": "Write a function that takes a data type name (string, e.g., \"float\", \"int\") and a list representing shape (e.g., [1] or [10]) and returns a formatted string description like \"float[1]\" or \"int[10]\"."
    },
    {
        "instruction": "Write a function that accepts two numerical scalar inputs, `a` and `b`. Inside this function, define a helper function that takes one argument and multiplies it by `a`. The main function should return the sum of calling the helper function with `a` and calling the helper function with `b`."
    },
    {
        "instruction": "Implement a function that takes a structured representation of a simple mathematical expression involving variable assignments and binary operations (e.g., a list like `[('assign', 'x', 5), ('assign', 'y', 10), ('add', 'z', 'x', 'y')]`). The function should return a multi-line, indented string representation using `let` bindings, mimicking functional programming expression formats."
    },
    {
        "instruction": "Create a function `create_multiplier` that accepts a numerical scalar `factor`. This function should define and return a new function, `inner_multiplier`. The returned `inner_multiplier` function should accept a single numerical scalar argument `value` and return `value` multiplied by the `factor` captured from `create_multiplier`."
    },
    {
        "instruction": "Develop a function `apply_and_sum` that accepts another function `op` (which takes one numerical scalar and returns one) and two numerical scalar arguments `val1`, `val2`. The function should compute `op(val1)` and `op(val2)` and return their sum."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays, `arr1` and `arr2`. Calculate the element-wise square of `arr1` and the element-wise square of `arr2`. Return the sum of all elements from both squared arrays."
    },
    {
        "instruction": "Create a function that takes a multi-line string as input. It should determine the common leading whitespace shared by all non-empty lines and return a new string where this common whitespace is removed from the beginning of each line."
    },
    {
        "instruction": "Write a function that accepts a string and returns a new string with all leading and trailing whitespace characters removed."
    },
    {
        "instruction": "Develop a function that accepts two input variable names (strings, e.g., 'x', 'y') and returns a formatted string representing the expression '(var1 * var1) + (var2 * var2)', substituting 'var1' and 'var2' with the provided names."
    },
    {
        "instruction": "Write a function that takes no arguments and returns a tuple containing two distinct floating-point values: positive zero (+0.0) and negative zero (-0.0)."
    },
    {
        "instruction": "Implement a function that takes two arguments: a non-zero floating-point number `numerator` and a floating-point number `denominator` which is guaranteed to be either positive zero (+0.0) or negative zero (-0.0). The function should return positive infinity if the denominator is +0.0 and negative infinity if the denominator is -0.0 (assuming a positive numerator)."
    },
    {
        "instruction": "Create a function that accepts a single floating-point number. It should return True if the input is numerically equal to zero but has a negative sign (-0.0), and False otherwise."
    },
    {
        "instruction": "Write a function that takes a single positive floating-point number as input. The function should return a tuple containing two values: the result of dividing the input by negative zero (-0.0) and the result of dividing the input by positive zero (+0.0). Ensure the results correctly represent negative and positive infinity according to standard floating-point behavior."
    },
    {
        "instruction": "Create a function that accepts two 2D numerical arrays suitable for matrix multiplication (A: M x K, B: K x N). The function should compute their product (C = A @ B) and return a tuple containing two elements: the product C itself, and the element-wise square of C."
    },
    {
        "instruction": "Implement a function to perform matrix multiplication on two 2D numerical arrays. Input arrays have shapes (M, K) and (K, N), and the output should be a 2D array of shape (M, N)."
    },
    {
        "instruction": "Develop a function that takes a tuple representing axis assignments (e.g., ('batch', None, 'features')) and a shape tuple (e.g., (10, 5, 20)). It should return a new tuple of the same length as the shape, containing the axis assignments, padded with `None` if the assignment tuple is shorter than the shape tuple's length."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns a new 2D array of the same shape where each element is the square of the corresponding input element."
    },
    {
        "instruction": "Create a function execution wrapper. This wrapper takes a function `F`, input data `X`, and input/output data arrangement specifications. The wrapper should execute `F(X)` respecting a rule (like the one from Task 4) that dictates the output arrangement based *only* on the input arrangement, ensuring the final result matches the expected output arrangement specification. Verify this by ensuring `wrapper(identity_func, data, spec_in, spec_out)` returns data equivalent to the original `data`."
    },
    {
        "instruction": "Design a way to associate metadata with a function. This metadata should describe how the function's output data arrangement relates to its input data arrangement. Implement a specific rule stating the output arrangement is identical to the input arrangement."
    },
    {
        "instruction": "Implement a function that takes a numerical data structure `A`. Inside the function, it conceptually applies an identity transformation `ID(A)` (which results in `A`) and then computes and returns the element-wise sum `A + ID(A)`."
    },
    {
        "instruction": "Write a function that takes a single numerical data structure (e.g., a 2D array) as input and returns the identical data structure as output."
    },
    {
        "instruction": "Develop a function that validates configuration settings for a data processing task. It accepts two boolean flags: `input_is_pre_partitioned` and `use_automatic_partitioning`. If both flags are `True`, the function must raise a `ValueError` with the exact message: 'Cannot use automatic partitioning when input is already pre-partitioned.' Otherwise, it should return `True`."
    },
    {
        "instruction": "Create a function that takes a tuple representing the dimensions of a multi-dimensional array (e.g., `(d1, d2, ..., dn)`) and returns the total number of elements in an array of those dimensions."
    },
    {
        "instruction": "Write a function that accepts a tuple representing dimensions (e.g., `(rows, cols)`) and a data type name (e.g., 'float32'). It should return a new 2D numerical array of the specified shape, filled sequentially with integer numbers starting from 0, cast to the given data type."
    },
    {
        "instruction": "Design a function that simulates mapping a data array onto a logical 2D grid. Inputs are the grid dimensions (e.g., `(grid_rows, grid_cols)`) and the total data shape (e.g., `(data_rows, data_cols)`). Return a representation (e.g., a list of tuples) describing how data indices map to grid cells. Assume dimensions are compatible."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) of shape (M, N) and returns its transpose, which will have the shape (N, M)."
    },
    {
        "instruction": "Write a function that accepts two 2D numerical arrays: `input_matrix` (shape M x N) and `expected_result` (shape M x M). The function should first compute the product of `input_matrix` with its transpose. Then, it should compare the computed result with `expected_result` element-wise and return `True` if they are identical (or numerically close), `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array (matrix A, shape M x N) and two indices (row `r`, column `c`). The function should compute the matrix product `P = A @ A.T` and return the specific element `P[r, c]`. Ensure `r` and `c` are valid indices for the resulting M x M matrix."
    },
    {
        "instruction": "Implement a function that computes the matrix product of a given 2D numerical array (matrix A, shape M x N) with its own transpose (A.T, shape N x M). The function should return the resulting square matrix of shape M x M."
    },
    {
        "instruction": "Create a function that extracts a rectangular slice from a given 2D numerical array. Inputs are the array and the slice definition (e.g., start row, end row, start column, end column). Return a new 2D array containing the extracted data."
    },
    {
        "instruction": "Develop a function to calculate the dimensions (shape) of a single partition block when a larger 2D grid is divided into a specified number of smaller grid blocks. Inputs: the total grid dimensions (e.g., (8, 8)) and the number of partitions along each dimension (e.g., (4, 2)). Return the shape of one partition block (e.g., (2, 4)), assuming even division."
    },
    {
        "instruction": "Design a function that checks the consistency of a partitioned matrix operation result. Inputs: 1) An input matrix `X` (shape M, N). 2) A list of smaller 2D arrays representing partitions of the expected result `X @ X.T`. 3) A corresponding list describing the slice (location and size) of each partition within the full (M, M) result matrix. The function should compute the full `X @ X.T` result and verify if each provided partition correctly matches its corresponding slice in the full result. Return `True` if all partitions are consistent, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) `X` of shape (M, N) and returns the result of multiplying `X` by its transpose `X.T`. The output should be a 2D array of shape (M, M)."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array `data` and four integers `r_start`, `r_end`, `c_start`, `c_end`. It should return a new 2D array representing the slice `data[r_start:r_end, c_start:c_end]`. Assume valid slice indices."
    },
    {
        "instruction": "Implement a function that takes one argument, a 2D numerical array, and returns the exact same array without any modifications."
    },
    {
        "instruction": "Write a function that accepts two positive integers, `rows` and `cols`, and returns a 2D numerical array (matrix) of shape (`rows`, `cols`) filled with sequential integers starting from 0 (row-major order)."
    },
    {
        "instruction": "Create a function that accepts two 2D numerical arrays. It should return `True` if both arrays have identical dimensions and all corresponding elements are equal, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a tuple representing shape (e.g., (M, N)) and creates a 2D numerical array of that shape, filling it with sequential floating-point numbers starting from 0.0."
    },
    {
        "instruction": "Develop a function that takes an object representing partitioned data (as described in Task 4) and an expected shape tuple (e.g., (P, Q)). The function should iterate through all accessible data partitions within the object and return `True` only if *every* partition's data has the exact shape specified by the input shape tuple. Otherwise, return `False`."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array as input. It should process this array (e.g., potentially rearranging its internal representation) and return a new object that logically represents the *exact same* 2D numerical data. Verify that the value represented by the output object is identical to the input array."
    },
    {
        "instruction": "Write a function to validate partitioned data. It accepts an original 2D numerical array and a second object representing the same data broken into multiple partitions. This second object allows access to each partition's data and its corresponding index (location) within the original array. The function must check if the data in *every* partition exactly matches the data in the original array at the partition's specified index. Return `True` if all partitions match, `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts an object representing a partitioned 2D array. This object has attributes: `global_shape` (a tuple like (R, C)), `partition_grid` (a tuple like (PR, PC)), and `num_partitions`. Verify if the total number of elements in the `global_shape` equals the product of elements per partition (derived from `global_shape` and `partition_grid`) and `num_partitions`. Return `True` if consistent, `False` otherwise. Assume perfect division."
    },
    {
        "instruction": "Write a function that simulates applying an element-wise operation (multiply by 2) on a conceptually partitioned 2D array and verifies the result. Input: the original 2D numerical array. Output: a new 2D numerical array representing the result after applying the operation. The function must internally check that the output array has the exact same dimensions as the input array and that every element in the output array is precisely double the corresponding element in the input array. Return the resulting 2D array if all checks pass, otherwise raise an error."
    },
    {
        "instruction": "Implement a function to check data consistency. Inputs are: a large 2D numerical array (full data), a list of smaller 2D numerical arrays (data segments), and a list of index tuples defining where each segment belongs in the full array (e.g., `(slice(0,2), slice(0,1))`). Return `True` if every segment's data exactly matches the corresponding slice in the full data array, `False` otherwise."
    },
    {
        "instruction": "Develop a function that calculates the shape of a single partition. It takes the global shape of a 2D array (e.g., `(8, 2)`) and the grid dimensions used for partitioning (e.g., `(4, 2)` meaning 4 partitions along the first axis, 2 along the second). Return the shape of one partition (e.g., `(2, 1)`). Assume the global shape is evenly divisible by the grid dimensions."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) `A` with shape (M, N). Calculate the matrix product of `A` and its transpose (`A` times `A.T`). Return the resulting square matrix of shape (M, M)."
    },
    {
        "instruction": "Implement a function that receives a nested tuple structure containing numerical arrays, for example `(array1, (array2, (array3, array4)))`. The function should simply return the exact same nested tuple structure it received."
    },
    {
        "instruction": "Write a function that accepts a nested tuple containing numerical arrays, like `(array_A, (array_B, array_C))`. Perform the following operations: calculate the matrix product of `array_A` with its transpose, and multiply `array_C` element-wise by 2. Return a new nested tuple `(result_A_product, (array_B, result_C_scaled))` containing the results and the original `array_B`. Ensure the shapes of the returned arrays are consistent with the operations performed (e.g., if `array_A` is M x N, `result_A_product` should be M x M; `result_C_scaled` should have the same shape as `array_C`)."
    },
    {
        "instruction": "Develop a function that takes a large 2D numerical array and a list of index specifications (e.g., representing row/column slices or ranges). For each index specification, extract the corresponding sub-array (slice) from the large array. Return a list containing these extracted sub-arrays."
    },
    {
        "instruction": "Implement a function that simulates preparing data for processing based on requirements. It receives the data (which knows its own current arrangement) and the required arrangement. If the data's current arrangement doesn't meet the requirement, raise a `ValueError`. Otherwise, return the data."
    },
    {
        "instruction": "Create a function that validates data arrangement. It takes a data array, its actual arrangement description, and an expected arrangement description. If the actual and expected arrangements don't match, it must raise a `ValueError` that includes the shape of the data array in its message. Otherwise, it should indicate success (e.g., return `True`)."
    },
    {
        "instruction": "Write a function that compares two descriptions of how data is arranged (e.g., across different processing units). It should return `True` if the arrangements are identical, `False` otherwise."
    },
    {
        "instruction": "Design a validation function `check_processing_compatibility`. It accepts two inputs: one describing the properties of input data (including its shape and current arrangement) and another describing the arrangement required by a processing step. If the data's arrangement is incompatible with the requirement, raise a `ValueError` clearly stating the mismatch and the data's shape. If compatible, return `True`."
    },
    {
        "instruction": "Develop a function that takes another function `f` and a list of expected partitioning schemes (one per argument of `f`). It should return a new function or object that encapsulates `f` along with these expected input schemes."
    },
    {
        "instruction": "Implement a function that simulates creating a partitioned array. It should accept a shape tuple (e.g., (8, 2)), a grid configuration object (from Task 1), and a partitioning scheme object (from Task 2). Return an object containing the array's shape and its assigned partitioning scheme."
    },
    {
        "instruction": "Write a validation function that accepts an encapsulated function (from Task 4) and a list of input array objects (from Task 3). It must compare the expected partitioning scheme for each argument (stored in the encapsulated function) with the actual scheme stored in each input array object. Raise a value error if any mismatch is detected."
    },
    {
        "instruction": "Create a function that takes a list of axis names (where None indicates replication along that dimension) and returns a data structure representing a data partitioning scheme based on those named axes."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array as input. Internally, it should call an identity function twice: first with the original input, then with the result of the first call. Simulate a 'setup cost' counter that increments only the *first* time a function is called with data of a specific shape and type during the execution of this outer function. Return the final count after the two calls."
    },
    {
        "instruction": "Implement a function `identity_func(data)` that accepts any single input `data` and returns it without modification."
    },
    {
        "instruction": "Implement a function wrapper or class that tracks the number of times a *unique* input data signature (e.g., based on shape and data type) is encountered by the wrapped function for the first time. Calling the wrapped function multiple times with data having the same signature should only count the first occurrence. The wrapper should allow retrieving the count."
    },
    {
        "instruction": "Create a function `reshape_array(input_array, new_rows, new_cols)` that takes a 1D numerical array `input_array` and reshapes it into a 2D array of shape `(new_rows, new_cols)`. Assume the total number of elements is compatible."
    },
    {
        "instruction": "Implement a function that compares two 1D numerical arrays element-wise and returns `True` if they are identical (same values in the same order) and `False` otherwise."
    },
    {
        "instruction": "Create a function `assign_location(data, location_id)` that takes a numerical array `data` and an integer `location_id` (representing an abstract computational location like 0, 1, etc.). It should return a representation (e.g., a tuple or simple object) associating the data with the given location ID."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns the array unchanged. The function should handle floating-point numbers."
    },
    {
        "instruction": "Design a mechanism to track the distinct locations associated with data processed by a specific function. Implement a wrapper or tracker that, given a function `func` (like the one in Task 1), counts how many unique `location_id`s (from Task 3) have been encountered in the inputs passed to `func` via a mechanism like Task 4. Provide a way to retrieve this count."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns a new 2D array of the same shape where each element `y` is calculated as `sin(x * 4 + 2)` from the corresponding input element `x`."
    },
    {
        "instruction": "Develop a function `process_array` that accepts a 2D numerical array. Inside this function, define and use a helper function `transform_and_sum` which takes a 2D array, applies `sin(value * 4 + 2)` element-wise, and returns the sum of each row as a 1D array. The main `process_array` function should call `transform_and_sum` on its input and then multiply the resulting 1D array by a fixed scalar constant (e.g., 6.0). Return the final 1D array."
    },
    {
        "instruction": "Write a function to approximate the local sensitivity of a given function `F`'s output to its input. `F` maps a 2D numerical array `X` to a 1D array `Y`. Your function should take `F` and `X` as input. For each element `X[i, j]`, compute how each element `Y[k]` changes when `X[i, j]` is perturbed by a small amount `epsilon`. Return a structure holding these approximate rates of change `delta Y[k] / delta X[i, j]`."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (e.g., shape M x N) and returns a 1D array (shape M) where each element is the sum of the corresponding row in the input array."
    },
    {
        "instruction": "Write a function that creates a 1D numerical array containing a sequence of numbers from 0 to N-1, and then reshapes it into a 2D array with specified dimensions (rows, columns). Ensure the total number of elements N matches rows * columns."
    },
    {
        "instruction": "Write a function that simulates extracting a specific data partition. It should accept a 2D numerical array and index information (e.g., start row, end row, start col, end col) defining a slice. The function should return a new 2D array containing only the elements within the specified slice."
    },
    {
        "instruction": "Design a function that verifies the outcome of a distributed identity operation. It takes an original 2D numerical array and a second 2D array (representing the result after the operation). It also takes descriptions of how both arrays are partitioned across a logical grid of processing units. The function should return `True` only if the data in both arrays is identical AND their partitioning schemes are equivalent, `False` otherwise."
    },
    {
        "instruction": "Given the total shape of a 2D array (e.g., (R, C)), the coordinates of a specific processing unit within a 2D logical grid (e.g., (grid_row, grid_col)), and the dimensions of the grid (e.g., (G_R, G_C)), calculate the slice (indices) of the original array that corresponds to this specific unit, assuming the array is partitioned evenly across the grid."
    },
    {
        "instruction": "Design a function that takes an object (containing a data array and a 'layout' attribute) and returns it. Then, write code to call this function once with an input object and check if the 'layout' attribute of the returned object is the *exact same object instance* (same memory ID) as the 'layout' attribute of the original input object. Return `True` if they are the same instance, `False` otherwise."
    },
    {
        "instruction": "Implement a function that accepts an object which contains both a numerical data array and a separate 'layout' description attribute. The function should return the unique memory identifier (ID) of this 'layout' attribute."
    },
    {
        "instruction": "Write a function that takes an object (containing a data array and a 'layout' attribute) and an integer `N`. Apply an identity operation (returning the object unchanged) `N` times sequentially. After each application (including the initial state), record the memory ID of the 'layout' attribute. Return `True` if all recorded IDs are identical *and* the final data array is element-wise identical to the initial data array, `False` otherwise."
    },
    {
        "instruction": "Create a function that takes two 2D numerical arrays of the same shape and returns `True` if they contain the exact same elements in the same positions, and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes the overall shape of a 2D data array and a description of how its dimensions are assigned to the axes of a 2D logical grid. Return an object or structure representing this assignment (e.g., dimension 0 maps to grid axis 'axis_0', dimension 1 maps to grid axis 'axis_1')."
    },
    {
        "instruction": "Implement a function `calculate_local_slice`. Given the total shape of a 2D array, the dimensions of a 2D logical grid it's distributed over, the assignment of array dimensions to grid axes, and the coordinates of a specific location within the grid, calculate and return the range of indices (start, end for each dimension) of the data slice held at that grid location. Assume data is evenly divided."
    },
    {
        "instruction": "Implement a function `get_cached_computation(key)`. This function should perform a mock computation based on the input `key` (e.g., return `f\"Computed value for {key}\"`). It must use an internal cache (e.g., a dictionary). If the `key` exists in the cache, return the cached value and record a 'hit'. Otherwise, perform the mock computation, store the result in the cache against the `key`, record a 'miss', and return the result. Provide a way to retrieve the total 'hit' and 'miss' counts."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array and returns an identical copy, preserving its shape, data type, and values."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar value. Return a new 2D array of the same shape where each element is the corresponding element of the input array multiplied by the scalar value."
    },
    {
        "instruction": "Design a function that simulates defining a data distribution pattern over a logical grid of resources (e.g., a 2x2 grid). The function should take the grid dimensions and axis identifiers (e.g., 'resource_dim_0', 'resource_dim_1') and return a representation of how data should be partitioned across this grid."
    },
    {
        "instruction": "Create a function that generates a 2D numerical array of specified dimensions (e.g., 8 rows, 2 columns) filled entirely with zeros, using a specified numerical data type (e.g., a 16-bit floating-point type)."
    },
    {
        "instruction": "Implement a function that verifies data distribution compatibility. It takes two arguments: (1) a description of how an input data array is currently distributed (e.g., 'fully on resource 0') and (2) a description of the required distribution pattern (e.g., 'distributed across a 2x2 grid according to pattern X'). Raise a custom error (e.g., `DistributionMismatchError`) if the current distribution is incompatible with the required pattern, otherwise return True."
    },
    {
        "instruction": "Develop a function that takes an integer `n`. It should generate `n` distinct tasks. Each task consists of a 1D numerical array of size `i` (initialized with values 0 to `i-1`) and an integer scalar `i`, where `i` ranges from 0 to `n-1`. Return these tasks as a list of tuples, where each tuple is (array, scalar)."
    },
    {
        "instruction": "Write a function that simulates concurrent execution and result verification. It takes a list of 'task' tuples, where each tuple contains (input_array, scalar_value). For each task, it calculates the expected result (input_array + scalar_value). It then simulates running these tasks (e.g., by simply calculating the result) and compares the simulated result with the expected result for every task. Return `True` if all results match, `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts an integer `n` and returns a 1D numerical array of length `n` where the element at index `j` has the value `j` (e.g., for n=3, return [0, 1, 2])."
    },
    {
        "instruction": "Implement a function that takes a list of functions and a corresponding list of input arguments (where each argument might be a tuple or list itself). The function should execute each function with its respective arguments and return a list containing the results of each execution."
    },
    {
        "instruction": "Write a function that takes a shape tuple (e.g., (8, 2)), generates a 2D numerical array of that shape with sequential integers, and then computes the matrix product of this array with its transpose. Return the final square matrix."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix) and returns its transpose. Input is an MxN array, output is an NxM array."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `M`. Inside the function, calculate the matrix product `P = M @ M.T`. Repeat this *exact* calculation (using the same `M`) 10 times. Return the final result `P` obtained from the last calculation."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) `M` and computes the matrix product of `M` with its transpose (`M` multiplied by `M_transpose`). Return the resulting square matrix."
    },
    {
        "instruction": "Write a function that checks if the number of available computational units (e.g., cores or accelerators) meets a specified minimum requirement (an integer). Return `True` if the count is greater than or equal to the minimum, `False` otherwise."
    },
    {
        "instruction": "Implement a function that compares two 1D numerical arrays for element-wise equality. It should return `True` if they have the same shape and all corresponding elements are equal within a small tolerance (for floating-point types), and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array where each element is doubled. The input and output arrays should have the same shape."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays of the same shape and returns a new array representing their element-wise sum. Ensure the output has the same shape as the inputs."
    },
    {
        "instruction": "Create a function that accepts exactly one keyword argument named `input_value`. The function should return the value provided for `input_value`."
    },
    {
        "instruction": "Implement a function that takes one required argument. Ensure this function correctly retrieves and returns the argument's value even if it's provided using its name (as a keyword argument) during the function call."
    },
    {
        "instruction": "Write a function that takes a single argument (any data type) and returns it directly without modification."
    },
    {
        "instruction": "Write a function wrapper that takes another function `f` as input. The wrapper should return a new function that accepts any keyword arguments, calls `f` with those arguments, and returns the result. Demonstrate by wrapping a function that expects a keyword argument `data`."
    },
    {
        "instruction": "Write a function that accepts an optional string argument with a default value of 'default_string'. The function should return the string argument (either the one provided or the default)."
    },
    {
        "instruction": "Write a function that takes one optional integer argument with a default value of 4. When called without any input, it should return this default value."
    },
    {
        "instruction": "Implement a function that takes one required numerical argument and an optional numerical argument that defaults to 5. The function should return the sum of the two arguments."
    },
    {
        "instruction": "Create a function that accepts an optional numerical argument, defaulting to 10 if not provided. The function should return the value of the argument it received (either the provided value or the default)."
    },
    {
        "instruction": "Create a context manager that acts as a counter. It should be initialized with a name. Within the `with` block, calling a specific method (e.g., `increment()`) on the context manager object increases an internal counter. After the block exits, the final count associated with the name should be retrievable. Ensure multiple instances with different names track counts independently."
    },
    {
        "instruction": "Write a function that accepts a single numerical value and returns that value incremented by one."
    },
    {
        "instruction": "Demonstrate using the context manager from Task 2 in a nested fashion. Show that entering a nested context correctly changes the 'execution_context' (e.g., to 'context_B') and exiting the inner context restores the value from the outer context ('context_A')."
    },
    {
        "instruction": "Implement a context manager class. Its `__enter__` method should set a global 'execution_context' variable to a value provided during instantiation (e.g., 'context_A'), and its `__exit__` method should restore the previous value of 'execution_context'."
    },
    {
        "instruction": "Write a function that accepts three numerical arrays as input (e.g., `arr1`, `arr2`, `arr3`) and returns a tuple containing these three arrays in the exact order they were received: `(arr1, arr2, arr3)`."
    },
    {
        "instruction": "Implement a function `generate_range_array(size)` that creates and returns a 1D numerical array containing sequential floating-point numbers starting from 0.0 up to (but not including) the integer `size`."
    },
    {
        "instruction": "Implement a function decorator or wrapper class that counts how many distinct ways a target function is called. A 'distinct way' is defined by the specific combination of positional and named arguments used. For example, `func(1, 2, z=3)` and `func(1, y=2, z=3)` should be counted as two distinct call patterns. The wrapper should maintain and report the total count of unique patterns encountered."
    },
    {
        "instruction": "Create a function `check_array_equality(array1, array2)` that takes two 1D numerical arrays and returns `True` if they contain the exact same elements in the same order, and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a non-negative integer `N` and returns a 1D numerical array containing the sequence of integers from 0 up to `N-1`. If `N` is 0, return an empty array."
    },
    {
        "instruction": "Write a function that accepts exactly six arguments (which can be any data type). The function should ignore the first five arguments and return the sixth argument unchanged."
    },
    {
        "instruction": "Write a function that takes multiple 1D numerical arrays as input arguments. It must use *only* the last array provided. The function should calculate and return a single number representing the sum of the squares of the elements in that last array."
    },
    {
        "instruction": "Develop a function that accepts several 1D numerical arrays and one 2D numerical array as input. The function should ignore all the 1D arrays and return the transpose of the input 2D array."
    },
    {
        "instruction": "Create a function that accepts five arguments (e.g., three numerical arrays, an integer, a string) but its return value depends *only* on the fifth argument (the string). The function should return the input string concatenated with itself, ignoring the first four arguments."
    },
    {
        "instruction": "Write a function `execute_with_subset` that takes another function `target_func`, an integer index `k`, and a variable number of arguments `*all_args`. Your function should invoke `target_func` passing *only* the k-th argument (0-indexed) from `*all_args`. Return the result produced by `target_func`. Assume `target_func` is designed to accept exactly one argument."
    },
    {
        "instruction": "Implement a function that takes exactly six numerical array arguments. The function must perform a calculation using *only* the sixth argument. Specifically, calculate the outer product of the sixth argument (assumed to be a 1D vector) with itself, returning the resulting 2D array (matrix). Ignore the first five arguments."
    },
    {
        "instruction": "Develop a function that accepts multiple numerical array arguments (variable number using *args). It should identify and use *only* the last argument provided. Return `True` if the last argument is a 1D array (vector) and `False` otherwise. Ignore all preceding arguments."
    },
    {
        "instruction": "Create a function that accepts a single 2D numerical array (matrix X, shape M x N) and computes the product of the matrix with its own transpose (X multiplied by X.T). Return the resulting square matrix (shape M x M)."
    },
    {
        "instruction": "Write a function that verifies a calculation. It takes two 2D numerical arrays: `computed_output` and `original_input`. Return `True` if `computed_output` is numerically equivalent to the product of `original_input` and its transpose, and `False` otherwise. Assume inputs are appropriate for the comparison."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication. It should accept two 2D numerical arrays, A (shape M x K) and B (shape K x N), and return their product C (shape M x N). Handle potential errors for incompatible shapes."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and returns its transpose. Ensure an input matrix of shape (M, N) results in an output matrix of shape (N, M)."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (e.g., shape M x N) and computes the sum of elements along axis 1, returning a 1D array (shape M,)."
    },
    {
        "instruction": "Write a function that takes a numerical array and applies the element-wise transformation `sin(element * 4 + 2)`, returning a new array of the same shape."
    },
    {
        "instruction": "Write a function to numerically approximate the gradient of a given scalar-valued function `f(x)` at a point `x` using the central difference formula: `(f(x + h) - f(x - h)) / (2h)`. The function should accept the callable function `f`, the point `x` (a 1D numerical array), and a small step `h`. Compute the gradient for each element of `x` independently and return a 1D array of the same shape as `x` containing the approximate partial derivatives."
    },
    {
        "instruction": "Define two functions, `process_data` and `analyze_result`. `process_data` takes a 2D numerical array, applies an element-wise transformation (e.g., `val * 0.5 + 1`), and returns the transformed array. `analyze_result` takes a 2D array, calls `process_data` on it, sums the result along axis 1, multiplies this 1D result by a fixed scalar (e.g., 6.0), and returns the final 1D array."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `Z` with shape (P, Q). For each row `z_row` (shape Q,) in `Z`, perform the following: 1. Create a 'scaled' array by multiplying the *entire* `Z` array by 2.0. 2. Reshape the current `z_row` into a 2D array of shape (1, Q). 3. Perform element-wise multiplication (using broadcasting rules) between the reshaped `z_row` (from step 2) and the 'scaled' `Z` array (from step 1). Collect these resulting broadcasted arrays for each row into a list and return the list."
    },
    {
        "instruction": "Write a function that takes a numerical array and returns a new array where each element of the input array is multiplied by the scalar value 2.0. The output array should have the same shape as the input array."
    },
    {
        "instruction": "Implement a function that performs element-wise multiplication between two numerical arrays that have broadcast-compatible shapes. The function should accept the two arrays as input and return the resulting array after broadcasting and multiplication."
    },
    {
        "instruction": "Define a function `outer_func` that accepts a numerical array `arr1`. Inside `outer_func`, compute an intermediate array `arr2` by multiplying `arr1` by 2.0. Then, define and immediately call an inner function `inner_func` that takes an array `arr3` and returns the element-wise product of `arr3` and the captured `arr2`. `outer_func` should call `inner_func` using `arr1` as the input `arr3`, and return the final result."
    },
    {
        "instruction": "Write a function `nested_compute` that takes a 1D numerical array `input_arr`. Inside this function: 1. Define a fixed 1D numerical array `param1`. 2. Calculate an intermediate 1D array `temp_result` using element-wise operations involving `input_arr`, `param1`, and potentially another generated array (e.g., `temp_result = (input_arr * 3.0) + param1`). 3. Define an inner function `final_compute` that takes a 1D array `data`. 4. `final_compute` should return the element-wise result of `data + (temp_result * 2.0) + param1`. 5. `nested_compute` must call `final_compute` with `input_arr` as its argument and return the result. Ensure all arrays used in element-wise operations have compatible sizes."
    },
    {
        "instruction": "Create a function that accepts two integers, `start` and `end`, and returns a 1D numerical array containing a sequence of floating-point numbers starting from `start` up to (but not including) `end`."
    },
    {
        "instruction": "Define a function `create_processor` that accepts a 1D numerical array `config_data`. This function should return a *new function* `process`. The returned `process` function should take a single 1D numerical array `input_data` (of the same size as `config_data`) and return a new 1D array representing the element-wise sum of `input_data` and the captured `config_data`."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays, `a` and `b`, of the same size, and a scalar number `s`. Return a new 1D array where each element `i` is calculated as `a[i] + b[i] * s`."
    },
    {
        "instruction": "Implement an outer function that accepts a 1D numerical array `x`. Inside this outer function, define a nested inner function that also accepts a 1D numerical array `z`. The outer function should call the inner function, passing `x` as the argument `z`, and return the result. The inner function should simply return its input `z` unmodified for now."
    },
    {
        "instruction": "Write a function that takes an integer `n` and returns a 1D numerical array containing the sequence of floating-point numbers from 0.0 up to (but not including) `n`."
    },
    {
        "instruction": "Create a function `outer_processor` that takes a 1D numerical array `input_data`. Inside `outer_processor`, define a fixed 1D numerical array `adjustment_vector` (e.g., sequence from 0.0 to 7.0). Then, define a nested function `inner_add` that takes a 1D array `arr` and returns the element-wise sum of `arr` and the `adjustment_vector`. `outer_processor` must call `inner_add` with `input_data` and return the final computed array."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays of the same size and returns a new 1D array representing their element-wise sum."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array where each element is the sine of the corresponding input element. Ensure the output array has the same length as the input."
    },
    {
        "instruction": "Write a function that takes two numerical arrays of the same shape and a small positive tolerance value. It should return `True` if all corresponding elements in the two arrays have an absolute difference less than or equal to the tolerance, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that computes the element-wise sine for any given N-dimensional numerical array. The output array must have the exact same shape as the input array."
    },
    {
        "instruction": "Create a higher-order function that accepts another function (which operates on a single number, e.g., cosine, exponentiation) and a 1D numerical array. It should return a new 1D array resulting from applying the accepted function element-wise to the input array."
    },
    {
        "instruction": "Develop a function `create_transformed_list` that takes two arguments: a list of numbers `input_list` and a numerical value `factor`. Inside this function, define a nested function `apply_factor` which takes a single number and returns that number multiplied by `factor`. `create_transformed_list` should then use `apply_factor` on each element of `input_list` and return the list of results."
    },
    {
        "instruction": "Implement a function that accepts a list of numbers. Inside this function, define a helper function that takes a single number and returns that number multiplied by itself (squared). The main function should apply this helper function to each number in the input list and return a new list containing the transformed numbers."
    },
    {
        "instruction": "Create a function `outer_func` that accepts a single argument `x`. Inside `outer_func`, define a nested function `inner_func` that also accepts a single argument `y`. `outer_func` should call `inner_func` with `x` as the argument and return the result. For this task, `inner_func` should simply return the argument it receives."
    },
    {
        "instruction": "Write a function that takes a list of numbers and returns a new list where each number is multiplied by 2."
    },
    {
        "instruction": "Write a function that takes an integer input, returns the integer incremented by one, and also appends a placeholder value (e.g., None or True) to an external list each time it is executed, allowing call tracking."
    },
    {
        "instruction": "Implement a function wrapper (e.g., a decorator or a higher-order function) called `run_once`. This wrapper should take a function `f` as input. The first time the wrapped function is called, it executes `f` normally. On subsequent calls with the *same* input arguments, it should return the previously computed result without re-executing `f` or its side effects."
    },
    {
        "instruction": "Develop a function `call_and_count` that accepts a function `target_func` (known to have a side effect like modifying a list) and a number `n`. It should call `target_func` exactly `n` times with a fixed input (e.g., the integer 1). It must return the total number of times the side effect was observed (e.g., by checking the length of the list modified by `target_func`)."
    },
    {
        "instruction": "Design a system with two functions: `execute_conditionally(func, *args)` and `force_always_execute(func, *args)`. `execute_conditionally` runs `func(*args)` only the first time for a unique set of `args`, storing the result and side effect state; subsequent calls return the stored result without running `func`. `force_always_execute` *always* runs `func(*args)` regardless of previous calls or stored results, ensuring side effects occur every time."
    },
    {
        "instruction": "Create a function that accepts two numerical arrays of identical shape and returns a new array representing their element-wise product."
    },
    {
        "instruction": "Implement a function that takes a numerical array and a 'placement hint' string (e.g., 'distribute_on_x') and returns a representation combining the array and its hint."
    },
    {
        "instruction": "Design a system that remembers the 'input characteristics' (data type, shape, placement hint) for the arguments of the first call to a function. On the second call, compare the new characteristics to the remembered ones. If any characteristic differs, return a string message detailing the first mismatch found (e.g., 'Input 1: Expected placement hint X, got Y'). If they match, return an empty string."
    },
    {
        "instruction": "Write a function that creates a 1D numerical array of a specified size `N`, containing floating-point numbers from 0.0 up to `N-1`."
    },
    {
        "instruction": "Write a function that takes two lists of integers of the same length and returns `True` if they are identical element by element, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional array and a target dimension index. It should apply a provided transformation function (which operates on a sub-array) to each slice of the input array along the specified dimension. Return the combined results as a new array with potentially a modified shape depending on the transformation but preserving the number of slices along the target dimension."
    },
    {
        "instruction": "Write a function that takes a total number of elements and a target shape (tuple of integers) and returns a multi-dimensional numerical array of that shape, filled with consecutive integers starting from 0."
    },
    {
        "instruction": "Develop a function that simulates applying a transformation iteratively. It takes an initial multi-dimensional array, a transformation function, and a number of steps. In each step, the transformation function is applied to the current array. The function should return the final array after all steps. Ensure the transformation preserves the array's shape throughout the process."
    },
    {
        "instruction": "Write a function that takes a numerical array and returns a new array where each element is multiplied by 2."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array which has one dimension of size 1 (e.g., shape (N, 1) or (1, N)) and returns a 1D array by removing that dimension."
    },
    {
        "instruction": "Implement a function that simulates applying an operation twice while preserving metadata. It accepts an array, an initial 'distribution marker', an operation function, and an 'expected output marker'. It should apply the operation to the input array once, verify the result is associated with the 'expected output marker', then apply the *same* operation to the *same original* input array again, and again verify the result is associated with the 'expected output marker'. Return True if both checks pass, False otherwise."
    },
    {
        "instruction": "Create a function that accepts a numerical array and an arbitrary 'distribution marker' object. Apply a simple element-wise transformation (e.g., add 1) to the array. Return the transformed array, ensuring it is explicitly associated with the *input* 'distribution marker'."
    },
    {
        "instruction": "Write a function that takes a numerical array and a scalar number, and returns a new array where each element of the input array is multiplied by the scalar."
    },
    {
        "instruction": "Implement a function that accepts an object representing a \"partitioned array\" (as created in Task 3) and an element-wise operation function (e.g., one that doubles each element). Apply the operation to the data within the partitioned array object and return a new partitioned array object containing the result, preserving the original partitioning specifications."
    },
    {
        "instruction": "Design a function or data structure that takes a numerical array and partitioning specifications (e.g., describing how data is split across logical axes) and returns an object representing the \"partitioned array\". This object should store both the data and its partitioning scheme."
    },
    {
        "instruction": "Create a function that generates a 1D numerical array containing a sequence of integers from 0 up to N-1, and then reshapes it into a 2D array with dimensions M x K. The function should take N, M, and K as input, ensuring N = M * K."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `data` and its associated metadata object `meta`. Apply an element-wise multiplication (e.g., multiply by 2) to `data`. Return `True` if the metadata object associated with the resulting array is of the exact same type and configuration as the input `meta`, and `False` otherwise."
    },
    {
        "instruction": "Design a system that can associate different types of 'distribution metadata' (e.g., 'SchemeA', 'SchemeB') with 2D numerical arrays. Implement a function application wrapper. This wrapper takes an operation function (like element-wise doubling) and an array with its metadata. It applies the operation and verifies that the output array retains the *identical* distribution metadata type and configuration as the input. The wrapper should work correctly regardless of whether the input metadata is 'SchemeA' or 'SchemeB'."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar value. Return a new 2D array of the same shape where each element is the result of multiplying the corresponding input element by the scalar."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and an associated 'layout' object (representing how data might be arranged). Calculate the sum of all elements in the array. Return the scalar sum and ensure the original 'layout' object is returned alongside it, unchanged."
    },
    {
        "instruction": "Create a function `run_with_messages` that takes a function `func` as input. Inside `run_with_messages`, print \"Starting...\" before calling `func`, and print \"Finished.\" after calling `func`. The function should return whatever `func` returns. Test it with a function that does nothing."
    },
    {
        "instruction": "Define a function `pointless_calculation` that calculates `1 + 1` internally but does not return the result. Call this function and verify that the value returned is the language's null/none value."
    },
    {
        "instruction": "Implement a function `execute_function` that takes one argument, expected to be another function (`func`). Inside `execute_function`, call the provided `func` and return its result. Demonstrate its use by passing a function that performs no action and returns nothing."
    },
    {
        "instruction": "Create a function `return_null` that takes no arguments and explicitly returns the language's equivalent of a null or none value. Write a line of code to call this function and check if the returned value is indeed the null/none value."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new array where each element is multiplied by 2."
    },
    {
        "instruction": "Implement a function that accepts a data representation (an array paired with a resource identifier, as from Task 2) and an operation function (e.g., a function that doubles each element). Apply the operation to the array and return a new representation containing the modified array but the original resource identifier."
    },
    {
        "instruction": "Develop a function that takes a data representation (an array paired with a source resource identifier) and a target resource identifier. Return a new representation containing the original array but associated with the target identifier, simulating a data move."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and a logical resource identifier (e.g., an integer). It should return a representation (like a tuple or simple object) pairing the array with the identifier, signifying its logical location."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array already associated with a processing group and strategy (like the output of Task 3). Apply an element-wise doubling operation to this array and return the modified array, maintaining its group/strategy association."
    },
    {
        "instruction": "Create a function that simulates assigning a 1D numerical array to a specific logical group of processing units (represented by an ID, e.g., 'group1') using a specified distribution strategy ('distributed' or 'replicated'). Return an object or structure representing the array's new state (e.g., containing the array, group ID, and strategy)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array where each element is multiplied by 2."
    },
    {
        "instruction": "Develop a function that checks if at least a specific number (e.g., 4) of processing units are available, given a list representing available units. Return True if the condition is met, False otherwise."
    },
    {
        "instruction": "Write a function that accepts three 2D numerical arrays (A, B, C) with potentially different but compatible shapes for the operations. The function should perform three independent calculations: (1) element-wise multiplication of A by 3, (2) element-wise squaring of B, (3) the transpose of C. Return these three resulting arrays as a collection (e.g., tuple or list)."
    },
    {
        "instruction": "Develop a function that computes the transpose of a given 2D numerical array. If the input array has shape (M, N), the output array should have shape (N, M)."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array and returns a new 2D array of the same shape where each element is the square of the corresponding element in the input array."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar number, and returns a new 2D array of the same shape where each element of the input array is multiplied by the scalar."
    },
    {
        "instruction": "Write a function that receives a list containing multiple numerical arrays and returns only the first array from that list."
    },
    {
        "instruction": "Write a function that takes a numerical array and returns a new array where each element is multiplied by 2."
    },
    {
        "instruction": "Develop a function that takes two numerical arrays, `arr1` and `arr2`, and an integer `count`. It should return a list containing `arr1` as the first element, followed by `count` repetitions of `arr2`."
    },
    {
        "instruction": "Create a function that accepts an integer `N` and returns a 1D numerical array containing the sequence of integers from 0 up to (but not including) `N`."
    },
    {
        "instruction": "Create two functions, `func_A` and `func_B`. Both should internally generate a pseudo-random integer based on a given integer seed. However, `func_A` should use configuration 'Mode A' and `func_B` should use configuration 'Mode B'. Ensure that for the same input seed, `func_A` and `func_B` produce *different* pseudo-random integers between 0 and 9."
    },
    {
        "instruction": "Write a function that takes an integer seed and returns a deterministic pseudo-random integer between 0 and 9 (inclusive). Calling the function multiple times with the same seed should always produce the same output."
    },
    {
        "instruction": "Implement a function that accepts an integer `x` and an integer `seed`. It should generate a pseudo-random integer between 0 and 9 based on the `seed` (using a fixed internal configuration) and return the sum of `x` and the random integer."
    },
    {
        "instruction": "Create a function `process(value, seed)` that generates a pseudo-random integer between 0 and 9 based on the `seed` using a specific internal configuration ('Mode X') and returns `value` plus the random integer. Write a wrapper or simulator `optimize(func)` that takes a function like `process` as input. Verify that calling `process(1, 72)` produces the exact same result as calling `optimize(process)(1, 72)`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (vector) of size `M` and returns a new 2D array of shape `(M, 1)` containing the same elements."
    },
    {
        "instruction": "Write a function that determines if two numerical arrays, `arr1` and `arr2`, with potentially different numbers of dimensions and different dimension sizes, are broadcast-compatible according to standard numerical library rules (comparing dimensions from right to left, they must match, or one dimension must be 1, or a dimension is missing). The function should return `True` if they are compatible for element-wise operations, and `False` otherwise. Do not perform the operation itself."
    },
    {
        "instruction": "Create a function that takes one numerical array as input and also accepts a *procedure* (a function that performs an action but returns no value and takes no arguments). The function should first execute the procedure, then return the original numerical array unchanged."
    },
    {
        "instruction": "Implement a function that accepts two numerical arrays: `matrix_a` (shape `M x N`) and `vector_b` (shape `M`). The function should effectively add `vector_b` to each column of `matrix_a` using broadcasting rules. Return the resulting `M x N` array."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `A` of shape (M, N) and a 1D numerical array `B` of shape (M,). It should return a new 2D array of shape (M, N) where each element `(i, j)` is the sum of `A[i, j]` and `B[i]` (effectively adding the vector `B` to each column of `A`)."
    },
    {
        "instruction": "Develop a function that accepts two numerical arrays, `matrix` (shape M, N) and `vector` (shape M,). It must compute and return the element-wise sum of `matrix` and `vector`, ensuring `vector` is broadcast correctly (e.g., treated as a column vector added to each column of `matrix`). Handle potential dimension mismatches gracefully (e.g., raise an error if `matrix.shape[0]` != `vector.shape[0]`)."
    },
    {
        "instruction": "Create a function that accepts one numerical array as input but performs no operations with it and explicitly returns no value (e.g., returns `None` or has an empty body)."
    },
    {
        "instruction": "Implement a function that takes two numerical arrays, `arr1` (shape M, N) and `arr2` (shape M,). Inside this function, first call a separate, pre-defined 'side_effect_function' (which accepts `arr1` but returns nothing), and then return the result of adding `arr2` (broadcasted appropriately as a column) to `arr1`."
    },
    {
        "instruction": "Write a function that takes existing multi-dimensional numerical data (e.g., a list of lists or equivalent structure) and returns a new array object representing this data, explicitly setting its element type to 32-bit floating point."
    },
    {
        "instruction": "Design a function `create_array_with_layout(data, layout_spec)` that takes numerical data (e.g., list of lists) and a layout specification object. It should return a new array object containing the data. Implement a mechanism to later query this returned array object to retrieve both its element data type and its associated `layout_spec`."
    },
    {
        "instruction": "Implement a function `are_arrays_equal(arr1, arr2)` that returns `True` if two input multi-dimensional numerical arrays `arr1` and `arr2` have identical shapes and element values, and `False` otherwise."
    },
    {
        "instruction": "Develop a function `get_array_dtype(arr)` that takes a multi-dimensional numerical array `arr` and returns a representation of its element data type (e.g., 'float32', 'int64')."
    },
    {
        "instruction": "Create a function that takes a numerical array and a 'partitioning configuration' object (e.g., a dictionary describing how data might be split across devices, like `{'axis_name': 'x', 'num_devices': 2}`). The function should return the array, ensuring this configuration is conceptually attached to it for later inspection."
    },
    {
        "instruction": "Write a function that accepts a positive integer `N` and returns a 1D numerical array containing the sequence of integers from 0 to `N-1`."
    },
    {
        "instruction": "Write a function `verify_configuration(array_with_config, expected_config)` that takes an array conceptually associated with a 'partitioning configuration' and an `expected_config` object. Return `True` if the associated configuration is identical to the `expected_config`, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that receives an array which is expected to have an associated 'partitioning configuration' (like the one from Task 2). The function should retrieve and return this configuration. If no configuration is associated, it should indicate this (e.g., return None or raise an error)."
    },
    {
        "instruction": "Write a function that associates a 1D numerical array with a specific logical resource group (represented by a list of identifiers, e.g., `[0, 1]`). Input: the array and the list of identifiers. Output: a structure (like a dictionary or custom object) containing both the array and its associated group identifiers."
    },
    {
        "instruction": "Create a function that partitions a list of resource identifiers (e.g., `[0, 1, 2, 3]`) into two equal, non-overlapping sub-lists representing distinct resource groups. The function should raise an error or return an indicator if the input list doesn't contain enough elements for the partition (e.g., requires at least 4 elements for two groups of 2). Return the two sub-lists."
    },
    {
        "instruction": "Create a function that generates an abstract description of a resource group layout. Input: the desired number of resources in the group (e.g., 2). Output: a data structure (like a dictionary or simple object) encapsulating this abstract property (e.g., `{'resource_count': 2}`). This structure is intended for use as a layout constraint, independent of specific resource identifiers."
    },
    {
        "instruction": "Create a function that applies an element-wise mathematical operation (e.g., sine) to a 1D numerical array. The function also takes an 'abstract layout template' (e.g., representing partitioning across N resources). Before computing, the function should conceptually check if the input array's properties (e.g., size) are compatible with the template. Return the transformed array."
    },
    {
        "instruction": "Design a way to represent a logical partitioning grid. This representation should store the grid's dimensions (e.g., a tuple like (2, 2)) and assign unique names to each dimension (e.g., ('dim_0', 'dim_1')). Implement a function or class constructor that takes the shape and names as input."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns a new 2D array of the same shape where each element is multiplied by 2."
    },
    {
        "instruction": "Create a function that generates a 1D sequence of integers from 0 up to (M*N)-1, and then reshapes this sequence into a 2D array with dimensions M rows and N columns. The function should accept M and N as arguments."
    },
    {
        "instruction": "Implement a function or structure to define a mapping between the axes of a data array and the named axes of a logical partitioning grid (like the one from Task 3). For instance, it should be able to represent that the first axis of a 2D array maps to 'dim_0' and the second axis maps to 'dim_1'."
    },
    {
        "instruction": "Write a function `check_same_shape(array1, array2)` that accepts two numerical arrays and returns `True` if they have identical shapes (same number of dimensions and same size in each dimension), `False` otherwise."
    },
    {
        "instruction": "Implement a function `scale_array(input_array, scalar)` that takes a numerical array `input_array` (any shape) and a number `scalar`. Return a new array of the same shape where each element is the original element multiplied by `scalar`."
    },
    {
        "instruction": "Create a function `generate_and_scale(rows, cols, multiplier)` that first generates a `rows` x `cols` 2D numerical array with sequential integers (0, 1, 2, ...) and then returns a new array where every element of the generated array is multiplied by `multiplier`."
    },
    {
        "instruction": "Develop a function `apply_elementwise_func(data_array, func)` which accepts a numerical array `data_array` and a function `func`. `func` takes a single number and returns a single number. The main function should return a new array of the same shape as `data_array`, where each element is the result of applying `func` to the corresponding element in `data_array`."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and returns a new 2D array containing the element-wise square of the input array (each element multiplied by itself)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar number. Return a new 2D array where each element of the input array is multiplied by the scalar."
    },
    {
        "instruction": "Develop a function that calculates the sum of all elements in a given 2D numerical array and returns the resulting single scalar value."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array. It should first multiply every element by 2, and then compute the element-wise square of the resulting array. Return the final 2D array."
    },
    {
        "instruction": "Create a function that performs element-wise multiplication between two 2D numerical arrays, supporting broadcasting rules (e.g., multiplying an M x N array by a 1 x N array). Return the resulting broadcasted array."
    },
    {
        "instruction": "Write a function that performs element-wise multiplication on two 2D numerical arrays, supporting broadcasting. Each array also has an associated 'layout specification' (e.g., a tuple describing partitioning per dimension). Verify if the layout specifications are compatible for broadcasting multiplication according to specific rules (e.g., dimensions being broadcast must have compatible or 'replicated' layouts). If compatible, return the resulting array. If incompatible, raise a custom `LayoutCompatibilityError`."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays of the exact same shape and returns a new 2D array representing their element-wise product."
    },
    {
        "instruction": "Implement a function that accepts two 2D numerical arrays and two corresponding 'layout hint' descriptors (e.g., strings or tuples indicating abstract partitioning like 'replicated' or 'partitioned_dim_0'). The function should check if the hints are compatible for an element-wise operation based on predefined rules (e.g., corresponding dimensions must have matching non-'replicated' hints). Return `True` if compatible, `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix) of shape (M, N) and returns its transpose with shape (N, M)."
    },
    {
        "instruction": "Write a function that computes the gradients of a scalar-valued function with respect to its two matrix inputs (A and B). The scalar function is defined as the sum of all elements of the matrix product of A and B. The function should return two gradient matrices, one with the same dimensions as A and one with the same dimensions as B."
    },
    {
        "instruction": "Develop a function that first performs matrix multiplication on two input matrices A (M x K) and B (K x N), and then calculates the sum of all elements in the resulting product matrix (M x N). Return this single scalar sum."
    },
    {
        "instruction": "Write a function that creates an 8x2 matrix (2D numerical array) containing sequential floating-point numbers starting from 0.0 (i.e., 0.0, 1.0, 2.0, ...)."
    },
    {
        "instruction": "Develop a function that first multiplies two compatible 2D numerical arrays (matrices) X (shape M, K) and Y (shape K, N) and then calculates the sum of all elements in the resulting product matrix (shape M, N). Return the final scalar sum."
    },
    {
        "instruction": "Create a function that computes the sum of all elements in a given 2D numerical array (matrix) and returns the resulting scalar value."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) of shape (M, N) and returns its transpose, which will have the shape (N, M)."
    },
    {
        "instruction": "Given two matrices, X (shape M, K) and the gradient of a scalar loss L with respect to the output of matrix multiplication Z (where Z = X @ Y), denoted as dL/dZ (shape M, N), write a function to compute the gradient of the loss with respect to the second input matrix Y, i.e., dL/dY. This involves the product of the transpose of X and dL/dZ. The function should return dL/dY (shape K, N)."
    },
    {
        "instruction": "Implement a function `transpose_matrix(matrix)` that takes a 2D numerical array (matrix) and returns its transpose."
    },
    {
        "instruction": "Write a function `create_sequential_matrix(rows, cols)` that returns a `rows x cols` numerical matrix filled with integers from 0 to `rows*cols - 1` in row-major order."
    },
    {
        "instruction": "Write a function `has_duplicate_dimension_tags(tags)` that takes a list of strings representing tags assigned to a matrix's dimensions (e.g., `['batch', 'feature']` or `['dim_x', 'dim_x']`). Return `True` if any tag appears more than once in the list, `False` otherwise."
    },
    {
        "instruction": "Develop a function `check_contracting_dimension_conflict(tags_a, tags_b, index_a, index_b)`. It takes lists of dimension tags for two matrices (`tags_a`, `tags_b`) and the indices of their contracting dimensions (`index_a`, `index_b`). Return `True` if the tags at these indices represent a conflict based on a rule (e.g., rule: conflict occurs if `tags_a[index_a] == tags_b[index_b]` and the tag is not 'None'), `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array and an axis specification (an integer index, or a special value indicating summation over all axes). It should return both the resulting sum (array or scalar) and the expected shape of this result."
    },
    {
        "instruction": "Implement a function that generates a 2D numerical array of shape (M, N) filled with sequential integers starting from 0. The function should then compute and return the sum of elements along a specified axis (0 or 1)."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and returns the sum of all its elements as a single scalar value."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and an integer axis index (0 or 1). Return a new array containing the sum of elements along the specified axis."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and an axis index (0 or 1). It should return a 1D array containing the maximum value found along the specified axis of the input array."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and returns a single scalar value representing the overall maximum element present in the entire array."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array of length L and two integers M and N, such that M * N equals L. The function should return a new 2D array with shape (M, N) containing the elements from the original 1D array, reshaped accordingly."
    },
    {
        "instruction": "Design a function that takes a 2D numerical array (e.g., shape M x N) as input. Conceptually, this function relates to how a final scalar value (derived from operations like finding maximums along an axis and then averaging) changes with respect to each element of the input. The function must return a 2D array of the exact same shape (M x N) as the input array, where each element represents the influence of the corresponding input element on the final scalar result."
    },
    {
        "instruction": "Write a function that takes a tuple representing the shape of a 2D array (e.g., `(M, N)`) and an integer `axis` (0, 1, or 2/-1). Return the shape tuple of the array after inserting a new dimension of size 1 at the specified axis."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array and an integer `axis`. It should return a new 3D array with a new dimension of size 1 inserted at the specified `axis`. For example, input shape (8, 2) and axis=0 should yield shape (1, 8, 2)."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array, an integer `axis` for dimension expansion, and an expected 3D shape tuple. The function should conceptually expand the array's dimensions at the given axis and verify if the resulting array's shape matches the provided expected shape. Return `True` if they match, `False` otherwise. Ensure proper handling of valid axis values (0, 1, 2, -1 for a 2D input becoming 3D)."
    },
    {
        "instruction": "Create a function that accepts an N-dimensional numerical array and an integer `axis`. Return a new (N+1)-dimensional array where a dimension of size 1 has been inserted at the specified `axis`. Handle positive and negative axis indices correctly."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays (list of lists) of the *same dimensions*. Return `True` if every element in the first array is equal to the corresponding element in the second array, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that generates a 2D numerical array (list of lists) with specified `rows` and `cols`. Populate this array with consecutive integers starting from 0, filling row by row."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array (list of lists) as input. Verify that the input is indeed 2-dimensional and return its dimensions (number of rows, number of columns). If it's not 2D, indicate an error."
    },
    {
        "instruction": "Implement a function that accepts a 2D numerical array (e.g., list of lists) and a positive integer `p`. It should return a new 2D array of the exact same dimensions where each element is the corresponding input element raised to the power `p`."
    },
    {
        "instruction": "Design a data structure or class that holds both a 1D numerical array and a simple string identifier representing its 'processing group'. Write a function to create an instance of this structure. Input: size (integer), group_id (string). Output: The structure containing the array (0 to size-1) and the group_id."
    },
    {
        "instruction": "Implement a function that performs element-wise addition of two 1D numerical arrays of the same size. Input: two 1D arrays. Output: a new 1D array containing the sums. Assume inputs are always compatible in size."
    },
    {
        "instruction": "Write a function that creates a 1D numerical array of a specified size, initialized with sequential integers starting from 0. Input: size (integer). Output: 1D array."
    },
    {
        "instruction": "Write a function that attempts element-wise addition (like Task 2) but operates on two instances of the structure from Task 3. Before performing the addition, it must check if their 'processing group' identifiers are the same (using logic similar to Task 4). If they are the same, return a new structure containing the resulting sum array and the shared group_id. If they are different, raise a specific error (e.g., `ValueError` with a message indicating group mismatch). Input: two data structures (array + group_id). Output: A new data structure or raises ValueError."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array of shape (`rows`, `cols`) filled with floating-point numbers starting from 0.0 and incrementing by 1.0 row by row."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and returns a new 2D array of the same dimensions where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array and an associated 'layout' description string. The function should apply an element-wise square root operation to the array and return both the resulting array and the *original* 'layout' description string unchanged."
    },
    {
        "instruction": "Develop a function that takes `rows` and `cols` as input, generates a 2D numerical array of that shape with sequential floats starting from 0.0, and then computes the element-wise sine of this array, returning the result."
    },
    {
        "instruction": "Write a function that accepts a 1D array of integers. It should return a *new* 1D array where each element is the floating-point representation of the corresponding input element. The output array must have a floating-point data type."
    },
    {
        "instruction": "Implement a function that takes a 2D integer array as input. It must return a *new* 2D array of the exact same dimensions, containing the same numerical values but converted to a standard 32-bit floating-point type."
    },
    {
        "instruction": "Create a function `generate_sequential_matrix(rows, cols)` that produces a 2D numerical array (matrix) with the specified number of `rows` and `cols`. The matrix elements should be consecutive integers starting from 0, filled row by row. The output array should have an integer data type."
    },
    {
        "instruction": "Develop a function `check_array_properties(original_array, converted_array)` that returns `True` if `converted_array` has the identical shape as `original_array` AND `converted_array`'s data type is floating-point. Otherwise, it should return `False`."
    },
    {
        "instruction": "Implement a function that rearranges the dimensions of a given N-dimensional numerical array according to a provided permutation of axes. The function should accept the array and a tuple representing the new order of dimensions (e.g., (1, 2, 0) for a 3D array)."
    },
    {
        "instruction": "Write a function that accepts a 3D numerical array with shape (A, B, C) and returns a new 3D array where the dimensions are permuted such that the original second dimension becomes the first, the original third dimension becomes the second, and the original first dimension becomes the third. The output shape should be (B, C, A)."
    },
    {
        "instruction": "Create a function that generates a 3D numerical array of specified dimensions (D1, D2, D3) filled with consecutive integers starting from 0."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and returns its transpose. For an input of shape (M, N), the output should have shape (N, M)."
    },
    {
        "instruction": "Implement a function that performs one-hot encoding. It should take a 1D array of non-negative integer indices and an integer `depth`. Return a 2D array where the element at `(i, arr[i])` is 1 and all others in row `i` are 0. The output array should have shape `(len(input_array), depth)`."
    },
    {
        "instruction": "Write a function that accepts a positive integer `n` and returns a 1D numerical array containing the sequence of integers from 0 up to `n-1`."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array `arr` and a target shape tuple `(rows, cols)`. First, create a new 1D array where each element is double the corresponding element in `arr`. Second, generate a 2D numerical array `iota_arr` with the target shape `(rows, cols)` where the value of each element `iota_arr[i][j]` is equal to its row index `i`. Return both the doubled 1D array and the generated 2D `iota_arr`."
    },
    {
        "instruction": "Develop a function that generates a 2D numerical array of a specified shape `(R, C)` and based on a given dimension index `d` (0 for rows, 1 for columns). The value of each element `output[i][j]` should be equal to its index `i` if `d=0`, or `j` if `d=1`."
    },
    {
        "instruction": "Write a function that first calculates the matrix product C = A @ B for two input 2D numerical arrays A (shape M x K) and B (shape K x N). Then, it computes the scalar sum S of all elements in the resulting matrix C. Finally, the function should return the gradients of S with respect to the input arrays A and B. The gradients should be returned as two separate arrays with the same shapes as A and B, respectively."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array of size P and two integers R and C (where R * C = P) and returns a new 2D numerical array of shape (R, C) containing the elements of the input array."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication. It should accept two 2D numerical arrays, A of shape M x K and B of shape K x N, and return their product C, a 2D array of shape M x N."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) of shape M x N and returns its transpose, which will be a new 2D array of shape N x M."
    },
    {
        "instruction": "Develop a function that takes a multi-dimensional numerical array and returns a new array of the same shape where each element is double the value of the corresponding element in the input array."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array and a target shape tuple. First, reshape the input array according to the target shape (assume valid). Then, calculate the sum of all elements in this reshaped array. Finally, return the square of this sum."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and a target shape tuple. If the reshape is valid (total elements match), return a new array with the target shape containing the original data. Otherwise, indicate an error (e.g., return None or raise an exception)."
    },
    {
        "instruction": "Write a function that takes a shape tuple (e.g., (2, 3, 4)) and returns a new multi-dimensional numerical array of that shape containing consecutive floating-point numbers starting from 0.0."
    },
    {
        "instruction": "Develop a function that checks if a proposed reshape operation between a source shape tuple and a destination shape tuple corresponds *only* to either splitting a single dimension or merging a sequence of adjacent dimensions. Return `True` if the reshape represents one of these allowed transformations and the total number of elements is conserved, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and a target shape tuple. Return a new array containing the same elements but arranged according to the target shape. Ensure the total number of elements in the input and output shapes are identical."
    },
    {
        "instruction": "Create a function that reshapes a multi-dimensional numerical array by 'splitting' a single specified dimension into multiple new dimensions. The function should accept the array, the index of the dimension to split, and a tuple representing the new dimensions that replace the original one. The product of the new dimensions must equal the size of the original dimension being split. Example: Input shape (A, B, C), split dimension 1 into (X, Y) where X*Y=B, output shape (A, X, Y, C)."
    },
    {
        "instruction": "Write a function that takes an input numerical array, a target shape, and a numerical multiplier. First, validate if reshaping the input array's shape to the target shape represents either a single-dimension split or an adjacent-dimension merge (similar to Task 4). If the reshape is valid, return a new array reshaped to the target shape with each element multiplied by the multiplier. If the reshape is invalid, raise a value error."
    },
    {
        "instruction": "Implement a function that performs element-wise conditional selection between two 2D numerical arrays (A and B) based on a 2D boolean array (condition). All arrays must have the same shape. The function should return a new 2D array where the element is taken from A if the condition is true at that position, and from B if the condition is false."
    },
    {
        "instruction": "Develop a function for conditional array selection that also enforces data layout consistency. Inputs are a 2D boolean array (condition) and two 2D numerical arrays (A and B), each associated with a 'layout_descriptor'. The function must first check if A and B have identical layout descriptors. If not, it should raise a type error with a message like 'select cases must have the same layout'. If they match, it performs element-wise selection (from A if true, B if false) and returns the result, ensuring the output array also carries the same layout descriptor."
    },
    {
        "instruction": "Write a function that creates a 1D numerical array containing integers from 0 to N-1 (inclusive) and then reshapes this array into a 2D array with R rows and C columns. The function should take R and C as input, calculate N = R * C, generate the sequence, and return the reshaped 2D array."
    },
    {
        "instruction": "Create a function that checks for layout compatibility between two multi-dimensional arrays. Assume each array has an associated metadata attribute describing its data distribution (e.g., 'layout_descriptor'). The function should take two such arrays as input and return `True` if their `layout_descriptor` attributes are identical, and `False` otherwise."
    },
    {
        "instruction": "Design a function that performs matrix multiplication on two inputs, where each input consists of a 2D array and its associated layout hints (as defined in Task 3). Input: `(Array1, (Hint1_Dim0, Hint1_Dim1))` and `(Array2, (Hint2_Dim0, Hint2_Dim1))`. Assume the inner dimensions (K) and their hints (`Hint1_Dim1`, `Hint2_Dim0`) are compatible. Output: A representation containing the resulting product array and its derived layout hints, calculated as `(Hint1_Dim0, Hint2_Dim1)`."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar number. Return a new 2D array where each element of the input array is multiplied by the scalar."
    },
    {
        "instruction": "Create a function that associates layout hints with a 2D numerical array. It takes the array and two symbolic 'hints' (e.g., strings like 'dim_x_split' or a special null value) representing how the first and second dimensions are conceptually arranged. Return a representation (like a tuple or simple object) containing the array and its two layout hints."
    },
    {
        "instruction": "Develop a function that applies an element-wise scaling operation (multiply by a scalar) to an input consisting of a 2D array and its associated layout hints. Input: `(Array, (Hint_Dim0, Hint_Dim1))` and a scalar value. Output: A representation containing the scaled array and its layout hints, which must be identical to the input layout hints `(Hint_Dim0, Hint_Dim1)`."
    },
    {
        "instruction": "Design a function that accepts a representation of how a 2D array's dimensions are distributed across computational resources (e.g., using symbolic names like 'X', 'Y' for partitioned dimensions, or 'None' for replicated dimensions). Given this input (e.g., ('X', None)), return a standardized representation confirming this distribution."
    },
    {
        "instruction": "Create a function that simulates checking an array's properties *during* a calculation. It accepts a 2D numerical array and an expected property description (e.g., a string like 'fully_replicated'). Inside the function, conceptually verify if the array matches this description. Return True if it matches, False otherwise."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array and a scalar value. It should return a new 2D array of the same shape where each element is the corresponding element from the input array multiplied by the scalar."
    },
    {
        "instruction": "Write a function that creates a 2D numerical array of shape 8x2, filling it with sequential integers starting from 0."
    },
    {
        "instruction": "Implement a validation function `is_valid_layout_transition(spec_before, spec_after)` that takes two 'layout specifications' (from Task 2). It should return `False` if the specifications are different *but* the collection of unique named logical axes involved remains exactly the same (ignoring None assignments). In all other cases (specifications are identical, or the set of unique named axes changes), it should return `True`."
    },
    {
        "instruction": "Create a function that accepts two 'layout specifications' (from Task 2). It should return `True` if both specifications assign the dimensions to the exact same logical axes (or None) in the same order, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and returns a new 2D numerical array of shape (`rows`, `cols`) populated with sequential integers starting from 0, filled row by row."
    },
    {
        "instruction": "Design a function or structure to represent a 'layout specification' for a 2D array. It should store how each of the two dimensions is assigned: either to a specific named logical axis (represented by a string) or to no specific axis (represented by None). The function should take the assignments for the two dimensions and return the specification object/structure."
    },
    {
        "instruction": "Write a function that takes two integers, M and N, and returns a 2D numerical array (M rows, N columns) filled with integers starting from 0 and increasing sequentially row by row."
    },
    {
        "instruction": "Design a data structure or class to represent a partitioning scheme for a 2D array. This structure should map the array's dimensions (e.g., 'rows', 'columns') to abstract partition axis names (e.g., 'partition_A', 'partition_B') or indicate if a dimension is not partitioned."
    },
    {
        "instruction": "Implement a function that associates a 2D numerical array with a given partitioning scheme (from Task 2). It should return an object or structure that logically binds the array data to its layout specification."
    },
    {
        "instruction": "Create a function that simulates attempting to change the partitioning scheme of an array. It takes an array already associated with an initial scheme (like the output of Task 3) and a target partitioning scheme. The function must raise a ValueError if changing from the initial scheme to the target scheme requires moving data between different explicitly named partition axes (i.e., an axis was named 'partition_A' initially and is named 'partition_B' in the target). Otherwise, it should indicate success (e.g., return True)."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays, `computed_result` and `expected_result`, assumed to have the same shape. The function should return `True` if all corresponding elements in the two arrays are equal, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that generates a 2D numerical array of shape (M, N) containing sequential integers starting from 0 (row-major order). For example, with M=8, N=2, the output should be [[0, 1], [2, 3], ..., [14, 15]]."
    },
    {
        "instruction": "Implement a function that takes two 2D numerical arrays (A and B) of identical shape. The function should first compute the element-wise product of A and B, and then multiply every element of the resulting array by 2. Return the final 2D array."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and a scalar number. It should return a new 2D array where every element of the input array is multiplied by the scalar."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns a new array where each element is multiplied by 2. Input shape (M, N) should result in output shape (M, N)."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays, A (M, K) and B (K, N), computes their matrix product C = A @ B, and then returns a new array where every element of C is multiplied by 2. The final output shape should be (M, N)."
    },
    {
        "instruction": "Implement a function simulating an aggregation step. It takes a list of 2D numerical arrays (all with the same shape, say PxQ) representing partial results, and returns a single 2D array of shape PxQ which is the element-wise sum of all arrays in the input list."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) of shape (M, N) and returns its transpose with shape (N, M)."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array. It should first extract a sub-array consisting of all rows and the first `k` columns (where `k` is also an input parameter less than the total number of columns). Then, it should compute and return the sum of all elements within this extracted sub-array."
    },
    {
        "instruction": "Develop a function that generates a 2D numerical array with `M` rows and `N` columns. The array should be filled sequentially with floating-point numbers starting from 0.0 (i.e., 0.0, 1.0, 2.0,...)."
    },
    {
        "instruction": "Design a function that attempts to slice a 2D numerical array based on start and end indices. The function also receives information describing how the array's data is partitioned (e.g., 'row-wise', 'column-wise', 'block-wise'). If the requested slice conflicts with the partitioning scheme (e.g., slicing across columns when the array is partitioned 'column-wise'), the function must raise a specific error (e.g., `ValueError` with a descriptive message). Otherwise, it should return the successfully sliced sub-array."
    },
    {
        "instruction": "Implement a function that slices a 2D numerical array to extract specific columns (e.g., columns 0 to `k`-1). Assume the input array follows a specific row-based data layout pattern. The function must verify that the resulting sliced array preserves this row-based layout pattern. Return `True` if the pattern is preserved, `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array and an axis index. If the dimension corresponding to the given axis index has size exactly 1, return a new array with that dimension removed. Otherwise, return the original array unchanged."
    },
    {
        "instruction": "Write a function `analyze_array` that takes a 3D numerical array with a known singleton dimension. Inside the function, remove the singleton dimension, calculate the sum of all elements in the resulting 2D array, and finally square this sum, returning the final scalar result. Then, implement a second function `calculate_impact` which takes the original 3D array and computes an array of the same shape, where each element represents how sensitive the final scalar result of `analyze_array` is to a small change in that corresponding input element."
    },
    {
        "instruction": "Implement a function that takes a 3D numerical array (e.g., shape (N, M, 1)). It should first remove the dimension of size 1 (resulting in an N x M array) and then return a new N x M array where each element is the square of the corresponding element in the intermediate array."
    },
    {
        "instruction": "Develop a function that accepts a 3D numerical array where one specific dimension is guaranteed to have size 1. The function should remove this singleton dimension to produce a 2D array and then return the sum of all elements in that 2D array as a single scalar value."
    },
    {
        "instruction": "Write a function `apply_padding_config(arr, pad_value, config)` that takes a 1D numerical array `arr`, a scalar `pad_value`, and a configuration tuple `config = (pad_low, pad_high, pad_interior)` containing non-negative integers. Return a new 1D array padded according to the configuration: `pad_low` values prepended, `pad_high` values appended, and `pad_interior` values inserted between original elements. Ensure correct handling of empty input arrays and zero padding amounts."
    },
    {
        "instruction": "Write a function `pad_ends(arr, pad_value, pad_low, pad_high)` that takes a 1D numerical array `arr`, a scalar `pad_value`, and two non-negative integers `pad_low`, `pad_high`. Return a new 1D array with `pad_low` copies of `pad_value` prepended and `pad_high` copies appended."
    },
    {
        "instruction": "Create a function `pad_interior(arr, pad_value, pad_interior)` that takes a 1D numerical array `arr`, a scalar `pad_value`, and a non-negative integer `pad_interior`. Return a new 1D array where `pad_interior` copies of `pad_value` are inserted between each adjacent pair of elements from the original `arr`. The ends are not padded. If the input array has fewer than 2 elements, no interior padding should be added."
    },
    {
        "instruction": "Implement a function `pad_and_transform(arr)` that takes a 1D numerical array `arr`. It should first pad the array by adding 2 zeros to the beginning and 2 zeros to the end. Then, calculate the sum of all elements in this padded array. Finally, return the square of this sum."
    },
    {
        "instruction": "Create a function `concatenate_with_layout_check` that takes two 2D numerical arrays and their respective 'layout specification' strings. If the layout strings are identical, concatenate the arrays horizontally (side-by-side, along the second dimension) and return the new array along with the original layout string. If the layout strings differ, raise a `ValueError`."
    },
    {
        "instruction": "Develop a function `create_sequential_array` that takes two integers, `rows` and `cols`. Return a new 2D numerical array of shape (`rows`, `cols`) filled with sequential floating-point numbers starting from 0.0 (e.g., 0.0, 1.0, 2.0,...)."
    },
    {
        "instruction": "Implement a function `process_concatenated_arrays` that accepts two 2D numerical arrays (`arr1`, `arr2`) with identical 'layout specifications'. First, concatenate them horizontally. Then, calculate the sum of all elements in the combined array. Finally, return the square of this sum. If the layout specifications are not identical, raise a `ValueError`."
    },
    {
        "instruction": "Write a function `verify_concatenation` that takes three 2D numerical arrays: `arr1`, `arr2`, and `result`. It should return `True` if `result` correctly represents `arr1` and `arr2` concatenated horizontally (side-by-side), and `False` otherwise. Assume `arr1` and `arr2` have compatible shapes for horizontal concatenation."
    },
    {
        "instruction": "Create a function that performs matrix multiplication of two 2D numerical arrays. It should accept array `A` with shape (M, K) and array `B` with shape (K, N) and return a new array `C` with shape (M, N)."
    },
    {
        "instruction": "Write a function that takes a numerical array of any shape and applies the Rectified Linear Unit (ReLU) activation element-wise. For each element `x`, the output element should be `max(0, x)`."
    },
    {
        "instruction": "Implement a function that takes two 2D numerical arrays, `Matrix1` (shape M x K) and `Matrix2` (shape K x N). It should compute `Intermediate = Matrix1 @ Matrix2`, apply ReLU element-wise to `Intermediate` to get `Activated`, compute the transpose `Matrix2_T` (shape N x K), and finally return the matrix product `Result = Activated @ Matrix2_T`. Ensure correct shape handling."
    },
    {
        "instruction": "Write a function that validates a 3D numerical input array intended for a sequence processing operation. Given the array and the index of the dimension representing the sequence steps (e.g., 0), verify that this dimension meets a specific structural requirement (e.g., ensuring data along this dimension is laid out consistently). Raise a ValueError with a descriptive message if the requirement is not met."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (M rows, N columns) and returns a 1D array containing the indices of the maximum values for each column (i.e., find max along axis 0). The output array should have length N."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns the index of the first occurrence of the minimum value."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns the index of the first occurrence of the maximum value."
    },
    {
        "instruction": "Develop a function that receives a 2D numerical array (M rows, N columns) and returns a 1D array containing the indices of the minimum values for each row (i.e., find min along axis 1). The output array should have length M."
    },
    {
        "instruction": "Implement a function that computes the transpose of a given 2D numerical array. If the input array has shape (M, N), the output array should have shape (N, M)."
    },
    {
        "instruction": "Write a function that accepts a single 2D numerical array `X` with shape (M, N). The function should first compute an intermediate array `Y` by multiplying every element of `X` by 2. Then, it should compute another intermediate array `Z` by taking the sine of each element in `Y`. Finally, it should return the result of the matrix multiplication of `Z` with the transpose of the original input `X`."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar number. Return a new 2D array of the same shape where each element of the input array is multiplied by the scalar."
    },
    {
        "instruction": "Develop a function to perform matrix multiplication on two 2D numerical arrays. It should take a first matrix A of shape (M, K) and a second matrix B of shape (K, N) and return their product, a matrix C of shape (M, N)."
    },
    {
        "instruction": "Develop a function that takes two 2D numerical arrays, `arr1` (shape M x K) and `arr2` (shape K x N). Inside the function, compute `temp = sin(arr1 * 2)`, then compute and return the matrix product of `temp` and `arr2`."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array of shape (M, N) and returns its transpose with shape (N, M)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array, multiplies every element by 2, and then applies the sine function element-wise. Return the resulting 2D array."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`. It should generate and return a 2D numerical array (matrix) of shape (`rows`, `cols`) filled with consecutive floating-point numbers starting from 0.0, incrementing row by row (e.g., for rows=2, cols=3, output is [[0., 1., 2.], [3., 4., 5.]])."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and returns a new array containing the element-wise sine of the input array."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `M` with dimensions R x C and computes the matrix product of `M` with its transpose (`M @ M.T`). The function should return the resulting R x R matrix."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns a new array where each element is multiplied by 2."
    },
    {
        "instruction": "Develop a function that receives a 2D numerical array as input. It should first scale all elements by 2, then apply the sine function element-wise to the scaled array, and finally compute the matrix product of this result with its own transpose. Return the final square matrix."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar number. Return a new 2D array where each element of the input array is multiplied by the scalar."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and returns a new 2D array containing the element-wise sine of the input array's elements."
    },
    {
        "instruction": "Develop a function that receives a 2D numerical array. It should first create an intermediate 2D array where every element is multiplied by 2. Then, it should compute the element-wise sine of this intermediate array. Return the final 2D array."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array containing N*M elements and reshapes it into a 2D array with dimensions N rows and M columns. Ensure the total number of elements is preserved."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array. Return a new 2D array of the same dimensions where each element is the sine of the corresponding element in the input array."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar number. Return a new 2D array of the same dimensions where each element is the corresponding element from the input array multiplied by the scalar."
    },
    {
        "instruction": "Implement a function that takes a single 2D numerical array `M` with shape (R, C). Compute and return the matrix product of `M` with its transpose (`M @ M.T`). The resulting array should have the shape (R, R)."
    },
    {
        "instruction": "Design a function that takes a 2D numerical array and an abstract 'layout specification' (e.g., a tuple like ('dim1', 'dim2') or (None, 'dim2')). The function should return a representation (like an object or dictionary) that bundles the array and its associated layout specification together."
    },
    {
        "instruction": "Write a function to compute the matrix product of two 2D numerical arrays. The function should accept matrix A (shape M x K) and matrix B (shape K x N) and return the resulting matrix C (shape M x N)."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix) with dimensions M rows and N columns, and returns its transpose, which will have dimensions N rows and M columns."
    },
    {
        "instruction": "Write a function that generates a 1D sequence of floating-point numbers from 0.0 up to (R*C)-1.0 and then reshapes this sequence into a 2D array (matrix) with R rows and C columns. Return the resulting 2D array."
    },
    {
        "instruction": "Develop a function that accepts a single 2D numerical array, let's call it matrix `X` with shape M x N. The function should first create a scaled version of `X` by multiplying every element by 2. Then, it should compute the transpose of the original matrix `X`. Finally, it should perform matrix multiplication between the scaled version of `X` and the transpose of `X`. Return the final resulting matrix (shape M x M)."
    },
    {
        "instruction": "Develop a function to check if parameters for splitting a 2D array are valid. It takes the array's shape (e.g., `(M, N)`), a list of desired chunk `sizes`, and the `axis` for splitting. Return `True` if the axis is valid (0 or 1) and the sum of `sizes` matches the array's dimension along that axis, otherwise return `False`. Input: shape tuple `(M, N)`, `sizes` list, `axis` integer. Output: Boolean."
    },
    {
        "instruction": "Design a function simulating a distributed computation and its gradient. It takes a 2D numerical array `A` and a 'layout' string. It should conceptually split `A` (e.g., row-wise), perform a calculation like `sum(square(chunk))` on each chunk, sum the results, and then return an array `G` of the same shape as `A` where `G[i,j] = 2 * A[i,j]`. Crucially, the function must also return the *original* 'layout' string alongside the result `G`. Input: Matrix `A` (M, N), layout string. Output: Tuple `(G, layout_string)`."
    },
    {
        "instruction": "Create a function that splits a 2D numerical array (matrix) into multiple smaller matrices along a specified dimension (`axis`). The sizes of the smaller matrices along that dimension are given by a list (`sizes`). Input: Matrix `A` of shape (M, N), `axis` (0 for rows, 1 for columns), `sizes` (a list of integers summing to M if axis=0, or N if axis=1). Output: A list/tuple of the resulting matrices."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array, splits it into chunks along the first dimension (rows) based on provided `sizes`, squares every element in each chunk, and returns the list of modified chunks. Input: Matrix `A` of shape (M, N), `sizes` (list summing to M). Output: A list/tuple of matrices with the same shapes as the chunks after splitting, but with elements squared."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array and returns it without any modifications to its shape or values."
    },
    {
        "instruction": "Write a function that generates a 2D numerical array of shape M x N, filling it with sequential integers starting from 0."
    },
    {
        "instruction": "Write a function that takes a representation containing a 2D numerical array and its 'distribution rule'. The function should simulate changing this rule (e.g., from 'distributed along dimension 0' to 'replicated'). It must return a new representation with the *original* array data but the *updated* distribution rule."
    },
    {
        "instruction": "Implement a function that accepts a 2D numerical array and a string representing a 'distribution rule' (e.g., 'distributed along dimension 0'). The function should return a representation (like a dictionary or simple object) containing both the array and its associated distribution rule."
    },
    {
        "instruction": "Write a function that takes two positive integers, M and N, and returns a 2D numerical array (matrix) of shape (M, N) populated with sequential integers starting from 0 (i.e., 0, 1, 2, ... M*N-1)."
    },
    {
        "instruction": "Using the metadata mechanism from Task 4, create a function that takes two inputs, each being a numerical array bundled with its own metadata dictionary. This function should process these inputs (e.g., by simply returning them as in Task 3). Ensure and verify that each output array is correctly bundled with the *exact* metadata dictionary that was associated with its corresponding input array."
    },
    {
        "instruction": "Implement a function that accepts exactly two arguments, which can be numerical arrays or other data structures. The function should return these two arguments unchanged as a two-element collection (like a pair or tuple), preserving the original order."
    },
    {
        "instruction": "Design a mechanism to associate a metadata dictionary with a numerical array. Write a function `attach_metadata(data_array, metadata_dict)` that returns a representation combining the array and its metadata. Also, provide a function `get_metadata(combined_object)` that retrieves the associated metadata dictionary."
    },
    {
        "instruction": "Design a function that takes two 2D numerical arrays (matrices) suitable for multiplication and a configuration string ('config'). If 'config' is 'valid', perform matrix multiplication and return the result. If 'config' is 'invalid_context', raise a custom `ValueError` with the message \"Configuration context mismatch\". For any other 'config' value, raise a `ValueError` with the message \"Unknown configuration\"."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication. It should accept two 2D numerical arrays, A (shape M x K) and B (shape K x N), and return their product C as a new 2D array with shape (M x N)."
    },
    {
        "instruction": "Develop a function that generates a 2D numerical array of a specified shape (M, N) populated with consecutive integers starting from 0, filling row by row."
    },
    {
        "instruction": "Write a function that checks if two matrices, represented as 2D numerical arrays A (shape M x K) and B (shape P x N), are compatible for standard matrix multiplication (A @ B). It should return `True` if K equals P, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that simulates a distributed computation step. It takes a 3D numerical array and an input layout description (e.g., ['X', None, None] meaning dimension 0 is partitioned, others replicated). The function performs element-wise multiplication by 2. It must return both the resulting numerical array and the *output* layout description, determined by the rule: partitioned input dimensions remain partitioned in the output, otherwise, they become replicated. For example, input ['X', None, None] should result in output ['X', 'Replicated', 'Replicated']."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and a scalar value. It should return a new array of the same shape where each element is the corresponding element from the input array multiplied by the scalar."
    },
    {
        "instruction": "Design a function that accepts an array shape (e.g., a tuple like (4, 2, 2)) and a partitioning specification (e.g., a list or tuple like ['X', None, None]). The specification indicates how each dimension is treated ('X' for partitioned, None for replicated). Return a representation (like a dictionary or string) summarizing this layout, e.g., 'Dim 0: Partitioned(X), Dim 1: Replicated, Dim 2: Replicated'."
    },
    {
        "instruction": "Write a function that creates a 3D numerical array of a specified shape (e.g., 4x2x2) and fills it with consecutive integers starting from zero."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and applies the trigonometric sine function element-wise to it. Return the resulting 2D array with the same dimensions."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar number. Return a new 2D array of the same shape where each element is the corresponding element of the input array multiplied by the scalar."
    },
    {
        "instruction": "Implement a function that calculates the matrix product of a given 2D numerical array (M x N) with its own transpose (N x M). The function should return the resulting square matrix (M x M)."
    },
    {
        "instruction": "Design a function that performs matrix multiplication `C = A @ A.T`. The function receives the 2D array `A` (M x N) and two abstract descriptions: one for how `A`'s dimensions are conceptually partitioned (e.g., 'partitioned_rows_cols') and one for how the output `C`'s dimensions should be partitioned (e.g., 'partitioned_rows_only'). Return the computed M x M matrix `C`. The partitioning descriptions are conceptual hints and do not require implementing distributed logic."
    },
    {
        "instruction": "Develop a function that takes a multi-dimensional numerical array and a target shape tuple. Return `True` if the array's shape exactly matches the target shape, and `False` otherwise."
    },
    {
        "instruction": "Create a function that performs a generalized tensor contraction based on the pattern 'bthD, bthi, bthj->ijD'. It accepts three 4D numerical arrays: `x` (shape B, T, H, D), `y` (shape B, T, H, I), and `z` (shape B, T, H, J). It should sum over the shared dimensions (B, T, H) and return a 3D array with shape (I, J, D)."
    },
    {
        "instruction": "Implement a function that performs a specific tensor contraction corresponding to the rule 'ab,bc->ac'. It takes two 2D numerical arrays, the first of shape (M, K) and the second of shape (K, N), and returns a new 2D array of shape (M, N) representing their product. Avoid using built-in high-level matrix multiplication functions; focus on element-wise operations and summation."
    },
    {
        "instruction": "Write a function that calculates the product of all elements in a given shape tuple. For example, input `(8, 32, 1, 16)` should return `4096`."
    },
    {
        "instruction": "Create a function that accepts a tuple representing array dimensions (e.g., `(A, B, C)`). Return a new multi-dimensional numerical array of these dimensions, populated with consecutive integers starting from 0."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and checks if its shape matches a given target shape tuple. Return `True` if they match exactly dimension by dimension, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and a target shape tuple. It should return a new array viewed with the target shape, containing the original elements in order. Raise an error if the total number of elements in the input and target shapes are not identical."
    },
    {
        "instruction": "Implement a function that takes three 4-dimensional numerical arrays: X with shape (B, T, H, D), Y with shape (B, T, H, I), and Z with shape (B, T, H, J). Compute and return a 3-dimensional array P with shape (I, J, D) where P[i, j, d] is the sum of X[b, t, h, d] * Y[b, t, h, i] * Z[b, t, h, j] over all possible values of b, t, and h."
    },
    {
        "instruction": "Design a function that takes three arrays: a 2D boolean array `condition` (shape M x 1), and two 2D numerical arrays `data1` and `data2` (both potentially shape M x N). First, verify internally that the first dimension (size M) is consistent across all three inputs; raise an error if not. If consistent, perform a conditional selection based on the `condition` array, broadcasting its logic across the second dimension, to produce an output array of shape (M, N) selecting elements from `data1` or `data2` row-wise based on the boolean value in the corresponding row of `condition`."
    },
    {
        "instruction": "Create a function that takes a single numerical value (e.g., an integer or float) and a target shape specified as a tuple (e.g., `(rows, cols)`). Return a new 2D numerical array with the specified target shape where all elements are equal to the input value."
    },
    {
        "instruction": "Implement a function that accepts a 2D boolean array `cond` with shape (M, 1), and two 2D numerical arrays `x` and `y` both of shape (M, N). Return a 2D numerical array of shape (M, N) where the element at `[i, j]` is `x[i, j]` if `cond[i, 0]` is true, and `y[i, j]` if `cond[i, 0]` is false."
    },
    {
        "instruction": "Write a function that accepts three input arrays (they can be 1D or 2D). Inside the function, check if all three input arrays have the exact same shape. Return `True` if they match, and `False` otherwise. The function should not modify the inputs."
    },
    {
        "instruction": "Develop a function that performs a tensor contraction involving three multi-dimensional numerical arrays (A, B, C) based on an index string like 'bthD, bthi, bthj -> ijD'. Sum over indices appearing in input strings but not the output ('b', 't', 'h'), and arrange the result according to output indices ('i', 'j', 'D'). Assume dimensions for the same letter across inputs are compatible."
    },
    {
        "instruction": "Write a function that accepts a shape tuple (e.g., (8, 32, 1, 16)) and returns a new multi-dimensional numerical array of that shape filled with consecutive integers starting from 0."
    },
    {
        "instruction": "Create a function to validate dimension mapping consistency for an operation involving multiple arrays. Input: a list of shapes and a corresponding list of mapping rules (e.g., dictionaries mapping dimension *indices* to symbolic resource *names*). Check if any single resource *name* is mapped to different dimension *indices* across the inputs. Return True if consistent, False otherwise."
    },
    {
        "instruction": "Implement a function that takes two multi-dimensional numerical arrays, A and B, and index strings specifying a contraction, like 'bthD, bthi -> tiD'. The function should compute the resulting array by summing over the shared indices ('b', 'h') and arranging the result according to the output indices ('t', 'i', 'D'). Assume dimensions corresponding to the same letter have compatible sizes."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `M` with dimensions (R rows, C columns). Calculate and return the matrix product of `M` multiplied by its transpose (`M.T`). The resulting matrix should have dimensions (R rows, R columns)."
    },
    {
        "instruction": "Write a single function that performs a sequence of operations. It accepts a 2D numerical array `X` (shape N x M). Inside the function: 1. Compute `Y` by multiplying every element of `X` by 2.0. 2. Compute `Z` by applying the sine function element-wise to `Y`. 3. Compute and return the matrix product `A = Z @ Z.T`. The final output `A` will be a square matrix (shape N x N)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar value. Return a new 2D array where each element of the input array is multiplied by the scalar value. The output shape must match the input shape."
    },
    {
        "instruction": "Develop a function that takes two positive integers, `N` and `M`. Generate a sequence of `N*M` consecutive floating-point numbers starting from 0.0. Reshape this sequence into a 2D array with `N` rows and `M` columns and return it."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array containing R * C elements and reshapes it into a 2D array with R rows and C columns."
    },
    {
        "instruction": "Develop two functions: `process(data)` which returns `data * 2`, and `compute(input_data)` which calls `process` on `input_data` and returns the result. Ensure `compute` works correctly for a 2D numerical array input."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array M of shape (R, C) and computes its matrix product with its transpose (M multiplied by M_transpose). Return the resulting 2D array of shape (R, R)."
    },
    {
        "instruction": "Design a function `check_data_property(data, property_spec)` that takes a 2D numerical array and a property specification (e.g., a string describing an expected layout like 'distributed_rows_only' or 'fully_replicated'). The function should return True if the data hypothetically meets the property, False otherwise. Then, create a higher-level function that orchestrates a sequence: it takes initial data and spec, applies a transformation (e.g., element-wise multiply by 2), checks the result against an intermediate spec using `check_data_property`, applies another transformation (e.g., sine), checks against a final spec, and returns the final numerical result along with a boolean indicating if *all* property checks passed."
    },
    {
        "instruction": "Develop a function that calculates the output shape for the indexed lookup operation described in Task 2. Given the shape of the 2D data array as a tuple `(M, P)` and the shape of the 2D index array as a tuple `(N, K)`, return the shape of the resulting 3D array as a tuple `(N, K, P)`."
    },
    {
        "instruction": "Implement a function to calculate the gradient accumulation for an indexed lookup. It takes the shape of the original 2D data array (tuple `(M, P)`), the 2D integer index array used for lookup (shape N x K), and an upstream gradient array (shape N x K x P, same as the lookup output). Return a gradient array of shape (M x P) where the gradient for row `i` of the data array is the sum of all upstream gradient vectors `upstream_grad[r, c, :]` where `index[r, c] == i`. Initialize the output gradient array with zeros."
    },
    {
        "instruction": "Write a function that takes two integers, `rows` and `cols`, and returns a 2D numerical array of shape (`rows`, `cols`) filled with sequential floating-point numbers starting from 0.0."
    },
    {
        "instruction": "Write a function that takes a 3D numerical array (e.g., shape B x T x D) and computes the sum of all its elements, returning a single scalar value."
    },
    {
        "instruction": "Create a function that simulates changing the logical partitioning scheme of a 2D array. It accepts the array, an initial partitioning spec (e.g., a tuple like `('partition_x', 'partition_y')`), and a target spec (e.g., `('partition_x', None)`). Return a representation confirming the array now adheres to the target partitioning spec. Assume specs define how array dimensions map to logical partitions."
    },
    {
        "instruction": "Implement a function that computes the sum of all elements in a multi-dimensional numerical array. Input: A numerical array of any shape. Output: A single scalar value representing the total sum."
    },
    {
        "instruction": "Develop a function that applies a transformation function independently to each 1D slice of a 2D array along its first dimension (rows). Input: A 2D numerical array, a transformation function (which takes a 1D array and returns a 1D array). Output: A new 2D array where each row is the result of applying the transformation function to the corresponding input row."
    },
    {
        "instruction": "Write a function that validates if a target data partitioning specification is compatible with an array's defined partitioning context. Assume partitioning specs are tuples (e.g., `('axis_a', None)`) and the context is a set of available axis names (e.g., `{'axis_a', 'axis_b'}`). Raise a ValueError with a descriptive message if the target specification uses an axis name not present in the context. Input: Target partitioning tuple, set of available axis names in the context. Output: None (or raises ValueError)."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) and returns its transpose. If the input shape is (M, N), the output shape should be (N, M)."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array and applies the sine function to each element individually, returning a new array of the same dimensions."
    },
    {
        "instruction": "Develop a function to perform matrix multiplication between two 2D numerical arrays, A (shape M x K) and B (shape K x N), returning the resulting array C (shape M x N)."
    },
    {
        "instruction": "Write a function that takes two 2D numerical input arrays, A (M x K) and B (K x N), and a scalar value S. It should first compute the element-wise sine of A, then multiply the result by B, and finally add S to every element of the resulting matrix. The function must ensure the final M x N output matrix conceptually follows a layout where its first dimension (M) is partitioned, but its second dimension (N) is replicated (not partitioned)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns a new 2D array of the same shape where each element is the sine of the corresponding element in the input array."
    },
    {
        "instruction": "Design a function that performs matrix multiplication on two 2D input arrays. The function must also accept input 'layout hints' (e.g., simple strings like 'dim0_resourceA', 'dim1_resourceB') specifying how each dimension of the input arrays conceptually aligns with abstract resource axes. It should return the resulting 2D array along with an output layout hint derived according to a predefined rule (e.g., output dimension 0 follows input 1's dimension 0 hint, output dimension 1 is 'unassigned')."
    },
    {
        "instruction": "Implement a function to perform matrix multiplication on two compatible 2D numerical arrays. It should take array A (M x K) and array B (K x N) and return their product C (M x N)."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array with dimensions M x N and returns its transpose, resulting in a new array with dimensions N x M."
    },
    {
        "instruction": "Create a function that accepts a single argument (which could be a numerical array or other data type) and returns that argument exactly as it was received, without modification."
    },
    {
        "instruction": "Develop a function that takes a 1D sequence (e.g., a list or array) of items and returns a new 1D sequence containing the same items but in reverse order."
    },
    {
        "instruction": "Write a function that takes an integer `N` and two integers `rows`, `cols` (where `rows * cols == N`). It should return a 2D numerical array of shape (`rows`, `cols`) containing the integers from 0 to `N-1` in row-major order."
    },
    {
        "instruction": "Create a function that accepts two arguments: an object representing data associated with a logical grid configuration (like the output from Task 4), and a target grid configuration (e.g., dimensions `(rows, cols)`). The function should return `True` if the object's associated grid configuration matches the target configuration, and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array (matrix) as input and returns a new matrix of the same dimensions where each element is the square of the absolute value of the corresponding element in the input matrix."
    },
    {
        "instruction": "Write a function to compute the L2 norm (also known as Frobenius norm) of a 2D numerical array (matrix). This involves calculating the square root of the sum of the squares of the absolute values of all elements. Return the resulting scalar norm value."
    },
    {
        "instruction": "Write a function that creates a 2D numerical array (matrix) of specified dimensions (rows, columns) filled entirely with zeros. Return the resulting matrix."
    },
    {
        "instruction": "Develop a function that accepts a 2D numerical array (matrix) and computes the sum of the squares of the absolute values of all its elements. Return this sum as a scalar value."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array. Inside this function, first multiply the array element-wise by 2, and then square the resulting array element-wise. Now, write a higher-level function that accepts a 2D array (M rows, N columns) and applies the first function to each *row* independently, returning a new 2D array of shape (M, N) containing the results."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar number. Return a new 2D array of the same shape where each element of the input array is multiplied by the scalar."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array. It should process each row independently by first multiplying the row's elements by 2, then squaring the elements of that result. Finally, the function should compute and return the sum of all elements across all processed rows in the resulting 2D array."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array. Return a new 2D array of the same shape where each element is the square of the corresponding element in the input array."
    },
    {
        "instruction": "Write a function that rearranges the dimensions of a 3D numerical array. Given an input array of shape `(B, D1, D2)`, return a new array where the dimension of size `B` (originally the 0th axis) is moved to become the last axis, resulting in a shape `(D1, D2, B)`."
    },
    {
        "instruction": "Write a function that takes a flat list or 1D array of 16 floating-point numbers and reshapes it into a 3D array with dimensions (4, 2, 2). Handle potential errors if the input does not contain exactly 16 elements."
    },
    {
        "instruction": "Create a function that takes two 3D numerical arrays, `Arr1` of shape (B, M, K) and `Arr2` of shape (B, K, N). Apply matrix multiplication to each corresponding pair of 2D slices `Arr1[i, :, :]` and `Arr2[i, :, :]` for `i` from 0 to B-1. Return a 3D array of shape (B, M, N) containing the results."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication between two 2D numerical arrays. It should accept an array `A` of shape (M, K) and an array `B` of shape (K, N) and return a new array `C` of shape (M, N)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical input array of size `N` and applies a transformation to each element. The transformation converts each scalar element into a fixed-size 1D array of size `M` (e.g., an array of zeros). The function should return a new 2D numerical array of shape `(M, N)`, where each column corresponds to the result of the transformation for each input element."
    },
    {
        "instruction": "Develop a higher-order function called `vectorize_and_stack`. It should accept two arguments: a function `element_transform` (which takes a scalar and returns a 1D array of fixed size `M`) and an integer `stack_axis`. `vectorize_and_stack` should return a *new* function. This new function will take a 1D numerical input array (size `N`), apply `element_transform` to each element, and stack the resulting `M`-sized arrays into a 2D array. If `stack_axis` is 0, the output shape should be `(N, M)`; if `stack_axis` is 1 or -1, the output shape should be `(M, N)`. Handle potential errors for invalid `stack_axis` values."
    },
    {
        "instruction": "Create a function that accepts a positive integer `N` and returns a 1D numerical array containing the sequence of integers from 0 up to, but not including, `N`."
    },
    {
        "instruction": "Implement a function that takes two arguments: a 1D numerical input array and a function `transform_func`. The `transform_func` accepts a single number (scalar) and returns a 1D numerical array. Your function should apply `transform_func` to each element of the input array and return a list containing the resulting 1D arrays."
    },
    {
        "instruction": "Write a function that takes a positive integer `N` and returns a 1D numerical array containing the sequence of integers from 0 up to (but not including) `N`."
    },
    {
        "instruction": "Develop a function that internally defines a fixed 1D numerical array (e.g., `[0, 1, 2, 3]`). The function should take no arguments and return a *new* array where each element of the internal array has been multiplied by 2."
    },
    {
        "instruction": "Write a higher-order function `apply_and_duplicate`. It should accept two arguments: a function `op` (which takes a 1D numerical array and returns a transformed 1D numerical array) and a 1D numerical array `arr`. `apply_and_duplicate` should call `op(arr)` once, and then return a new 1D array formed by concatenating the result of `op(arr)` with itself."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and returns a new 1D array formed by appending the original array to itself (e.g., input `[1, 2]` results in `[1, 2, 1, 2]`)."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix) with dimensions M x N and returns its transpose, which will have dimensions N x M."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and two positive integers, `rows` and `cols`. Reshape the input array into a 2D numerical array (matrix) with the specified `rows` and `cols`. Raise an error if the total number of elements in the 1D array does not equal `rows * cols`."
    },
    {
        "instruction": "Develop a function to compute the product of two 2D numerical arrays (matrices). Input matrices `A` (shape M x K) and `B` (shape K x N) should produce an output matrix `C` (shape M x N). Include a check for compatible dimensions (inner dimensions must match) and raise an error if they are incompatible."
    },
    {
        "instruction": "Create a function that validates dimension labels for a matrix multiplication-like operation based on Einstein summation notation. It takes three strings representing the labels for the first input, second input, and the desired output (e.g., 'ik', 'kj', 'ij'). The function should return `True` if the labels describe a valid contraction (shared inner dimension, correct outer dimensions) and `False` otherwise. For example, 'ik', 'kj' -> 'ij' is valid, but 'ik', 'jk' -> 'ij' or 'ik', 'kj' -> 'ik' are not."
    },
    {
        "instruction": "Develop a function that multiplies two 2D numerical arrays based on index notation. Given arrays A and B, and a string like 'ik,kj->ij' specifying how indices contract and which form the output, compute and return the resulting array. Assume valid input notation corresponding to standard matrix multiplication."
    },
    {
        "instruction": "Implement a function that accepts a 2D numerical array (matrix) with dimensions M x N and returns its transpose, which will have dimensions N x M."
    },
    {
        "instruction": "Create a function to perform matrix multiplication. It should take two 2D numerical arrays, A (shape M x K) and B (shape K x N), verify their inner dimensions match (K), and return their product C (shape M x N). If dimensions are incompatible, it should signal an error (e.g., return None or raise an exception)."
    },
    {
        "instruction": "Write a function that accepts two 2D numerical arrays, `mat1` (shape M x N) and `mat2` (shape P x Q). The function should first determine if `mat2` can be transposed to become compatible for multiplication with `mat1` (i.e., check if N == P). If they are compatible after transposition, compute the product of `mat1` and the transpose of `mat2`. Return the resulting array (shape M x Q) or indicate incompatibility if N != P."
    },
    {
        "instruction": "Write a function that compares two numerical arrays of the same shape. It should return `True` if all corresponding elements are equal, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that calculates the cumulative sum of a numerical array along a specified dimension (axis). The function should accept the array and the axis index as input and return a new array of the same shape with the cumulative sums along that axis."
    },
    {
        "instruction": "Create a function that generates a 2D numerical array of shape (M, N) filled with sequential integers starting from 0, arranged row by row. The function should take integers M and N as input."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is the cumulative sum of the input elements up to that position. Example: Input `[1, 2, 3]`, Output `[1, 3, 6]`."
    },
    {
        "instruction": "Write a function `create_layout` that takes grid dimensions (e.g., `(2, 2)`) and dimension names (e.g., `('rows', 'cols')`) and returns a simple structure representing this 2D data layout specification."
    },
    {
        "instruction": "Implement a function `apply_layout` that accepts a 2D numerical array and a layout specification structure (from Task 1). It should return a new object containing both the original array data (unchanged) and the provided layout specification."
    },
    {
        "instruction": "Write a function `enforce_layout` that takes a 2D numerical array (which might conceptually have a pre-existing layout association) and a target layout specification. Return an object containing the original array data and the target layout specification, effectively guaranteeing the data is associated with the target layout, irrespective of any prior association."
    },
    {
        "instruction": "Create a function `are_arrays_equal` that takes two numerical arrays and returns `True` if they have the same shape and all corresponding elements are identical, `False` otherwise."
    },
    {
        "instruction": "Develop a function `prepare_input_for_wider_bitcast(input_array, input_bits, output_bits)` that takes an array and the bit widths for its current element type and a target element type. If `output_bits > input_bits`, reshape the input array by adding a new last dimension of size `output_bits // input_bits`. Check if `output_bits` is divisible by `input_bits`; raise an error if not. If `output_bits <= input_bits`, return the array unchanged. Return the potentially reshaped array."
    },
    {
        "instruction": "Write a function `check_bit_compatibility(bits1, bits2)` that takes the integer bit widths of two data types. Return `True` if a bitcast conversion between them is generally possible (i.e., one bit width is an integer multiple of the other), and `False` otherwise."
    },
    {
        "instruction": "Write a function `get_bit_width(dtype_name)` that takes a string representing a common numerical data type (e.g., 'int8', 'float32', 'uint16') and returns its corresponding bit width (e.g., 8, 32, 16). Handle cases where the input string might not correspond to a known type by returning an error or a specific value like -1."
    },
    {
        "instruction": "Create a function `calculate_bitcast_output_shape(input_shape, input_bits, output_bits)` that takes an input shape tuple, the bit width of the input type, and the bit width of the output type. It should return the expected output shape tuple after a bitcast conversion. If `input_bits == output_bits`, return `input_shape`. If `input_bits > output_bits`, append a new dimension of size `input_bits // output_bits` to `input_shape`. If `input_bits < output_bits`, return the input shape with its last dimension removed (assume the input was already appropriately shaped for this case). Ensure bit widths are compatible (one is an integer multiple of the other); raise an error if not."
    },
    {
        "instruction": "Create a function that takes a tuple of positive integers representing dimensions (e.g., `(2, 5, 6)`) and returns a new numerical array of this shape, filled with consecutive integers starting from 0."
    },
    {
        "instruction": "Write a function `are_contexts_compatible(context_a, context_b)` that takes two context identifiers (e.g., strings or numbers) and returns `True` if they are identical, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array and returns a tuple representing its dimensions (shape)."
    },
    {
        "instruction": "Design a function `execute_with_context_check(outer_func, inner_func, data, outer_context, inner_context)`. This function simulates running `outer_func` which internally calls `inner_func`. Before execution, it must compare `outer_context` and `inner_context`. If they differ, it must raise a `ValueError` indicating incompatible contexts. If they are the same, it should execute `outer_func(data)` and return its result. Assume `outer_func` is structured to call `inner_func`. (Note: `outer_context` and `inner_context` can be simple types like strings or integers)."
    },
    {
        "instruction": "Create a class `DataHolder` that stores a 1D numerical array. Include methods to initialize with data, retrieve the data, and explicitly mark the data as 'deleted' (e.g., by setting an internal flag and clearing the data reference). Add a property to check if the data is currently marked as 'deleted'."
    },
    {
        "instruction": "Implement a function `verify_deletion_error`. This function should create a `DataHolder` instance with a sample 1D numerical array, mark the data as 'deleted' using the instance's method, and then call the `process_data` function (from Task 4) with the modified instance. The function should return `True` if `process_data` correctly raises the expected `ValueError` due to the deleted data, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes an integer `N` and returns a 1D numerical array containing integers from 0 to `N-1`."
    },
    {
        "instruction": "Write a function `process_data` that takes a `DataHolder` instance. If the data is not marked as 'deleted', it should retrieve the data and return a new array with each element incremented by 1. If the data is marked as 'deleted', the function must raise a specific error (e.g., `ValueError`) indicating that the data is inaccessible."
    },
    {
        "instruction": "Design a class `DataContainer` to hold a 1D numerical array. Implement methods: `get_data()` to retrieve the array, `is_valid()` to check if the data is considered valid, and `invalidate()` to mark the data as invalid (e.g., by clearing the internal reference and updating a status flag). Create a function `process_container(container, operation)` that uses `is_valid()` before applying the `operation` to the data obtained via `get_data()`. If invalid, it should raise a `RuntimeError`."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array. Simulate calling an operation (like adding 1 to each element) on this array. Then, simulate 'deleting' the array's underlying buffer or marking it as unusable. Finally, demonstrate that attempting the *same* operation again on the *same* array reference now results in a specific error being raised (e.g., `RuntimeError`)."
    },
    {
        "instruction": "Implement a function `checked_operation` that takes an operation function `op` (which accepts a 1D numerical array) and a data object. The function should first check if the data object is marked as 'valid'. If valid, it applies `op` to the data and returns the result. If not 'valid', it must raise a `ValueError` with the message 'Input data is invalid'."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a new array of the same size where each element is the corresponding input element plus one."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is incremented by 1. Ensure the output array has the same shape as the input."
    },
    {
        "instruction": "Develop a function that accepts two 1D numerical arrays. It should verify that both arrays have the same number of elements. If they do, return the first array. If not, raise a value error indicating a mismatch."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns `True` if the number of elements in the array is greater than 2, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays, `arr_data` and `arr_condition`. If `arr_condition` contains more than 2 elements, return a new array where each element of `arr_data` is incremented by 1. Otherwise, return a new array where each element of `arr_data` is incremented by 2. The output array shape must match `arr_data`."
    },
    {
        "instruction": "Create a function accepting three parameters of potentially different types (like a string, an integer, a float). It should return a tuple composed solely of the first and the last parameter passed to it."
    },
    {
        "instruction": "Write a function that takes an ordered sequence (e.g., list of numbers), a floating-point number, and an integer. The function should return the original sequence and the integer, packaged together (e.g., in a tuple)."
    },
    {
        "instruction": "Develop a function that takes exactly three inputs. The function's logic should disregard the second input entirely and produce a result (e.g., a tuple or list) containing only the first and third inputs."
    },
    {
        "instruction": "Implement a function that receives a numerical data collection (like a list or array), a configuration value (like a number), and a status indicator (like a number or boolean). The function must return the data collection and the status indicator packaged together (e.g., in a tuple), ignoring the configuration value."
    },
    {
        "instruction": "Write a function that takes the shapes of two input matrices intended for multiplication (e.g., `(M, K)` and `(K, N)`) and returns the expected shape of the resulting product matrix (e.g., `(M, N)`). Return `None` or raise an error if the shapes are incompatible for multiplication."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication. It should take two 2D numerical arrays, `A` (shape `M x K`) and `B` (shape `K x N`), and return their product, a 2D numerical array of shape `M x N`."
    },
    {
        "instruction": "Write a function that takes a total number of elements `N` and two dimensions `rows`, `cols` (where `rows * cols == N`). It should return a 2D numerical array of shape (`rows`, `cols`) filled sequentially with integers from 0 to `N-1`."
    },
    {
        "instruction": "Create a function that accepts the shapes of two matrices (represented as tuples like `(M, K)` and `(K, N)`) and returns `True` if they are compatible for standard matrix multiplication (A @ B), `False` otherwise."
    },
    {
        "instruction": "Create a function that extracts a 2D slice from a 4D numerical array. The function should take the 4D array and two indices (i, j) corresponding to the first two dimensions. It should return the 2D sub-array located at array[i, j, :, :]."
    },
    {
        "instruction": "Develop a function that generates an abstract mapping string for a tensor operation. Given the rank (number of dimensions) of two input tensors and one output tensor, and the indices representing the core operation dimensions (e.g., matrix multiplication indices), produce a string like 'batch_dims input1_op_dims, batch_dims input2_op_dims -> batch_dims output_op_dims' using symbolic letters for dimensions (e.g., 'a b i j, a b j k -> a b i k' for rank 4 inputs/output with batch dims 'a', 'b' and op dims 'i', 'j', 'k')."
    },
    {
        "instruction": "Implement a function to perform batch matrix multiplication. It should accept two 3D numerical arrays with shapes (B, M, N) and (B, N, K), where B is the batch size. The function must return a 3D array of shape (B, M, K) containing the batch-wise matrix products."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a tuple representing target dimensions (e.g., (2, 3, 4, 5)). Reshape the input array into the specified multi-dimensional shape. Raise an error if the total number of elements doesn't match."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and applies a standard element-wise mathematical function (like sine) to each element, returning the resulting 1D array."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array (associated with a device) and an element-wise function. Apply the function to the array twice, storing each result. Return `True` if the device associated with the first result is the same as the device associated with the second result, `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array (assumed to be associated with a specific device) and a function to apply element-wise. It should execute the function on the array and return the identifier of the device associated with the *resulting* array."
    },
    {
        "instruction": "Write a function simulating computation across devices. It accepts: data_A (1D array on 'device0'), data_B (1D array on 'device1'), and a function `func`. The function should: 1. Apply `func` to data_A, note the result's device. 2. Perform an operation involving data_B (e.g., apply `func` to it). 3. Apply `func` *again* to the original data_A, note this result's device. Return `True` if the device noted in step 1 is the same as the device noted in step 3, `False` otherwise."
    },
    {
        "instruction": "Create a function or data structure to define how dimensions of a multi-dimensional array should map to the dimensions of a logical processing grid (from Task 2). For instance, specify that the first array dimension maps to the 'rows' grid dimension and the second array dimension maps to the 'cols' grid dimension."
    },
    {
        "instruction": "Write a function that takes a shape tuple (e.g., `(100, 200)`) and a data type identifier (e.g., 'custom_float16') and returns a new multi-dimensional numerical array of that shape and type, initialized entirely with zeros."
    },
    {
        "instruction": "Implement a function that creates a zero-filled numerical array of a given shape and data type. The function should also accept parameters representing a desired data layout strategy (based on a logical grid and partitioning rules from Tasks 2 & 3) but only needs to return the zero array itself."
    },
    {
        "instruction": "Design a data structure or function to represent a logical grid of processing units. It should accept the grid dimensions (e.g., `(2, 2)`) and optional names for each dimension (e.g., `('rows', 'cols')`) and store this configuration."
    },
    {
        "instruction": "Design a function that defines a mapping between the axes of a multi-dimensional array and the named dimensions of a logical resource grid. Input: the number of array axes and a sequence where each element is either a grid dimension name (string) or `None`, indicating how the corresponding axis is mapped (e.g., for a 2-axis array on a `('dim_x', 'dim_y')` grid, a mapping could be `('dim_x', 'dim_y')`). Return a data structure representing this axis mapping rule."
    },
    {
        "instruction": "Develop a function to compare two axis mapping rules (as defined in Task 3). It should take two mapping rule data structures as input and return `True` if they represent the identical mapping of array axes to grid dimension names, and `False` otherwise. Ensure the comparison handles the number of axes and the mapping for each axis correctly."
    },
    {
        "instruction": "Create a function to represent a logical resource grid. It takes grid dimensions (e.g., `(2, 2)`) and corresponding dimension names (e.g., `('dim_x', 'dim_y')`). Return a data structure holding this grid information."
    },
    {
        "instruction": "Write a function that accepts a shape (tuple of positive integers) and a string representing a numerical data type (e.g., 'float16', 'int32'). It should return a new multi-dimensional array of the specified shape and type, initialized entirely with zeros."
    },
    {
        "instruction": "Write a function that takes another function `f` and returns a new function `g`. The new function `g` should accept the same arguments as `f` but should conceptually mark two specific arguments (e.g., the first two) as 'configuration' arguments whose values are treated as fixed identifiers for this specific version of `g`."
    },
    {
        "instruction": "Develop a function that simulates executing an operation on a specific processing unit while respecting a data layout constraint. It takes an initial array, a layout constraint object (which implies a set of required processing units), and a target processing unit ID. If the layout's required units are not compatible (using logic similar to Task 3) with the target unit, raise a `ValueError` with a descriptive message about the incompatibility. Otherwise, return the initial array (as simulation)."
    },
    {
        "instruction": "Write a function that creates a multi-dimensional numerical array filled with zeros. It should accept a tuple defining the dimensions (shape) and a string specifying the desired numerical data type (e.g., 'float16', 'int32'). Return the created zero array."
    },
    {
        "instruction": "Implement a function that simulates assigning a data distribution pattern to an array. It takes a numerical array and a pattern object (assume this object describes how data maps to logical partitions, e.g., partitioning a 2D array across a 2x2 grid). The function should return the array conceptually associated with this pattern."
    },
    {
        "instruction": "Write a function that accepts a positive integer `n` and returns a 1D numerical array of length `n` containing only zeros."
    },
    {
        "instruction": "Write a function that takes an integer `count`. It should simulate launching `count` parallel tasks. Each task determines its unique index (from 0 to `count-1`). The function should collect and return a list or 1D numerical array containing these indices in order: `[0, 1, ..., count-1]`."
    },
    {
        "instruction": "Create a higher-order function `with_context_index(context_name, func_to_run)`. This function simulates setting up a parallel context named `context_name`. It should then call `func_to_run`, making an integer `index` (representing the worker's ID in that context, e.g., simulate index `1` if `context_name` is 'data', else `0`) implicitly available *within* `func_to_run`. The function should return whatever `func_to_run` returns. `func_to_run` itself takes no arguments but uses the implicit `index`."
    },
    {
        "instruction": "Implement a function `get_replica_index(context_id)` that simulates returning the integer index (e.g., 0, 1, 2...) of the current execution instance within a named parallel context specified by `context_id`. Assume a fixed context named 'data' always returns index `1`, and any other `context_id` returns `0`."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array and four non-negative integers representing padding widths: `pad_top`, `pad_bottom`, `pad_left`, `pad_right`. Pad the array using wrap-around logic according to these widths. Return the padded array."
    },
    {
        "instruction": "Implement a function that pads a 2D numerical array by adding one layer of padding *after* the first dimension using wrap-around logic, and one layer of padding *before* the second dimension using a constant value of 0.0. An input of shape (M, N) should result in an output of shape (M+1, N+1)."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and pads its second dimension *before* the existing elements using wrap-around logic (values from the end of the dimension wrap to the beginning). Pad with exactly one layer. An input of shape (M, N) should result in an output of shape (M, N+1)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and pads its first dimension *after* the existing elements with a single layer of zeros. For an input array of shape (M, N), the output should have shape (M+1, N)."
    },
    {
        "instruction": "Create a function that takes no arguments and returns a tuple containing two identical 1-dimensional numerical arrays (vectors) of size 1, both initialized with the value zero."
    },
    {
        "instruction": "Define a function factory: write a function that takes a desired shape (e.g., `(1,)`) as input and *returns* a *new function*. This new function, when called with no arguments, should produce a numerical array of the specified shape, filled with zeros."
    },
    {
        "instruction": "Implement a function that accepts a shape specification (e.g., a tuple like `(1,)` or `(2, 3)`) and returns a numerical array of that shape filled entirely with zeros."
    },
    {
        "instruction": "Write a function that takes no arguments and returns a single 1-dimensional numerical array (vector) of size 1, initialized with the value zero."
    },
    {
        "instruction": "Design two distinct context manager classes, `ManagerType1` and `ManagerType2`. Write a function `run_nested_operation(operation_func)` that attempts to enter a `ManagerType1` context and, immediately inside it, enter a `ManagerType2` context. If this nesting occurs, the entry into `ManagerType2` should raise a `ConfigurationError` indicating that nested use is forbidden. If nesting doesn't raise the error, then call `operation_func()`."
    },
    {
        "instruction": "Write a function that accepts two boolean flags, `use_context_A` and `use_context_B`. If both flags are `True`, raise a `ValueError` with the message 'Context A and Context B cannot be used together'. Otherwise, the function should do nothing."
    },
    {
        "instruction": "Implement a function `execute_under_contexts(context_managers, operation)` that takes a list of context manager objects and a callable `operation`. The function should enter all context managers. Before executing `operation`, it must check if both a context of type 'LegacyContext' and type 'NewContext' are simultaneously active. If this specific combination is detected, raise a `ValueError` stating they are incompatible. Otherwise, execute `operation()`."
    },
    {
        "instruction": "Implement a stateful `ContextTracker` class. It needs methods `start_context(context_name)` and `end_context(context_name)`. Internally, it tracks the set of currently active context names. Modify `start_context` so that if it's called with `context_name='new'` while `'legacy'` is already in the active set (or vice-versa), it raises a `RuntimeError` with the message 'Conflicting context types active'. Ensure `end_context` correctly removes the name from the active set."
    },
    {
        "instruction": "Write a function `assign_layout` that takes a 2D numerical array and a layout description string (e.g., \"fully_replicated\"). It should return a structure containing the original array data and the provided layout string. Verify the returned data matches the input array."
    },
    {
        "instruction": "Develop a function `package_data_with_rule` that accepts any 2D numerical data (e.g., representing integers or floats) and a distribution rule identifier (e.g., an integer code or string like \"shard_dim_1\"). Return a simple container object holding references to the original data and the rule identifier."
    },
    {
        "instruction": "Implement a function `change_data_layout` that takes an object representing data already distributed according to a `current_layout` specification, and a `new_layout` specification. The function should return a new object representing the same data values but now associated with the `new_layout`. Ensure data integrity is maintained during this conceptual re-distribution."
    },
    {
        "instruction": "Create a function `apply_distribution` that accepts a 2D numerical array (e.g., 4x4) and a distribution rule object describing how data is mapped to a logical grid (e.g., rule might specify splitting across grid dimension 'x'). Return an object representing this distributed data, ensuring it holds the original values and the applied rule object."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `matrix`, a row index `r`, a column index `c`, and a value `v`. It should return a *new* 2D array identical to `matrix` except the element at `(r, c)` is set to `v`. Ensure the original matrix is not modified."
    },
    {
        "instruction": "Develop a function that accepts an integer `n`, a 1D array `row_indices`, and a 1D array `col_indices` (assume they have the same length). It should first create an `n x n` 2D numerical array filled with zeros. Then, for each pair `(r, c)` from `row_indices` and `col_indices` at the same position, set the corresponding element in the matrix to 1. Return the modified matrix."
    },
    {
        "instruction": "Write a function that takes an existing 2D numerical array `matrix`, a 1D array `row_indices`, a 1D array `col_indices` (same length as `row_indices`), and a 1D array `values` (same length again). The function should return a *new* 2D array where the elements at the specified `(row_indices[i], col_indices[i])` locations are updated to `values[i]`. All other elements should retain their original values from the input `matrix`."
    },
    {
        "instruction": "Create a function that takes an integer `k` and returns a 1D numerical array containing the sequence of integers from 0 up to (but not including) `k`."
    },
    {
        "instruction": "Implement a function that calculates and returns the sum of all elements in a given numerical array (can be multi-dimensional)."
    },
    {
        "instruction": "Write a function that simulates assigning data to resource groups. It takes a numerical array and two group identifiers (e.g., integers representing group 0 and group 1). Assume the array starts associated with the first group. The function should return a representation (e.g., a tuple) containing the original array and the second group identifier, signifying its new association."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and a scalar number. It should return a new array where each element of the input array is multiplied by the scalar."
    },
    {
        "instruction": "Develop a function that computes the result of `sum((input_array**2) * 3)` and also calculates the analytical gradient of this expression with respect to the `input_array`. Input is a 1D numerical array. Return both the scalar sum and the 1D gradient array."
    },
    {
        "instruction": "Develop a function that accepts two positive integers, `size1` and `size2`. It should generate two separate 1D arrays (one with integers from 0 to `size1-1`, the other from 0 to `size2-1`), concatenate them, and return the resulting single 1D array."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays as input and returns a new 1D array formed by joining them end-to-end (concatenation)."
    },
    {
        "instruction": "Write a function that takes a positive integer `N` and returns a 1D numerical array containing the sequence of integers from 0 up to (but not including) `N`."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns the largest numerical value present in that array."
    },
    {
        "instruction": "Develop a function `are_arrays_identical` that takes two 1D numerical arrays. Return `True` if they have the exact same length and all corresponding elements are equal, otherwise return `False`."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and a string representing a \"layout rule\". The function should ignore the rule and return the original array unmodified."
    },
    {
        "instruction": "Implement a higher-order function `apply_nested_identity`. This function takes a 1D numerical array `data`. Inside `apply_nested_identity`, define a simple inner function `inner_identity` that just returns its input. Then, call `inner_identity` with `data` and return the result."
    },
    {
        "instruction": "Create a function `get_output_layout` that takes an object representing an \"input layout specification\". The function should return the exact same object, signifying that the output layout should match the input layout."
    },
    {
        "instruction": "Create a function that receives a data structure representing how a 1D array is distributed (containing layout information). It should return a new data structure representing the same distribution layout."
    },
    {
        "instruction": "Develop a function that takes descriptions of input data distribution. It must return a tuple containing: (1) an environment identifier, (2) a callable function that performs an identity transformation (returns its input), and (3) descriptions for input and output distributions, ensuring the output distribution description matches the input's."
    },
    {
        "instruction": "Write a function that accepts a single argument (e.g., a numerical array) and returns that argument completely unchanged."
    },
    {
        "instruction": "Implement a function `define_execution` that takes metadata about input data (e.g., shape, distribution info). Inside `define_execution`, define and return a simple callable `execute_step` which takes one argument and returns it. The `define_execution` function should return this `execute_step` callable."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns the array unchanged (identity function)."
    },
    {
        "instruction": "Create a function that accepts a non-negative integer `N` and returns a 1D numerical array containing integers from 0 up to (but not including) `N`."
    },
    {
        "instruction": "Develop a function that compares two numerical arrays element-wise for exact equality. Input: two numerical arrays. Output: True if they have the same shape and all corresponding elements are equal, False otherwise."
    },
    {
        "instruction": "Implement a function that checks if a given data object is associated with a specific, single processing unit identifier. Assume the object has a way to retrieve its associated unit(s). Input: data object, string identifier. Output: True if associated only with the given identifier, False otherwise."
    },
    {
        "instruction": "Implement a function that processes a 2D distributed numerical array. The function should perform a sequence of operations (e.g., an element-wise calculation followed by a matrix multiplication). Critically, within the function, include steps to *verify* that the intermediate array after the element-wise step and the final output array match specific, predefined distribution layout specifications. Return the final computed array."
    },
    {
        "instruction": "Design a function `outer_func` that accepts a 2D distributed numerical array `arr`. Inside `outer_func`, first compute an intermediate array `intermediate = arr * 2.0`. Then, pass `intermediate` to an `inner_func` (which performs a matrix multiplication like `intermediate @ intermediate.T`). `outer_func` should return the result of `inner_func`, ensuring the final output array adheres to a specific, predefined distribution layout potentially different from `inner_func`'s default."
    },
    {
        "instruction": "Create a function that accepts a 2D distributed numerical array and a scalar value. Return a new 2D array where each element is the corresponding input element multiplied by the scalar. The output array should maintain the same distribution layout as the input."
    },
    {
        "instruction": "Implement a function that takes a 2D distributed numerical array and computes the sine of each element. The resulting 2D array should retain the input array's distribution scheme."
    },
    {
        "instruction": "Write a function that simulates applying a partitioning constraint to data. It takes a data structure (containing a 1D numerical array and an initial partitioning string) and a target partitioning string. The function should simply return a new data structure containing the original array but associated with the *target* partitioning string."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a string representing a partitioning specification (e.g., 'dimension_x'). Return a data structure (like a dictionary or tuple) containing both the array and the partitioning string."
    },
    {
        "instruction": "Implement a function that simulates applying an operation while tracking data partitioning. It takes an input data structure (containing a 1D numerical array and its current partitioning string) and an output partitioning string. The function should perform an identity operation (return the array unchanged) but associate it with the *output* partitioning string, returning a new data structure (e.g., (array, output_spec_string))."
    },
    {
        "instruction": "Create a function that accepts a tuple of 1D numerical arrays and a single partitioning specification string. It should return a new tuple where each element represents one of the input arrays associated with the provided specification (e.g., a tuple of (array, spec_string) pairs)."
    },
    {
        "instruction": "Implement a function that takes a 2D array `A` of shape `(Y, N)` and a 3D array `B` of shape `(X, Y, M)`. It should apply a specific concatenation operation (joining along the last dimension) between the fixed array `A` and each 2D slice `B[i, :, :]`. The function should return a 3D array where the results for each `i` are stacked along the first dimension, resulting in a shape `(X, Y, N+M)`."
    },
    {
        "instruction": "Create a function that takes two 3D arrays, `A` of shape `(X, Y, N)` and `B` of shape `(X, Y, M)`. For each index `i` along the first dimension, concatenate the slice `A[i, :, :]` with the corresponding slice `B[i, :, :]` along the last dimension. Stack these concatenated results along the first dimension. The output should be a 3D array of shape `(X, Y, N+M)`."
    },
    {
        "instruction": "Write a function that takes a single multi-dimensional numerical array of any rank (e.g., 2D, 3D, 4D) as input and returns a tuple of integers representing the size of each dimension of the array (its shape)."
    },
    {
        "instruction": "Design a function that accepts a 4D array `Arr1` with shape `(B, D1, D2, N)` and a 3D array `Arr2` with shape `(D1, D2, M)`. This function should effectively perform a nested mapping operation equivalent to the following: iterate through the first dimension of `Arr1` (size `B`), then iterate through the second dimension of the current `Arr1` slice (size `D1`), then iterate through the first dimension of `Arr2` (size `D1`). In the innermost step, concatenate the appropriate slice of `Arr1` (shape `(D2, N)`) and the appropriate slice of `Arr2` (shape `(D2, M)`) along the last axis. Combine the results preserving the iteration structure to produce a final output array of shape `(B, D1, D1, D2, N+M)`."
    },
    {
        "instruction": "Write a function `sum_groups` that takes a 1D numerical array and an integer `group_size`. Assume the array's length is a multiple of `group_size`. The function should return a new 1D array where each element is the sum of a contiguous block of `group_size` elements from the input array."
    },
    {
        "instruction": "Write a function `calculate_total_sum` that accepts a 2D numerical array and returns the sum of all its elements as a single scalar value."
    },
    {
        "instruction": "Create a function `sum_rows` that takes a 2D numerical array (M rows, N columns) and returns a 1D array of length M, where each element is the sum of the corresponding row from the input array."
    },
    {
        "instruction": "Implement a function `cumulative_sum_1d` that takes a 1D numerical array and returns a new 1D array of the same size, where the element at index `i` is the sum of all elements from index 0 to `i` in the input array."
    },
    {
        "instruction": "Write a function that creates a 2D numerical array of specified dimensions (rows, columns) filled entirely with the value 1.0. The function should take two integer arguments, `rows` and `cols`, and return the corresponding 2D array."
    },
    {
        "instruction": "Implement a function that takes another function `f` and a 2D numerical array `arr`. It should apply `f` to each row of `arr` independently and return a new 2D array containing the results stacked row-wise. Assume `f` accepts a 1D array (a row) and returns a 1D array."
    },
    {
        "instruction": "Create a function that accepts a list of strings representing axis partitioning specifications (e.g., ['axis_x', 'unconstrained', 'axis_y']). The function should return two values: a formatted string representation (e.g., \"Spec(axis_x, unconstrained, axis_y)\") and a set containing the integer indices where the string 'unconstrained' appears in the input list."
    },
    {
        "instruction": "Design a function that recursively searches through a nested data structure representing a computational graph (e.g., nested dictionaries/lists). It should find the first node dictionary containing a specific key-value pair (e.g., `'primitive': 'constraint_op'`) and return a tuple containing the values associated with two other keys (e.g., `'spec'` and `'unconstrained_dims'`) within that same node dictionary. Return `(None, None)` if no such node is found."
    },
    {
        "instruction": "Develop a function that accepts two input arguments (which can be numerical arrays) and returns a tuple containing the shape of each argument. For example, if inputs have shapes (R1, C1) and (R2, C2), return ((R1, C1), (R2, C2))."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array and an integer `k`. Split the array horizontally into `k` equal contiguous sub-arrays (slices based on rows). Return a list containing these `k` sub-arrays. Assume the number of rows in the input array is divisible by `k`."
    },
    {
        "instruction": "Write a function that takes two square 2D numerical arrays (matrices) of the same size (N x N) and an integer `k`. First, compute the matrix product of the two input matrices. Second, split the resulting N x N product matrix horizontally into `k` equal sub-matrices. Return the list of these `k` sub-matrices. Assume N is divisible by `k`."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and returns a 2D array (matrix) of shape (`rows`, `cols`) filled with sequential integers starting from 0 and increasing row by row."
    },
    {
        "instruction": "Implement a function `assign_to_device(data_item, device_id)` that takes a data item and a device identifier (integer). It should return an object representing the data assigned exclusively to that device, ensuring the original data type is maintained."
    },
    {
        "instruction": "Create a function `check_type(data_item, expected_type_tag)` that returns `True` if the `data_item` matches the `expected_type_tag` (e.g., a string like \"key_type\"), and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes an initial seed (integer) and a count `N`. It should generate and return a list containing `N` distinct small integer arrays, each representing a unique key."
    },
    {
        "instruction": "Write a function `place_data_with_sharding(data_array, sharding_spec)`. `data_array` is a list of items. `sharding_spec` describes how to map items to logical devices (e.g., a list where `sharding_spec[i]` is the device ID for `data_array[i]`). The function should return a representation of the distributed data and confirm that (1) each item is associated with the correct device per the spec, and (2) all items retain their original data type."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array containing 64 elements and reshapes it into a 3D array with dimensions (8, 4, 2). Return the new 3D array."
    },
    {
        "instruction": "Create a function that computes the sum of all elements within any given multi-dimensional numerical array. It should take one array as input and return a single scalar value representing the total sum."
    },
    {
        "instruction": "Implement a function performing a tensor contraction specified by the pattern 'btd,dhq->bhtq'. It accepts two 3D numerical arrays, A (shape B, T, D) and B (shape D, H, Q), and returns a 4D numerical array C (shape B, H, T, Q) where C[b,h,t,q] is the sum over d of A[b,t,d] * B[d,h,q]."
    },
    {
        "instruction": "Develop a function that validates the output dimensions of a specific tensor operation ('btd,dhq->bhtq'). The function takes two 3D input arrays, A (shape B, T, D) and B (shape D, H, Q), performs the contraction, and returns `True` if the resulting array has the shape (B, H, T, Q), and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts two 1D numerical arrays of the same size and performs element-wise addition. The function must return the result as the same fundamental array data structure type as the inputs, not a different data structure like a list."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays (potentially of different numerical types, e.g., integer and float) of the same size and returns their element-wise sum. Ensure the output array uses a numerical type that can accurately represent the result (e.g., float if inputs are int and float)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a new 1D array where each element is doubled (i.e., the array added to itself)."
    },
    {
        "instruction": "Develop a function that takes two 1D numerical arrays, A and B, of the same size. It should compute their element-wise sum, S = A + B, and then return the element-wise sum of S with itself (S + S)."
    },
    {
        "instruction": "Write a function that takes a flat list of items (e.g., representing processing units) and two integers, `rows` and `cols`. It should return a 2D list (a grid) by arranging the items row by row. Raise an error if the total number of items does not equal `rows * cols`."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a mathematical function `func` as input. It should return a new 2D array of the same shape where each element `output[i][j]` is the result of `func(input[i][j])`."
    },
    {
        "instruction": "Create a function that defines a mapping between named data dimensions and named processing grid dimensions. It accepts two lists of unique strings: `data_dimension_names` (e.g., `['batch', 'features']`) and `grid_dimension_names` (e.g., `['processors_x', 'processors_y']`). Return a dictionary where keys are from `data_dimension_names` and values are the corresponding `grid_dimension_names` based on index order. If `data_dimension_names` is longer than `grid_dimension_names`, map the extra `data_dimension_names` to `None`."
    },
    {
        "instruction": "Implement a function wrapper that tracks if it's the *first time* being called. It should accept a target function. The wrapper, when invoked, executes the target function only on the very first invocation and returns a tuple: `(result, was_executed)`, where `was_executed` is true only on the first call. Subsequent calls return the *cached* result from the first call and `False` for `was_executed`."
    },
    {
        "instruction": "Develop a function that receives a 1D numerical array, calculates the sine of each element, and then returns the sum of all elements in the resulting array (a single scalar value)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array of the same size where each element is the sine of the corresponding element in the input array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a single scalar value representing the sum of all its elements."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and returns a new array of the same size where each element is the cosine of the corresponding element in the input array."
    },
    {
        "instruction": "Write a function that takes a non-negative integer `N` and returns a 1D numerical array containing floating-point numbers from 0.0 up to (but not including) `N`."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and returns a new 1D array of the same size, where each element is the sine of the corresponding element in the input array."
    },
    {
        "instruction": "Write a function that accepts two 1D numerical arrays, `vec_a` and `vec_b`. Calculate the total sum of all elements in `vec_a`. Then, compute the element-wise sine of `vec_b`. Finally, return a new 1D array representing the element-wise addition of the scalar sum (from `vec_a`) to the sine results (from `vec_b`). The output array should have the same dimensions as `vec_b`."
    },
    {
        "instruction": "Develop a function that takes a scalar numerical value and a 1D numerical array. It should return a new 1D array of the same size as the input array, where each element is the sum of the scalar value and the corresponding element from the input array."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar number. Return a new 2D array of the same dimensions where each element is the corresponding element from the input array multiplied by the scalar."
    },
    {
        "instruction": "Implement a function that receives a 2D numerical array (matrix) with dimensions M rows and N columns. Calculate and return the matrix product of this matrix with its own transpose. The resulting matrix should have dimensions M rows and M columns."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `A` with shape (M, N). Inside the function, compute intermediate results `B = A * 2` and `C = elementwise_sin(B)`, and the final result `D = matrix_multiply(C, transpose(C))`. Verify internally that `B` and `C` have shape (M, N) and `D` has shape (M, M). Return the final matrix `D`."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array. It should compute the trigonometric sine for each element and return a new 2D array containing the results, maintaining the original dimensions."
    },
    {
        "instruction": "Design a function that accepts a 2D numerical array and an associated data partitioning description (e.g., a tuple of strings representing named axes). The function should perform an element-wise operation (e.g., multiply by 2) on the array and return both the resulting array and the original partitioning description it received."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array and a scalar value, and returns a new 2D array where each element of the input array is multiplied by the scalar."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array, multiplies each element by 2.0, and then applies the sine function element-wise to the intermediate result, returning the final 2D array."
    },
    {
        "instruction": "Implement a function that applies the trigonometric sine function element-wise to a given 2D numerical array."
    },
    {
        "instruction": "Implement a function `execute_twice` that takes another function `func` and two arguments `arg1`, `arg2`. It should call `func(arg1, arg2)` exactly two times and return the result of the second call."
    },
    {
        "instruction": "Create a function that accepts a list of numbers (e.g., integers or floats) and returns a 1D numerical array containing those numbers."
    },
    {
        "instruction": "Design a mechanism (e.g., using a class or closure) that wraps a given function. The wrapper should keep track of whether the wrapped function has been executed *at least once*. It should provide a method to check this status (returning true if executed one or more times, false otherwise) and a method to execute the wrapped function."
    },
    {
        "instruction": "Create a function that accepts another function `op` (expecting two numerical array arguments) and two 1D numerical arrays `a` and `b`. This function should execute `op(a, b)` multiple times (e.g., twice). It must also internally track if this specific `op` (or an equivalent operation signature) has been executed before. The function should return a tuple containing the result of the operation and a boolean indicating if this was the *first time* this specific operation signature was executed by this tracking mechanism."
    },
    {
        "instruction": "Write a function that processes a 3D numerical array `arr` of shape `(B, M, N)`. For each 2D slice `arr[i, :, :]` (indexed by `i`), apply two distinct dimension-handling rules: Rule 1 focuses on dimension `M` while treating `N` as secondary, and Rule 2 focuses on dimension `N` while treating `M` as secondary. The exact rules are less important than the concept of applying dimension-specific logic within a loop over the first dimension. Return an aggregated result (e.g., a tuple containing results derived from Rule 1 and Rule 2 applied across all slices)."
    },
    {
        "instruction": "Write a function that takes a 3D numerical array (e.g., shape BxMxN) and creates a nested data structure: a list containing exactly two elements. The first element is a dictionary with keys 'a' and 'b', where 'a' maps to the input array and 'b' maps to the input array multiplied by 2. The second element of the list is the input array multiplied by 3. Return this nested structure."
    },
    {
        "instruction": "Create a function that accepts a nested data structure containing numerical arrays (like the output of Task 1). It should apply a provided function element-wise to *every* numerical array found anywhere within the structure. Return the modified nested structure with the same layout."
    },
    {
        "instruction": "Implement a function that simulates applying an operation across the leading dimension ('batch' dimension) of numerical arrays within an arbitrarily nested data structure (lists/dictionaries). Input: A nested structure where all arrays share the same size for their first dimension, and a function `f`. The function `f` takes a single 'slice' of the structure (where each array is represented by its i-th sub-array along the first dimension) and returns a similarly structured slice. Your function should iterate from i=0 to B-1 (where B is the size of the first dimension), apply `f` to each slice, and reassemble the results into a new nested structure with the same layout as the input, where each array now has the results stacked along the first dimension."
    },
    {
        "instruction": "Implement a function that receives an abstract description of a 2D array (containing its shape tuple and data type identifier) and a scalar number. The function should return a new abstract description representing the result of adding the scalar to each element, ensuring the shape remains the same and the data type is appropriate."
    },
    {
        "instruction": "Create a function that accepts a shape tuple (e.g., (2, 2)) and a data type identifier (e.g., 'float32'), and returns a simple object or dictionary holding these two pieces of metadata."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a single number (scalar). Return a new 2D array of the same dimensions where the scalar has been added to every element of the input array."
    },
    {
        "instruction": "Develop a function that takes a shape tuple as input and returns `True` if the shape represents a 2-dimensional array (i.e., the tuple has exactly two positive integer elements), and `False` otherwise."
    },
    {
        "instruction": "Simulate a function transformation step. Create a higher-order function called `processor` that accepts an object containing both a function and its associated index tuple (like the output from Task 3 or 4). The `processor` should return a new object that contains the *same* function and the *same* index tuple. Write code to demonstrate that the index tuple remains unchanged after passing the function object through the `processor`."
    },
    {
        "instruction": "Implement the function described in Task 1. Then, using the mechanism from Task 3, associate the metadata `(0,)` with this function, indicating that the first argument (index 0) has a special property. Verify that you can correctly retrieve this associated index tuple."
    },
    {
        "instruction": "Design a mechanism to associate metadata with a function. Create a wrapper or class that takes a function and a tuple of non-negative integers (representing argument indices) as input. Provide a method to retrieve this associated tuple of indices later."
    },
    {
        "instruction": "Create a simple data structure (like a class or dictionary) to represent metadata for an array. It should store the array's shape (as a tuple of positive integers) and its data type (as a string, e.g., 'float32', 'int64'). Implement a way to initialize this structure."
    },
    {
        "instruction": "Design a mechanism (like a class or function) to associate metadata with a function object. This mechanism should accept a function and a list of strings, where each string represents the name of an input parameter to that function whose provided data can potentially be reused. Store the function and this list of names together."
    },
    {
        "instruction": "Write a function that accepts a list of strings (representing parameter names) and a target string (a specific parameter name). It should return the zero-based index of the target string within the list. If the target string is not found, it should return -1."
    },
    {
        "instruction": "Write a function that takes the associated structure from Task 3 and a specific parameter name (string) from the 'reusable' list. It should determine and return the zero-based positional index of that parameter in the original function's signature. Assume the function's parameter list is accessible. Handle the case where the provided name is not a parameter of the function."
    },
    {
        "instruction": "Implement a function that takes a single numerical array (of any dimension and data type) as input and returns the exact same array as output."
    },
    {
        "instruction": "Write a function that accepts two 2D numerical arrays (matrices) and arbitrary keyword arguments (`**kwargs`). The function must compute and return the matrix product of the two input matrices, correctly handling the matrix multiplication regardless of any provided keyword arguments."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array (matrix) `M` and a scalar value `s`. It should return a new matrix of the same shape as `M`, where each element is the corresponding element of `M` plus `s`."
    },
    {
        "instruction": "Create a function that accepts exactly two positional arguments and any number of keyword arguments (**kwargs). The function should return the first positional argument, ignoring the second positional argument and all keyword arguments."
    },
    {
        "instruction": "Write a function that takes two integers, `rows` and `cols`, and returns a 2D numerical array (matrix) of shape (`rows`, `cols`) filled with consecutive integers starting from 0."
    },
    {
        "instruction": "Write a function `create_sequential_matrix(rows, cols)` that returns a `rows` x `cols` matrix filled with integers starting from 0, incrementing row by row."
    },
    {
        "instruction": "Write a function `check_matrix_pair(input_data)` that verifies if `input_data` is a sequence (list/tuple) containing exactly two items, both of which are 2D numerical arrays. Return `True` if valid, `False` otherwise."
    },
    {
        "instruction": "Implement a function `matrix_multiply(matrix_a, matrix_b)` that computes the product of two 2D numerical arrays. Ensure it checks for compatible dimensions for multiplication and raises an error if they are incompatible."
    },
    {
        "instruction": "Create a function `add_scalar(array, scalar)` that takes a numerical array (any shape) and a number, returning a new array with the scalar added to each element."
    },
    {
        "instruction": "Write a function to generate a type mismatch error message. It takes two dictionaries: one mapping argument names to expected type strings (e.g., `{'x': 'float32', 'y': 'float32'}`) and another mapping argument names to actual type strings (e.g., `{'x': 'int32', 'y': 'int32'}`). Return a formatted string listing all arguments with type mismatches, or `None` if all types match."
    },
    {
        "instruction": "Implement matrix multiplication for two 2D numerical arrays. Given inputs of shape (M, K) and (K, N), the function should return a new 2D array of shape (M, N)."
    },
    {
        "instruction": "Develop a function that takes two positive integers, `rows` and `cols`. Return a 2D numerical array of shape (`rows`, `cols`) populated with integers from 0 to `rows*cols - 1` in row-major order."
    },
    {
        "instruction": "Create a wrapper function that validates argument types. It accepts a target function and a specification of expected data types for its arguments (e.g., by position or name). The wrapper should return a new function that checks if the runtime arguments match the specified types. If a mismatch occurs, it must raise a `TypeError` detailing the discrepancies; otherwise, it executes the target function."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array (matrix) of shape (`rows`, `cols`) filled with sequential integers starting from 0."
    },
    {
        "instruction": "Create a function that checks if two matrices, represented as 2D numerical arrays with known dimensions (rows1, cols1) and (rows2, cols2), are suitable for standard matrix multiplication (A @ B). Return `True` if compatible, `False` otherwise."
    },
    {
        "instruction": "Write a function that first generates a 1D numerical array containing sequential integers from 0 up to `N*M - 1`, and then reshapes this array into a 2D matrix of dimensions `N` rows and `M` columns. The function should take `N` and `M` as input and return the resulting 2D matrix."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array (matrix) and a scalar number. Return a new matrix of the same dimensions where the scalar has been added element-wise to every element of the input matrix."
    },
    {
        "instruction": "Write a function that takes a positive integer `N` and returns a 1D numerical array containing the sequence of integers from 0 up to (but not including) `N`."
    },
    {
        "instruction": "Write a function that accepts a single positive integer `n`. Inside the function, create two square matrices of size `n x n`: matrix `X` containing integers from 0 to `n*n - 1` (row-major order), and matrix `Y` containing integers from 1 to `n*n` (row-major order). Compute and return the matrix product of `X` and `Y`."
    },
    {
        "instruction": "Implement a function to compute the product of two matrices. It should accept two 2D numerical arrays, `matrix_a` (shape M x K) and `matrix_b` (shape K x N), and return their resulting matrix product (shape M x N)."
    },
    {
        "instruction": "Develop a function that takes two positive integers, `rows` and `cols`. It should first generate a sequence of integers from 0 to `rows * cols - 1`, and then return this sequence reshaped into a 2D numerical array (matrix) with the specified `rows` and `cols`."
    },
    {
        "instruction": "Design a function that takes a 2D numerical array and a configuration dictionary (e.g., `{'partitions': 2, 'replicas': 1}`) as input. Perform a simple element-wise operation (like adding 1 to each element) on the array. Return a tuple containing two items: the modified array and a formatted string summarizing the configuration used, like 'Execution context: partitions=2, replicas=1'."
    },
    {
        "instruction": "Implement a function that takes a shape tuple `(rows, cols)` as input. Generate a 2D numerical array `A` of this shape containing sequential floats starting from 0.0. Generate another array `B` by adding 1.0 to every element of `A`. Return the element-wise sum of `A` and `B`."
    },
    {
        "instruction": "Create a function that accepts two 2D numerical arrays (matrices) of the exact same shape. It should return a new 2D array of the same shape, where each element is the sum of the corresponding elements from the input arrays."
    },
    {
        "instruction": "Write a function that accepts a single string (potentially containing multiple lines) as input. The function should return `True` if the string contains both the substring 'partition_count = 2' and the substring 'replica_count = 1', and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array (matrix) of shape (`rows`, `cols`) filled with sequential integers starting from 0 and increasing row by row."
    },
    {
        "instruction": "Write a function that performs matrix multiplication but includes input validation. It takes two 2D numerical arrays, `A` and `B`. It must first verify that the number of columns in `A` equals the number of rows in `B`. If compatible, return the resulting product matrix. If not compatible, return an indicator (e.g., None or raise an error) signifying incompatible dimensions."
    },
    {
        "instruction": "Develop a function that takes a tuple representing a desired shape `(rows, cols)`. It should generate and return two 2D numerical arrays of this shape. The first array should contain sequential integers starting from 0, and the second array should be identical to the first but with 1 added to each element."
    },
    {
        "instruction": "Implement a function to perform matrix multiplication. It should accept two 2D numerical arrays, `A` (shape M x N) and `B` (shape N x P), and return their product as a new 2D array of shape M x P. Assume valid numerical inputs."
    },
    {
        "instruction": "Develop a function that takes a tuple representing a shape `(M, N)`. Generate a matrix `A` of this shape filled with sequential integers starting from 0 (row by row). Then, generate matrix `B` by adding 1 to every element of `A`. Return the element-wise sum of `A` and `B`, which will also have the shape `(M, N)`."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array (matrix) of shape `(rows, cols)` filled with sequential integers starting from 0, incrementing row by row."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) and a scalar number. It should return a new matrix of the same shape where the scalar value has been added to every element of the input matrix."
    },
    {
        "instruction": "Write a robust matrix multiplication function. It takes two 2D numerical arrays, `A` and `B`. Check if their inner dimensions are compatible for multiplication (i.e., if `A` has shape `M x N`, `B` must have shape `N x P`). If compatible, return their product (an `M x P` matrix). If not compatible, raise a specific error (e.g., ValueError) indicating the shape mismatch."
    },
    {
        "instruction": "Create a function that performs matrix multiplication. It should accept two 2D numerical arrays, A (shape M x N) and B (shape N x P), and return their product C (shape M x P). Handle the case where the inner dimensions (N) do not match by raising an appropriate error."
    },
    {
        "instruction": "Implement a function that takes two 2D numerical arrays (matrices) of the exact same shape (e.g., both R x C) and returns a new matrix of the same shape representing their element-wise sum."
    },
    {
        "instruction": "Develop a function that takes a single integer `N` as input. Inside the function, generate two distinct square matrices of shape `N x N`, both filled with sequential integers starting from 0. Then, compute and return the matrix product of these two generated matrices."
    },
    {
        "instruction": "Write a function to compute the matrix product of two 2D numerical arrays, A (M x N) and B (N x P), *without* using any built-in matrix multiplication operators or optimized library functions. Implement the calculation explicitly using nested loops based on the mathematical definition of matrix multiplication. Return the resulting M x P matrix."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and two positive integers, `rows` and `cols`. Reshape the input array into a 2D numerical array with the specified `rows` and `cols`. Assume the number of elements in the input array is exactly `rows * cols`. Return the new 2D array."
    },
    {
        "instruction": "Implement a function to compute the matrix product of two square 2D numerical arrays of the same size (N x N). The function should accept the two N x N arrays and return their N x N matrix product."
    },
    {
        "instruction": "Develop a function that takes two positive integers, `rows` and `cols`. Generate a 1D numerical array containing integers from 0 to `rows * cols - 1`, then reshape it into a 2D array of shape (`rows`, `cols`). Return the resulting 2D array."
    },
    {
        "instruction": "Write a function that multiplies two 2D numerical arrays, A and B. Input A has shape (M, K) and input B has shape (K, N). The function should return the resulting 2D array C of shape (M, N). Ensure the function handles the requirement that the inner dimensions (K) must match."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and two integers, `rows` and `cols`, and reshapes the array into a 2D numerical array (matrix) with the specified dimensions. Assume the total number of elements matches `rows * cols`."
    },
    {
        "instruction": "Develop a function that takes two integers, `rows` and `cols`, and generates a 2D numerical array (matrix) of shape (`rows`, `cols`) filled with sequential integers starting from 0, filling row by row."
    },
    {
        "instruction": "Create a function that takes a square 2D numerical array (matrix) `A`. It should generate a second matrix `B` by adding 1 to every element of `A`. Then, it should compute and return the matrix product of `A` and `B`."
    },
    {
        "instruction": "Implement a function to compute the matrix product of two given 2D numerical arrays (matrices). Assume the input matrices have compatible shapes for multiplication."
    },
    {
        "instruction": "Given two 2D square numerical arrays (matrices) `A` and `B` of the same size `N x N`, write a function that calculates their matrix product `C = A @ B` and returns the value of the element at the first row and first column (index 0, 0) of the resulting matrix `C`."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication for two given 2D numerical arrays (matrices) `A` (shape M x K) and `B` (shape K x N). Return the resulting matrix of shape M x N. Avoid using direct built-in matrix multiplication operators or high-level library functions for the core calculation."
    },
    {
        "instruction": "Write a function that takes an integer `N`, creates two `N x N` matrices (Matrix A filled with integers 0 to N*N-1, Matrix B filled with integers 1 to N*N), performs matrix multiplication `A @ B`, and returns the resulting `N x N` matrix."
    },
    {
        "instruction": "Write a function that takes an integer `N` and returns a 2D square array (matrix) of shape `(N, N)` filled with consecutive integers starting from 0."
    },
    {
        "instruction": "Write a function that takes the shapes of two matrices (represented as tuples like `(rowsA, colsA)` and `(rowsB, colsB)`) and returns `True` if they can be multiplied in the order A then B (i.e., `colsA == rowsB`), and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and two integers, `rows` and `cols`, and reshapes the array into a 2D numerical array with the specified dimensions. Assume the total number of elements in the 1D array is equal to `rows * cols`."
    },
    {
        "instruction": "Develop a function that accepts two integers, `rows` and `cols`, and returns a 2D numerical array of shape (`rows`, `cols`) filled with sequential integers starting from 0, arranged in row-major order."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication on two 2D numerical arrays, `A` and `B`. It should return the resulting 2D array. Assume the input arrays have compatible shapes for multiplication (i.e., columns of A equals rows of B)."
    },
    {
        "instruction": "Design a function that determines the shape of a sub-grid when a larger grid is partitioned. Input: the global grid shape (e.g., `(8, 6)`) and the number of partitions along each dimension (e.g., `(2, 3)`). Output: the shape of one partition (e.g., `(4, 2)`). Assume dimensions are evenly divisible."
    },
    {
        "instruction": "Implement a function that calculates the total number of elements in a potential multi-dimensional array given its shape as a tuple of dimensions (e.g., `(1, 4, 2)` results in 8)."
    },
    {
        "instruction": "Write a function that takes a shape tuple (e.g., `(4, 2)`) and creates a multi-dimensional numerical array of that shape, filling it with consecutive integers starting from 0."
    },
    {
        "instruction": "Write a function that takes a list of multi-dimensional numerical arrays (representing partitions of a larger array, assume row-major ordering of partitions) and information about the partitioning grid (e.g., `(2, 2)` partitions). Reconstruct and return the original single large array by appropriately combining the partitions."
    },
    {
        "instruction": "Implement a simulator that prepares a simple data operation (e.g., identity) for execution. This simulator accepts an input data shape and an *expected* partitioning specification. It should return an object representing the 'prepared' operation, storing the expected specification internally."
    },
    {
        "instruction": "Write a function that takes a shape tuple (e.g., `(rows, cols)`) and returns a 2D numerical array of that shape, filled with sequential floating-point numbers starting from 0.0."
    },
    {
        "instruction": "Develop a function that takes a 'prepared' operation object (from Task 4) and an input data structure (from Task 3, containing data and its actual partitioning specification). Compare the input's actual specification against the prepared operation's expected specification. If they do not match, raise a `ValueError` indicating a configuration mismatch for the input. Otherwise, return the input data."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a partitioning specification (e.g., `('axis_x', 'axis_y')`). Return a structure or object that bundles the array data together with its assigned partitioning specification."
    },
    {
        "instruction": "Implement a function `identity_triple(arg1, arg2, arg3)` that takes exactly three arguments of any type and returns them unmodified within a tuple: `(arg1, arg2, arg3)`."
    },
    {
        "instruction": "Write a function `analyze_io_structure(num_inputs, num_outputs)` that simulates analyzing a function's interface. Given the number of inputs and outputs (positive integers), it should return a dictionary like `{'output_count': num_outputs, 'input_structure_complexity': num_inputs}`. Raise an error if inputs are not positive."
    },
    {
        "instruction": "Create a function `describe_logical_grid(dimensions)` that accepts a tuple of integers representing grid dimensions (e.g., `(2, 2)`). Return a simple data structure (like a dictionary or a custom object) that stores these dimensions."
    },
    {
        "instruction": "Develop a function `get_data_properties(data_array)` that takes a numerical array as input and returns a dictionary containing its 'shape' (as a tuple) and its 'dtype' (as a string representation, e.g., 'float32')."
    },
    {
        "instruction": "Develop a function `generate_and_verify_identity(rows, cols)` that first creates a 2D numerical array `A` of shape `(rows, cols)` with sequential floats, then calls an identity function `f(x, y) = (x, y)` with `A` as both inputs, and finally verifies that both outputs are identical to the original array `A`. Return `True` if verified, `False` otherwise."
    },
    {
        "instruction": "Write a function `create_sequential_array(rows, cols)` that returns a 2D numerical array of shape `(rows, cols)` filled with sequential floating-point numbers starting from 0.0."
    },
    {
        "instruction": "Write a function `calculate_chunk_shapes(global_shape, grid_shape, partition_rule)` that determines the shapes of data chunks distributed across a logical grid. `global_shape` is the shape of the full array (e.g., `(M, N)`), `grid_shape` defines the grid dimensions (e.g., `(G1, G2)`), and `partition_rule` specifies how array dimensions map to grid dimensions (e.g., `(0, 1)` means array dim 0 maps to grid dim 0, array dim 1 to grid dim 1). Return a dictionary mapping grid coordinates `(g1, g2)` to the calculated chunk shape for that coordinate. Assume even division for simplicity."
    },
    {
        "instruction": "Create a function `describe_partitioning(data_shape, partition_spec)` where `data_shape` is a tuple (e.g., `(M, N)`) and `partition_spec` describes how dimensions are treated (e.g., `('split', 'replicate')`). Return a textual description or a simple structure explaining how an array of `data_shape` would be conceptually divided based on `partition_spec`."
    },
    {
        "instruction": "Implement a function that compares two resource group structures. It should return `True` if they contain the exact same set of resource identifiers (order doesn't matter), and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a tuple representing data dimensions (e.g., `(10, 4)`) and a string for the data type (e.g., `'int32'`). Return a simple structure or object that encapsulates this shape and type information."
    },
    {
        "instruction": "Write a function that takes a list of resource identifiers (e.g., strings like 'gpu:0', 'gpu:1') and a name (string). Return a structure that stores both the name and the unique set of resource identifiers provided."
    },
    {
        "instruction": "Develop a validation function that takes a list of input assignments (each associating an input name with a resource group structure). Check if all resource groups referenced in the assignments contain the exact same set of resource identifiers. Raise a specific error (e.g., `ValueError` with a descriptive message) if they are not identical; otherwise, return `True`."
    },
    {
        "instruction": "Implement a function `process_many_inputs(*inputs)` that takes a variable number of numerical arrays as input arguments and returns them unmodified as a tuple. Ensure it can handle a very large number of input arguments (e.g., over 2000)."
    },
    {
        "instruction": "Create a function `generate_mixed_specs(count, spec_explicit, spec_auto)` that returns a list of length `count` (e.g., >2000). Initialize the list with `spec_auto`. Then, for indices `i = 0, 2, 4, ...` up to `count // 2 * 2`, replace the element at index `i` with `spec_explicit`."
    },
    {
        "instruction": "Write a function `create_sequential_array(rows, cols)` that returns a 2D numerical array of shape `(rows, cols)` filled with integers starting from 0, incrementing row by row."
    },
    {
        "instruction": "Write a function `check_explicit_placements(actual_input_placements, actual_output_placements, explicit_placement, total_count)` that takes two lists (representing input and output placement information) and an explicit placement object/value. Verify that for indices `i = 0, 2, 4, ...` up to `total_count // 2 * 2`, both `actual_input_placements[i]` and `actual_output_placements[i]` are equal to the `explicit_placement`. Return `True` if all checks pass for these specific indices, `False` otherwise."
    },
    {
        "instruction": "Create a function that takes two 2D numerical arrays, `A` and `B`, both of shape (M, N), and computes the matrix product of `A` with the transpose of `B`. Return the resulting 2D array of shape (M, M)."
    },
    {
        "instruction": "Write a function that accepts a single multi-dimensional numerical array and returns it unchanged. The function should handle various numerical data types."
    },
    {
        "instruction": "Implement a function that accepts a nested dictionary where leaf nodes are numerical arrays. The function should return the dictionary structure unchanged, effectively acting as an identity function for this nested structure."
    },
    {
        "instruction": "Design a function that takes two arguments: `data` (a numerical array) and `expected_layout` (a description of its expected layout, e.g., a string like 'row_partitioned'). The function should validate if the `data` conforms to the `expected_layout`. If it conforms, return the `data`. If not, raise a `ValueError` detailing the layout mismatch."
    },
    {
        "instruction": "Design a function `simulate_execution(data_placement_description, operation_logic_stub, operation_input_requirements)`. It should first use logic similar to Task 4 to check compatibility between `data_placement_description` and `operation_input_requirements`. If compatible, it should apply the `operation_logic_stub` (a function that takes and returns a data description, e.g., `lambda desc: desc` for identity) to the `data_placement_description` and return the result. If incompatible, it should raise a ValueError."
    },
    {
        "instruction": "Write a function `define_grid(rows, cols)` that returns a simple representation (e.g., a dictionary or custom object) of a logical computation grid with the specified number of rows and columns."
    },
    {
        "instruction": "Write a function `check_compatibility(data_placement_description, operation_input_requirements)` that takes the outputs from Task 2 and Task 3. It should return `True` if the data's shape and placement rule exactly match the operation's requirements, and `False` otherwise."
    },
    {
        "instruction": "Create a function `assign_data_placement(data_shape, grid_representation, placement_rule)` where `data_shape` is a tuple (e.g., (8, 2)), `grid_representation` is the output from Task 1, and `placement_rule` is a string (e.g., 'replicated', 'sharded_on_rows'). Return a description (e.g., a dictionary) indicating the data's shape and how it's conceptually placed on the grid (e.g., {'shape': (8, 2), 'placement': 'replicated', 'grid': grid_representation})."
    },
    {
        "instruction": "Create a function that accepts a nested dictionary. It should validate if the input dictionary strictly matches a predefined structure template (e.g., `{'config': {'param_a': object, 'param_b': object}, 'data': object}`). If it matches, return `True`; otherwise, raise a `TypeError` indicating a structure mismatch."
    },
    {
        "instruction": "Implement a function `compare_structure(structure_one, structure_two)` that recursively compares the keys and nesting of two dictionary-like objects. It should return `True` if the structures are identical and `False` if they differ at any level."
    },
    {
        "instruction": "Write a function that takes two arbitrarily nested dictionaries and returns `True` if they have the exact same structure (keys and nesting levels), ignoring the actual values, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that generates two distinct nested dictionary structures. For example, one could be `{'a': {'c': 1, 'd': 2}}` and the other `{'a': 3, 'c': {'b': 4, 'e': 5}}`. The function should return both dictionaries."
    },
    {
        "instruction": "Write a function that accepts two positive integers, `rows` and `cols`. It should return a 2D numerical array (matrix) of shape (`rows`, `cols`) containing sequential integers starting from 0 (i.e., 0, 1, 2,... row by row)."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array (matrix) as input. It should return a new 2D array of the same dimensions where every element of the input array has been increased by 1."
    },
    {
        "instruction": "Implement a function that takes two arguments: an integer `control_value` and a 2D numerical array `data_matrix`. If `control_value` is exactly 0, the function should return the original `data_matrix`. Otherwise (if `control_value` is not 0), it should return a new 2D array where each element is the corresponding element of `data_matrix` plus 1."
    },
    {
        "instruction": "Develop a function `check_matrix_equality` that takes two 2D numerical arrays (matrices) assumed to have identical shapes. The function should return `True` if all corresponding elements in the two matrices are numerically equal, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes three integers: `limit`, `rows`, `cols`. Generate a sequence of integers from 0 up to (but not including) `limit`. Reshape this sequence into a `rows` x `cols` 2D numerical array. Return the 2D array. Assume `limit == rows * cols`."
    },
    {
        "instruction": "Implement a function to compute the product of two 2D numerical arrays (matrices). It takes matrix `A` (shape M x K) and matrix `B` (shape K x N) and returns their product matrix (shape M x N)."
    },
    {
        "instruction": "Given the shape (number of rows `M`, number of columns `N`) of an input 2D numerical array, write a function that returns the shape (a tuple of two integers: rows, columns) of the matrix resulting from multiplying the input matrix by its transpose."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) and returns its transpose. If the input has shape (M, N), the output must have shape (N, M)."
    },
    {
        "instruction": "Implement a function that accepts two 1D numerical arrays (or lists of numbers) of identical size. Return a new array/list containing the element-wise sum of the two inputs."
    },
    {
        "instruction": "Develop a function that takes a single 1D numerical array `arr` as input. The function should compute `(arr * 2) + arr` element-wise and return the resulting 1D numerical array of the same size."
    },
    {
        "instruction": "Create a function factory: define an outer function that establishes a fixed 1D numerical array `C` (e.g., representing `[0.0, 1.0, ..., 7.0]`). This outer function should return a new inner function. The inner function accepts one argument, a 1D numerical array `x` of the same size as `C`, and returns a new array representing the element-wise computation `(C * 2) + x`."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array (or list of numbers) and a scalar number. Return a new array/list of the same size where each element of the input is multiplied by the scalar."
    },
    {
        "instruction": "Design a system with two functions: `prepare_computation` and `execute_prepared`. `prepare_computation` takes an initial data structure (containing an array and its 'distribution type' string) and a simple element-wise function (e.g., multiply by 2). It should store the 'distribution type' of this initial data and return a 'prepared handle'. `execute_prepared` takes this handle and a *new* data structure (array + potentially different type string). It must apply the element-wise function to the new array but return the result bundled with the 'distribution type' string *stored during preparation*."
    },
    {
        "instruction": "Write a function that takes a data structure (containing an array and a 'distribution type' string) and a target type string. It should return `True` if the structure's 'distribution type' string exactly matches the target type string, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes two integers, `rows` and `cols`, and returns a 2D numerical array of shape (`rows`, `cols`) filled with sequential integers starting from 0 (filling row by row)."
    },
    {
        "instruction": "Create a function that accepts a numerical array and a scalar number. It should return a new numerical array of the same shape where each element is the corresponding element from the input array multiplied by the scalar."
    },
    {
        "instruction": "Create a function `simulate_data_processing` that accepts an initial 1D numerical array `initial_data` and a processing function `process_func`. Inside, create a *second* 1D numerical array `runtime_data` with the *same values* as `initial_data` (representing data from a different source). Apply `process_func` to `runtime_data` and return the result. Verify the result's length matches `initial_data`'s length."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a scalar number. It should return a new 1D array where each element of the input array is multiplied by the scalar."
    },
    {
        "instruction": "Design a function `execute_in_context`. It takes a 'context' specification (e.g., expected output shape/type), an operation function `op`, and input `data` (a 1D numerical array). Apply `op` to `data`. Before returning the result, validate that it strictly conforms to the 'context' specification (e.g., must be a 1D array of the same length as the input `data`). Return the validated result."
    },
    {
        "instruction": "Create a function that accepts a positive integer `N` and returns a 1D numerical array containing the sequence of integers starting from 0 up to (but not including) `N`."
    },
    {
        "instruction": "Create a function that generates a 1D numerical array containing a sequence of integers from 0 up to N-1. Input: A positive integer N. Output: A 1D numerical array of length N."
    },
    {
        "instruction": "Design a function that simulates a simple optimization pass on a list of operation strings. If an operation string representing data placement with a 'default' target (e.g., 'PLACE dataX DEFAULT') immediately follows the operation string that computed 'dataX' (e.g., 'COMPUTE dataX = ...'), remove the 'PLACE' operation. Input: List of strings. Output: Optimized list of strings."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a scalar number. Return a new 1D array where each element is the corresponding element of the input array multiplied by the scalar."
    },
    {
        "instruction": "Implement a function that accepts a multi-line string and a list of specific forbidden substrings. The function should return `True` if *none* of the forbidden substrings are present anywhere within the input string, and `False` otherwise."
    },
    {
        "instruction": "Create a function that generates a 2D numerical array of specified dimensions (rows, columns) filled with consecutive integers starting from 0."
    },
    {
        "instruction": "Implement a function that accepts two 2D numerical arrays of identical shape and type. The function should apply the *same* element-wise transformation (e.g., multiplying by 2) independently to each input array and return the two resulting transformed arrays as a pair."
    },
    {
        "instruction": "Design a way to represent the structural information of an array (its dimensions and data type, e.g., 'int32') without storing the actual data. Write a function that takes this structural information for two potential inputs and verifies if a simple element-wise operation (like addition or multiplication) would be valid given their shapes and types."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns a new 2D array of the same dimensions where each element is double the value of the corresponding input element."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns a new 2D array where each element is multiplied by 2. Input shape (M, N), output shape (M, N)."
    },
    {
        "instruction": "Develop a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array of shape (`rows`, `cols`) filled with integers starting from 0 and increasing sequentially row by row."
    },
    {
        "instruction": "Implement a function that receives two 2D numerical arrays, `A` (shape M, N) and `B` (shape M, N). It must return a tuple containing exactly two elements: (1) array `A` with each element doubled, and (2) the transpose of array `B`."
    },
    {
        "instruction": "Write a function that accepts one or more inputs. It should examine the *first* input and return `True` if it is a two-dimensional array (matrix) of numbers, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts two arguments (which can be any data type) but returns only the first argument, completely ignoring the second."
    },
    {
        "instruction": "Implement a function `get_parameter_count` that accepts another function `func` as input. This function should return the number of positional parameters declared in `func`'s definition, without calling `func`."
    },
    {
        "instruction": "Develop a function `call_two_args` that takes three inputs: a callable function `target_func`, a value `val1`, and a value `val2`. The function should call `target_func` with `val1` and `val2` as its two arguments and return the result produced by `target_func`."
    },
    {
        "instruction": "Write a function that accepts two 1D numerical arrays, `arr_a` and `arr_b`. The function should return a tuple containing two elements: the first element should be `arr_a` itself, and the second element should be the integer 2, representing the number of array arguments received."
    },
    {
        "instruction": "Write a function that validates array metadata. It takes a metadata dictionary (with 'shape' and 'dtype') and checks if the shape is a tuple of non-negative integers and the dtype is a recognized numerical type identifier (e.g., 'int32', 'float64'). Return True if valid, False otherwise."
    },
    {
        "instruction": "Create a function that simulates analyzing an identity operation. Given metadata for one input array (a dictionary with 'shape' and 'dtype' keys, e.g., {'shape': (8,), 'dtype': 'int32'}), the function should return a list containing one identical metadata dictionary, representing the single output."
    },
    {
        "instruction": "Write a function that takes a shape tuple (e.g., `(8,)`) and a data type identifier (e.g., 'int32') representing a 1D numerical array. The function should return a dictionary containing two keys: 'shape' holding the input tuple and 'dtype' holding the input data type identifier."
    },
    {
        "instruction": "Develop a function that simulates analyzing an operation that takes two inputs and returns them unchanged. Input: two metadata dictionaries (each with 'shape' and 'dtype'). Output: a list containing two metadata dictionaries, identical to the inputs and in the same order."
    },
    {
        "instruction": "Implement a function that compares two 1D numerical arrays. It should return `True` if both arrays have the same length and all corresponding elements are identical, and `False` otherwise."
    },
    {
        "instruction": "Write a higher-order function that takes three arguments: a function `op` (which applies an element-wise operation), an input 1D numerical array `data`, and an expected output 1D numerical array `expected`. The function should apply `op` to `data` and return `True` if the result is element-wise identical to `expected`, `False` otherwise."
    },
    {
        "instruction": "Develop a function that checks if a given 1D numerical array conforms to an expected shape. The function takes the array and a shape tuple (e.g., `(8,)`) as input and returns `True` if the array's shape matches the tuple, `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new 1D array where each element is multiplied by 2. The output array should have the same shape as the input."
    },
    {
        "instruction": "Create a function that takes any data and a string representing a 'location tag' (e.g., 'CPU', 'GPU_1', 'TPU_Cluster'). It should return a representation that bundles the data and its location tag together (e.g., a tuple, dictionary, or simple object)."
    },
    {
        "instruction": "Create a function that simulates a pre-configured operation. It should take an 'expected location tag' (string) during setup. This setup function returns *another* function. The returned function accepts a data bundle (containing data and a location tag). If the bundle's tag matches the 'expected location tag' set during setup, it performs an element-wise doubling on the data (assuming it's a 1D numerical array) and returns the result. If the tags don't match, it must raise a `ValueError` with a descriptive message about the location mismatch."
    },
    {
        "instruction": "Implement a function that generates a 1D numerical array containing integers from 0 up to (but not including) a given positive integer N."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new 1D array where each element is multiplied by 2. Maintain the original data type."
    },
    {
        "instruction": "Write a function that takes a non-negative integer `N` and returns a 1D numerical array containing the sequence of integers from 0 up to (but not including) `N`."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and returns a new array of the same length where each element is the square of the corresponding input element."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array where each element is doubled. The output array should have the same length as the input."
    },
    {
        "instruction": "Develop a function that takes two 1D numerical arrays of the same length and returns a new array of that same length, where each element is the sum of the corresponding elements from the two input arrays."
    },
    {
        "instruction": "Write a function that validates the setup for a partitioned computation. It accepts a list of input array definitions (some abstract with partition count N, some concrete with partition count M) and an optional target environment. It must perform these checks: 1. Verify that if abstract and concrete definitions are mixed for the same logical input, their partition counts match (N == M). Raise `PartitionMismatchError` if not. 2. Verify that if *any* input definition is abstract, a target environment is specified. Raise `MissingEnvironmentError` if not. 3. Verify that no input definition remains abstract if a final 'compilation' step is implied (e.g., via a boolean flag). Raise `AbstractInputError` if abstract inputs exist when finalization is requested. If all checks pass, return a dictionary like `{'status': 'valid', 'partition_count': N}` (where N is the determined partition count)."
    },
    {
        "instruction": "Create a function to check compatibility between an abstract array definition (including an abstract partition count N) and a concrete array definition (including a concrete partition count M). The function takes these two definitions as input and returns `True` only if their shapes, data types, and partition counts (N == M) are identical, `False` otherwise."
    },
    {
        "instruction": "Write a function that creates a data structure representing an abstract array. It should accept a shape (tuple of integers), a data type (e.g., string like 'float32'), and an abstract partitioning scheme (e.g., an integer representing the number of partitions). Return the structure containing these three pieces of information."
    },
    {
        "instruction": "Develop a function that determines the abstract description of the output of a simple element-wise operation (like doubling). Input is an abstract array description (shape, type, partitioning scheme). Output should be a *new* abstract array description with the same shape, type, and partitioning scheme."
    },
    {
        "instruction": "Develop a function for element-wise multiplication of two 1D numerical arrays (can be integer or float). It should return the resulting array if the inputs have the same length, otherwise signal an error."
    },
    {
        "instruction": "Write a basic function that computes the element-wise product of two predefined 1D integer arrays, each of length 8. Ensure the calculation is performed sequentially element by element, without any parallel processing assumptions."
    },
    {
        "instruction": "Write a function that accepts two 1D numerical arrays of identical length and returns a new array representing their element-wise product."
    },
    {
        "instruction": "Implement a function taking two 1D integer arrays. If both arrays have a length of exactly 8, return their element-wise product as a new array. Otherwise, indicate an input error (e.g., return None or raise an exception)."
    },
    {
        "instruction": "Create a function to verify partitioning consistency. Input: two partitioning scheme descriptions (like the output of Task 3), representing an input and an output partitioning. Output: Boolean `True` if both schemes describe the identical partitioning strategy (same grid, same number of partitions, same data slices mapped to the same conceptual grid cells), `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts two positive integers, `rows` and `cols`. Return a 2D numerical array with shape (`rows`, `cols`) containing sequential integers starting from 0 (i.e., 0, 1, 2,...)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar number. Return a new 2D array of the same shape where each element is the corresponding input element multiplied by the scalar."
    },
    {
        "instruction": "Design a function that defines a partitioning scheme for a 2D array across a 2D logical grid. Input: grid dimensions (tuple `grid_shape`) and data dimensions (tuple `data_shape`). Output: A data structure (e.g., a list of tuples) describing how the data array is tiled, mapping each logical grid cell index to the corresponding slice of the data array. Assume partitioning along both dimensions."
    },
    {
        "instruction": "Design a data structure (e.g., a dictionary or custom object) to represent a 2D logical grid layout. The structure should store the grid dimensions (e.g., 2x2) and the names assigned to each dimension (e.g., 'dim_a', 'dim_b')."
    },
    {
        "instruction": "Implement a function to validate a partitioning plan. It takes an array's shape (tuple of integers), a grid definition (e.g., dimensions and axis names), and a partitioning specification (sequence of axis names or None). Return True if the number of elements in the specification matches the array's dimensions and all specified axis names exist in the grid definition, False otherwise."
    },
    {
        "instruction": "Write a function that creates and returns a 3D numerical array of shape (4, 2, 2) filled with sequential integers starting from 0."
    },
    {
        "instruction": "Write a function that generates a descriptive string representing how a multi-dimensional array is intended to be partitioned across a logical grid. Input: the array's shape, the grid's configuration (e.g., shape and axis names), and the partitioning rule (sequence of axis names/None per array dimension). Output: A formatted string summarizing this information, e.g., 'Constraint applied: Array shape (4, 2, 2) partitioned via ['dim_a', None, 'dim_b'] across grid (2, 2) ['dim_a', 'dim_b']'."
    },
    {
        "instruction": "Write a function that creates a 3D numerical array of specified dimensions (e.g., 4x2x2) and fills it with consecutive integers starting from zero."
    },
    {
        "instruction": "Create a function that validates a partitioning specification against a target array. It accepts the array's shape (e.g., a tuple like (4, 2, 2)) and a specification (e.g., a list/tuple like ['split_A', None, 'split_B']). Return True if the specification has the same number of elements as the array has dimensions, False otherwise."
    },
    {
        "instruction": "Implement a function that generates a descriptive mapping for array partitioning. Input: array dimensions (e.g., `(4, 2, 2)`), a logical resource grid definition (e.g., `{'x': 4, 'y': 2}`), and a partitioning specification (e.g., `['x', None, 'y']`). Output: A dictionary mapping each array dimension index to its partitioning status (e.g., `{0: 'partitioned by x', 1: 'unpartitioned', 2: 'partitioned by y'}`)."
    },
    {
        "instruction": "Write a function to verify if a partitioning specification uses valid resource names. Input: a specification (e.g., ['dim_X', None, 'dim_Y']) and a set of available resource names (e.g., {'dim_X', 'dim_Y', 'dim_Z'}). Return True if all names used in the specification exist in the available set (ignore None entries), False otherwise."
    },
    {
        "instruction": "Write a function that performs matrix multiplication on two 2D numerical arrays A and B. Ensure it handles compatible dimensions (A's columns == B's rows) and returns the resulting 2D array. Specify input shapes (M, K) and (K, N) should yield output shape (M, N)."
    },
    {
        "instruction": "Write a function that inspects a string representing a computational execution plan. The function should take the plan string and details of a resource grid (e.g., a dimension name and size) and return True if the plan explicitly mentions partitioning data across that named grid dimension with the correct size, and False otherwise."
    },
    {
        "instruction": "Create a function that defines the structure of a multi-dimensional array. It should accept a tuple representing dimensions (shape) and a string representing the data type (e.g., 'float32', 'int64') and return an object or structure holding this information."
    },
    {
        "instruction": "Implement a function to define a logical grid of computational resources. It should take a tuple of dimension sizes and a tuple of corresponding dimension names, returning a representation of this named grid (e.g., a dictionary mapping names to sizes)."
    },
    {
        "instruction": "Create a function that takes a positive integer `N` and returns a 1D array containing integers from 0 to `N-1` in sequence. The array should have a 32-bit integer data type."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new array where each element is multiplied by 2. The output array must have the same shape and data type as the input array."
    },
    {
        "instruction": "Implement a function `apply_and_get_dtype`. It takes another function `func` and an input array `arr`. It should call `func(arr)` and return the data type of the resulting output array."
    },
    {
        "instruction": "Implement a function `apply_and_get_shape`. It takes another function `func` and an input array `arr`. It should call `func(arr)` and return the shape (as a tuple) of the resulting output array."
    },
    {
        "instruction": "Develop a function that takes three numerical inputs (let's call them `p`, `q`, `r`). It should calculate `100*p + 10*q + r`, ensuring `r` is cast to `q`'s type first. The function must also signal (e.g., by appending to a list passed as an argument or modifying a global list) each time its main calculation logic runs. Return the calculated numerical result."
    },
    {
        "instruction": "Create a function that takes three numerical inputs: a, b, and c. Before performing any calculation, ensure that c is converted to the same data type as b. Then, return the value of 100*a + 10*b + c."
    },
    {
        "instruction": "Design a mechanism (like a class or a higher-order function) that manages calls to a target function. This mechanism should accept arbitrary positional and keyword arguments for the target function. It must track not just the *values* of the arguments but also *how* they were passed (positional vs. keyword). The target function should only be executed if the exact combination of argument values and calling style hasn't been seen before. If seen before, return the previously computed result. If new, execute the target function, store the result associated with the specific call signature, and return the result. The target function for testing can be one that calculates `100*x + 10*y + z`."
    },
    {
        "instruction": "Implement a function that takes three numerical arguments, potentially passed as a mix of positional and keyword arguments. The function should maintain an external counter (e.g., in a list or variable outside the function) that increments only when the function's core logic is executed for the first time with a specific set of argument values *and* calling style (i.e., positional vs. keyword matters). The function itself should return a simple fixed value (e.g., True)."
    },
    {
        "instruction": "Simulate a system with two contexts: \"default\" and \"alternate\". Define a simple calculation function. Verify it runs in \"default\". Temporarily switch the default to \"alternate\" and verify the calculation runs there. Now, explicitly associate an input value with \"default\". Verify that even when \"alternate\" is the temporary default, using the associated input forces the calculation back to \"default\"."
    },
    {
        "instruction": "Create a function that accepts two abstract computational context identifiers (strings like \"context_A\", \"context_B\") and returns `True` if they represent the same context, `False` otherwise."
    },
    {
        "instruction": "Implement a way to temporarily override the default computational context. Write a function `perform_operation(value)` that normally uses \"default_context\". Show that when the override mechanism sets \"temp_context\", `perform_operation` uses \"temp_context\", and reverts to \"default_context\" after the override ends."
    },
    {
        "instruction": "Write a function that takes a numerical input, adds 1 to it, and returns both the result and an abstract identifier representing the computational context (e.g., \"context_A\") where the addition was performed."
    },
    {
        "instruction": "Implement a function that takes a sequence (e.g., a list or tuple) of integers and calculates the total sum of its elements."
    },
    {
        "instruction": "Write a function that sums the elements of a variable-length list of numbers. For example, input `[1, 2, 3]` should return `6`, and input `[10, -2, 0, 5]` should return `13`."
    },
    {
        "instruction": "Develop a function that takes one argument, a list of numbers, and returns a single number representing the sum of all elements in the list."
    },
    {
        "instruction": "Create a function that receives a list potentially containing many numerical elements and computes their sum efficiently."
    },
    {
        "instruction": "Develop a function `execute_binary_op` that accepts three arguments: a function `func` (which itself takes two arguments) and two values `val1` and `val2`. The `execute_binary_op` function should call `func` with `val1` and `val2` as inputs and return the result produced by `func`."
    },
    {
        "instruction": "Implement a function that takes a one-dimensional array of integers, computes the sum of its elements, and returns this sum explicitly converted to a floating-point data type."
    },
    {
        "instruction": "Create a function that receives two one-dimensional arrays: `arr_float` (containing floats) and `arr_int` (containing integers). The function should calculate the sum of elements in `arr_float`, calculate the sum of elements in `arr_int`, convert the integer sum to a float, and finally return the sum of these two floating-point results."
    },
    {
        "instruction": "Write a function that accepts a one-dimensional array of floating-point numbers and returns their sum as a single floating-point value."
    },
    {
        "instruction": "Develop a function that accepts a list of 1D numerical arrays. It should return a new list containing arrays of the same lengths, where each element in the corresponding output array is the element from the input array plus 1."
    },
    {
        "instruction": "Write a function that takes three 2D numerical arrays. First, check if all three arrays have the exact same shape. If not, raise an error. If they do, return a tuple containing three new arrays: (1) the element-wise sum of the first and second arrays, (2) the element-wise product of the second and third arrays, and (3) the first array with each element squared."
    },
    {
        "instruction": "Create a function that takes two integers, `rows` and `cols`, and a numerical value `fill_value`. It should return a 2D numerical array with the specified dimensions, filled entirely with `fill_value`."
    },
    {
        "instruction": "Implement a function that takes two 2D numerical arrays of the same shape as input. It should return a tuple containing two new arrays: the first input array with each element multiplied by 3, and the second input array with each element multiplied by 5."
    },
    {
        "instruction": "Develop a function that accepts a numerical array and returns `True` if the array has exactly two dimensions (is a matrix), and `False` otherwise."
    },
    {
        "instruction": "Create a function that generates a 2D numerical array of specified dimensions (e.g., rows=2, cols=5) filled entirely with a given constant scalar value."
    },
    {
        "instruction": "Implement a function that accepts a numerical array and a scalar multiplier. It should return a new array of the same shape as the input, with each element multiplied by the scalar."
    },
    {
        "instruction": "Design a function that takes a numerical array, performs an element-wise doubling operation to create a *new* result array. The function should return both the result array and a boolean status indicating that the *original input array* should be considered invalid or unusable by the caller after this function returns."
    },
    {
        "instruction": "Create a function `create_filled_array(rows, cols, value)` that returns a new 2D numerical array with the specified `rows` and `cols`, filled entirely with the provided numerical `value`."
    },
    {
        "instruction": "Implement a function `double_elements_kw(**kwargs)` that accepts exactly one keyword argument named `data`, which is expected to be a 2D numerical array. The function must return a new 2D array where each element is double the value of the corresponding element in the input `data` array."
    },
    {
        "instruction": "Create a higher-order function `wrap_consumer(transform_func, arg_index)` that takes a function `transform_func` (which accepts one numerical array and returns one numerical array) and an integer `arg_index`. It should return a *new* function. This new function accepts any number of arguments. When called, it applies `transform_func` to the argument at the position specified by `arg_index`, returns the result, and simulates that the original input argument at `arg_index` is now invalid (e.g., by returning the result and a status flag)."
    },
    {
        "instruction": "Develop a function `process_and_invalidate(input_array)` that takes a 2D numerical array. It should compute a new array where each element is doubled. The function must return the new array and also provide a clear indication (e.g., through a multi-value return like `(result, is_invalidated)`) that the original `input_array` reference should be considered invalid after the call."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays (e.g., lists of numbers) of the same size and returns a new 1D array representing their element-wise sum."
    },
    {
        "instruction": "Implement a function that takes two arguments of any type and returns `True` if both arguments reference the exact same object in memory (aliasing), and `False` otherwise."
    },
    {
        "instruction": "Define a function that accepts another function `func` (which takes two arguments) and two arguments `a` and `b`. The function should call `func(a, b)` and return its result."
    },
    {
        "instruction": "Create a function that accepts an integer `size` and returns a 1D numerical array (e.g., a list) of that `size` containing only zeros."
    },
    {
        "instruction": "Design two functions, `record_event` and `clear_events`. `record_event` should increment a shared counter (initially 0). `clear_events` should reset this shared counter back to 0. Demonstrate their use: show the counter is 1 after one call to `record_event`, and 0 after a subsequent call to `clear_events`."
    },
    {
        "instruction": "Implement a function that acts as a simple call counter. It should maintain a count, initialized to zero. Each time it's called, it increments the count by one and returns the *updated* count."
    },
    {
        "instruction": "Create a function `process_and_track` that accepts another function `func` (expecting two numerical arguments) and two numbers `x`, `y`. It should call `func(x, y)`, increment a persistent counter associated with `process_and_track` calls, and return the result of `func(x, y)`. The counter should start at 0 and increase by 1 for each call to `process_and_track`."
    },
    {
        "instruction": "Write a function that takes two numbers as input and returns their sum."
    },
    {
        "instruction": "Write a function `call_and_count` that takes an integer `limit`. Inside the function, use a loop to call a simple, predefined function `do_work()` exactly `limit` times. The `do_work()` function should append a timestamp to a global list `work_log` each time it's called. `call_and_count` should return the final size of `work_log`."
    },
    {
        "instruction": "Design a class `SelectiveExecutor` that takes a function `func` (which might have side effects like appending to a list). The executor should normally cache results based on input arguments (like `FunctionCache` in Task 2). Implement a context manager `ForceExecution`. When the executor is called *within* an active `ForceExecution` context, it must *always* execute the original `func` (triggering any side effects) and bypass the cache, returning the fresh result."
    },
    {
        "instruction": "Write a function `record_call` that takes one argument. Inside the function, append the integer `1` to a predefined global list named `call_log`. The function should return the argument it received, unmodified."
    },
    {
        "instruction": "Implement a class `FunctionCache`. It takes a function `func` during initialization. Instances should be callable. When an instance is called with arguments `*args`, it should execute `func(*args)` only the *first* time for a unique combination of `args`. Subsequent calls with the same `args` should return the stored result without re-executing `func`. Use a dictionary to store results, mapping argument tuples to return values."
    },
    {
        "instruction": "Create a function that takes two same-length 1D sequences: `data` (containing numbers) and `mask` (containing booleans). Return a new sequence where elements from `data` corresponding to `True` in `mask` are replaced by a placeholder (e.g., `None`)."
    },
    {
        "instruction": "Develop a function that takes one argument. If the argument's type is *not* a simple numerical type (integer or float), raise a `TypeError` with the message \"Unsupported data type\". Otherwise, return the input argument."
    },
    {
        "instruction": "Write a function that accepts a single argument of any type and returns that argument unchanged."
    },
    {
        "instruction": "Write a function that accepts a sequence potentially containing masked values (represented by `None`). The function must validate that *no* `None` values are present. If `None` is found, raise a `ValueError` stating \"Masked values are not supported\". If validation passes, return `True`."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new array containing the element-wise arithmetic negative of the input array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns `True` if all elements in the array are negative, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes an integer `N` as input, generates a 1D array of `N` random floating-point numbers, and then returns a new 1D array where each element is the negative of the corresponding element in the generated array."
    },
    {
        "instruction": "Create a function that takes an integer `size` as input and returns a 1D array of that size filled with random floating-point numbers."
    },
    {
        "instruction": "Implement a function `create_tracker` that takes any Python object as input and returns a 'tracker' object. This tracker object must have a method `is_object_alive()` which initially returns `True`. The tracker should monitor the original object such that `is_object_alive()` returns `False` if and only if the original object has been garbage collected (or all strong references are gone). Do not use the `weakref` module directly."
    },
    {
        "instruction": "Write a script demonstrating reference management. Create a data object (e.g., `[10, 20, 30]`). Create a function `f` that captures this data. Create a second function `g` which somehow represents a 'processed' version of `f` and also holds a reference to the data independently of `f`. Use a tracking mechanism (like in Task 2, or conceptually) to verify: (1) the data is alive after `f` is created, (2) the data is still alive after `f` is deleted but `g` still exists, (3) the data is no longer alive after `g` is also deleted."
    },
    {
        "instruction": "Write a function that accepts a data object (e.g., a list or numerical array) and returns a *new* function (a closure). This returned function, when called with no arguments, should simply return the original data object it captured."
    },
    {
        "instruction": "Write a function that takes an integer `size` as input and returns a list containing `size` floating-point numbers, all initialized to the value 1.0."
    },
    {
        "instruction": "Create a function `attempt_operation` that takes an arbitrary Python object. Inside the function, try to perform an operation that is known to fail with a `TypeError` for objects defined with `__slots__ = []` (e.g., simulate adding it to a special collection that requires weak references). The function should catch *only* this specific `TypeError` and return the string 'Operation Failed Due To Type'. If no error or a different error occurs, it should return 'Operation Succeeded or Other Error'."
    },
    {
        "instruction": "Write a Python class `Incrementer` with no instance attributes (use `__slots__ = []`). Make instances callable, so that calling an instance with a number `x` returns `x + 1`."
    },
    {
        "instruction": "Implement a function `create_and_call` that defines a nested class `InnerCallable` with `__slots__ = []` and a `__call__` method returning its input plus one. The function should instantiate `InnerCallable`, attempt to call the instance with the value `5`, and return the result. Handle any `TypeError` that might occur during the call, returning `None` in that case."
    },
    {
        "instruction": "Write a higher-order function `process_callable` that accepts a callable object `func`. This function should simulate applying a process that is incompatible with callables lacking standard instance dictionaries (like those using `__slots__ = []`). It should return a *new* function. If `func` is detected as incompatible (check for the absence of `__dict__` attribute after ensuring it's not a built-in function/method), the new function, when called, must raise a `TypeError`. Otherwise, the new function should execute the original `func`."
    },
    {
        "instruction": "Implement a function `call_and_reraise_value_error(func, *args, **kwargs)` that calls the provided function `func` with the given arguments. If `func` raises a `ValueError`, this function must catch it and immediately re-raise the *exact same* `ValueError` object. Other exceptions should propagate normally."
    },
    {
        "instruction": "Define a custom exception class `MyHashingError` that inherits from `Exception`. Then, create a class `SpecialObject` whose `__hash__` method always raises `MyHashingError`. Finally, write a function `attempt_set_add(obj)` that tries to add `obj` to a standard set. If a `MyHashingError` is caught during this attempt, return the string \"Hashing failed\"; otherwise, return the string \"Added successfully\"."
    },
    {
        "instruction": "Write a function `process_item(item, processing_func)` that first tries to calculate the hash of `item`. If hashing raises *any* exception, the function should catch that specific exception object and return it. If hashing succeeds, the function should call `processing_func(item)` and return its result."
    },
    {
        "instruction": "Write a function `can_be_dict_key(obj)` that takes any object `obj`. It should return `True` if the object can be successfully used as a key in a standard dictionary, and `False` if attempting to do so raises a `TypeError`."
    },
    {
        "instruction": "Write a function `run_nested_check(outer_config, inner_config, data)` that simulates a nested operation. It should accept two configuration identifiers and data. Inside, it should call a hypothetical `inner_operation(data)` (which simply returns `data + 1`). Before calling, it must check if `outer_config` and `inner_config` are different. If they are different, it must raise a `ValueError` with the message \"Configuration mismatch detected\". If they are the same, it should return the result of the `inner_operation`."
    },
    {
        "instruction": "Implement a function `execute_conditionally(config_id, data)` that takes a configuration identifier `config_id` and some `data`. Define an inner operation (e.g., return `data + 1`). If `config_id` is considered \"invalid\" (e.g., equals the string \"invalid\"), raise a `ValueError` with a message like \"Invalid configuration provided\". Otherwise, perform the inner operation and return the result."
    },
    {
        "instruction": "Write a function `increment_data(data)` that takes a numerical input `data` and returns `data + 1`."
    },
    {
        "instruction": "Create a function `check_compatibility(config_a, config_b)` that accepts two configuration identifiers (e.g., strings like \"context1\", \"context2\"). It should return `True` if they are identical and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a single keyword argument `text` containing a string and returns that exact string."
    },
    {
        "instruction": "Implement a function that accepts a single keyword argument `element`. The function should return a tuple containing the `element` as both its first and second items."
    },
    {
        "instruction": "Write a function that accepts a single keyword argument named `data` and returns the value associated with `data` unchanged."
    },
    {
        "instruction": "Construct a function that receives a list of items via a keyword argument named `items` and returns the identical list."
    },
    {
        "instruction": "Write a function that takes an optional integer argument named `value` which defaults to 4. The function should simply return the value it receives."
    },
    {
        "instruction": "Define a function that takes two arguments: a required string `name` and an optional integer `age` defaulting to 30. The function should return a formatted string like \"Name: [name], Age: [age]\"."
    },
    {
        "instruction": "Write a function that accepts an optional list argument `items` which defaults to an empty list `[]`. The function should return the list itself."
    },
    {
        "instruction": "Create a function that accepts an optional numerical argument `count` with a default value of 10. The function should return double the value of `count`."
    },
    {
        "instruction": "Write a function that simulates a process iterating 1000 times. It starts with an initial 1D numerical array. In each step, it applies a simple transformation (like element-wise increment) to get a new array. The function must efficiently track and return only the *last* 100 arrays generated during this process, without storing all 1000 intermediate arrays simultaneously."
    },
    {
        "instruction": "Create a function that generates a 1D numerical array of a specified size (e.g., 10000 elements), filled entirely with the floating-point value 1.0."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array where each element is incremented by one."
    },
    {
        "instruction": "Develop a function that iteratively applies an element-wise increment operation to a 1D numerical array 1000 times. In each iteration, record some property of the intermediate array (e.g., its sum or the value of its first element) into a list. Return the list of recorded properties."
    },
    {
        "instruction": "Create a function that takes an array of numbers and returns a new array where each element is the result of applying two additions: first add 4, then add 2."
    },
    {
        "instruction": "Implement a function `apply_operation_elementwise` that takes two arguments: a function `op` (which accepts a single number and returns a single number) and an array of numbers `data`. The function should return a new array containing the results of applying `op` to each element in `data`."
    },
    {
        "instruction": "Create a higher-order function `create_vectorized_wrapper` that accepts a function `scalar_func` designed to operate on single numerical inputs. It should return a *new* function that takes an array of numbers. This new function must attempt to apply `scalar_func` to each element of the array. If `scalar_func` raises a `TypeError` during this process (signifying it cannot handle the vectorized call context), the wrapper function must catch this `TypeError` and raise a `ValueError` with a message like 'Operation cannot be applied element-wise'. If no `TypeError` occurs, it should return the array of results."
    },
    {
        "instruction": "Write a function that accepts a single numerical input and returns the result of adding 4 to it."
    },
    {
        "instruction": "Define a custom class representing unique identifiers (e.g., with an 'id_code' attribute). Implement the necessary methods (`__hash__`, `__eq__`) so that instances of this class can be reliably used as dictionary keys. Write a function that takes a list of data items and uses instances of your identifier class (derived from the data items) as keys in a dictionary to store the corresponding data items as values."
    },
    {
        "instruction": "Write a function that accepts a dictionary where keys are members of an enumeration (e.g., representing user roles ADMIN, USER, GUEST) and values are permission levels (integers). The function also takes a specific role enum member and should return the corresponding permission level. Handle the case where the role is not found by returning a default value of 0."
    },
    {
        "instruction": "Create a function that takes a list of key-value pairs. The keys are members of a predefined enumeration (e.g., representing colors RED, GREEN, BLUE), and the values are integers. Return a dictionary constructed from these pairs."
    },
    {
        "instruction": "Implement a function that receives a dictionary whose keys might be instances of a simple enumeration (e.g., representing directions NORTH, SOUTH, EAST, WEST). The function should iterate through the dictionary's key-value pairs and return a list containing only the values associated with enum keys."
    },
    {
        "instruction": "Write a function that accepts a single argument of any basic type (integer, boolean, float) and returns it unchanged, ensuring the output type is identical to the input type."
    },
    {
        "instruction": "Design a function that maintains an internal state remembering the last value it received. It should take one argument. If the current argument has the same value *and* type as the last one, return \"Repeated Input\". Otherwise, update the internal state with the current argument and return \"New Input\". Handle the very first call appropriately (e.g., return \"New Input\")."
    },
    {
        "instruction": "Create a function that takes two arguments and returns `True` if they are equal in value *and* are of the exact same type, otherwise returns `False`."
    },
    {
        "instruction": "Implement a higher-order function (a function that takes another function `g` as an argument). This wrapper function should accept one argument `x` and keep track of the type of `x` from the previous call. Before calling `g(x)`, it should print 'Argument type changed' if the type of `x` is different from the previous call's argument type (skip this check for the very first call). It then calls `g(x)` and returns its result, updating the stored type for the next invocation. Assume `g` is a simple function like an identity function."
    },
    {
        "instruction": "Implement a function that accepts two scalar numerical values and returns `True` if their absolute difference is below a small tolerance (e.g., 1e-5), and `False` otherwise."
    },
    {
        "instruction": "Design a function `apply_and_verify` that accepts two arguments: a function `func` (which takes no arguments and returns a scalar numerical value) and a positive integer `n`. First, call `func` once to get an `expected_result`. Then, call `func` `n` more times. Verify that each of these `n` results is approximately equal to the `expected_result`. Return the `expected_result` if all checks pass, otherwise raise a value error indicating inconsistency."
    },
    {
        "instruction": "Create a function that takes another function `op` (which accepts no arguments and returns a scalar value) and a positive integer `k`. The function should execute `op` exactly `k` times. It must verify that every execution yields the exact same scalar value and then return that single scalar value. If any execution yields a different value, it should raise an error."
    },
    {
        "instruction": "Write a function that takes a list or 1D array of scalar numerical values. It should return `True` if all values in the collection are numerically identical to the first element (within a small tolerance), and `False` otherwise. Handle empty or single-element inputs appropriately (e.g., return `True`)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is the square of the corresponding element in the input array."
    },
    {
        "instruction": "Create a function that calculates the sum of all elements in a given 1D numerical array and returns the single scalar sum."
    },
    {
        "instruction": "Write a function that takes another function `op` (which accepts a 1D numerical array and returns a scalar) and a 1D numerical array `data`. The function should call `op(data)` exactly three times and return the scalar result obtained from the final call."
    },
    {
        "instruction": "Implement a function that accepts a 1D numerical array, squares each element, and then returns the sum of these squared elements as a single numerical value."
    },
    {
        "instruction": "Write a function that takes a floating-point number `x`. Calculate `y = 1 + x * 0`. If the result `y` is `NaN`, return the boolean value `True`. Otherwise, return the boolean value `False`."
    },
    {
        "instruction": "Implement a function that takes three floating-point numbers `a`, `b`, and `c`. Calculate and return `a + b * c`. The function must correctly propagate `NaN` values according to standard arithmetic rules (e.g., `NaN` involved in multiplication or addition generally results in `NaN`)."
    },
    {
        "instruction": "Write a function that takes a single floating-point number `x` as input. The function should return the result of multiplying `x` by zero. Ensure it correctly handles `NaN` inputs, returning `NaN` if `x` is `NaN`."
    },
    {
        "instruction": "Create a function that accepts one floating-point number `x`. It should calculate `1 + x * 0` and return the result. Verify that if the input `x` is `NaN`, the output is also `NaN`."
    },
    {
        "instruction": "Write a function `generate_sequence(length)` that takes a non-negative integer `length` and returns a list containing integers from 0 up to `length - 1`. For example, `generate_sequence(4)` should return `[0, 1, 2, 3]`."
    },
    {
        "instruction": "Create a function `run_once_check_later(func, initial_arg, later_arg)`. This function should first call `func(initial_arg)`. Then, it should compare the type and (if applicable) length of `later_arg` with `initial_arg`. If they differ, raise a `ValueError`. If they are the same, call and return `func(later_arg)`."
    },
    {
        "instruction": "Write a function `get_arg_info(arg)` that returns a tuple containing the type of the argument and, if the argument is a list or tuple, its length. For non-sequence types, the length part can be None. Example: `get_arg_info([1, 2])` returns `(list, 2)`, `get_arg_info(5)` returns `(int, None)`."
    },
    {
        "instruction": "Implement a stateful callable class `RestrictedRunner`. It's initialized with a function `target_func`. The first time its instance is called (e.g., `runner_instance(arg)`), it executes `target_func(arg)`, stores information about `arg` (type and length if sequence), and returns the result. On subsequent calls with a new argument `new_arg`, it checks if `new_arg`'s info matches the stored info. If it matches, it runs `target_func(new_arg)`. If it *doesn't* match, it must raise a `RuntimeError`."
    },
    {
        "instruction": "Write a function that attempts to extract a single scalar value from an input container. If the input is a 0-dimensional container with one element, return the element. If the input has more than one dimension or element, raise a `ValueError`."
    },
    {
        "instruction": "Implement a function that takes an input object. It should check if the object is a 0-dimensional numerical container holding exactly one element. Return `True` if it is, `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a 0-dimensional numerical container holding exactly one scalar value (e.g., float or integer) and returns that scalar value."
    },
    {
        "instruction": "Create a function that takes a single numerical scalar value (like 5.0 or 3) and returns a 0-dimensional data structure containing only that value."
    },
    {
        "instruction": "Develop a higher-order function that takes a function `f` and a list/tuple of integer indices `arg_indices`. When called with arguments for `f`, it should return a tuple: (1) the result of `f`, and (2) a tuple containing the gradients (derivatives) of `f` with respect to each positional argument specified in `arg_indices`, evaluated at the given arguments. The order of gradients in the output tuple must match the order of indices in `arg_indices`. Assume `f` is differentiable with respect to the specified arguments."
    },
    {
        "instruction": "Implement a function wrapper `apply_func`. It should accept another function `target_func`, a variable number of positional arguments (`*args`), and a variable number of keyword arguments (`**kwargs`). `apply_func` must call `target_func`, correctly passing all received positional and keyword arguments to it, and return whatever `target_func` returns."
    },
    {
        "instruction": "Create a higher-order function that takes another function `f` (which accepts numerical arguments and returns a single numerical value) as input. Your function should accept the same arguments as `f`. It must return a tuple containing: (1) the result of calling `f` with the given arguments, and (2) the gradient (derivative) of `f` with respect to its *first* positional numerical argument, evaluated at the given arguments. Assume `f` is differentiable."
    },
    {
        "instruction": "Write a function that accepts three numerical inputs (x, y, z) and a boolean flag. If the flag is true, it should return the result of a predefined linear combination (e.g., `1.0*x + 2.0*y + 3.0*z`). Ensure the function correctly uses the flag to conditionally perform the calculation."
    },
    {
        "instruction": "Implement a function `can_broadcast(shape1, shape2)` that takes two tuples representing array shapes. Return `True` if arrays with these shapes are compatible according to standard broadcasting rules (comparing dimensions right-to-left), and `False` otherwise."
    },
    {
        "instruction": "Create a function that attempts element-wise addition of two numerical arrays (potentially multi-dimensional). First, check if their shapes are compatible for broadcasting. If compatible, return the resulting array. If not, raise a ValueError with a message showing the incompatible shapes."
    },
    {
        "instruction": "Write a higher-order function `wrap_binary_op(elementwise_func)`. It takes a function `elementwise_func` (that performs an element-wise operation on two compatible arrays) and returns a *new* function. This new function accepts two numerical arrays, checks if they are broadcast-compatible, calls `elementwise_func` if they are, and raises a ValueError detailing the shape mismatch if they are not."
    },
    {
        "instruction": "Develop a function that takes two 1D numerical arrays guaranteed to have the same length. Return a new 1D array containing their element-wise sum. No error checking for length is required."
    },
    {
        "instruction": "Create a testing scenario. First, define a function `process_inplace` that takes a 1D numerical array and modifies it in-place (e.g., doubles every element). Second, write code that: a) creates a 1D zero array, b) calls `process_inplace` on it, c) subsequently attempts to perform a hypothetical `explicit_transfer` operation on the *same array variable* used in step b. This `explicit_transfer` attempt must be enclosed in error handling logic that specifically expects and catches a predefined error type (e.g., `InvalidBufferError`), verifying that the transfer fails due to the array's state after the in-place modification."
    },
    {
        "instruction": "Create a function that initializes and returns a 1D numerical array (vector) of a specified size, filled entirely with zeros. The function should accept the desired size and numerical data type (e.g., float) as arguments."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a scalar number. It returns a *new* 1D array where each element is the corresponding element of the input array multiplied by the scalar. The original array must not be modified."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array which is assumed to represent a data buffer that cannot be explicitly moved or copied after certain operations. The function should simulate an attempt to 'place' or 'copy' this array onto a specific computational resource (represented by an ID, e.g., 0 or -1). This simulation must *always* fail by raising a specific predefined error (e.g., `BufferStateException` or `ValueError`)."
    },
    {
        "instruction": "Create a function `assign_to_partitions(data_array, partition_configs)` that takes a 1D numerical array and a list of partition configurations (e.g., each config could specify a target partition ID). Return a representation (like a dictionary or list of tuples) mapping each partition ID to the portion of the `data_array` assigned to it, simulating data distribution."
    },
    {
        "instruction": "Write a function that accepts a positive integer `N` and returns a 1D numerical array containing the sequence of floating-point numbers from 0.0 up to (but not including) `N`."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and returns a new 1D array of the same size, where each element is exactly double the value of the corresponding element in the input array."
    },
    {
        "instruction": "Simulate resource consumption. Write a function `process_data(data_handle, operation)` that applies an `operation` function to the data represented by `data_handle`. The function should also return a status indicating if the `data_handle` is still valid or if it has been 'consumed' (invalidated) by the operation."
    },
    {
        "instruction": "Create a function `double_and_check_positive` that takes a single number `x` as input. It should return a tuple containing two values: the number multiplied by 2, and a boolean value indicating whether the input number `x` was greater than 0."
    },
    {
        "instruction": "Implement a function `process_and_select` that takes a number `num`. This function should first call another function `internal_compute(num)` (assume `internal_compute` returns a pair: `(result_num, result_bool)`). `process_and_select` must return only the `result_num` from the pair."
    },
    {
        "instruction": "Given a simple function `f(x)` that computes `2 * x`. Write another function `compute_gradient_product` that takes an input value `x_val` and an output gradient `grad_out`. It should return the product of `grad_out` and the mathematical derivative of `f(x)` evaluated at `x_val`."
    },
    {
        "instruction": "Consider a function `complex_process(x)` which internally calculates `(value_a, value_b)` based on `x`, but ultimately only returns `value_a`. Implement a function `backpropagate_effect` that takes an input point `x_point` and an effect `effect_on_a` applied to `value_a`. Calculate and return the corresponding effect on the original input `x`, ensuring that the calculation pathway related to `value_b` does not contribute to the final result. Assume `value_a = 2*x` and `value_b = x > 0` for the internal calculation."
    },
    {
        "instruction": "Implement a function that accepts two objects, each representing a 2D vector with named numerical attributes `x` and `y`. Calculate and return the dot product of these two vectors (v1.x * v2.x + v1.y * v2.y) as a single numerical value."
    },
    {
        "instruction": "Define a simple data structure, like a class or named tuple, called `Point2D` that can store two named floating-point attributes: `x` and `y`. Write a function that accepts an instance of `Point2D` and returns the sum of its `x` and `y` attributes."
    },
    {
        "instruction": "Design a higher-order function `apply_field_wise` that takes two arguments: an object `data_object` (which has named numerical attributes like `x`, `y`, etc.) and a function `transform_func`. The `transform_func` itself takes the `data_object` and returns a dictionary mapping attribute names (strings) to new numerical values. The `apply_field_wise` function must then construct and return a *new object* of the *same type* as `data_object`, initializing its attributes using the values from the dictionary returned by `transform_func`."
    },
    {
        "instruction": "Write a function that calculates the Euclidean distance (magnitude) of a 2D point from the origin. The function should accept an object having numerical attributes `x` and `y`, and return a single non-negative floating-point number representing `sqrt(x**2 + y**2)`."
    },
    {
        "instruction": "Implement a function that takes an object with numerical attributes 'x' and 'y'. The function should return a new object of the same type (or a compatible structure) where 'x' is the square of the input 'x' and 'y' is the square of the input 'y'."
    },
    {
        "instruction": "Write a function that takes an object representing a point. This object must provide access to numerical 'x' and 'y' coordinates and must have a method `check_condition()` that returns a boolean value. If `check_condition()` returns True, the function should return 0.0; otherwise, it should return the value of the 'x' coordinate."
    },
    {
        "instruction": "Define a simple data structure to hold two numerical values, 'x' and 'y'. Write a function that accepts an instance of this structure and returns True if both 'x' and 'y' are zero, False otherwise."
    },
    {
        "instruction": "Define a base data structure representing a 2D point with 'x' and 'y' coordinates. Create a specialized version (subclass or similar mechanism) of this structure that includes a method `is_at_origin()` which returns True if x=0 and y=0, and False otherwise."
    },
    {
        "instruction": "Implement a data structure that stores the shape (as a tuple of positive integers) and data type (as a string, e.g., 'float32', 'int64') of a potential array. Provide methods to retrieve the stored shape tuple and data type string."
    },
    {
        "instruction": "Develop a function or method that, given a non-empty shape tuple (e.g., `(5, 2, 3)`), returns the size of the first dimension (i.e., the first element of the tuple). If the input shape tuple is empty `()`, it should raise an appropriate error."
    },
    {
        "instruction": "Implement a function or method that generates a specific string representation for an object containing shape and data type information. For an object representing shape `(A, B, C)` and data type `'dtype_string'`, the function must return the exact string: `'ShapeDtypeStruct(shape=(A, B, C), dtype=dtype_string)'`."
    },
    {
        "instruction": "Write a function that accepts a shape tuple (e.g., `(5,)`, `(2, 3)`, `(4, 1, 6)`) representing array dimensions. The function must return the number of dimensions (rank) of the shape as an integer."
    },
    {
        "instruction": "Write a function that takes a list of numbers and returns a new list where each number is incremented by one."
    },
    {
        "instruction": "Write a function that takes two arguments: a function `transform_func` and a list `data_list`. The `transform_func` itself takes one argument. Your function should apply `transform_func` to every element in `data_list` and return a new list containing the transformed elements. Ensure it works correctly even if `data_list` is empty."
    },
    {
        "instruction": "Develop a function that accepts a list of strings and returns a list of integers, where each integer is the length of the corresponding string in the input list."
    },
    {
        "instruction": "Create a function that accepts another function `f` (which takes one numerical argument and returns one numerical result) and a single number `x`. The function should return the result of calling `f(x)`."
    },
    {
        "instruction": "Implement a function that takes two numerical arrays, `arr1` and `arr2`. Check if the size of the first dimension of `arr1` is equal to the size of the first dimension of `arr2`. If not, raise a `ValueError` with a message clearly stating the mismatched sizes and indicating they came from `arr1` and `arr2`."
    },
    {
        "instruction": "Create a function `check_batch_consistency` that accepts one positional numerical array argument `pos_arg` and one keyword numerical array argument `kw_arg`. The function must verify that the size of the *first dimension* of `pos_arg` is identical to the size of the *first dimension* of `kw_arg`. If the sizes differ, raise a `ValueError` indicating which argument ('positional' or 'keyword') has which size along the first dimension. If the sizes are consistent, the function should return `True`."
    },
    {
        "instruction": "Write a function that takes a list of numerical arrays and another list of numerical arrays. Assume both lists have the same length. Return a new list where the i-th element is the element-wise sum of the i-th arrays from the two input lists. Ensure corresponding arrays are compatible for addition (e.g., same shape), raising a `ValueError` if not."
    },
    {
        "instruction": "Create a function that takes two numerical arrays as input. Return `True` if the size of their first dimension is the same, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a list of strings (representing captured log messages) and a list of required substrings. Return `True` if the captured messages contain lines that include *all* of the required substrings, and `False` otherwise."
    },
    {
        "instruction": "Create a function that executes a given zero-argument callable and captures any messages logged to a standard diagnostic stream during its execution. Return a list of the captured message strings."
    },
    {
        "instruction": "Write a function that accepts either a single number or a list of numbers. It should return a new number or list containing the input value(s) multiplied by 2."
    },
    {
        "instruction": "Develop a function that receives a list of strings (log messages). It should return `True` if *any* string in the list contains the specific phrase 'Operation complete', and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a single number and returns double its value."
    },
    {
        "instruction": "Design a function that takes a list representing a sequence of simple operations, like `[('multiply', 'input1', 2, 'temp1'), ('add', 'input2', 'temp1', 'result')]`. It also takes a dictionary mapping initial variable names (e.g., 'input1', 'input2') to their numerical values. Process the operations sequentially, storing intermediate results using the specified variable names. Return the final computed value associated with the variable name in the last operation step."
    },
    {
        "instruction": "Create a function that takes two numerical inputs, `val1` and `val2`. It should return a tuple where the first element is the sum of `2 * val1` and `val2`, and the second element is the constant integer `3`."
    },
    {
        "instruction": "Write a function that simulates evaluating a predefined sequence of two arithmetic operations: first, multiply an input `x` by 2, then add another input `y` to the result. The function should accept `x` and `y` as numerical inputs and return the final numerical result."
    },
    {
        "instruction": "Write a function that takes another function `f` as input. It should return a *new* function `g` that, when called, simply calls the original function `f` with the arguments passed to `g`."
    },
    {
        "instruction": "Write a function that accepts an integer. Inside the function, define a nested function that increments the integer by 1. Call the nested function once and return the *incremented* value."
    },
    {
        "instruction": "Create a function `run_monitored_loop` that initializes an internal counter to 0. It then runs a loop exactly 5 times. Inside the loop, it calls a provided function `step_func`. `step_func` takes no arguments. After calling `step_func`, the `run_monitored_loop` increments its internal counter. Add a check: If the provided `step_func` has the exact name `modify_counter_directly`, `run_monitored_loop` must raise a `RuntimeError` *before* calling it inside the loop. If the loop completes without error, return the final counter value (should be 5)."
    },
    {
        "instruction": "Implement a function `check_and_run` that takes a list of functions and an initial value. It should iterate through the functions, applying each one sequentially to the value (output of one becomes input to the next). However, if it encounters a function with the exact name 'increment_unsafe', it must immediately raise a `ValueError` with the message 'Unsafe function detected'. Otherwise, it completes all applications and returns the final value."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array (input vector) of size N. For each element in the input vector, it should generate a fixed 1D array of size M=2 containing zeros. The function should return a list containing N of these M-sized zero arrays."
    },
    {
        "instruction": "Develop a function that accepts a 1D numerical array (input vector) of size N. For each element in the input vector, it should generate a fixed 1D array of size M=2 containing only zeros. The function must collect these M-sized arrays and stack them such that the resulting 2D output array has shape (M, N)."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical array (input vector) of size N. For each element of the input vector, it should produce a constant 1D array of size M=2 containing only zeros. The function should then stack these M-sized arrays vertically (row-wise) to create and return a 2D array of shape (N, M)."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array of shape (`rows`, `cols`) filled entirely with zeros."
    },
    {
        "instruction": "Implement a function that receives a list of integers and calculates their sum. If the list is empty, it should return 0."
    },
    {
        "instruction": "Write a function that accepts two integer numbers as input and returns their sum."
    },
    {
        "instruction": "Create a function that takes three numerical inputs: `value1`, `value2`, and `expected_result`. The function should return `True` if the sum of `value1` and `value2` equals `expected_result`, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes a single numerical input and returns `True` if the input is exactly equal to the integer 2, and `False` in all other cases."
    },
    {
        "instruction": "Implement a function `run_and_detect_append` that takes three inputs: a target function `func`, an argument `value` for `func`, and an external list `observed_list`. Call `func(value)`. Return `True` if the length of `observed_list` increased as a result of the call, and `False` otherwise."
    },
    {
        "instruction": "Define a function that accepts one argument. This function should append the received argument to a list defined outside its own scope, and then return the argument unchanged."
    },
    {
        "instruction": "Create a global list variable. Write a function that takes one argument and appends this argument to the global list. The function itself should not return any value."
    },
    {
        "instruction": "Write a function that accepts a single argument of any type and returns that argument unmodified."
    },
    {
        "instruction": "Design a function `execute_and_report_append(func, arg, monitored_list)` which calls `func(arg)`. If `func(arg)` appends one or more items to `monitored_list`, `execute_and_report_append` must raise a custom `ValueError` with the message 'Append detected'. Otherwise, it should return the result of `func(arg)`."
    },
    {
        "instruction": "Implement a simple context manager class. On entering the context, it should record a start time. On exiting, it should record the end time and print the duration elapsed within the context."
    },
    {
        "instruction": "Create a function `run_with_side_effect_check(func_to_run, arg, target_list)` that executes `func_to_run(arg)`. It should return `True` if calling `func_to_run` resulted in *any* change to the length of `target_list`, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts another function `target_func` and an argument `val`. It should call `target_func(val)` and use basic exception handling to catch a general `Exception`. If such an exception is caught, the function should return the string 'Error Occurred'. Otherwise, it should return the result of `target_func(val)`."
    },
    {
        "instruction": "Create a function `derivative_of_identity` that takes a single numerical scalar `x` as input. It should return the value of the derivative of the mathematical function f(z) = z evaluated at the point `x`."
    },
    {
        "instruction": "Write a function `identity_op` that accepts a single numerical argument (which could be a scalar or an array) and returns the argument unchanged."
    },
    {
        "instruction": "Develop a function `create_range_array` that takes a non-negative integer `N` and returns a 1D numerical array containing the sequence of integers starting from 0 up to, but not including, `N`. If N is 0, it should return an empty array."
    },
    {
        "instruction": "Write a function `apply_elementwise` that takes two arguments: a function `g` (which operates on numerical scalars) and a multi-dimensional numerical array `input_array`. The function should return a new numerical array with the same dimensions as `input_array`, where each element is the result of applying `g` to the corresponding element in `input_array`."
    },
    {
        "instruction": "Create a function that accepts a list of numerical values. It should return a new list of the same size, where every element is the floating-point value `1.0`, irrespective of the input values."
    },
    {
        "instruction": "Write a function simulating one step of a state update. It takes a single numerical value as the initial 'state'. Inside the function, apply a rule where the new state is always `1.0` and the associated output for this step is null or empty. Return the new state (`1.0`)."
    },
    {
        "instruction": "Implement a reusable 'scan' operation. This function accepts an initial 'carry' value, a sequence of input items (e.g., a list), and an 'update' function. The 'update' function takes the current carry and one item, returning a tuple: `(new_carry, step_output)`. Your 'scan' function should iterate through the input items, applying the update function at each step, and finally return the last carry value and a list containing all the `step_output` values generated."
    },
    {
        "instruction": "Develop a function that takes a list of numerical initial 'states'. For each state in the input list, it independently performs a single-step update identical to the one described in Task 2 (new state becomes `1.0`). The function should return a new list containing the resulting state (`1.0`) for each corresponding input state."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new 1D array of the same size, where each element in the output array is identical to the corresponding element in the input array."
    },
    {
        "instruction": "Implement a function that takes two arguments: a 'current_value' (a number) and an 'ignored_input'. The function should return the 'current_value' unchanged as the primary result, and a secondary null or placeholder value."
    },
    {
        "instruction": "Implement a function that performs a sequential computation over a series of steps. It takes an initial 'carry' value and a 'step_function'. The 'step_function' takes the current carry and a step index (or placeholder), returning the next carry and a per-step output. Your function should execute the 'step_function' a specified number of times (e.g., once), updating the carry each time, and return the final carry value."
    },
    {
        "instruction": "Create a function that simulates applying a transformation function exactly once. It should accept an initial 'state' (a number) and a 'transform_function'. The 'transform_function' itself takes the current state and an ignored second argument, returning the next state and a placeholder. Your function should call the 'transform_function' once with the initial state and return the resulting next state."
    },
    {
        "instruction": "Create a function `check_for_exception` that accepts another function `callback` as input. Call `callback()` inside a `try...except` block. If `callback` raises any `Exception`, return `True`. Otherwise, return `False`."
    },
    {
        "instruction": "Implement a context manager class `DetectModification`. Its `__init__` should accept a list. The `__enter__` method should return the list. The `__exit__` method should check if the list *provided during initialization* has been modified (e.g., its length changed or elements differ) during the `with` block. If modified, it should raise a `ValueError` with the message \"List modified!\"."
    },
    {
        "instruction": "Write a function `modify_list_safely` that takes a list `data`. Inside, define a nested function `append_item` that takes an item, appends it to `data`, and returns `None`. Call `append_item` with the value `10`. The `modify_list_safely` function should return the modified `data` list."
    },
    {
        "instruction": "Create a function `create_accumulator`. This function should initialize an internal sum to zero. It should return a *new* function, `add_value`, which takes a number, adds it to the internal sum, and returns the updated sum. Each call to `add_value` should modify the *same* internal sum."
    },
    {
        "instruction": "Write a function that accepts an object known to contain a 1D numerical array. The function should access this internal array and return a new 1D numerical array where each element is the cosine of the corresponding element in the internal array."
    },
    {
        "instruction": "Implement a function that takes an object wrapping a numerical array (potentially multi-dimensional) and returns a new standard numerical array representation of the data stored within the object."
    },
    {
        "instruction": "Develop a function that takes a nested structure (e.g., a list of lists, or tuple of tuples) containing objects, where each object internally holds a single numerical scalar value. The function must convert this entire structure into a single multi-dimensional standard numerical array, reflecting the nesting levels as dimensions."
    },
    {
        "instruction": "Design a class that holds a numerical array. Implement a special method (or convention) that allows instances of this class to be automatically treated as the underlying numerical array when passed to functions that expect numerical arrays. Demonstrate this by showing how a hypothetical `compute_sum(array)` function could work directly with an instance of your class."
    },
    {
        "instruction": "Object Decomposition/Reconstruction: Implement a class storing one numerical array. Add a method `flatten()` that returns the array and `None` as auxiliary data. Add a class method `unflatten(aux_data, array)` that takes the auxiliary data and array, returning a new instance of the class."
    },
    {
        "instruction": "Array Exposure: Design a class holding a numerical array. Implement a method `get_array()` that returns the underlying array, enabling the object to provide its data when needed by external functions."
    },
    {
        "instruction": "Enabling External Operations: Create a class that encapsulates a 2D numerical array (matrix). Ensure that an instance of this class can be used as an argument in external functions that operate on matrices (like matrix multiplication), by providing a mechanism for these functions to access the underlying matrix data implicitly."
    },
    {
        "instruction": "Attribute Proxy: Create a class that takes a numerical array during initialization and stores it. Implement `shape`, `ndim`, and `dtype` properties on the class that return the corresponding attributes of the stored array."
    },
    {
        "instruction": "Define a structure or class representing named integer constants, specifically mapping the name 'SUCCESS' to the integer value 1. Write code to retrieve the integer value associated with 'SUCCESS'."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array as input but ignores it. The function should access a predefined named constant representing the integer 1 (defined elsewhere, similar to Task 2) and return that integer value."
    },
    {
        "instruction": "Implement a function that accepts a 1D numerical array. The function should return a new 1D numerical array of the same size as the input, where every element is the integer constant 1."
    },
    {
        "instruction": "Write a function that takes an integer `n` and returns a 1D numerical array containing the sequence `0, 1, ..., n-1`, with each element incremented by 1."
    },
    {
        "instruction": "Write a function that takes no arguments and returns the numerical value representing the mathematical constant 'e' raised to the power of 0."
    },
    {
        "instruction": "Develop a function that accepts a shape tuple (e.g., (3, 4)) and a string representing a numerical data type. Return a new numerical array of the given shape, filled entirely with the value 1, where each element is represented using the specified data type."
    },
    {
        "instruction": "Implement a function that takes a string representing a numerical data type (e.g., 'float64'). The function should compute the exponential of the number 0, where 0 is first represented using the specified data type. Return the result, ensuring it has the same data type."
    },
    {
        "instruction": "Write a function that takes a string specifying a numerical data type (e.g., 'complex64', 'float32') and returns the numerical value 1.0, explicitly represented in that data type."
    },
    {
        "instruction": "Create a function `prepare_computation(captured_value)` that defines an inner computation (e.g., adding the `captured_value` to a future input). Return an object or structure that stores both the description of the computation (e.g., 'add') and the `captured_value`. Then, write a second function `execute_computation(computation_object, input_value)` that takes the prepared object and an `input_value`, performs the stored computation using the captured value, and returns the result."
    },
    {
        "instruction": "Implement a function `apply_func_to_list(func, input_list)` that takes a function `func` (which accepts one argument) and a list `input_list`. It should return a new list where each element is the result of applying `func` to the corresponding element in `input_list`."
    },
    {
        "instruction": "Write a function `process_collection(collection, constant)` that takes a collection (e.g., a list) of numbers and a single numerical `constant`. For each number in the collection, it should add the `constant` to it. Return a new collection containing the results."
    },
    {
        "instruction": "Define two functions: `add(a, b)` which returns the sum of two numbers, and `apply_add(val1, val2)` which calls `add` with `val1` and `val2` and returns the result."
    },
    {
        "instruction": "Write a function that computes the dot product of a square numerical matrix with itself. Input: A 2D array of shape (N, N). Output: A 2D array of shape (N, N)."
    },
    {
        "instruction": "Create a function wrapper that counts how many times the wrapped function is invoked. The wrapper should accept a function as input and return a new function. Calling the new function executes the original and increments a counter. Include a way to access the counter's value."
    },
    {
        "instruction": "Implement a function that accepts a boolean flag, two callable functions (func_true, func_false), and a single argument. If the flag is true, call func_true with the argument; otherwise, call func_false with the argument. Assume both callables accept the same argument type and return the same result type."
    },
    {
        "instruction": "Design a function execution system sensitive to a global 'mode' setting (e.g., 'precise', 'fast'). When a managed function is called, the system checks the current mode. If the mode has changed since the last call *to that specific function*, it must re-execute the function. If the mode is unchanged, it can potentially skip re-execution (assume re-execution is the default if unsure). Focus on the logic for triggering re-execution based on mode changes."
    },
    {
        "instruction": "Design a function simulating a backward computation step that manages internal state. The function receives an incoming numerical value ('gradient'). It maintains an internal list tracking state from previous calls. It checks a condition based on the list's length and the state of its elements (e.g., if length is 2, check if the first element's state indicates 'processed'). It then updates the list with new state information, creates a specific output value (e.g., zero), and returns that value."
    },
    {
        "instruction": "Define a pair of functions simulating a custom computation step. `func_fwd(x)` should return `(x, None)`. `func_bwd(context, grad_in)` should take the context (None) and an incoming numerical gradient `grad_in`, perform an internal check (e.g., assert a global counter is less than 5), increment the counter, create a new zero value, and return a tuple containing only that zero value as the output gradient."
    },
    {
        "instruction": "Write a function `calculate_derivative_chain(input_val)` that computes the derivative of a thrice-composed identity function `f(f(f(x)))` (where `f(x)=x`) evaluated at `input_val`. Simulate this using a rule where the 'derivative' of `f` is always 1, and apply the chain rule for the composition."
    },
    {
        "instruction": "Implement a function `apply_thrice(func, value)` that takes another function `func` and a `value`, and returns the result of applying `func` three times consecutively: `func(func(func(value)))`."
    },
    {
        "instruction": "Write a function that takes two inputs: an N-dimensional numerical array `A` and a scalar `s`. First, compute a new array `B` by adding `s` element-wise to `A`. Second, implement a verification check within the function that compares `B` to the expected result (`A` element-wise + `s`) using an approximate equality check (e.g., absolute difference less than 1e-5) for each element. Return `True` if all elements match approximately, `False` otherwise."
    },
    {
        "instruction": "Implement a function that accepts an N-dimensional numerical array and a single scalar value. The function must return a new N-dimensional array of the exact same shape and data type as the input, where each element is the sum of the corresponding input element and the scalar."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (e.g., a list or vector of numbers) and a single scalar number. Return a new 1D array of the same size where the scalar has been added to each element of the input array."
    },
    {
        "instruction": "Create a function that generates a multi-dimensional numerical array (e.g., 4D) with specified dimensions. Fill this array with random floating-point numbers uniformly distributed between 0.0 and 1.0."
    },
    {
        "instruction": "Implement a function `chain_scale_transform`. This function should first define an inner scaling function `f(x) = 2.0 * x`. Then, it should determine the scaling factor used in `f` (which is `2.0`). Finally, it should apply this scaling factor to a *different* input value, say `3.0`, returning the result `(3.0 * 2.0)` wrapped in a tuple: `(6.0,)`."
    },
    {
        "instruction": "Develop a function `wrap_in_tuple` that takes a single floating-point number and returns a tuple containing only that number."
    },
    {
        "instruction": "Implement a function `scale_by_two` that accepts a single floating-point number `x` and returns `2.0 * x`."
    },
    {
        "instruction": "Write a function `create_linear_transformer` that takes a constant `slope` (a float). It should return *a new function* that takes a single float `v` and returns `v * slope`."
    },
    {
        "instruction": "Write a function that implements the mathematical function f(x) = 2x. It should accept a single numerical input `x` and return the numerical output `2*x`."
    },
    {
        "instruction": "Implement a function that takes a numerical input `value` and returns the result of applying a pre-defined linear transformation (multiplication by 2) to it. That is, given `value`, return `2 * value`."
    },
    {
        "instruction": "Create a function that simulates applying a directional derivative. It should accept two numerical inputs: `derivative_at_point` (representing the derivative of some function f at a point x) and `direction_vector` (representing the direction v). The function should return the product `derivative_at_point * direction_vector`."
    },
    {
        "instruction": "Write a function that calculates the derivative of the function f(x) = 2x. Since the derivative is a constant value (2), the function should accept a numerical input `x` (which won't be used in the calculation for this specific f(x)) and return the numerical value `2.0`."
    },
    {
        "instruction": "Create a function that accepts another function `g` (which takes one numerical scalar argument and returns one numerical scalar) and a numerical scalar value `y`. The function should call `g` with `y` and return the result wrapped in a single-element tuple."
    },
    {
        "instruction": "Develop a higher-order function named `get_linear_transpose_scaler`. It should accept a constant numerical scaling factor `a` as input. It should return a *new function* which takes a single numerical scalar input `y` and returns `a * y`."
    },
    {
        "instruction": "Implement a function that represents the linear transpose (adjoint) of the specific function `f(x) = 2.0 * x`. This new function should take a numerical scalar input `y` and return the result `2.0 * y`."
    },
    {
        "instruction": "Write a function that takes a single numerical scalar input `x` and returns the result of multiplying it by a constant factor of 2.0."
    },
    {
        "instruction": "Simulate a computation cache sensitive to a global state. Implement: (a) A cache storing results keyed by input array shape. (b) A global boolean flag. (c) A function performing element-wise array addition (`x+x`) that uses the cache. (d) Logic such that toggling the global flag invalidates all entries in the cache, forcing the addition to be re-executed (verified by an execution counter) on the next call, even for a previously cached shape."
    },
    {
        "instruction": "Design a mechanism to manage a single global configuration setting represented by a string (e.g., 'allow', 'warn', 'raise'). Provide functions/methods to get the current value, set a new value globally, and temporarily modify the value within a specific code block, ensuring the original value is restored upon exiting the block."
    },
    {
        "instruction": "Write a function that accepts a numerical array of any shape and returns a new array of the same shape where each element is the sum of the corresponding input element with itself."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array. Maintain a record of input array shapes encountered so far. The first time the function receives an array of a particular shape, it should perform element-wise addition (element + element), increment a counter, store the result associated with the shape, and return the result. Subsequent calls with the same shape should return the stored result without incrementing the counter."
    },
    {
        "instruction": "Implement a simple counter mechanism. Create a structure (like a class or using closures) that increments an internal counter every time a specific associated function is executed. Provide a way to retrieve the current count."
    },
    {
        "instruction": "Extend the counter mechanism from Task 2. Add a function or method that resets the internal counter back to zero. Verify that retrieving the count after resetting yields zero."
    },
    {
        "instruction": "Simulate a function execution cache. Create a wrapper that takes a function `f`. When the wrapper is called with arguments, it should check if it has been called with these exact arguments before. Keep track of the unique argument sets encountered. Provide functions to: (a) get the number of unique argument sets encountered so far, and (b) clear the record of encountered argument sets."
    },
    {
        "instruction": "Write a function that creates and returns a 1D numerical array containing only the floating-point value `1.0`."
    },
    {
        "instruction": "Design a function that compares a new data signature (represented as a tuple: e.g., `('float32', {'hi': ('float32', (3,))})` ) against a list of previously seen signatures. If an exact match exists in the list, return ('exact_match', index). If not, find the signature in the list with the minimum number of differences (e.g., count type and shape mismatches) and return ('closest_match', index, list_of_differences), where list_of_differences describes the mismatches (e.g., ['Scalar type: expected float32, got int32', 'Dict key hi shape: expected (3,), got (4,)']). If the list is empty, return ('first_encounter', -1, [])."
    },
    {
        "instruction": "Implement a function that simulates checking function call argument structure. It takes the number of positional arguments and a list of keyword argument names used in a call. Compare this to a predefined expected structure (e.g., 1 positional argument, keyword arguments ['y']). Return a descriptive string: 'Match' if it matches, or the first reason for mismatch (e.g., 'Mismatch: Expected 1 positional argument, got 2', 'Mismatch: Unexpected keyword argument z', 'Mismatch: Missing keyword argument y')."
    },
    {
        "instruction": "Write a function that takes two arguments, a numerical scalar and a dictionary containing a single 1D numerical array under the key 'data'. Return `True` if the scalar is a 32-bit float and the array is a 1D float array of length 3, otherwise return `False`."
    },
    {
        "instruction": "Create a function that accepts two dictionaries, `dict_a` and `dict_b`. Both dictionaries map string keys to 1D numerical arrays. Compare the arrays associated with the same keys in both dictionaries. Return a list of strings, where each string describes a mismatch found (e.g., 'Key data: Shape mismatch, expected (3,), got (4,)', 'Key info: Type mismatch, expected float32, got float64'). If all common keys have matching array types and shapes, return an empty list."
    },
    {
        "instruction": "Develop a function that accepts a list of strings and a search string. Return `True` if *any* string in the list contains the search string as a substring, and `False` otherwise."
    },
    {
        "instruction": "Create a higher-order function that accepts another function as input. It should execute the input function and return a list containing all lines of text that the input function printed to the standard output during its execution."
    },
    {
        "instruction": "Implement a function that validates a list of log messages based on a mode flag. Input: a boolean `strict_mode`, a list of strings `messages`, and a string `keyword`. If `strict_mode` is true, return true if `len(messages)` is between 10 and 15 (inclusive) AND at least one message contains the `keyword`. If `strict_mode` is false, return true if `len(messages)` is exactly 5 AND *all* messages contain the `keyword`. Otherwise, return false."
    },
    {
        "instruction": "Write a function that takes a list of strings and two integers, `min_count` and `max_count`. Return `True` if the number of strings in the list is greater than or equal to `min_count` and less than or equal to `max_count`, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes a list of numbers. It should first create a randomly shuffled version of the input list. Then, it should compute the sine of each number in the *shuffled* list. Finally, it should return the list containing these computed sine values."
    },
    {
        "instruction": "Create a function that takes a list of numerical values and returns a new list where each value `x` is replaced by `sin(x)`."
    },
    {
        "instruction": "Write a function that accepts a list of numbers `L` (length `N`) and an integer `k` (`0 <= k <= N`). The function must perform the following steps: 1. Create a randomly shuffled copy of the input list `L`, let's call it `S`. 2. Construct an intermediate list by concatenating two parts: the first `k` elements of `S`, and the results of applying the sine function to each of the first `N-k` elements of `S`. 3. Randomly shuffle the intermediate list. 4. Return the shuffled intermediate list."
    },
    {
        "instruction": "Implement a function that takes a list of numbers `L` of length `N` and an integer `k` (`0 <= k <= N`). It should return a new list of length `N` created by concatenating two sub-lists: the first `k` elements of `L`, and the results of applying the sine function to each of the first `N-k` elements of `L`."
    },
    {
        "instruction": "Develop a function that takes a single input `x`. If `x` is a standard number type (integer or float) that can be compared to zero, return `1` if `x > 0` and `0` otherwise. If `x` is not such a number, raise a `TypeError` indicating that the input cannot be compared to zero."
    },
    {
        "instruction": "Implement a function that takes two string arguments: `text` and `forbidden_substring`. The function should return `True` if `forbidden_substring` is *not* found anywhere within `text`, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a single input value. It should attempt to use the value in a boolean context (e.g., `if value:`). If this succeeds, return `True`. If it raises a TypeError (indicating it cannot be implicitly converted to bool), return `False`."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x`. It should return the integer `1` if `x` is strictly greater than zero, and the integer `0` otherwise."
    },
    {
        "instruction": "Write a function named `return_zero_float` that takes no arguments and always returns the floating-point value `0.0`."
    },
    {
        "instruction": "Implement a function that calculates the sine of the constant value `1.0`. If the resulting value is positive (> 0), the function should return `1.0`; otherwise, it should return `0.0`."
    },
    {
        "instruction": "Develop a function that takes a floating-point number `x`. It should compute `sin(x)`. If `sin(x)` is greater than `0.5`, return the integer `1`; otherwise, return the integer `0`."
    },
    {
        "instruction": "Create a function that accepts a single floating-point number. If the number is strictly greater than zero, return the float `1.0`; otherwise, return the float `0.0`."
    },
    {
        "instruction": "Write a function that takes a single floating-point number `x` as input. Compute the sine of `x`, and then compute the sine of that result. Return the final floating-point number."
    },
    {
        "instruction": "Implement a function to numerically approximate the derivative of a single-variable function `f` at a point `x`. The function `f` takes one float argument and returns one float. Use the central difference formula: `(f(x + h) - f(x - h)) / (2 * h)` with a small step `h` (e.g., 1e-5). Return the approximated derivative as a float."
    },
    {
        "instruction": "Develop a function that verifies the consistency of two different numerical calculation approaches. It should accept two functions, `method1` and `method2`, both taking no arguments and returning a numerical scalar. The function should execute both methods and return `True` if the absolute difference between their results is below a small threshold (e.g., 1e-6), `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts two other functions, `func1` and `func2`. Both `func1` and `func2` take no arguments and return a single numerical value. Your function should call `func1`, call `func2`, and return `True` if their return values are numerically equal (within a tolerance like 1e-6), and `False` otherwise."
    },
    {
        "instruction": "Implement a function that computes the mathematical derivative of the expression `f(x) = sin(sin(x))` with respect to `x`. The function should take a scalar numerical value `x` as input and return the value of this derivative evaluated at `x` (i.e., `cos(sin(x)) * cos(x)`)."
    },
    {
        "instruction": "Write a function that calculates the linear approximation of `f(x) = sin(sin(x))` around a point `x0`. It should take `x0` and a perturbation `dx` as input. The function should return the value `f'(x0) * dx`, where `f'(x0)` is the derivative of `f` evaluated at `x0`."
    },
    {
        "instruction": "Design a mechanism (e.g., using a class or higher-order function) to wrap a given mathematical function, `func`. When the derivative of the wrapped function is computed at a point `x`, the mechanism should not only return the derivative's value but also count how many times specific primitive operations (e.g., 'sine', 'cosine') were executed *during the derivative calculation itself*. Test with `func(x) = sin(sin(x))`."
    },
    {
        "instruction": "Write a function that accepts a single numerical scalar input `x`. This function should calculate and return the result of applying the sine function twice to the input (i.e., `sin(sin(x))`)."
    },
    {
        "instruction": "Implement a function `wrapper(num)` that calls another function `inner(num)`. Assume `inner(num)` returns a pair of values (e.g., `(value1, value2)`). The `wrapper` function should discard the second value and return only the first value (`value1`)."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number. If the number is positive (> 0), return its sine. Otherwise (if <= 0), return its cosine."
    },
    {
        "instruction": "Consider a function `f(x)` which, based on a *fixed* boolean condition (e.g., determined *before* `f` is called with a specific `x`), calculates either `sin(x)` or `cos(x)`. Implement a method to find the mathematical derivative of `f(x)` with respect to `x`, evaluated at a given point (e.g., `x=2.0`), assuming the fixed condition led to the `sin(x)` branch being chosen."
    },
    {
        "instruction": "Design a function that takes a boolean flag and a floating-point number. If the flag is true, the function returns the sine of the number. If the flag is false, it returns the cosine of the number."
    },
    {
        "instruction": "Implement a function that takes a floating-point number as input. If the input number is positive, the function should return its sine. If the input number is zero or negative, it should return its cosine."
    },
    {
        "instruction": "Design a function that takes an object containing a numerical value `v`. This object type should be considered unsuitable for use as a key in hash maps. The function should execute conditional logic: if `v > 0`, it computes `sin(v)`; otherwise, it computes `cos(v)`. Write a second function that calculates the sensitivity of the first function's output with respect to small changes in the input value `v` around a specific point `v0`. This sensitivity represents the rate of change (like a derivative)."
    },
    {
        "instruction": "Define a simple data container (like a class or struct) that holds a single numerical value. Create a function that takes an instance of this container, accesses the numerical value stored inside it, and returns that value."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number. It should return the string \"Positive\" if the number is greater than zero, and \"Non-positive\" otherwise."
    },
    {
        "instruction": "Create a function `cached_computation` that takes a single hashable argument (e.g., number, string). It should maintain an internal cache. If the argument is seen for the first time, it should perform a computation (e.g., calculate argument length if string, or argument * 2 if number), store the result associated with the argument in the cache, and return the result. If the argument is already in the cache, it should return the stored result directly without re-computing. Include a way to track how many times the actual computation was performed."
    },
    {
        "instruction": "Implement a mechanism (like a class or a higher-order function) to add caching behavior to *any* given function `func`. The enhanced function should store results based on input arguments. When the enhanced function is called, if the arguments have been seen before, return the cached result. Otherwise, call the original `func`, store its result, and return it. Also, track and report the number of times the original `func` was actually executed (cache misses). Test it with a function that takes one argument, prints a message \"Calculating...\", and returns the argument tripled."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number. It should compute both the sine and cosine of the input number and return these two results as a pair (e.g., a tuple or list)."
    },
    {
        "instruction": "Implement a function that takes one numerical input. The function should calculate the square of the input. Additionally, maintain a counter that increments *every time* the core calculation logic inside the function is executed. Return the calculated square. Write a small script to call this function 10 times with the same input and verify the counter reflects 10 executions."
    },
    {
        "instruction": "Create a function that takes any input value. The function's primary purpose is to increment an integer counter variable defined *outside* the function's scope exactly once each time the function is executed. The function itself can return a fixed value (e.g., None or True)."
    },
    {
        "instruction": "Implement a mechanism (e.g., a class wrapper or a higher-order function) that caches the results of a given function based on its input arguments. The mechanism should also track how many times the original function's body was actually executed (cache miss) using an external counter. When the wrapped function is called, if the result for the given arguments is cached, return it directly without executing the original function or incrementing the counter. If not cached, execute the original function, increment the counter, cache the result, and then return it. Test by calling the wrapped function multiple times with the same input and checking that the counter was incremented only once."
    },
    {
        "instruction": "Write a main script or function that initializes an external counter to zero. Then, loop 10 times. Inside the loop, call a specific function `f` with the *same* constant numerical input (e.g., 2.0) on each iteration. The function `f` should internally call another function `g` which increments the external counter. After the loop, verify the final value of the counter."
    },
    {
        "instruction": "Implement a function `process_data(input_value)` that internally calls a helper function `get_data(value)`. The `get_data` function performs a check (e.g., is the value positive?) and returns a pair of values, like `(result, status_code)`. The `process_data` function should call `get_data` and return *only* the `result` component, discarding the `status_code`."
    },
    {
        "instruction": "Write a function that takes a single floating-point number `x` as input and returns the result of the expression `cos(sin(x)) * cos(x)`. Assume standard mathematical sine and cosine functions are available."
    },
    {
        "instruction": "Implement a function to numerically approximate the derivative of a given single-variable function `f` at a point `x`. Use the central difference formula: `(f(x + epsilon) - f(x - epsilon)) / (2 * epsilon)`, where `epsilon` is a small positive number also provided as input. Inputs: function `f`, number `x`, number `epsilon`. Output: approximated derivative (number)."
    },
    {
        "instruction": "Create a function that accepts another function `func` (which takes one numerical argument and returns one numerical value) and a numerical value `val`. The function should execute `func` with `val` as input and return the computed result."
    },
    {
        "instruction": "Write a function that takes a single floating-point number `x` as input and returns the result of applying the sine function twice: `sin(sin(x))`. Assume standard mathematical sine function is available."
    },
    {
        "instruction": "Implement a higher-order function (or decorator) named `apply_policy`. It should take another function `target_func` and a policy function `policy_func` as input. It returns a new function that, when called with arguments `*args`, first calls `policy_func(*args)`. If the policy returns true, it executes and returns `target_func(*args)`; otherwise, it might return a default value (e.g., None) or raise an error, based on a defined behavior."
    },
    {
        "instruction": "Write a function that numerically estimates the derivative of a given single-variable function `f(x)` at a point `x0` using the finite difference method: `(f(x0 + h) - f(x0 - h)) / (2 * h)` for a small `h`. The function should take `f`, `x0`, and `h` as input and return the estimated derivative (a float)."
    },
    {
        "instruction": "Create a class or mechanism that wraps a simple mathematical function (e.g., one that calculates `x*x`). The wrapper should execute the original function but also increment an internal counter each time it's called. Provide a method to get the current count."
    },
    {
        "instruction": "Write a function that accepts two floating-point numbers, `a` and `b`, and returns a single floating-point number representing `sin(a) * b`."
    },
    {
        "instruction": "Develop a function that accepts two numerical inputs, `a` and `b`. It should define an inner function that computes the product `a * b`. The outer function must call this inner function and return the computed product."
    },
    {
        "instruction": "Implement a function that takes one numerical input `x`. Inside this function, calculate an intermediate value `y = x + 5`. Then, define a nested function that simply returns `y`. The outer function should call the nested function and return its result."
    },
    {
        "instruction": "Create a function that defines a nested function. The nested function should return the fixed value 10. The outer function should call the nested function and return its result."
    },
    {
        "instruction": "Write a function that takes a single numerical input. Define an inner function that takes no arguments but returns the input received by the outer function. The outer function should call the inner function and return its result."
    },
    {
        "instruction": "Create a function `specialize_on_boolean` that accepts two arguments: a boolean value `condition` and a function `operation` which takes a single numerical input. `specialize_on_boolean` should return a *new* function that accepts only one numerical argument `x`. If `condition` was true during the call to `specialize_on_boolean`, the new function should always return `operation(x) + 1`. If `condition` was false, the new function should return `operation(x)`."
    },
    {
        "instruction": "Create a function that accepts a boolean value and a number. It should return the number incremented by 1 if the boolean is true, and the original number otherwise."
    },
    {
        "instruction": "Assume you have a function `conditional_increment(use_increment, number)` that returns `number + 1` if `use_increment` is true, and `number` otherwise. Write the code to call this function with `use_increment` set to `True` and `number` set to `10`, storing the result."
    },
    {
        "instruction": "Develop a function `wrap_conditional` that takes one argument: a function `op` which itself accepts a boolean and a number. `wrap_conditional` should return a *new* function. This new function must accept a boolean `b` and a number `n`, then call the original `op(b, n)`, and return its result."
    },
    {
        "instruction": "Implement a function `apply_composed` that takes two single-argument numerical functions, `f` and `g`, and a numerical input `x`. It should compute `g(f(x))`. Assume both `f` and `g` increment their respective call counters (managed externally) upon execution. The function should return the final numerical result."
    },
    {
        "instruction": "Create a function `count_calls` that takes a function `func` and an argument `arg`. It should execute `func(arg)`, increment a counter stored outside the function scope each time `func` is called, and return the result of `func(arg)`. Assume `func` takes one numerical argument and returns one numerical value."
    },
    {
        "instruction": "Write a function `process_and_reverse` that takes a numerical function `func`, an initial value `val`, and a boolean `recompute`. It first calculates `result = func(val)`. If `recompute` is true, it calls `func(val)` *again* during a conceptual 'reverse' step. The function should use an external counter to track total calls to `func` and return the initial `result`."
    },
    {
        "instruction": "Design a function `execute_pipeline` that takes two numerical functions `step1` and `step2`, an input `value`, and two boolean flags `recompute1` and `recompute2`. It calculates `mid_result = step1(value)` and `final_result = step2(mid_result)`. Then, simulate a 'reverse' phase: if `recompute2` is true, call `step2(mid_result)` again; if `recompute1` is true, call `step1(value)` again. Track total calls to `step1` and `step2` separately using external counters. Return `final_result`."
    },
    {
        "instruction": "Implement a function to compute the product of a 1D numerical array (vector) `v` of size N and a 2D numerical array (matrix) `M` of size N x M. The function should treat `v` as a row vector and return a 1D array (vector) of size M."
    },
    {
        "instruction": "Develop a function that accepts a 1D numerical array `x` (size N) and a square 2D numerical array `W` (size N x N). The function should apply the following transformation three times in sequence: `x = sin(dot(x, W))`, where `dot` represents row-vector-matrix multiplication. Return the final 1D array."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array `x` (size N) and a 2D numerical array `W` (size N x M). It should first compute the product `y = dot(x, W)` (treating `x` as a row vector) and then compute the element-wise sine of `y`. Return the resulting 1D array (size M)."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new 1D array of the same size where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Create a function that takes a numerical input `x`, multiplies it by a small constant (e.g., 0.001), and returns the sine of the result."
    },
    {
        "instruction": "Write a function that takes a square numerical matrix (2D array) and returns the result of multiplying the matrix by itself. Ensure the computation is performed with high precision."
    },
    {
        "instruction": "Create a function that takes an initial numerical value (scalar or matrix) and an integer `N`. It should repeatedly apply a predefined transformation function (which involves steps like self-multiplication and element-wise sine) `N` times, using the output of one step as the input to the next. Return the final value after `N` applications."
    },
    {
        "instruction": "Implement a function that takes a square numerical matrix. It should perform the following sequence three times: multiply the matrix by itself (with high precision), scale the result by 0.001, and apply the element-wise sine function. Return the final matrix."
    },
    {
        "instruction": "Create a function `process_scalar(x)` that takes a scalar number `x`. Inside the function, compute `a = x * x`, then apply a predefined `simple_nonlinear_transform` (assume it exists and operates on scalars) to `a * 0.001`, let the result be `b`. Finally, compute `c = b * b` and return `c`."
    },
    {
        "instruction": "Implement a function `chain_rule_backward(input_x, func1, backward1, func2, backward2)` that simulates the chain rule for `z = func2(func1(input_x))`. `func1` and `func2` are the forward functions. `backward1` computes the gradient w.r.t. `func1`'s input given `func1`'s input value and the gradient w.r.t. `func1`'s output. `backward2` computes the gradient w.r.t. `func2`'s input given `func2`'s input value and the gradient w.r.t. `func2`'s output. Assume the initial gradient w.r.t. `z` is 1.0. The function should compute and return the gradient w.r.t. `input_x`. You'll need to execute `func1`, then `func2`, then `backward2`, then `backward1`."
    },
    {
        "instruction": "Write a function `apply_twice(initial_value, transform_func)` that takes a scalar `initial_value` and a function `transform_func`. It applies `transform_func` to the `initial_value` to get a new value, and then applies `transform_func` again to that new value. Return the final result after the two applications."
    },
    {
        "instruction": "Implement a function `high_precision_dot_product(vec1, vec2)` that takes two 1D numerical arrays of the same size. It should compute their dot product, performing intermediate calculations with increased precision where possible, and return the scalar result."
    },
    {
        "instruction": "Write a function that accepts a single numerical scalar input `x` and returns a tuple containing two identical elements, both equal to the input `x`."
    },
    {
        "instruction": "Write a function that takes a scalar numerical input and returns its value unchanged. Then, write a second function that takes a scalar input, calls the first function with it, and returns the result, demonstrating simple function composition."
    },
    {
        "instruction": "Implement a function that takes another function `f` (which accepts a scalar and returns a tuple of two scalars) and a scalar value `x`. Your function should compute the derivative of the *first* element returned by `f(x)` with respect to `x`, evaluated at the given `x`. Assume a hypothetical `compute_derivative(target_function, point)` tool exists."
    },
    {
        "instruction": "Design a function that takes another function `h` (which accepts a scalar and returns a scalar) and a scalar value `x`. Your function should compute the derivative of `h(x)` with respect to `x`, evaluated at the given `x`. Assume a hypothetical `compute_derivative(target_function, point)` tool exists."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array (matrix) and computes the sum of its elements along the first axis (column-wise sum). If the input shape is (M, N), the output should be a 1D array of shape (N,)."
    },
    {
        "instruction": "Implement a function `my_func` that performs a specific operation on a 1D numerical array (e.g., calculates its sum). Then, implement a second function `my_func_forward_derivative` that takes two 1D arrays of the same size, `primal_input` and `tangent_input`. This second function should return two values: the result of applying `my_func` to `primal_input`, and the result of applying the *linearized* version of `my_func` (its directional derivative) to `tangent_input` based on the `primal_input`. For summation, the directional derivative is also summation applied to the `tangent_input`."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array (shape K, N) and another function `row_processor` as input. It should apply `row_processor` independently to each row (of shape N) of the input array and return a new 2D array (shape K, N) containing the results."
    },
    {
        "instruction": "Implement a function that processes a 2D numerical array (shape K, N). First, it applies a given `transform_row` function (which takes a 1D array of shape N and returns a 1D array of shape N) to each row independently. Then, it computes the element-wise sum of all the transformed rows, resulting in a final 1D array of shape (N,). The function should take the 2D array and `transform_row` as input."
    },
    {
        "instruction": "Define two functions. `compute_value(x)` takes a 1D numerical array `x` and returns a new array `y` where `y[i] = x[i] * i`. `compute_sensitivity(x_sensitivity)` takes a 1D array `x_sensitivity` (representing the sensitivity of `x`) and returns the corresponding sensitivity of `y`, calculated as `y_sensitivity[i] = x_sensitivity[i] * i`."
    },
    {
        "instruction": "Implement a function `apply_iteratively(initial_state, num_steps, transform_func)`. It takes a 1D numerical array `initial_state`, an integer `num_steps`, and a function `transform_func`. It applies `transform_func` repeatedly, using the output of one step as the input for the next, for `num_steps` iterations. Return the final state array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `x` and returns a new array where the element at index `i` is the product of `x[i]` and `i`."
    },
    {
        "instruction": "Consider a process: take a 1D numerical array `x`, transform it by multiplying each element `x[i]` by its index `i` to get `y`, and then compute the sum of `y`. Write a function that calculates the derivative (rate of change) of the final sum with respect to the entire input array `x`. You can assume the derivative rule for the transformation step: the sensitivity of `y[i]` with respect to `x[j]` is `i` if `i=j` and 0 otherwise."
    },
    {
        "instruction": "Develop a function that takes an initial 1D numerical array (vector X) and a 2D numerical array (matrix W). Inside the function, repeatedly update the vector X exactly three times using the rule: `X_new = sin(dot(X_old, W))`, where `dot` represents matrix-vector multiplication and `sin` is applied element-wise. Assume dimensions are compatible. Return the final vector after the three updates."
    },
    {
        "instruction": "Write a function that simulates applying a transformation iteratively. The function accepts an initial 1D numerical array `x`, a 2D numerical array `W`, and a positive integer `n_steps`. It should iteratively apply a transformation `T(v) = sin(dot(v, W))` for `n_steps`, where `dot` is matrix-vector multiplication and `sin` is element-wise. Return the final array after `n_steps` iterations."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array (vector V) and a 2D numerical array (matrix W). It first computes the matrix-vector product of W and V, and then applies the element-wise sine function to the resulting vector. Return the final vector."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and applies the mathematical sine function to each element, returning a new array of the same shape."
    },
    {
        "instruction": "Write a function that accepts a numerical scalar `x` and a positive integer `n`. The function should apply the mathematical sine operation to the input `x` repeatedly, `n` times in total (i.e., `sin(sin(...sin(x)...))`). Return the final numerical scalar result."
    },
    {
        "instruction": "Create a function that simulates applying another function `f` exactly once using a structure designed for iteration. It takes the function `f` (which accepts and returns a numerical scalar) and an initial numerical scalar value `x`. Inside, it should use a loop construct that runs only one iteration, applying `f` to `x` within that iteration. Return the result of `f(x)`."
    },
    {
        "instruction": "Write a function that analyzes a string representing a sequence of computational steps separated by ' -> '. The function takes the string (e.g., \"start -> op_A -> op_B -> op_A -> end\") and a target operation name (e.g., \"op_A\"). Return the total number of times the exact target operation name appears as a step in the sequence."
    },
    {
        "instruction": "Implement a function that takes a numerical scalar input `x`. It should compute and return *both* the sine of `x` and the cosine of `x`. The function should return these two numerical scalar values."
    },
    {
        "instruction": "Write a function `count_operation_calls(function_list, initial_value)` where `function_list` is a list of callable functions. The function should apply each function in the list sequentially, passing the output of one as the input to the next, starting with `initial_value`. Return a dictionary where keys are unique function identifiers (e.g., function names or objects) and values are the counts of how many times each function was called."
    },
    {
        "instruction": "Design a higher-order function `execute_with_policy(func, policy, arg)`. `func` is a function that internally calls specific named sub-operations (e.g., 'op1', 'op2'). `policy` is a function that takes an operation name (string) and returns `True` if its result should be conceptually 'saved', `False` otherwise. `execute_with_policy` should execute `func(arg)` and return a list of the names of sub-operations whose results were *not* saved according to the `policy`. (Assume `func` can report which sub-operations it calls)."
    },
    {
        "instruction": "Write a function that takes another function `f` and a scalar numerical value `x`. It should apply `f` to `x` exactly once and return the result."
    },
    {
        "instruction": "Create a function `apply_and_report(operation, derivative_op, value)` that accepts two functions, `operation` and `derivative_op`, and a scalar `value`. It should compute `y = operation(value)` and `d = derivative_op(value)`. Return a tuple `(y, d)`."
    },
    {
        "instruction": "Write a higher-order function named `apply_conditionally`. It should accept a boolean condition, two functions (`func_if_true`, `func_if_false`), and an input value `x`. If the condition is true, the function should call `func_if_true(x)` and return its result. Otherwise, it should call `func_if_false(x)` and return its result."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array `x`. It should first compute a temporary array where each element `x[i]` is multiplied by its index `i`. Then, it should return the sum of all elements in this temporary array. Input: 1D array. Output: Scalar number."
    },
    {
        "instruction": "Define two related functions. The first function, `transform_data`, takes a 1D numerical array `data` and returns a new array where `output[i] = data[i] * i`. The second function, `transform_variation`, takes a 1D numerical array `variation_in` (same size as `data`) and returns a new array where `variation_out[i] = variation_in[i] * i`. Both functions perform index-based element-wise multiplication. Input/Output for both: 1D numerical arrays of the same size."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `x` and returns a new array where each element `x[i]` is multiplied by its index `i`. Input: 1D array. Output: 1D array of the same size."
    },
    {
        "instruction": "Design a function that takes a single numerical input `x` and an optional boolean flag `strict_mode`, defaulting to `False`. If `strict_mode` is `True`, the function should immediately raise a `ValueError` indicating that value-based checks are forbidden. If `strict_mode` is `False`, it should perform a check: return `x` if `x` is positive, otherwise return `0`."
    },
    {
        "instruction": "Implement a function that takes one argument. If the argument is a positive number, return the string \"Positive Number\". If it's a non-positive number, return the number itself. If it's not a number, return the string \"Not a number\"."
    },
    {
        "instruction": "Write a function that takes a single number as input. If the number is positive, return the number itself. Otherwise, return zero."
    },
    {
        "instruction": "Create a function `run_conditionally` that accepts another function `target_func` and an input `value`. Inside `run_conditionally`, first check if the `value` is an instance of a specific custom class named `SymbolicPlaceholder`. If it is, raise a `TypeError` stating \"Cannot execute with symbolic value\". Otherwise, call `target_func` with `value` and return the result. You will also need to define the empty `SymbolicPlaceholder` class."
    },
    {
        "instruction": "Write a higher-order function called `create_processor`. This function accepts a boolean configuration parameter `use_identity`. It returns a *new* function that takes one numerical argument `val`. If `use_identity` was True when `create_processor` was called, the returned function should simply return `val`. If `use_identity` was False, the returned function should compute and return the sine of `val`."
    },
    {
        "instruction": "Develop a function that accepts two arguments: a numerical value `data` and a boolean flag `is_simple`. If `is_simple` is True, the function returns `data` directly. If `is_simple` is False, the function returns the sine of `data`."
    },
    {
        "instruction": "Write a function that takes a single number `x`. If `x` is strictly positive, return `x`. Otherwise (if `x` is zero or negative), return 0."
    },
    {
        "instruction": "Create a function that accepts a single numerical input representing an angle in radians and returns its sine."
    },
    {
        "instruction": "Implement a function that takes a scalar number, a shape tuple, and a target data type string. It should first create an array by broadcasting the scalar to the given shape, and then convert the elements of this new array to the specified target data type. Return the final array."
    },
    {
        "instruction": "Write a function that receives a numerical array and a desired data type string. Check if the array's current data type matches the desired type string. If they match, return the original array. If they don't match, return a *new* array containing the original values converted to the desired data type."
    },
    {
        "instruction": "Write a function that takes a single numerical value and a tuple representing a shape. Return a new array of that shape where every element is the input value."
    },
    {
        "instruction": "Develop a function that takes an input numerical array and a target shape tuple. If the input array's dimensions are compatible for broadcasting to the target shape, return a new array representing the input broadcasted to the target shape. Handle incompatible shapes appropriately (e.g., return an error indicator or raise an exception)."
    },
    {
        "instruction": "Implement two related functions. The first, `compute_value`, takes a 1D numerical array `x` and returns `x` multiplied element-wise by a predefined constant 1D array `C` (e.g., `[0.0, 1.0, 2.0]`). The second, `compute_derivative_effect`, takes a 1D array `x_dot` (same size as `x`) and returns `x_dot` multiplied element-wise by the same constant array `C`."
    },
    {
        "instruction": "Design a function that simulates applying a transformation iteratively while tracking sensitivity. It takes an initial 1D array `x0`, an initial sensitivity array `x0_dot` (same size), a function `step_func` (that takes and returns a 1D array), its sensitivity propagation function `step_func_dot` (takes sensitivity array, returns propagated sensitivity array), and an integer `N`. Apply `step_func` iteratively `N` times starting with `x0`. Concurrently, calculate the propagated sensitivity using `step_func_dot` at each step, starting with `x0_dot`. Return the final array after `N` steps and the final sensitivity array."
    },
    {
        "instruction": "Develop a function that generates a 1D numerical array of length `N` where the element at index `i` is equal to `float(i)`."
    },
    {
        "instruction": "Create a function that accepts an initial 1D numerical array `carry` and another function `step_func`. It should apply `step_func` once to `carry` and return the result. The `step_func` itself takes one 1D array and returns one 1D array of the same size."
    },
    {
        "instruction": "Create a function that accepts two scalar floating-point numbers, `x` (an input value) and `g` (a direction/scaling factor). It should return a pair (tuple) containing two values: the sine of `x`, and the result of `2 * cos(x) * g`."
    },
    {
        "instruction": "Implement a function that takes a scalar floating-point number `x` and returns the value `2 * cos(x)`. This represents a specific calculation related to the input."
    },
    {
        "instruction": "Write a function that calculates the standard mathematical derivative of the sine function (i.e., cosine) for a given scalar floating-point input number."
    },
    {
        "instruction": "Implement a function that takes a scalar floating-point number `x` and returns the result of applying a specific rule: `2 * cos(x)`. This function simulates calculating a gradient value based on a predefined, non-standard rule."
    },
    {
        "instruction": "Implement a function `wrapper_func` that takes a scalar floating-point number `x`. Inside `wrapper_func`, call another function `inner_func(x)` (assume `inner_func` is defined elsewhere and takes a scalar returning a scalar) and return the result obtained from `inner_func`."
    },
    {
        "instruction": "Design a function `compute_value_and_transformed_direction` that takes three arguments: a base function `func` (which accepts a scalar and returns a scalar), an input value `x` (scalar), and a direction `d` (scalar). This function should return a pair: the result of `func(x)`, and the result of applying a predefined 'transformation rule' function `transform(x, d)` (assume `transform` is provided, taking `x` and `d` and returning a scalar representing the transformed direction)."
    },
    {
        "instruction": "Create a function that accepts two scalar floating-point inputs: a value `x` and a 'direction' `d`. It should return a pair of values: the result of `cos(2 * x) / 2.0`, and the result of `3 * d`."
    },
    {
        "instruction": "Implement a function `nested_computation` that takes a scalar input `x` and a scalar direction `d`. This function should first internally compute `(y1, t1)` by applying a primary function `f(x)` and a primary transformation rule `rule1(x, d)`. Then, it should use `y1` and `t1` as inputs to a secondary function `g(y1)` and a secondary transformation rule `rule2(y1, t1)` to compute and return the final pair `(y2, t2)`. Assume `f`, `rule1`, `g`, and `rule2` are given functions."
    },
    {
        "instruction": "Write a function `conditional_math` that accepts a single floating-point number `x`. If `x` is greater than zero, return the sine of `x`. Otherwise (if `x` is zero or negative), return the cosine of `x`."
    },
    {
        "instruction": "Create a function `piecewise_constant` that takes a single number `x`. Return the floating-point value `2.0` if `x` is positive, and `3.0` otherwise."
    },
    {
        "instruction": "Define a function `process_sequence_conditionally`. It takes a list of floating-point numbers. For each number `x` in the list, if `x > 0`, calculate `sin(x)` and associate it with a 'rate' of `2.0`. If `x <= 0`, calculate `cos(x)` and associate it with a 'rate' of `3.0`. The function should return two lists of the same length as the input: one containing all the calculated `sin/cos` values in order, and another containing the corresponding 'rates' (`2.0` or `3.0`)."
    },
    {
        "instruction": "Write a function `calculate_value_and_rate` that accepts a single floating-point number `x`. It should return a pair (e.g., a tuple or list) of two numbers: the first element is `sin(x)` if `x > 0` else `cos(x)`, and the second element is `2.0` if `x > 0` else `3.0`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and applies a given scalar mathematical function (e.g., sine) to each element individually. It should return a new 1D array of the same size containing the results."
    },
    {
        "instruction": "Implement a function that computes both the value and the directional derivative of a scalar function element-wise across a 1D numerical array. It should accept the 1D input array `X`, a corresponding 1D array `G` representing directions, and use a pre-defined scalar function `f` with its associated custom directional derivative rule `f_deriv(x, g)`. For each index `i`, it calculates `f(X[i])` and `f_deriv(X[i], G[i])`. Return two 1D arrays: one for the function values and one for the derivative values."
    },
    {
        "instruction": "Extend the previous task (Task 4) to operate on 2D numerical arrays. The function should accept 2D input array `X`, a corresponding 2D array `G` (directions), and use the pre-defined scalar function `f` with its custom derivative rule `f_deriv(x, g)`. Apply `f` and `f_deriv` element-wise using corresponding elements from `X` and `G`. Return two 2D arrays of the same shape: one containing the function results and one containing the derivative results."
    },
    {
        "instruction": "Design a way to represent a scalar function (e.g., f(x) = sin(x)) along with a specific, potentially non-standard, rule for computing its directional derivative (e.g., derivative_value = 2 * cos(x) * direction). Ensure both the function and its derivative rule strictly operate on scalar inputs."
    },
    {
        "instruction": "Create a function that accepts two floating-point numbers, `value` and `direction`, and returns the result of `2 * cos(value) * direction`."
    },
    {
        "instruction": "Write a function that takes a single floating-point number as input and returns its sine."
    },
    {
        "instruction": "Write a function that takes a single floating-point number as input and returns its cosine."
    },
    {
        "instruction": "Design a structure or function that associates a primary calculation function (e.g., `sin(x)`) with a secondary, custom 'sensitivity' function (e.g., one that calculates `2 * cos(x) * g` given `x` and `g`). Provide a method to execute both, returning the result of the primary function and the result of the sensitivity function as a pair, given an input value `x` and a direction `g`."
    },
    {
        "instruction": "Write a function that takes two dictionaries, `dict1` and `dict2`, both expected to have a key 'a' with a numerical value. Calculate two results: `result1 = sine(dict1['a'])` and `result2 = 2 * cosine(dict1['a']) * dict2['a']`. Return these two numerical results, for example, as a tuple `(result1, result2)`."
    },
    {
        "instruction": "Implement a function that simulates a specific directional derivative calculation. It takes two dictionaries as input: `primal_input` (e.g., `{'a': value}`) and `tangent_input` (e.g., `{'a': tangent}`). It should return a dictionary `tangent_output` (e.g., `{'b': result}`) where the result is calculated as `2 * cosine(primal_input['a']) * tangent_input['a']`."
    },
    {
        "instruction": "Create a function that takes a dictionary and a key name (string) as input. If the key exists in the dictionary and its corresponding value is a number, return the cosine of that number. Handle cases where the key doesn't exist or the value is not a number (e.g., return a default value or signal an error)."
    },
    {
        "instruction": "Design a pair of functions operating on dictionaries. The first function, `compute_value`, takes `x = {'a': val}` and returns `{'b': sine(val)}`. The second function, `compute_derivative_effect`, takes two dictionaries, `x = {'a': val}` and `d = {'a': d_val}`, and returns a dictionary `{'b': 2 * cosine(val) * d_val}`, representing how a small change `d` in the input affects the output of `compute_value` according to a specific rule."
    },
    {
        "instruction": "Define a function `calculate(val1, val2, param=1.0)` that returns `param * (val1 + val2)`. Then, define a second function `calculate_derivative_wrt_param(primals, tangents)` which takes original inputs (`val1`, `val2`, `param`) as `primals` and their corresponding directional derivatives (`t_val1`, `t_val2`, `t_param`) as `tangents`. This second function should return a tuple containing the original result `calculate(val1, val2, param)` and *only* the tangent `t_param`, effectively ignoring the influence of `val1` and `val2` on the derivative calculation."
    },
    {
        "instruction": "Write a function `outer_func(p1, p2)` that internally calls `inner_func(p1, p2, config=2.0)`. Assume `inner_func` has a predefined custom directional derivative rule that ignores derivatives with respect to its first two arguments (`p1`, `p2`) and only considers the derivative w.r.t `config`. `outer_func` then squares the result of `inner_func`. Implement a method to compute the overall directional derivative of `outer_func` with respect to `p1` and `p2`, ensuring the custom rule of `inner_func` is correctly applied during the calculation."
    },
    {
        "instruction": "Create a function that accepts two numerical scalar inputs. Inside this function, call a separate helper function `process(a, b, factor=2.0)` (which computes `factor * (a + b)`). Square the result returned by the helper function. Return this final squared value."
    },
    {
        "instruction": "Implement a system where a primary function `compute(arg1, arg2, option=1.0)` can be associated with a custom directional derivative rule. The primary function calculates `option * (arg1 + arg2)`. The custom rule must specify that the directional derivative output depends *only* on the directional derivative corresponding to the `option` input, ignoring contributions from `arg1` and `arg2`. Ensure the system correctly handles the keyword argument `option` during this association."
    },
    {
        "instruction": "Write a function that accepts a single numerical input `x` and returns the value `3 * x`."
    },
    {
        "instruction": "Calculate the rate of change of the *rate of change* (second derivative) for the composite function `h(x)` described in Task 4, again using the custom rule for the inner transformation `f`. Evaluate this second derivative at `x=3.0`."
    },
    {
        "instruction": "Implement a mechanism to associate a primary function (e.g., `y = f(x)`) with a secondary function that describes how the output `y` changes when the input `x` changes by a small amount `dx`. For a primary function `f(x) = 3*x`, the secondary function should specify that the change in output is `2 * dx`. The mechanism should return both the primary function's output and the calculated change."
    },
    {
        "instruction": "Given a composite function `h(x)` formed by applying a transformation `f(c)` (where `f` has a custom rule for its rate of change, as described in Task 2) once to an initial value `x`, calculate the overall rate of change of `h(x)` with respect to `x`. Use the custom rule for `f` in the calculation. For `f(x)=3*x` with the custom change rule `2*dx`, find the rate of change of `h(x)` at `x=3.0`."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array as input. It should process this array element-wise based on a predefined rule that mimics a specific derivative calculation: for each input element, the corresponding output element is 2 times that input element. Return the resulting 1D array."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array. It should first apply a specific transformation (multiply by 3) to each element, and then return the sum of all elements in the transformed array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and applies a given scalar function (which takes one number and returns one number) to each element, returning a new 1D array of the results."
    },
    {
        "instruction": "Write a function that simulates a custom calculation rule. It accepts two numerical scalars: a 'value' and a 'rate'. It should return a pair: the first element being 3 times the 'value', and the second element being 2 times the 'rate'."
    },
    {
        "instruction": "Design a function that accepts a function `f` (unary operation on numbers), a primary numerical input `x`, and a secondary numerical input `t`. The function should return a pair: the first element being the result of `f(x)` and the second element being the value `3 * t`."
    },
    {
        "instruction": "Create a function that takes a single numerical input `t` and returns the value `3 * t`."
    },
    {
        "instruction": "Implement a function that takes two arguments: a function `func` (taking one numerical input) and a numerical value `x`. Return the result of applying `func` to `x`."
    },
    {
        "instruction": "Create a function `apply_with_custom_sensitivity` that takes a function `operation` (mapping number to number), a numerical value `input_val`, and a numerical `sensitivity_in`. It should return two values: the primary result `operation(input_val)` and a secondary result `sensitivity_out` calculated as `3 * sensitivity_in`. Ensure the calculation of `sensitivity_out` *only* uses `sensitivity_in` and fixed constants, independent of the `operation` function itself."
    },
    {
        "instruction": "Implement a function `calculate_value_and_scaled_input` that takes two numerical scalar inputs, `base_value` and `scale_factor_input`. It should return a pair: the first element is `base_value`, and the second element is `scale_factor_input` multiplied by a fixed constant (e.g., 5.0)."
    },
    {
        "instruction": "Write a function `evaluate_with_fixed_param` that accepts a numerical scalar `y`. Inside the function, multiply a predefined constant (e.g., 2.0) by `y` and return the result."
    },
    {
        "instruction": "Write a function that accepts two numerical scalar inputs and returns their product."
    },
    {
        "instruction": "Create a function that takes one numerical scalar input `t` and returns the result of multiplying it by a fixed constant (e.g., 5.0)."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays, `primal_input` and `tangent_input`, assumed to have the same length. The function should return a tuple containing two 1D arrays: the first is the `primal_input` unchanged, and the second is a new array where each element is 5 times the corresponding element in `tangent_input`."
    },
    {
        "instruction": "Write a function that simulates applying a calculation with a custom transformation rule. It takes a 'fixed' scalar value `x`, a 'varying' 1D numerical array `y`, and a 'tangent' 1D numerical array `t_y` (same shape as `y`). It should return a tuple of two 1D arrays: (1) an array resulting from element-wise multiplication of `x` with `y`, and (2) an array resulting from element-wise multiplication of `5` with `t_y`."
    },
    {
        "instruction": "Write a function that takes a single scalar numerical value `x` and a 1D numerical array `y`. Return a new 1D array where each element is the product of `x` and the corresponding element in `y`."
    },
    {
        "instruction": "Develop a function `apply_vectorized` that accepts another function `element_func` (which takes two scalar arguments), a single scalar value `scalar_arg`, and a 1D numerical array `vector_arg`. The `apply_vectorized` function should return a new 1D array where the i-th element is the result of calling `element_func(scalar_arg, vector_arg[i])`."
    },
    {
        "instruction": "Design a function decorator `@enforce_structure_consistency`. When this decorator is applied to a function `my_rule_func(*args)`, it should ensure that `my_rule_func` returns exactly two outputs, say `out1` and `out2`. The decorator must check if `out1` and `out2` have identical data structures (nesting and container types like list/tuple). If they do, the decorated function should return `(out1, out2)`. If the structures differ, it must raise a `TypeError` clearly stating that the structures of the two outputs are inconsistent."
    },
    {
        "instruction": "Write a function `compare_structure(data1, data2)` that takes two arbitrary nested data structures (composed of lists and tuples containing basic types like numbers or strings) and returns `True` if they have the same nesting pattern and container types (list vs. tuple) at each level, and `False` otherwise. Ignore the actual values. For example, `compare_structure((1, [2, 3]), ('a', ['b', 'c']))` should return `True`, but `compare_structure((1, [2, 3]), [4, (5, 6)])` should return `False`."
    },
    {
        "instruction": "Implement a function `package_value(value)` that takes a single numerical value. The function must return a tuple containing exactly one element: the input value itself. For example, `package_value(5.0)` should return `(5.0,)`."
    },
    {
        "instruction": "Write a function `transform_data(input_value)` that takes a single numerical input. Inside the function, compute two results: `output1` should be a tuple containing the square of the input (`(input_value**2,)`). `output2` should be a list containing twice the input and the input itself (`[2 * input_value, input_value]`). The function should return both `output1` and `output2`."
    },
    {
        "instruction": "Write a function `check_structure_match` that takes two arguments, `primary_output` and `secondary_output`. It must verify that the `secondary_output` has a structure (shape and element type) that strictly corresponds to the `primary_output` (e.g., if `primary_output` is a float scalar, `secondary_output` must also be a float scalar; if `primary_output` is a float array of shape [N, M], `secondary_output` must also be a float array of shape [N, M]). If the structures do not match, raise a type error detailing the expected and received structures. If they match, the function should do nothing."
    },
    {
        "instruction": "Write a function that accepts a single numerical scalar input and returns its square."
    },
    {
        "instruction": "Create a function that takes a single numerical scalar value and returns a new 1-element numerical array containing that value."
    },
    {
        "instruction": "Implement a function that receives two numerical inputs, `val1` and `val2`. It should return `True` if both inputs are scalars of the same type OR if both are numerical arrays with the exact same shape and element type. Otherwise, it should return `False`."
    },
    {
        "instruction": "Write a function that accepts a single numerical input and returns its square."
    },
    {
        "instruction": "Create a function that checks if a given input variable is specifically a list or a tuple containing exactly two elements. Return `True` if it matches, `False` otherwise."
    },
    {
        "instruction": "Design a function `validate_computation_output` that accepts another function `compute_rule`, example primary inputs `primals` (a tuple), and example rate-of-change inputs `tangents` (a tuple). It should call `compute_rule(primals, tangents)`. Verify that the returned value is a list or tuple of exactly length 2. If yes, return the result. If no, raise a `TypeError` including the name of the `compute_rule` function (hint: use `compute_rule.__name__`) and a description of the failure (e.g., \"Rule '[rule_name]' must return a pair, but returned [actual_result]\")."
    },
    {
        "instruction": "Write a function `compute_value_and_derivative` that takes a primary numerical input `p` and a rate-of-change input `t`. Inside the function, calculate a primary output `y = p * p` and a corresponding rate-of-change output `dt = 2 * p * t`. Return these two values as a tuple `(y, dt)`."
    },
    {
        "instruction": "Develop a function `validate_structure` that takes two arguments, `output1` and `output2`, which can be nested structures of lists and tuples containing basic data types. It must return `True` if both arguments have the exact same nesting structure (e.g., `([1], (2, 3))` matches `(['a'], ('b', 'c'))` but not `[1, 2, 3]` or `([1, 2], (3,))`). Otherwise, it should raise a `TypeError` indicating a structure mismatch."
    },
    {
        "instruction": "Write a higher-order function `check_rule_output` that takes an `original_func`, a `rule_func`, and an `input_val`. It calls `original_result = original_func(input_val)` and `rule_output = rule_func(input_val)`. It must verify two conditions: (1) `rule_output` must be a tuple or list of length exactly 2. (2) The first element of `rule_output` must have the *exact same data type and value* as `original_result`. If either condition fails, raise a `TypeError` with a specific message about the failure. If both pass, return the `rule_output`."
    },
    {
        "instruction": "Implement a function `apply_n_times` that takes a function `func`, an initial value `value`, and an integer `n`. It should call `func` on the `value`, then call `func` on the result, repeating this process `n` times. Return the final result."
    },
    {
        "instruction": "Create a function that accepts two arguments, `arg1` and `arg2`. It should raise a `TypeError` with a descriptive message if the basic data type (e.g., integer, float, list, tuple) of `arg1` is different from the basic data type of `arg2`. If the types match, it should return `True`."
    },
    {
        "instruction": "Develop a function that computes the gradient of a specific composite operation. The operation involves: a) applying an element-wise transformation to a 1D numerical input array (where the transformation always yields zero), and b) summing the elements of the resulting array. Your function should return the gradient of this sum with respect to the original input array (which should be an array of zeros of the same size as the input)."
    },
    {
        "instruction": "Write a function that performs an element-wise operation on a 1D numerical array and simultaneously calculates its directional derivative. It accepts two 1D numerical arrays of the same size: `primal_input` and `tangent_input`. It should return two 1D arrays: `primal_output` (where each element is zero, based on `primal_input`) and `tangent_output` (which is identical to the `tangent_input` array)."
    },
    {
        "instruction": "Implement a function that takes two arguments: a 1D numerical array representing primal inputs and another 1D numerical array of the same size representing tangent inputs. The function should return a pair of 1D arrays: the first being an array of zeros (like Task 1, based on the primal input size), and the second being the *identical* tangent input array."
    },
    {
        "instruction": "Create a function that simulates element-wise application of a simple transformation. It takes a 1D numerical array as input. For each element in the input array, it applies a predefined operation (which, for this task, should always result in the value 1). It returns a new 1D array of the same size containing the results (all ones)."
    },
    {
        "instruction": "Write a function that performs matrix-vector multiplication. Input: a 2D numerical array (M x N) and a 1D numerical array (N,). Output: a 1D numerical array (M,)."
    },
    {
        "instruction": "Develop a function that takes a scalar numerical input `theta`. Inside the function, create a 3x3 identity matrix `A` and a 1D array `b` of length 3 containing the value `theta` in all positions. Compute the matrix-vector product `z = A @ b` and return the first element (index 0) of the resulting 1D array `z`."
    },
    {
        "instruction": "Implement a function that simulates an iterative accumulation process. It takes an initial scalar value `q_init` and a fixed number of iterations `k`. In each iteration, it calls a predefined `compute_value()` function (assume this function exists and returns a 1D numerical array), takes the first element of the returned array, and adds it to the current scalar value. The function should return the final accumulated scalar value after `k` iterations."
    },
    {
        "instruction": "Create a function that takes an integer `n` and returns two items: a 2D numerical array representing an `n x n` identity matrix, and a 1D numerical array of length `n` where all elements are 1.0."
    },
    {
        "instruction": "Develop a function that simulates applying a transformation exactly one time. It accepts an initial numerical `state` and a transformation function `op`. It should return the result of applying `op` to `state` once."
    },
    {
        "instruction": "Write a function that calculates both the output and the derivative of a simple process. The process is defined as applying the negation function `f(x) = -x` to an input `x`. The function should take `x` and return a pair: the result (`-x`) and the derivative (`-1`)."
    },
    {
        "instruction": "Write a function that takes a single numerical input and returns its negation."
    },
    {
        "instruction": "Implement a function that takes an initial numerical value and a single-argument function `op`. The function should return the result of applying `op` to the initial value exactly once."
    },
    {
        "instruction": "Create a function `process_nested` accepting a number `x`. Inside it, define `level1` accepting `y`. Inside `level1`, define `level2` accepting `w`. `level2` should perform the calculation: `result = y + (w + y) + (x * y)`. `level1` should call `level2` with `w=x`. `process_nested` should call `level1` with `y=x`. Return the final `result`."
    },
    {
        "instruction": "Implement a higher-order function `execute_and_return` that takes two arguments: a function `func` and a value `val`. This function should call `func` with `val` as its argument and return the result produced by `func`. Demonstrate its use by wrapping a function that squares its input."
    },
    {
        "instruction": "Create a function `outer_func` that accepts a number `x`. Inside `outer_func`, define a function `inner_func` that accepts a number `y`. `inner_func` should return the sum `x + y`. `outer_func` should call `inner_func` with `x` as the argument and return the result."
    },
    {
        "instruction": "Write a function that accepts two numerical inputs, `a` and `b`, and returns the result of `sin(a) * b`."
    },
    {
        "instruction": "Write a higher-order function `map_function` that takes two arguments: a function `fn` (which accepts a single argument) and a list of inputs `inputs`. `map_function` should apply `fn` to each element in the `inputs` list and return a new list containing the results."
    },
    {
        "instruction": "Develop a function `generate_seeds` that takes a master numerical seed (e.g., an integer) and a count `n`. It should return a list of `n` distinct numerical seeds derived from the master seed using a deterministic process (e.g., simple arithmetic transformations)."
    },
    {
        "instruction": "Write a function that accepts a numerical seed and a positive scalar parameter `alpha`. It should return a single positive scalar value drawn from a probability distribution parameterized by `alpha`. Ensure different seeds produce different results."
    },
    {
        "instruction": "Implement two functions. The first function, `my_func(param)`, takes a scalar parameter and returns a computed scalar value based on some non-linear transformation (e.g., `param / (1 + param)`). The second function, `my_func_jvp(param, d_param)`, takes the parameter and a tangent `d_param`. It must first call `my_func(param)` to get the result, then calculate the analytical derivative of `my_func` with respect to `param`, multiply it by `d_param`, and finally return the result from `my_func` and the calculated derivative component as a pair."
    },
    {
        "instruction": "Write a function `handle_zero_input(input_val, zero_marker)` that takes a numerical value `input_val` and a special `zero_marker` object. If `input_val` is identical to `zero_marker`, return `zero_marker`. Otherwise, return a default numerical value (e.g., 0.0)."
    },
    {
        "instruction": "Define a function `identity_pair(a, b)` that takes two scalar inputs and returns them as a tuple `(a, b)`. Also, define a corresponding 'sensitivity propagation' rule function `identity_pair_propagate(primals, sensitivities)` where `primals=(a, b)` and `sensitivities=(sa, sb)`. This rule should return an output sensitivity tuple `(2.0 * sa, zero_like(b))`, where `zero_like(b)` creates a zero value with the same type/structure as `b`."
    },
    {
        "instruction": "Create a function `apply_iterative_step(step_func, initial_state, num_iterations)` that repeatedly applies `step_func` to a state for `num_iterations`. `step_func` takes the current state (potentially a tuple) and returns the next state. If `step_func` has an associated sensitivity propagation rule, your function must correctly compute the sensitivity of the final state with respect to the sensitivity of the `initial_state`."
    },
    {
        "instruction": "Implement a function `apply_custom_rule(rule_func, inputs, sensitivities)` that executes a given sensitivity propagation rule. `rule_func` takes `inputs` (a tuple) and `sensitivities` (a tuple) and returns the calculated output sensitivities. Your function should handle cases where elements in the `sensitivities` tuple might represent structured zeros."
    },
    {
        "instruction": "Implement a function `custom_rule` that takes two numerical inputs, `x` and `g`. It should compute and return the value `2 * cos(x) * g`."
    },
    {
        "instruction": "Write a function that accepts a single numerical input `x` and returns the sine of `x`."
    },
    {
        "instruction": "Write a function that takes a numerical input `x`. Calculate and return both the value of `sin(sin(x))` and the value of its standard mathematical derivative, `cos(sin(x)) * cos(x)`, at that point `x`."
    },
    {
        "instruction": "Implement a function `derivative_of_composition`. Assume an inner function `f(x) = sin(x)` has a specific derivative rule given by `f_deriv(x, g) = 2 * cos(x) * g`. Your function should take a numerical input `x` and compute the derivative of the composed function `h(x) = f(f(x))` at `x`, using the chain rule and the provided `f_deriv` rule for both applications of `f`."
    },
    {
        "instruction": "Write a function `apply_twice` that takes a single-argument function `f` and a scalar value `x`. It should return the result of applying the function twice, i.e., `f(f(x))`."
    },
    {
        "instruction": "Implement a function `compute_f` that calculates `sin(x)` for a scalar input `x`. Additionally, create a function `compute_f_derivative` that calculates `2 * cos(x)` for a scalar input `x`. Both functions should handle floating-point numbers."
    },
    {
        "instruction": "Write a function `evaluate_composition` that takes two single-argument functions, `func1` and `func2`, and a numerical value `val`. It should return the result of `func1(func2(val))`."
    },
    {
        "instruction": "Extend the previous task. Write a function `apply_second_order_chain_rule` that accepts six functions: `f`, `g`, `f_prime`, `g_prime`, `f_prime_prime` (second derivative of `f`), and `g_prime_prime` (second derivative of `g`). All functions operate on scalar floats. The function should also take a scalar float `x` and return the second derivative of `h(x) = f(g(x))` evaluated at `x`, using the appropriate rule: `f_prime_prime(g(x)) * (g_prime(x))**2 + f_prime(g(x)) * g_prime_prime(x)`."
    },
    {
        "instruction": "Create a function that accepts a single scalar number `x`. Assume a fixed 1D numerical array `Y` (e.g., containing [1.0, 2.0, 3.0]) is accessible. The function should return the scalar result of `3 * x * sum(Y)`."
    },
    {
        "instruction": "Write a function that computes and returns the sum of all elements in a given 1D numerical array."
    },
    {
        "instruction": "Implement a function `apply_func_once` that takes an initial scalar value `c` and a function `f` (which accepts a scalar and returns a scalar). The `apply_func_once` function should call `f(c)` exactly one time and return the scalar result."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array `V` and a scalar function `f` (accepts scalar, returns scalar). It should return a new 1D numerical array of the same size as `V`, where each element is the result of applying `f` to the corresponding element of `V`."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and returns a 1D array (column vector) where each element is `1 / num_cols`, with `num_cols` being the number of columns in the input matrix. The output should have the same number of rows as the input."
    },
    {
        "instruction": "Develop a function `process(matrix_A, matrix_B, matrix_C, scalar_val)` where `matrix_A` is (R, R), `matrix_B` is (R, N), `matrix_C` is (N, 1), and `scalar_val` is a number. It should compute `matrix_A @ ( (matrix_B @ matrix_C / scalar_val**0) + (matrix_B @ matrix_C / scalar_val**1) )`. Return the resulting (R, 1) array."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) of shape (M, N). Return a 3D array of shape (M * N, M, N) constructed by tiling the input matrix M*N times and stacking these tiles along a new leading dimension."
    },
    {
        "instruction": "Implement a function that computes the sum of elements along a specified axis of a 2D numerical array (0 for columns, 1 for rows). The function must ensure the output array retains the summed dimension (e.g., summing rows of an M x N array results in shape M x 1)."
    },
    {
        "instruction": "Develop a function that takes a scalar numerical input `x`. Inside the function, use a predefined 1D numerical array `C`. First, compute the element-wise product of `C` and `x` (broadcasting `x`). Then, return the sum of the elements in the resulting array as a scalar."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `v` and a scalar `s`. It should return a new 1D array where each element of `v` is multiplied by `s`. The output array must have the same shape as `v`."
    },
    {
        "instruction": "Implement a function `apply_scaling(data_input)`. Assume a predefined 1D numerical array `SCALE_FACTORS` exists globally. The function should multiply `SCALE_FACTORS` element-wise by `data_input`. Handle the case where `data_input` is a scalar, applying broadcasting rules so the output matches the shape of `SCALE_FACTORS`."
    },
    {
        "instruction": "Design a function `compute_and_differentiate(scalar_val, scalar_dir)`. This function uses a predefined 1D numerical array `A`. It must compute and return two 1D arrays: (1) `result = A * scalar_val` (element-wise, broadcasting `scalar_val`), and (2) `derivative_result = A * scalar_dir` (element-wise, broadcasting `scalar_dir`). Both output arrays should have the same shape as `A`."
    },
    {
        "instruction": "Write a function that defines and returns a *new* function (a closure). This inner function, when called, should access a variable defined in the outer function scope but always return the integer `0`."
    },
    {
        "instruction": "Implement a higher-order function that accepts another function, `func` (which takes no arguments), as input. The higher-order function should call `func` once, and return a tuple containing exactly two elements: the result of calling `func`, and an empty list."
    },
    {
        "instruction": "Create a function that accepts a collection (like a list or tuple) and returns `True` if the collection is empty, and `False` otherwise."
    },
    {
        "instruction": "Design a function `analyze` that takes one argument: a function `target_func` which itself takes no arguments. `analyze` should execute `target_func` and check if the list of auxiliary arguments associated with its execution context is empty. Return `True` if the auxiliary argument list is empty, `False` otherwise. (You may need to simulate or assume a mechanism exists to inspect these auxiliary arguments)."
    },
    {
        "instruction": "Develop a function that calculates and returns the sum of all elements within a given 2D numerical array."
    },
    {
        "instruction": "Write a function that takes a scalar value `p`, a fixed 2D numerical array `D`, and a unary numerical function `func`. First, compute an intermediate 2D array `M` by multiplying `p` with `D` element-wise. Second, apply `func` element-wise to `M`. Third, sum all elements of the resulting array. The function should return the analytical derivative of this final sum with respect to the initial scalar parameter `p`. Assume `func` is differentiable."
    },
    {
        "instruction": "Implement the mathematical function `f(x) = sin(pi*x) / (pi*x)` for a single numerical input `x`. Ensure correct handling for the input `x=0`, where the function value is 1."
    },
    {
        "instruction": "Write a function that takes a scalar numerical value and a 2D numerical array. Return a new 2D array of the same dimensions where each element is the product of the corresponding element in the input array and the input scalar."
    },
    {
        "instruction": "Implement a function simulating a custom forward differentiation rule. It takes inputs: `static_scalar`, `static_array`, `dynamic_scalar`, `dynamic_array`, and tangent inputs: `tangent_dynamic_scalar`, `tangent_dynamic_array`. Compute 'primal' outputs: `out_scalar = static_scalar + dynamic_scalar`, `out_array = static_array + dynamic_array`. Compute 'tangent' outputs using a *specific custom* rule: `tangent_out_scalar = static_scalar + 90`, `tangent_out_array = tangent_dynamic_array + 91`. Return the pair `((out_scalar, out_array), (tangent_out_scalar, tangent_out_array))`. Assume arrays are 1D."
    },
    {
        "instruction": "Design a function `apply_custom_forward_rule`. It accepts: a) a list of primal inputs (mix of scalars and 1D arrays), b) a corresponding list of tangent inputs where some might be numerical tangents and others are special 'zero' markers (represented by `None`), c) a function `compute_primals(primals)` that returns primal outputs, and d) a function `compute_tangents(primals, tangents)` that returns tangent outputs using custom logic (potentially using primal values where tangent is `None`). `apply_custom_forward_rule` should call `compute_primals` and `compute_tangents` and return `(primal_outputs, tangent_outputs)`."
    },
    {
        "instruction": "Create a higher-order function `vectorize_func` that takes a function `func` as input. `vectorize_func` should return a *new* function. This new function accepts arguments (scalars or 1D arrays), adds a leading dimension of size 1 to each argument, applies `func` to these modified arguments (assuming `func` operates element-wise), removes the leading dimension from the results, and returns them. Handle multiple arguments and multiple return values."
    },
    {
        "instruction": "Write a function that accepts two scalars (`s1`, `s2`) and two 1D numerical arrays (`a1`, `a2` of the same length). It should return a tuple containing the sum `s1 + s2` and the element-wise sum `a1 + a2` (a new 1D array)."
    },
    {
        "instruction": "Write a function that accepts two 1D numerical arrays of the same length. It should return a new 1D array where each element is the product of the corresponding elements from the input arrays."
    },
    {
        "instruction": "Create a function that takes four scalar inputs: `val1`, `val2`, `change1`, `change2`. It should return a tuple containing two values: the product `val1 * val2`, and the value `change2`. Add logic inside the function to check if `change2` represents a specific 'zero change' placeholder value (e.g., None or a dedicated sentinel object) and perhaps log or handle this case."
    },
    {
        "instruction": "Design a function that simulates applying a calculation and a custom propagation rule element-wise. It takes: a binary function `func`, a rule function `rule`, two 1D numerical input arrays `in1`, `in2`, and two 1D 'change' arrays `ch1`, `ch2` (all arrays same length). The `rule` function takes two lists/tuples `(primals, tangents)` and returns `(primal_out, tangent_out)`. Your function should iterate through the arrays, applying `rule` to each corresponding set of elements `([in1[i], in2[i]], [ch1[i], ch2[i]])`, and return two new arrays: one with all `primal_out` values and one with all `tangent_out` values."
    },
    {
        "instruction": "Write a function that calculates and returns the sum of all elements in a given 1D numerical array."
    },
    {
        "instruction": "Develop a function `bind_second_arg` that takes a two-argument function `f(a, b)` and a value `b_val`. It should return a new one-argument function `g(a)` such that `g(a)` is equivalent to calling `f(a, b_val)`."
    },
    {
        "instruction": "Design a system to compute function values and their directional derivatives using custom rules. Define a primary function (e.g., `multiply(x, y)`). Associate a custom rule with it that calculates the output derivative given input derivatives (`dx`, `dy`), potentially simplifying if `dx` is zero (e.g., output derivative is just `dy`). Create a mechanism that, given the primary function and input values (`x0`, `y0`), returns both the result `multiply(x0, y0)` and a callable object representing the directional derivative calculation at that point using the custom rule."
    },
    {
        "instruction": "Write a function that accepts two numerical scalar inputs and returns their product."
    },
    {
        "instruction": "Create a function that simulates a custom forward derivative calculation. It takes four numerical scalar inputs: `val1`, `val2`, `deriv1`, `deriv2`. It should return a pair: the product of `val1` and `val2`, and the value `deriv2`."
    },
    {
        "instruction": "Implement a function `handle_special_zero(val1, val2, zero_marker)` that takes two inputs, which can be numbers or a special `zero_marker` object. If `val1` is the `zero_marker`, return `val2`. If `val2` is the `zero_marker`, return `val1`. If neither is the `zero_marker`, return the sum of `val1` and `val2`."
    },
    {
        "instruction": "Write a function `validate_inputs(in1, in2, zero_marker)` that accepts two values and a `zero_marker`. It should return `True` if at least one of the inputs is *not* the `zero_marker`, and `False` otherwise."
    },
    {
        "instruction": "Design a function `apply_custom_rule(base_func, primals, tangents, zero_marker)` that takes a two-argument function `base_func`, a tuple `primals=(x, y)`, and a tuple `tangents=(tx, ty)`. `tx` and `ty` can be numbers or the `zero_marker`. First, check if at least one tangent is not `zero_marker` (return an error or boolean False if both are `zero_marker`). If valid, calculate `result = base_func(x, y)`. Then, calculate `output_tangent` using the rule: `ty` if `tx` is `zero_marker`, `tx` if `ty` is `zero_marker`, else `tx + ty`. Return the pair `(result, output_tangent)`."
    },
    {
        "instruction": "Create a function `apply_binary_operation(operation, val1, val2)` that takes a function `operation` (expecting two numerical arguments) and two numerical inputs `val1`, `val2`. It should return the result of applying the `operation` to `val1` and `val2`."
    },
    {
        "instruction": "Develop a function that simulates a fixed number of iterations. It accepts an initial state (a pair of numbers), a count `N`, and an update function (like `step_processor` from Task 3). It should repeatedly apply the update function `N` times, where the output state from one iteration becomes the input state for the next. The function should return only the final state pair after `N` iterations."
    },
    {
        "instruction": "Create a function that takes two pairs of numerical values as input: `primals = (p1, p2)` and `tangents = (t1, t2)`. The function should return a pair containing the first primal value and its corresponding tangent: `(p1, t1)`."
    },
    {
        "instruction": "Implement a function named `step_processor` that takes a state represented as a pair of numbers `(current_val, previous_val)`. Inside the function, it should call a hypothetical function `process(current_val, previous_val)` which simply returns `current_val`. The `step_processor` function should return a new state pair `(process(current_val, previous_val), current_val)` and a secondary null value (e.g., None)."
    },
    {
        "instruction": "Write a function that accepts two numerical inputs, `a` and `b`, but returns only the first input `a`."
    },
    {
        "instruction": "Implement a function that takes four scalar numerical inputs (x, y, dx, dy) and a list of two booleans `use_outputs`. It should calculate primal values P = (sine(x), x + cosine(y)) and associated rate values T = (2.0 * cosine(x) * dx, 1.5 * dx - 0.5 * sine(y) * dy). The function should efficiently compute and return only the primal and rate values corresponding to the indices where `use_outputs` is true, minimizing computations for unused outputs. For example, if `use_outputs` is `[True, False]`, it should return `(P[0], T[0])` and avoid computing `P[1]` and `T[1]` if possible."
    },
    {
        "instruction": "Write a function that accepts two scalar numerical inputs, x and y. It should return a tuple containing two scalar numerical outputs: the sine of x, and the sum of x and the cosine of y."
    },
    {
        "instruction": "Write a function that accepts two scalar numerical inputs, y and dy. It should return a tuple containing two values: the cosine of y, and the result of -0.5 * sine(y) * dy."
    },
    {
        "instruction": "Create a function that takes four scalar numerical inputs: x, y, dx, and dy. It should compute and return a tuple of two scalar outputs based on the following rules: (2.0 * cosine(x) * dx) and (1.5 * dx - 0.5 * sine(y) * dy)."
    },
    {
        "instruction": "Define a function that accepts two required numerical arguments (`a`, `b`) and one optional keyword-only numerical argument `c` (defaulting to 0). The function should return a tuple containing `a + b` and `b * c`."
    },
    {
        "instruction": "Create a wrapper function `check_extra_kwarg` that takes a function `func` as input. Assume `func` accepts only one positional argument (`p`) and no keyword arguments. The wrapper should call `func` with the required positional argument and an extra keyword argument (e.g., `func(5, extra=1)`), catch the expected `TypeError` for an unexpected keyword argument, and return `True` if caught, `False` otherwise."
    },
    {
        "instruction": "Design a function `configure_system` that takes one required string argument `mode` and one optional keyword-only boolean argument `strict` (defaulting to `False`). If the function is called with any keyword arguments other than `strict`, it must raise a `TypeError` with a message explicitly stating the name of the unexpected keyword argument (e.g., \"unexpected keyword argument: 'debug_level'\"). If called correctly, it should return a dictionary summarizing the configuration."
    },
    {
        "instruction": "Implement a function `process_inputs` that requires two positional numerical arguments (`input1`, `input2`) and accepts an optional keyword-only argument `scale` (defaulting to 1.0). If the function is called with fewer than two positional arguments, it must raise a `TypeError` with a message explicitly stating which required argument is missing (e.g., \"missing required positional argument: 'input2'\"). Otherwise, it should return `(input1 - input2) * scale`."
    },
    {
        "instruction": "Implement a function that takes a single floating-point number `x`. It should compute and return two values: the sine of `x` and the cosine of `x`. The cosine value represents a necessary intermediate result for a subsequent calculation."
    },
    {
        "instruction": "Develop a function that accepts two floating-point numbers: an `intermediate_value` (representing `cos(x)`) and an `incoming_gradient`. The function must return the product `2 * intermediate_value * incoming_gradient`, simulating the application of a custom gradient rule."
    },
    {
        "instruction": "Define a structure or mechanism containing two related functions. The first function should compute `sin(x)` for a float input `x` and also return `cos(x)` as a cache. The second function should accept this cache and an incoming gradient `g` (a float), and return a custom gradient computed as `2 * cache * g`."
    },
    {
        "instruction": "Write a function that takes a single floating-point number `x` as input and returns its sine value."
    },
    {
        "instruction": "Write a function that takes a single scalar numerical input `x` and returns the value of `cos(2*x) / 2.0`."
    },
    {
        "instruction": "Write a function that takes a single scalar numerical input `x` and returns the analytical derivative of `cos(2*x) / 2.0`, which is `-sin(2*x)`. Compare the output of this function with the gradient part returned by the function in Task 3 for a given input `x`."
    },
    {
        "instruction": "Define two functions. The first function, `func(x)`, should compute `cos(2*x) / 2.0`. The second function, `custom_grad_rule(x, upstream_gradient)`, should take a scalar `x` and an `upstream_gradient` value, and return `upstream_gradient * 3`."
    },
    {
        "instruction": "You are given `f`, `g`, and `evaluate_and_apply_custom_grad` (from Task 2 & 3). Create a new function `f_wrapper(x)` that calls `evaluate_and_apply_custom_grad(f, g, x)` and returns only the *first* element of the pair (the function value). Now, implement a function `check_consistency` that takes `x`, calculates `evaluate_and_apply_custom_grad(f, g, x)` and `evaluate_and_apply_custom_grad(f_wrapper, g, x)`, and returns `True` if both the function values and the gradient values from these two calls are approximately equal (use a small tolerance, e.g., 1e-6), `False` otherwise."
    },
    {
        "instruction": "Write a function that takes two scalar numbers: an 'original_input' value and an 'incoming_gradient'. If 'original_input' was positive, return 2 times 'incoming_gradient'. Otherwise, return 3 times 'incoming_gradient'."
    },
    {
        "instruction": "Create a function that accepts a single scalar number. It should evaluate a specific mathematical function based on whether the input is positive (use sine) or non-positive (use cosine). Return the result of the chosen function."
    },
    {
        "instruction": "Design a function simulating a custom backward gradient calculation step. It accepts two arguments: 'saved_context' (which contains the original scalar input value from a prior forward step) and an 'incoming_gradient' (a scalar). Using the original input value retrieved from 'saved_context', it must compute and return a resulting gradient: 2 times 'incoming_gradient' if the original input was positive, and 3 times 'incoming_gradient' otherwise."
    },
    {
        "instruction": "Write a function that takes a single scalar number as input. If the number is positive, return its sine. Otherwise (if it's zero or negative), return its cosine."
    },
    {
        "instruction": "Create a function that accepts a numerical array (1D or 2D) and returns a new array of the same shape where each element is twice the cosine of the corresponding input element."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a scalar function with a predefined custom gradient. The function should first apply the scalar function element-wise to the array, sum the results, and then compute the gradient of this sum with respect to the original input array using the custom gradient rule. Return the resulting 1D gradient array."
    },
    {
        "instruction": "Write a function that takes a numerical array (1D or 2D) and applies the sine function element-wise, returning a new array of the same shape."
    },
    {
        "instruction": "Develop a function that applies a given scalar function element-wise across all elements of a 2D numerical input array. Assume the scalar function has a defined (potentially custom) gradient. The function should return a 2D array of the results, preserving the input shape."
    },
    {
        "instruction": "Write a function `apply_scaling_rule` that takes three floating-point arguments: `intermediate_value`, `scale_factor`, and an unused `input_value` (for structural similarity). The function should compute and return `2 * intermediate_value * scale_factor`."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number and returns its sine value."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number and returns its cosine value."
    },
    {
        "instruction": "Implement a function that takes a single floating-point number `x` and calculates `2 * cos(x)`. Return the floating-point result."
    },
    {
        "instruction": "Create a function that takes a dictionary `input_data = {'angle': num}` (where num is an angle in radians). Return a new dictionary `{'cos_value': computed_cosine}`, where `computed_cosine` is the cosine of the input angle."
    },
    {
        "instruction": "Write a function that accepts a dictionary containing a single key 'value' mapped to a number. Return a new dictionary where the number is mapped to the key 'result'."
    },
    {
        "instruction": "Define two functions: `forward_compute` and `backward_compute`. \n- `forward_compute` takes `{'data': x}`, calculates `y = x + 10` and `residual = x / 2`, then returns two dictionaries: `({'primary': y}, {'aux': residual})`. \n- `backward_compute` takes two dictionaries `residual_dict = {'aux': r}` and `gradient_dict = {'grad_primary': g}`, calculates `grad_x = r + g`, and returns a tuple containing a single dictionary: `({'grad_data': grad_x},)`. "
    },
    {
        "instruction": "Implement a function that accepts a dictionary `x = {'a': val}`. It should compute `result = val * 5` and `intermediate = val - 1`. Return *two* separate dictionaries: the first being `{'output': result}` and the second being `{'cache': intermediate}`."
    },
    {
        "instruction": "Create a mechanism (e.g., a class or structure) to associate a primary function `f(x)` with two auxiliary functions: a `forward_rule(x)` that returns both the result of `f(x)` and some intermediate data needed for gradient calculation, and a `reverse_rule(intermediate_data, grad_output)` that uses the intermediate data and an incoming gradient to compute the gradient with respect to the input `x`. This setup defines a custom *reverse-mode* differentiation rule."
    },
    {
        "instruction": "Design a function `check_compatibility(function_properties, differentiation_mode)` which takes properties of a function (specifically, whether it uses custom *reverse-mode* differentiation rules like in Task 2) and a desired differentiation mode ('forward' or 'reverse'). The function should raise a specific error (e.g., `CompatibilityError`) if 'forward' mode differentiation is requested for a function that has custom *reverse-mode* rules defined."
    },
    {
        "instruction": "Write a function that applies a given mathematical operation (e.g., sine) element-wise to a numerical input, which can be either a single number or a 1D array of numbers. Return the result in the same format (scalar or 1D array)."
    },
    {
        "instruction": "Develop a function `vectorize_scalar_func(scalar_func, input_array)` that takes a function `scalar_func` (which operates on single numerical inputs) and a 1D numerical array `input_array`. It should return a new 1D array where the i-th element is the result of applying `scalar_func` to the i-th element of `input_array`."
    },
    {
        "instruction": "Define two related functions. `forward_multiply(a, b)` should return `a * b`. `backward_multiply(a, b, sensitivity_out)` should return a tuple `(sensitivity_a, sensitivity_b)`, where `sensitivity_a` is `sensitivity_out * b` and `sensitivity_b` is `sensitivity_out * a`. These represent the sensitivities of the inputs given the output sensitivity."
    },
    {
        "instruction": "Write a function that accepts two numerical inputs `x` and `y`, and an optional numerical keyword argument `scale` (defaulting to 1.0). Return the value of `scale * (x + y)`."
    },
    {
        "instruction": "Implement a function that takes a list or array of numbers and calculates the sum of the squares of its elements."
    },
    {
        "instruction": "Implement a function `approximate_partial_derivative_first_arg`. It takes a function `func` (which accepts two numerical arguments, `arg1` and `arg2`) and two numerical values `val1`, `val2`. It should approximate the partial derivative of `func` with respect to its *first* argument at the point (`val1`, `val2`) using a small finite difference `h` (e.g., `(func(val1 + h, val2) - func(val1, val2)) / h`)."
    },
    {
        "instruction": "Write a function `compute_sine_and_cosine(x)` that takes a single floating-point number `x` and returns a pair (e.g., tuple or list) containing two values: the sine of `x` and the cosine of `x`."
    },
    {
        "instruction": "Implement a function `compute_sine(x)` that takes a single floating-point number `x` and returns its sine."
    },
    {
        "instruction": "Implement a function `evaluate_custom_first_derivative(value)` that calculates the *custom* first derivative of a conceptual function `f` at a given `value`. Assume `f`'s derivative is defined by the rule `f'(value) = 2 * cos(value)`. The function should return this custom derivative evaluated at the input `value`."
    },
    {
        "instruction": "Create a function `apply_custom_gradient_rule(residual, upstream_gradient)` that accepts two scalar floating-point numbers: `residual` (an intermediate value from a related computation, conceptually `cos(x)`) and `upstream_gradient`. It should return the product `upstream_gradient * 2 * residual`."
    },
    {
        "instruction": "Implement a function that applies a given *scalar* function `g(x)` element-wise to all elements of an input 1D numerical array. The function should return a new 1D array of the results."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and calculates the sum of the outputs after applying a specific scalar transformation `f(x) = 3*x` to each element. It should return a single scalar value representing the sum."
    },
    {
        "instruction": "Create a function that generates a 1D numerical array containing integers from 0 up to (but not including) a given positive integer `N`."
    },
    {
        "instruction": "Design a system where a function `f(x) = 3*x` (operating on scalars) can have a custom \"backward pass\" rule defined. This rule, given the original input `x` and an upstream value `dL_df`, computes the downstream value `dL_dx` as `2 * cos(x) * dL_df`. Implement a way to compute this `dL_dx` for a given `x` and `dL_df`."
    },
    {
        "instruction": "Design a mechanism (e.g., using functions or a class) `custom_apply` that takes a transformation function `f` and a numerical value `x`. Evaluating `custom_apply(f, x)` should yield `f(x)`. Additionally, provide a method to compute a 'sensitivity' with respect to `x`. This sensitivity should be calculated as the cosine of the original `x` multiplied by an external sensitivity value provided to the method, explicitly ignoring the transformation `f` in this sensitivity calculation."
    },
    {
        "instruction": "Implement a function `backward_op` that takes two numerical inputs: `saved_value` and `gradient_in`. It should return the product of these two values."
    },
    {
        "instruction": "Write a function `evaluate_and_get_cosine` that takes a numerical input `x` and returns a tuple containing `x` itself and the cosine of `x`."
    },
    {
        "instruction": "Write a higher-order function `apply_func` that takes two arguments: a function `fn` and a value `val`. The `apply_func` should return the result of calling `fn` with `val`."
    },
    {
        "instruction": "Design a structure or mechanism (e.g., using multiple functions or a simple object) to encapsulate a computation and its custom gradient rules. It should include: (1) the main computation function, (2) a 'forward' function returning the main result and auxiliary data, and (3) a 'backward' function taking auxiliary data and an upstream gradient to compute the downstream gradient. Demonstrate with a simple example like squaring an input."
    },
    {
        "instruction": "Create a function `custom_backward_operation(auxiliary_data, upstream_gradient)` that takes numerical `auxiliary_data` (produced by a corresponding forward operation) and an `upstream_gradient`. It should return the calculated gradient with respect to the original input, using a predefined rule like `auxiliary_data * upstream_gradient`."
    },
    {
        "instruction": "Write a function `create_multiplier(factor)` that accepts a numerical `factor`. It should return a *new function* that takes a single numerical argument `value` and returns the product `factor * value`."
    },
    {
        "instruction": "Write a function `evaluate_derivative(value)` that takes a numerical `value`. It should calculate and return the value of the derivative of the sine function evaluated at the given `value` (i.e., compute cos(value))."
    },
    {
        "instruction": "Implement a higher-order function `apply_generated_func(func_generator, generator_arg, func_arg)`. This function receives: `func_generator` (a function that takes one argument and returns another function), `generator_arg` (an argument for `func_generator`), and `func_arg` (an argument for the function *returned* by `func_generator`). Your function should call `func = func_generator(generator_arg)` and then return the result of calling `func(func_arg)`."
    },
    {
        "instruction": "Write a function factory `create_multiplier(factor)` that accepts a numerical scalar `factor`. This factory should return a *new* function. The returned function must take a single numerical scalar argument `value` and return the product `factor * value`."
    },
    {
        "instruction": "Create a function `scale_array(arr, scalar)` that takes a 1D numerical array `arr` and a numerical scalar `scalar`. It must return a new 1D numerical array of the same size, where each element is the corresponding element of the input array `arr` multiplied by the `scalar`."
    },
    {
        "instruction": "Implement a function `vectorized_closure_call(input_array, fixed_arg)` that takes a 1D numerical array `input_array` and a numerical scalar `fixed_arg`. For each element `x` in `input_array`, the function should conceptually create a unique temporary function `temp_func(y)` that computes `x * y` (using the specific `x` from the array). It must then call this `temp_func` with `fixed_arg` (i.e., `temp_func(fixed_arg)`). Collect all results into a new 1D numerical array of the same size as `input_array` and return it."
    },
    {
        "instruction": "Develop a function `calculate_derived_value(param1, param2)` that accepts two numerical inputs, `param1` and `param2`. It should compute and return the value `param1 * cos(param2)`, assuming `param2` is in radians."
    },
    {
        "instruction": "Create a function `compute_cosine(angle)` that takes a single numerical input `angle` (in radians) and returns its cosine value."
    },
    {
        "instruction": "Write a function factory `create_multiplier(factor)` that accepts a number `factor`. It should return a *new function* that takes a single number `value` and returns their product (`factor * value`)."
    },
    {
        "instruction": "Implement a function `elementwise_scalar_multiply(data_array, scalar)` that takes a 1D numerical array `data_array` and a scalar number `scalar`. Return a new 1D array where each element is the product of the corresponding element in `data_array` and the `scalar`."
    },
    {
        "instruction": "Implement a function that takes two numerical scalar inputs: an intermediate value `intermediate` (representing `cos(y)` from a previous calculation) and an incoming gradient `g`. It should return the product `intermediate * g`."
    },
    {
        "instruction": "Design a function that takes two numerical scalar inputs, `a` and `b`. Assume `a` should be treated as a constant (non-differentiable) and `b` as a variable. The function should simulate computing the derivative of `a * b` with respect to `b`, potentially using helper functions for forward and backward steps (like those in Task 2 and 3), and return the resulting derivative."
    },
    {
        "instruction": "Create a function that takes two numerical scalar inputs, `x` and `y`. It should return a tuple containing two values: the product `x * y`, and the cosine of `y`."
    },
    {
        "instruction": "Develop a function wrapper that takes another function `target_func`, a tuple of its arguments `args`, and a tuple `non_diff_indices` indicating which arguments (by index) should be treated as non-differentiable. The wrapper should execute `target_func(*args)`. Add a mechanism (e.g., a check before execution or based on hypothetical tracing info) to raise a `ValueError` if an operation attempts to compute a derivative with respect to any argument whose index is in `non_diff_indices`. Otherwise, return the result of `target_func`."
    },
    {
        "instruction": "Create a function that accepts two lists (or tuples) and returns `True` if they have the same number of elements, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a single argument and returns it directly. The function should accept any data type."
    },
    {
        "instruction": "Define two functions, `forward_pass` and `backward_pass`. `forward_pass` accepts a single input `arg1` and returns a tuple `(result, state)`. `backward_pass` accepts `state` and `gradient_in` and should return a tuple representing gradients for the inputs of `forward_pass`. Implement a check mechanism that verifies if the tuple returned by `backward_pass` has exactly one element (matching the single input `arg1` of `forward_pass`). If the number of elements is incorrect, raise a `TypeError` indicating the structural mismatch."
    },
    {
        "instruction": "Implement a function that takes one input value `x`. It should return a tuple containing two elements: the original value `x` and a second element which can be a fixed placeholder (e.g., `None` or 0)."
    },
    {
        "instruction": "Write a function `verify_output_match` that accepts three arguments: an `original_output`, a `derived_output_pair`, and a descriptive `function_name` (string). The `derived_output_pair` is expected to be a list or tuple of length two. The function must check two conditions: 1) Is `derived_output_pair` actually a list/tuple of length two? 2) Does the *first* element of `derived_output_pair` exactly match `original_output` in terms of structure, shape, and data type? If either check fails, raise a `TypeError` including the `function_name` and details about the mismatch (e.g., 'output structure mismatch', 'output shape/type mismatch'). If both checks pass, return `True`."
    },
    {
        "instruction": "Create a function `apply_and_extract` that takes two arguments: a function `func` and an initial value `val`. Assume `func` takes one argument and returns a sequence (like a list or tuple). Call `func` with `val`. Return only the *first* element from the sequence returned by `func`."
    },
    {
        "instruction": "Implement a function `check_structure_match` that accepts two arbitrary data structures (which could be scalars, lists, or tuples, possibly nested). Return `True` if the overall structure (types and nesting of containers like lists/tuples) is identical for both inputs, ignoring the actual values of non-container elements. Return `False` otherwise."
    },
    {
        "instruction": "Write a function `create_pair_output` that takes a single numerical value `v`. It should return a tuple containing two elements: the original value `v` and the value `v` again."
    },
    {
        "instruction": "Consider the function `h(a, x) = max(0, a) * x`. Write a function that calculates the partial derivative of `h` with respect to its second argument, `x`. This derivative function should take `a` and `x` as input and return the numerical value of the derivative at that point."
    },
    {
        "instruction": "Define a function that takes a numerical value 'a'. It should return a *new* function that takes a single numerical argument 'x' and computes `max(0, a) * x`."
    },
    {
        "instruction": "Write a function that accepts two arguments: a callable object `f` and a numerical value `x`. The function should invoke the callable `f` with `x` as its argument and return the result."
    },
    {
        "instruction": "Implement the Rectified Linear Unit (ReLU) function. It takes a single numerical input and returns 0 if the input is negative, otherwise returns the input itself."
    },
    {
        "instruction": "Write a function that simulates applying a backward derivative calculation. It should take an input value `x` and an 'output sensitivity' value `v`. Using the derivative of `f(x) = x**2`, the function should return the product of the derivative evaluated at `x` and the value `v`."
    },
    {
        "instruction": "Create a function that calculates the mathematical derivative of the function `f(x) = x**2`. It should take a numerical value `x` as input and return the derivative evaluated at `x`."
    },
    {
        "instruction": "Implement a pair of functions to enable custom derivative calculation for `y = x**2`. The first function (`forward_pass`) takes `x`, computes `y`, and returns `y` along with any necessary intermediate information (e.g., `x`). The second function (`backward_pass`) takes the intermediate information and an incoming 'sensitivity' value (`dL/dy`) and returns the calculated sensitivity with respect to the input (`dL/dx`)."
    },
    {
        "instruction": "Define two simple mathematical functions, `f(x)` (e.g., `x**2`) and `g(y)` (e.g., `y * 3`). Write a third function that computes the derivative of the composite function `h(x) = g(f(x))` at a given point `x` by applying the chain rule, explicitly using the derivatives of `f` and `g`."
    },
    {
        "instruction": "Define a function pair for custom gradient calculation. The `forward_pass` function takes a scalar `x`, computes `output = f(x)` and an `intermediate = g(x)`, returning both `(output, intermediate)`. The `backward_pass` function takes the `intermediate` value and an incoming gradient `grad_output`, returning the gradient with respect to `x` based on a rule like `grad_input = h(intermediate) * grad_output`."
    },
    {
        "instruction": "Implement a function `map_function_to_array`. It takes a 1D numerical array `DataArray` and a scalar function `ProcessElement`. It should return a new 1D array where each element is the result of applying `ProcessElement` to the corresponding element of `DataArray`."
    },
    {
        "instruction": "Create a function that accepts a single scalar numerical input `x` and uses a predefined constant `C`. The function should return `A * x * C`, where `A` is another predefined constant (e.g., 3). Include a check to ensure the input `x` is a scalar."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns the sum of all its elements."
    },
    {
        "instruction": "Write a function that computes the mathematical derivative of the function `f(y) = 2.0 * cos(y)` with respect to `y`. The function should take a numerical value `y_val` as input and return the derivative evaluated at that point (i.e., `-2.0 * sin(y_val)`)."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array `input_array`. For each element `y` in `input_array`, it calculates `2.0 * cos(y)`. The function should return a new 1D numerical array containing these results."
    },
    {
        "instruction": "Create a function that accepts a numerical input `y` and returns `2.0` times the cosine of `y`."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x` and returns `2.0` times the sine of `x`."
    },
    {
        "instruction": "Implement a pair of functions simulating a custom differentiation rule for `f(x) = 2.0 * sin(x)`. The first function ('forward') should compute `y = f(x)` and store `x` (or `y`) for the backward pass. The second function ('backward') should take the stored value and an incoming gradient `g_y`, returning the computed gradient with respect to the input, `g_x = 2.0 * cos(x) * g_y`."
    },
    {
        "instruction": "Develop a function that calculates the second derivative of the function `f(x) = 2.0 * sin(x)` at a given numerical input `x`, returning `-2.0 * sin(x)`."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x` and returns the value `2.0 * sin(x)`."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and applies a given mathematical operation (e.g., computing `2.0 * sin(value)`) to each element, returning a new 1D array containing the results."
    },
    {
        "instruction": "Design a function simulating a 'reverse-mode sensitivity calculation' step. It accepts auxiliary data (e.g., `(constant_value, original_input)`) and an incoming sensitivity value. It should return a tuple representing the calculated sensitivities corresponding to the original inputs of the forward step. For this task, specifically return `(constant_value, zero_sensitivity)`, where `constant_value` is from the auxiliary data and `zero_sensitivity` represents zero sensitivity for a potentially non-differentiable input type (like an integer). The incoming sensitivity value might be ignored."
    },
    {
        "instruction": "Create a function that takes a numerical value `x`. It should return a tuple containing two elements: the original value `x`, and some auxiliary data represented as a tuple `(constant_value, x)`, where `constant_value` is a predefined numerical constant (e.g., 2.0)."
    },
    {
        "instruction": "Implement a function that performs one iteration of a loop-like process. The function takes a 'carry' value (which can be a tuple, e.g., `(val1, val2)`) and applies a predefined transformation `transform_func` to the carry (or part of it). It returns the updated carry after one application of `transform_func`."
    },
    {
        "instruction": "Define a computation involving one iterative step (like Task 4). The `transform_func` used has a specific 'sensitivity propagation rule': when calculating sensitivities backwards, it always propagates `(constant_value, zero_sensitivity)` back to its inputs, regardless of the sensitivity it receives. Given initial inputs (e.g., numeric `input1`, integer-like `input2` forming the initial carry), determine the sensitivity of the final carry's first element with respect to the initial `input1` and `input2`, considering the iterative application and the special sensitivity rule. The expected sensitivity result should be `(constant_value, zero_sensitivity)`."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number `x` and returns its sine value."
    },
    {
        "instruction": "Implement a function that simulates applying a custom differentiation rule. Given an input value `x` and an incoming 'gradient signal' `g`, the function should return `2 * cos(x) * g`. This represents a modified backward pass calculation for a function whose forward pass computes `sin(x)`."
    },
    {
        "instruction": "Write a function to compute the derivative of a composite function `g(x) = f(f(x))` at a point `x`, where `f(x) = sin(x)`. Assume that the differentiation process for `f` uses a non-standard rule where the backward pass calculation involves multiplying the incoming gradient signal by `2 * cos(input_to_f)`. The input `x` is a single floating-point number."
    },
    {
        "instruction": "Define a function `compute_value(x)` that returns `sin(x)`. Define a second function `compute_derivative_component(x)` that returns `cos(x)`. Both functions accept a single floating-point number `x`."
    },
    {
        "instruction": "Implement a pair of functions simulating a custom forward and backward pass for differentiation of `f(x) = sin(x)`. The forward function should take `x` and return `(sin(x), cos(x))`. The backward function should take the saved `cos(x)` from the forward pass and an incoming gradient `g`, and return `2 * cos(x) * g`."
    },
    {
        "instruction": "Develop a function that computes the second derivative of the composite function `k(x) = sin(sin(x))` evaluated at a given numerical input `x`."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x` and returns the result of applying the sine function twice: `sin(sin(x))`."
    },
    {
        "instruction": "Create a function that computes the first derivative of the composite function `k(x) = sin(sin(x))` evaluated at a given numerical input `x`."
    },
    {
        "instruction": "Write a function that takes two scalar numerical inputs and returns their product."
    },
    {
        "instruction": "Implement a function that calculates the sine of a single scalar numerical input."
    },
    {
        "instruction": "Write a function that computes the derivative of `h(x) = f(x, x)` at a point `x0`, using custom `forward_pass` and `reverse_pass` functions defined for `f(x, y)` (like those in Task 4). Your function should perform the forward pass of `h`, then use the results and the `reverse_pass` function to calculate the total derivative with respect to the original input `x`, correctly applying the chain rule by summing the gradient contributions corresponding to both inputs of `f`."
    },
    {
        "instruction": "Define two related functions for a base operation `f(x, y)` (where `x`, `y` are scalars). The first function, `forward_pass(x, y)`, should compute the result of `f` and also return an auxiliary value needed for gradient calculation (e.g., `cos(y)` if `f` involves `sin(y)`). Return `(result, auxiliary_value)`. The second function, `reverse_pass(auxiliary_value, output_gradient)`, should take the auxiliary value and the gradient flowing back from the output (`output_gradient`). It must return a tuple `(gradient_x, gradient_y)`. Ensure `gradient_x` is always zero (or None), and `gradient_y` is computed based on `auxiliary_value` and `output_gradient` (e.g., `2 * auxiliary_value * output_gradient`)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array `x` and returns a new 1D array containing the element-wise cosine of `x`."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array `arr`. It should first compute an intermediate array where each element `i` is `arr[i] * sin(arr[i])`. Then, it should sum all elements of this intermediate array. Finally, it should compute and return a \"sensitivity\" array where each element `i` corresponds to `2 * cos(arr[i])`, representing how the sum changes with respect to small changes in the input `arr[i]`."
    },
    {
        "instruction": "Write a function `reverse_pass` that takes two scalar numerical inputs: `residual` (representing an intermediate value like `cos(y)`) and `gradient_in` (representing an incoming gradient signal). It should return a tuple of two values: `None` as the first element, and `2 * residual * gradient_in` as the second element."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size, `a` and `b`, and returns a new 1D array where each element `i` is the result of `a[i] * sin(b[i])`."
    },
    {
        "instruction": "Write a function that accepts a tuple containing two numbers `xs` and a single number `y`. It should return the product of the two numbers in `xs` multiplied by the sine of `y`."
    },
    {
        "instruction": "Define two functions: `forward_calc(value)` which computes `(value * value * sin(value), cos(value))` and returns this pair, and `backward_calc(intermediate, grad_in)` which computes and returns `2 * intermediate * grad_in`. Then, create a third function `get_specific_derivative_component(input_val)` that calls `forward_calc` with `input_val`, takes the second element (the `cos` value) from its result, and passes this intermediate value to `backward_calc` with `grad_in=1.0`. Return the result of `backward_calc`."
    },
    {
        "instruction": "Create a function that accepts two numerical inputs: `intermediate_value` and `incoming_gradient`. It should return a tuple representing gradients for two conceptual original inputs. The first element of the tuple must be `None`, and the second element should be `2 * intermediate_value * incoming_gradient`."
    },
    {
        "instruction": "Implement a function that takes a tuple of two numbers `xs` and a single number `y`. It should compute `result = xs[0] * xs[1] * sin(y)` and `residual = cos(y)`. Return both `result` and `residual` (e.g., as a tuple)."
    },
    {
        "instruction": "Create a function that accepts a floating-point number `x`. It should return a pair of values: the sine of `x` and the cosine of `x`."
    },
    {
        "instruction": "Write a function that takes a single floating-point number as input and returns its sine."
    },
    {
        "instruction": "Implement a function that receives two floating-point numbers, `saved_value` and `incoming_gradient`. It must return a pair where the first element is explicitly `None` and the second element is the result of `2 * saved_value * incoming_gradient`."
    },
    {
        "instruction": "Define two related functions. `func_forward` takes a float `x` and returns two floats: `output = x * x` and `intermediate = 2 * x`. `func_backward` takes the `intermediate` value (a float) and an `incoming_gradient` (a float) and returns the computed gradient for the original input `x`, calculated as `intermediate * incoming_gradient`."
    },
    {
        "instruction": "Write a function that accepts a single number `x` and returns its square (`x` * `x`)."
    },
    {
        "instruction": "Create a function `f` that accepts a single number `x`. `f(x)` should return a tuple containing two elements: the result of `x` squared, and a *new function*. This new function should accept a single number `g` and return the product `g * x`."
    },
    {
        "instruction": "Write a function that takes a single number `x`. It should compute and return a pair (or tuple) containing two values: the square of `x` (`x**2`) and the derivative of the square function evaluated at `x` (`2*x`)."
    },
    {
        "instruction": "Write a function that accepts a single number `x` and returns the value `2 * x`, representing the mathematical derivative of `x^2`."
    },
    {
        "instruction": "Design a function that takes two scalar numbers, `x` and `y`. It should return a pair: the first element is the sum (`x + y`), and the second element is another function (or callable object) that takes no arguments and returns a tuple `(1.0, 1.0)`, representing the gradient of the sum."
    },
    {
        "instruction": "Create a function that accepts two floating-point numbers, `numerator` and `denominator`. It should return a pair: the result of `numerator / denominator`, and a callable object. This callable object should accept a single floating-point 'sensitivity' value `s` and return a tuple `(s / denominator, -s * numerator / (denominator**2))`."
    },
    {
        "instruction": "Write a function that accepts two floating-point numbers as input and returns their product as a floating-point number."
    },
    {
        "instruction": "Develop a function that accepts two scalar numerical values, `val1` and `val2`, and returns a tuple containing `(val2, val1)`."
    },
    {
        "instruction": "Develop a function that calculates the sum of the sines of all elements in a given 1D numerical array. Input: 1D array, Output: Scalar sum."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array containing the sine of each element. Input: `[a, b, c]`, Output: `[sin(a), sin(b), sin(c)]`."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array of size N and generates another 1D numerical array of the same size N, starting from 3.0 and incrementing by 1.0 for each subsequent element. Input: Array of size N, Output: `[3.0, 4.0, ..., 3.0 + N - 1]`."
    },
    {
        "instruction": "Design a function that takes a 1D numerical array `x`. It should return two results: (1) a scalar value equal to the sum of sines of the elements in `x`, and (2) a *transformation rule*. This rule, when applied to a scalar `g`, should produce a 1D array where the element at index `i` is `cos(x[i]) * (3.0 + i) * g`. The rule itself could be represented as a function or lambda."
    },
    {
        "instruction": "Write a function that represents the identity operation `f(x) = x`. Then, create another function that computes the first derivative of this identity function using standard calculus rules. Evaluate the derivative function at an arbitrary numerical input."
    },
    {
        "instruction": "Design a structure or function that bundles a primary calculation (e.g., squaring a number `x`) with a related secondary calculation rule. The secondary rule should take two arguments: an upstream value `g` and the original input `x`, and return their product `g * x`. The main structure/function, when given an input `x`, should return the result of the primary calculation and the secondary rule function itself."
    },
    {
        "instruction": "Develop a function to compute the second derivative of a primary function `f` at a point `x`. You are provided with `f` and its custom derivative rule `df(g, x)` as described in Task 3. This requires applying the differentiation logic, using the custom rule `df`, twice in succession. Example: Use `f(x) = x^2` and `df(g, x) = g * x`."
    },
    {
        "instruction": "Write a function that accepts a single numerical input and returns its square."
    },
    {
        "instruction": "Create a higher-order function called `select_output`. This function should take another function `f` (which returns multiple values, e.g., a tuple) and an index `i` as input. `select_output` should return a *new* function that, when called with the same arguments as `f`, executes `f` and returns only the element at index `i` from `f`'s result."
    },
    {
        "instruction": "Implement a function simulating a gradient calculation step. It takes two gradient inputs, `g1` and `g2`. These inputs can be numerical values or a special object/value representing 'structural zero'. The function should return three output gradients: `(g1, g1, g2)`. Ensure the function correctly propagates the 'structural zero' marker if it appears in `g2`."
    },
    {
        "instruction": "Design a structure or class that bundles a primary function `func` with two associated rule functions: `forward_rule` and `backward_rule`. `func` takes `(x, y, z)` and returns `(x, x)`. `forward_rule` takes `(x, y, z)` plus information about which inputs are active, returning `(x, x)`. `backward_rule` takes gradients corresponding to the outputs `(g1, g2)` and returns gradients for the inputs `(gx, gy, gz)`, potentially handling special 'zero' markers. Implement a method that executes the appropriate rule based on a mode ('forward' or 'backward')."
    },
    {
        "instruction": "Write a function that accepts three numerical inputs (e.g., floats or integers) and returns a tuple containing two elements, both being the value of the first input."
    },
    {
        "instruction": "Write a function that accepts three numerical arrays `a`, `b`, and `c` of potentially different shapes and returns them unmodified in a tuple `(a, b, c)`."
    },
    {
        "instruction": "Design a function `validate_shapes` that accepts two lists of numerical arrays: `original_inputs` and `computed_gradients`. It must verify that for every index `i`, the shape of `computed_gradients[i]` exactly matches the shape of `original_inputs[i]`. If any pair of shapes mismatches, the function should raise a `ValueError` with the message 'Shape mismatch detected between input and gradient'. If all shapes match, the function should return `True`. Assume both lists have the same length."
    },
    {
        "instruction": "Create a function that takes a tuple containing exactly three numerical arrays `(g1, g2, g3)` and returns a new tuple where the positions of the first two arrays are swapped: `(g2, g1, g3)`."
    },
    {
        "instruction": "Implement a function that compares the shapes of numerical arrays. It takes two numerical arrays as input and returns `True` if they have the exact same shape (dimensionality and size in each dimension), and `False` otherwise."
    },
    {
        "instruction": "Implement a function that receives five arguments: a scalar `r_s`, and four 'signals' `sig_ss`, `sig_sa`, `sig_ds`, `sig_da`. `sig_ss` is expected to be a special 'null signal' object, `sig_sa` and `sig_da` are 1D numerical arrays, and `sig_ds` is a scalar. Verify that `sig_ss` is the null signal. Return a tuple: `(r_s + 90, sig_sa + 91, sig_ds + 92, sig_da + 93)`. Ensure array shapes are preserved."
    },
    {
        "instruction": "Create two functions: `add_batch_dim` takes a scalar or a 1D numerical array and returns a 2D array by adding a leading dimension of size 1. `remove_batch_dim` performs the inverse operation, taking a 2D array with a leading dimension of size 1 and returning the original scalar or 1D array."
    },
    {
        "instruction": "Define a pair of functions, `forward_pass` and `backward_pass`, simulating a custom calculation step. `forward_pass` takes inputs (`in_ss`, `in_sa`, `in_ds`, `in_da` - scalar, array, scalar, array) and identifies `in_ds`, `in_da` as 'dynamic'. It computes `out_ds = in_ss + in_ds`, `out_da = in_sa + in_da`. It returns results `(in_ss, in_sa, out_ds, out_da)` and context `(in_ss,)`. `backward_pass` takes context and output signals (`g_ss`, `g_sa`, `g_ds`, `g_da`). It must check `g_ss` is a 'null signal'. It computes and returns input signals `(context[0] + 90, g_sa + 91, g_ds + 92, g_da + 93)`, ensuring the first element corresponds to a non-dynamic input."
    },
    {
        "instruction": "Write a function that accepts two scalars (`s1`, `s2`) and two 1D numerical arrays (`a1`, `a2`) of the same size. Return a tuple containing `s1`, `a1`, the sum `s1 + s2`, and the element-wise sum `a1 + a2`."
    },
    {
        "instruction": "Extend the custom 'gradient calculation' rule from Task 4. In the 'backward' part, before returning the calculated gradients for inputs `a` and `b`, add a check to determine if the received gradient corresponding to output `b` explicitly represents a structural zero (indicating `b` provably did not contribute to the final differentiated value). If it is a structural zero, print a message confirming this detection."
    },
    {
        "instruction": "Define a function `process(a, b)` that returns the pair `(a, b)`. Implement a custom 'gradient calculation' rule for this function. This rule needs two parts: a 'forward' part that executes the original function and potentially stores intermediate values, and a 'backward' part. The 'backward' part receives gradients corresponding to the outputs `a` and `b` and must calculate and return the gradients corresponding to the inputs `a` and `b`."
    },
    {
        "instruction": "Create a higher-order function `vectorize(element_func)` that takes a function `element_func` (assuming it operates on single elements) and returns a new function. The new function should accept a list or array of elements and apply `element_func` to each element independently, returning a list or array of the results."
    },
    {
        "instruction": "Implement a function `my_func(x)` that returns `x`. Also, create a corresponding 'backward pass' function `my_func_bwd(upstream_grad)`. This backward function should take one argument representing the gradient flowing from the output of `my_func` and simply return it, representing the gradient with respect to the input `x`."
    },
    {
        "instruction": "Implement a function `backward_computation` that mimics the backward pass for differentiation. It should accept two arguments: the tuple of intermediate values produced by `forward_computation` (from Task 3), and an incoming numerical gradient (gradient w.r.t. the output of `process_data`). It must return a tuple containing the computed gradients with respect to the original inputs (the container's value and the multiplier)."
    },
    {
        "instruction": "Create a class `DataContainer` that stores a single numerical value. Implement two methods: `flatten` which returns a list containing the stored value and `None` as auxiliary data, and `unflatten` which takes auxiliary data (`None`) and a list containing one value, returning a new `DataContainer` instance initialized with that value."
    },
    {
        "instruction": "Write a function `process_data` that accepts a `DataContainer` instance (from Task 1) and a numerical scalar `multiplier`. The function should return the product of the value stored in the container and the `multiplier`."
    },
    {
        "instruction": "Implement a function `forward_computation` that mimics the forward pass for differentiation of the `process_data` function (from Task 2). It should take a `DataContainer` instance and a `multiplier` as input. It must return a tuple containing: (1) the result of `process_data`, and (2) a tuple of intermediate values (e.g., the container's value and the multiplier) needed for a subsequent backward pass."
    },
    {
        "instruction": "Write a function that accepts a tuple containing two numerical scalars, `(a, b)`, and returns a new tuple `(a + b, a)`. Ensure it works for standard numerical types like integers and floats."
    },
    {
        "instruction": "Implement a function simulating the backward pass corresponding to the operation `result = val1 + val2`. This function takes two arguments: auxiliary data (which can be ignored) saved from a forward pass (like in Task 3), and an incoming numerical scalar gradient `grad_result`. It should return a tuple containing the gradients with respect to the original inputs `val1` and `val2`, which are both equal to `grad_result` in this case."
    },
    {
        "instruction": "Implement a function that simulates a fixed number of steps (`N`) of an iterative process. It takes an initial state tuple `(x0, y0)` (two numerical scalars) and the number of steps `N`. In each step, update the state `(x, y)` to `(x + y, x)`. Return the final state tuple after `N` iterations."
    },
    {
        "instruction": "Create a function simulating the forward pass of a computation. It should accept two numerical scalar inputs, `val1` and `val2`. It must return a tuple containing two elements: the sum `val1 + val2`, and a second element which can be any constant value (e.g., None or 0) representing auxiliary data saved for a potential backward pass."
    },
    {
        "instruction": "Create a function that maps a value to a specific position within a nested structure. The function takes a value `g` and an index path (e.g., `[1, 0]` representing the first element of the second element in a structure like `(v1, (v2, v3))`). It should return a new nested tuple mirroring the target structure, placing `g` at the location specified by the index path and `None` everywhere else. Example: For `g=5.0`, path `[1, 0]`, and target structure `(v1, (v2, v3))`, return `(None, (5.0, None))`."
    },
    {
        "instruction": "Implement a function that receives a single numerical value `grad_out`. It should return a tuple representing a gradient structure `(grad_out, (None, None))`, where `None` explicitly indicates a zero gradient for corresponding potential inputs."
    },
    {
        "instruction": "Write a function that takes a nested tuple (e.g., `(a, (b, c))`) and returns a new tuple of the same structure, where each original numerical or non-None element is replaced by `None`. Example: Input `(10, (20, 30))` returns `(None, (None, None))`. Input `(10, (None, 30))` returns `(None, (None, None))`. "
    },
    {
        "instruction": "Write a function that accepts a nested tuple containing at least one element (e.g., `(item1, (item2, item3))`) and returns only the very first element (`item1`)."
    },
    {
        "instruction": "Design a function that simulates value propagation for element selection. It takes two arguments: an 'original input' structure `S` (e.g., a nested tuple like `(a, (b, c))`) and a 'propagation' value `P`. The function should return a new structure, identical in shape to `S`, where the position corresponding to the *first element* (`a`) holds `P`, and all other leaf positions hold `None`. Example: `S = ('x', ('y', None))`, `P = 1.0`. Output: `(1.0, (None, None))`."
    },
    {
        "instruction": "Create a function that takes any nested structure composed of lists and tuples containing various data types (numbers, strings, `None`). It should return a new structure with the identical nesting layout, but with every non-list/non-tuple element replaced by `None`."
    },
    {
        "instruction": "Develop a function that takes a potentially nested structure containing numbers and `None` values. Return a boolean value indicating whether the *second element* of the top-level structure is exactly `None`. Assume the top-level structure has at least two elements. Example: `(10, None)` -> `True`; `(10, (20, None))` -> `False`; `(5, 0)` -> `False`."
    },
    {
        "instruction": "Implement a function that receives a nested tuple `T = (val1, (val2, val3))` and a single value `new_val`. It must return a new tuple with the same structure as `T`, but where the position originally holding `val1` now contains `new_val`, and all other leaf positions (like those for `val2` and `val3`) contain `None`. Example: Input `T=(1, (2, 3))`, `new_val=99` -> Output `(99, (None, None))`."
    },
    {
        "instruction": "Write a function that accepts two numerical inputs and returns their product."
    },
    {
        "instruction": "Write a function that accepts two numerical values and returns these two values contained within a list."
    },
    {
        "instruction": "Create a function that takes two numerical inputs. It should compute their product and return both the product and the original two inputs, bundled together (e.g., in a tuple or list)."
    },
    {
        "instruction": "Develop a pair of functions. Function A takes two numbers, computes their product, and returns the product plus the original two numbers. Function B takes the two original numbers (from Function A's output) and a third number (`upstream_grad`). Function B should return `upstream_grad` times the second original number, and the first original number times `upstream_grad`."
    },
    {
        "instruction": "Implement a function that takes two arguments: a tuple containing three numerical scalar values (`val1`, `val2`, `val3`) and a single numerical scalar `g`. The function should return a tuple of two numerical scalars, calculated as `(val1 * g * val3, val2 * g)`."
    },
    {
        "instruction": "Create a function that takes two numerical scalar inputs, `x` and `y`. It should compute and return a tuple containing four values: the result of `sin(x) * y`, and the intermediate values `cos(x)`, `sin(x)`, and `y`."
    },
    {
        "instruction": "Write a function that calculates the partial derivatives of the expression `sin(x) * y` with respect to `x` and `y`. The function should take `x` and `y` (numerical scalars) as input and return a tuple containing the two partial derivatives (`d/dx`, `d/dy`)."
    },
    {
        "instruction": "Design a function that simulates a two-step calculation process. The first step takes two numerical scalars `x` and `y`, computes `sin(x) * y`, and prepares intermediate data (`cos(x)`, `sin(x)`, `y`). The second step takes this intermediate data and another numerical scalar `g`, then computes two final results using the logic `(cos(x) * g * y, sin(x) * g)`. The function should manage this two-step process and return the final two results."
    },
    {
        "instruction": "Write a function that takes two scalar numerical inputs, `x` and `y`, and returns the result of `sin(x) * y`."
    },
    {
        "instruction": "Create a function that accepts a single scalar numerical input `x` and returns a tuple containing both `sin(x)` and `cos(x)`."
    },
    {
        "instruction": "Define a function `prepare_backward` that takes two scalar numerical inputs `x` and `y`. This function should compute intermediate values `intermediate1 = cos(x)`, `intermediate2 = sin(x)`. It must then return *another* function, `execute_backward`. The returned `execute_backward` function should accept a single scalar numerical input `g` and return the tuple `(intermediate1 * g * y, intermediate2 * g)`, using the `intermediate1`, `intermediate2`, and `y` values captured when `prepare_backward` was called."
    },
    {
        "instruction": "Write a function that takes two arguments: `saved_values` (a tuple containing three numerical values, representing `val1`, `val2`, `val3`) and `g` (a single numerical value). It should compute and return a tuple of two values: `(val1 * g * val3, val2 * g)`."
    },
    {
        "instruction": "Write a function that applies a given transformation function `transform_func` element-wise to two input 1D numerical arrays, `a` and `b`. The `transform_func` takes two numbers and returns a tuple of results (e.g., `(result1, result2, result3)`). Your main function should apply `transform_func` to each pair `(a[i], b[i])` and return the results collated into separate 1D arrays (e.g., one array for all `result1`s, one for all `result2`s, etc.). Assume `transform_func` always returns the same number of results."
    },
    {
        "instruction": "Implement a function that simulates a backward calculation step. It takes three 1D numerical arrays (`d`, `e`, `f`) and another 1D array `g` (representing an incoming gradient), all of the same size. It should compute and return two new 1D arrays: `grad_a` where `grad_a[i] = d[i] * g[i] * f[i]`, and `grad_b` where `grad_b[i] = e[i] * g[i]`."
    },
    {
        "instruction": "Develop a function that generates a sequence of `n` evenly spaced numbers starting from `start` and ending at `stop`. Return the sequence as a 1D numerical array."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays, `a` and `b`, of the same size. It should return a new 1D array where each element is the sine of the corresponding element in `a` multiplied by the corresponding element in `b`."
    },
    {
        "instruction": "Write a function `calculate_selective_gradient(x, y, use_first, use_second)` that takes two scalar numbers and two boolean flags. It should compute `cos_x = cos(x)` and `sin_y = sin(y)`. Based *only* on the flags that are true, it calculates a gradient tuple `(grad_x, grad_y)` by summing contributions: add `(2.0 * cos_x, 0.0)` if `use_first` is true, and add `(1.5, -0.5 * sin_y)` if `use_second` is true. Return the final `(grad_x, grad_y)`. If both flags are false, return `(0.0, 0.0)`."
    },
    {
        "instruction": "Create a function that takes two scalar numerical inputs, `x` and `y`, and a boolean flag `compute_first`. If the flag is true, the function should compute and return the sine of `x`. If the flag is false, it should return a default value (e.g., 0.0) without computing the sine."
    },
    {
        "instruction": "Implement a function that simulates a custom gradient calculation step. It takes two tuples as input: `intermediates` (containing two pre-computed values, say `cos_x` and `sin_y`) and `output_gradients` (containing gradients for two outputs, say `grad_a` and `grad_b`). It must return a tuple representing input gradients calculated using the formula: `(2.0 * cos_x * grad_a + 1.5 * grad_b, -0.5 * sin_y * grad_b)`."
    },
    {
        "instruction": "Develop a function that takes two scalar numerical inputs, `x` and `y`, and a boolean flag `compute_second`. If the flag is true, the function should compute and return the sum of `x` and the cosine of `y`. If the flag is false, it should return a default value (e.g., 0.0) without performing the sum or cosine calculation."
    },
    {
        "instruction": "Develop a function `process_options` that accepts one required positional argument `item_id` and any number of keyword arguments. If a keyword argument named 'priority' is *not* provided in a call, raise a `TypeError` stating 'Missing required keyword argument: priority'."
    },
    {
        "instruction": "Write a function that accepts exactly two numerical arguments, `x` and `y`, and returns their sum. Demonstrate calling it correctly."
    },
    {
        "instruction": "Write a function wrapper `validate_signature` that takes another function `func` as input. `validate_signature` should return a new function that behaves like `func` but performs argument validation before calling `func`. Specifically, the wrapper should check if all required positional arguments are provided and if any unexpected keyword arguments are given, raising appropriate `TypeError` messages similar to those in Tasks 2 and 4 if validation fails."
    },
    {
        "instruction": "Implement a function `filter_kwargs` that takes one positional argument `config_name` and arbitrary keyword arguments `**settings`. The function should only allow 'mode' and 'level' as valid keys in `settings`. If any other keyword argument is passed (e.g., `filter_kwargs('test', mode='A', unknown=1)`), raise a `TypeError` indicating the unexpected keys, like 'Unexpected keyword arguments: ['unknown']'."
    },
    {
        "instruction": "Implement a function that takes two numerical arrays, `x` and `y`, of the same shape. It should compute `x / y` element-wise and then add the result element-wise to the original `x`. Return the final array."
    },
    {
        "instruction": "Create a function that accepts two numerical arrays, `a` and `b`, of identical shape and returns a new array representing their element-wise sum."
    },
    {
        "instruction": "Write a function that takes two numerical arrays, `a` and `b`, of the same shape and returns a new array where each element is the corresponding element of `a` divided by the corresponding element of `b`."
    },
    {
        "instruction": "Create a function `combine_operation` that takes three numerical arrays `a`, `b`, `c` of the same shape. Inside `combine_operation`, define and use a helper function `divide(op1, op2)` that performs element-wise division `op2 / op1`. The `combine_operation` function should call this helper function as `divide(b, a)` and return the element-wise sum of `c` and the result of this division."
    },
    {
        "instruction": "Create a function that scales a numerical array by a constant factor. It should take a numerical array `data` and a scalar `factor` as input, returning a new array where each element is multiplied by `factor`."
    },
    {
        "instruction": "Write a function that performs element-wise division between two input numerical arrays of the same shape. The function should accept arrays `numerator` and `denominator` and return `numerator / denominator`. Consider how to handle cases where `denominator` contains zeros."
    },
    {
        "instruction": "Implement a function that combines two numerical arrays, `x` and `y` (same shape), using the formula `result = x + (x / y)` for each corresponding element. Return the `result` array. Address potential division by zero."
    },
    {
        "instruction": "Develop a function that applies a specific transformation based on two input numerical arrays, `param` and `value` (same shape). The function should return a new array where each element is `value / param`."
    },
    {
        "instruction": "You are provided with four element-wise unary functions: `f`, `ft`, `ftt`, and `fttt`, which all operate on numerical arrays of the same shape and return an array of that shape. Write a verification function `check_cyclic_transforms` that accepts these four functions and an input numerical array `x`. The function must return `True` only if both conditions hold (within a small floating-point tolerance): 1) `f(x)` is element-wise close to `ftt(x)`. 2) `ft(x)` is element-wise close to `fttt(x)`. Otherwise, return `False`."
    },
    {
        "instruction": "Write a function that takes two numerical arrays `r` and `x` of the same shape and returns a new array containing the element-wise result of `x / r`. Ensure appropriate handling for cases where elements of `r` might be zero (e.g., return a placeholder value like NaN or raise an error)."
    },
    {
        "instruction": "Create a function that takes two numerical arrays, `x` and `y`, of the same shape. Calculate an intermediate array `z` where `z[i] = y[i] / x[i]`. Return the element-wise sum `x + z`. Handle potential division by zero during the calculation of `z`."
    },
    {
        "instruction": "Implement a function that accepts two numerical arrays `r` and `t` of identical shapes. Return a new array containing the element-wise result of `t / (2.0 * r)`. Include handling for potential division by zero in `r`."
    },
    {
        "instruction": "Create a function that takes a single scalar numerical input `x` and returns a list containing exactly two elements, both equal to `x`."
    },
    {
        "instruction": "Develop a function that accepts two scalar numerical inputs, `c` and `x`. It should first compute the product `p = c * x`, and then return a list containing `p` duplicated twice: `[p, p]`."
    },
    {
        "instruction": "Write a function that takes a list `t` containing exactly two numerical values and a scalar numerical factor `c`. The function should return the result of `c * (t[0] + t[1])`."
    },
    {
        "instruction": "Implement a function that receives a list containing exactly two numerical values and returns their sum."
    },
    {
        "instruction": "Create a sequence of four functions operating conceptually on an initial value `x`. `process_0` should return `x`. `process_1` should ignore its input and return a constant `C`. `process_2` should return its input (like `process_0`). `process_3` should ignore its input and return the same constant `C` (like `process_1`). Write code demonstrating the output of each function when conceptually applied (e.g., `process_0(x)`, `process_1(x)`, `process_2(x)`, `process_3(x)`)."
    },
    {
        "instruction": "Define a function `outer(x)` that internally calls `inner(x)` (where `inner(x)` returns `x`) and returns the result. Specify that the 'transform' associated with `outer` should yield a constant value (e.g., 7.0), irrespective of the transform associated with `inner`. Simulate calling `outer(5.0)` and its conceptual 'transform' applied to an arbitrary value (e.g., 1.0), showing the expected outputs (5.0 and 7.0)."
    },
    {
        "instruction": "Create a function that takes a numerical input `x`. Define a related 'transform' function that ignores its input and always returns the constant value 7.0."
    },
    {
        "instruction": "Implement a function `f(x)` that returns `x`. Implement a second function `f_t(y)` that returns a constant `C` (e.g., 7.0). Implement a third function `f_tt(z)` that returns `z`. Demonstrate calling each with a sample input value."
    },
    {
        "instruction": "Design a function that accepts another function `op` and two 1D numerical arrays `arr1`, `arr2` as input. The function `op` itself takes two arrays and performs an element-wise operation. Your designed function should apply `op(arr1, arr2)` and return the result."
    },
    {
        "instruction": "Create a function that takes two 1D numerical arrays, `a` and `b`, of the same size and returns a new array where each element is the result of dividing the corresponding element of `a` by the corresponding element of `b`. Handle potential division by zero appropriately (e.g., return a placeholder like infinity or zero)."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size and returns a new array where each element is the sum of the corresponding elements from the input arrays."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays, `input_val` and `param`. Inside, define two local functions: `forward_rule(p, i) = i / p` and `transpose_rule(p, t) = t / p`. The main function should calculate `result = input_val + forward_rule(param, input_val)`. It should also calculate a second value using the transpose rule, for instance, `transpose_related = transpose_rule(param, result)`. Return both `result` and `transpose_related`."
    },
    {
        "instruction": "Create a mechanism or class that allows associating a 'forward' function with its corresponding 'backward' function. Implement this for element-wise division: the forward function computes `z = x / y`, and the backward function, given `y` and an incoming value `t` (representing influence from `z`), computes the corresponding influence on `x` as `t / y`. The mechanism should allow calling the forward function and retrieving its associated backward function."
    },
    {
        "instruction": "Create a function that takes two numerical arrays, `numerator` and `divisor`, of identical shapes. It should return a new array containing the result of element-wise division (`numerator / divisor`). Include error handling or specific behavior for potential division by zero elements."
    },
    {
        "instruction": "Write a function that accepts two numerical arrays of the same shape and returns a new array representing their element-wise sum."
    },
    {
        "instruction": "Define two related functions. The first function, `forward_div`, takes two numerical arrays `x` and `y` (same shape) and returns their element-wise division `x / y`. The second function, `backward_div_related`, takes the original divisor `y` and a third array `t` (same shape) and returns the element-wise computation `t / y`. Return both functions."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays of identical shape and returns a new array containing their element-wise sum."
    },
    {
        "instruction": "Define a function `calculate_ratio` that takes two 1D numerical arrays, `x` and `y` (same shape), and returns their element-wise division `x / y`. Define a second, separate function `calculate_transformed_ratio` that takes two 1D numerical arrays, `r` and `t` (same shape), and returns the element-wise calculation `t / (2.0 * r)`."
    },
    {
        "instruction": "Implement a function `apply_and_scale`. This function accepts two arguments: another function `compute_func` (which takes one 1D numerical array and returns a 1D numerical array of the same shape) and a 1D numerical input array `data`. Inside `apply_and_scale`, first call `compute_func` with `data` to get an intermediate result array. Then, return a final array computed by element-wise multiplication of this intermediate result with the original `data` array."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same shape and returns a new array representing the element-wise division of the first array by the second. Handle potential division by zero gracefully (e.g., return a placeholder value like 0 or NaN)."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size, `a` and `b`, and returns a new 1D array where each element is the result of `b[i] / a[i]`. Handle potential division by zero by returning 0 for that element."
    },
    {
        "instruction": "Create a function `compose_func` that accepts two 1D numerical arrays, `x` and `y` (of the same size), and another function `inner_func`. `inner_func` takes two arrays (`p`, `q`) and returns an array result. `compose_func` should return the element-wise sum of `x` and the result of calling `inner_func(y, x)`."
    },
    {
        "instruction": "Write a function `check_transform_property`. It takes an initial function `f` (1D array -> 1D array), a function `apply_transform` (which takes a function like `f` and returns its transformed version), and an input array `x`. Compute `f_transformed = apply_transform(f)` and `f_transformed_twice = apply_transform(f_transformed)`. Return `True` if the output of `f_transformed_twice(x)` is element-wise numerically close (within a small tolerance, e.g., 1e-5) to the output of `f(x)`, and `False` otherwise."
    },
    {
        "instruction": "Implement a function `apply_transform_twice`. It takes an initial function `f` (which maps a 1D numerical array to another 1D numerical array) and an input array `x`. Assume a conceptual transformation `T` exists. This function should simulate applying `T` to `f` to get `f_prime`, then applying `T` to `f_prime` to get `f_double_prime`, and finally return the result of calling `f_double_prime(x)`. The exact transformation `T` should be implicitly defined by the steps you implement based on a simple rule (e.g., related to element-wise division by a constant factor)."
    },
    {
        "instruction": "Create a function that accepts a single numerical input `y` and returns a list containing two copies of that input: `[y, y]`."
    },
    {
        "instruction": "Define a function `f(x)` that returns `[x, x]`. Define another function `f_related(t)` where `t` is a two-element list `[t1, t2]`, which returns `t1 + t2`. Write code that demonstrates calling `f` with a value and `f_related` with a two-element list."
    },
    {
        "instruction": "Write a function that takes two scalar numerical inputs, `c` and `x`, and returns their product `c * x`."
    },
    {
        "instruction": "Develop a function that takes two scalar numerical inputs, `c` and `x`. The function should compute `y = c * x` and then return the list `[y, y]`."
    },
    {
        "instruction": "Using the function pair concept from Task 3, define a pair where the original function returns its input, and the transformed function returns the constant 7.0. Show that applying the `get_transform` operation twice to the original function yields a function that behaves identically to the original function."
    },
    {
        "instruction": "Write a function that takes a single numerical input and returns it unchanged. Define a second related function that takes a numerical input but always returns 0.0."
    },
    {
        "instruction": "Create a function that accepts a single numerical input but ignores it and always returns the constant value 7.0. Define a second related function that takes a numerical input and returns that input unchanged."
    },
    {
        "instruction": "Implement a concept of function pairs (original, transformed). Define a pair where the original function returns its input, and the transformed function returns 0.0. Create an operation `get_transform` that returns the associated function (transform of original is transformed, transform of transformed is original). Verify this bidirectional relationship."
    },
    {
        "instruction": "Modify the structure from Task 4. Ensure that invoking the 'switch_behavior' operation more than once has no additional effect. After the first invocation, the structure should permanently use the second function for all subsequent calls, regardless of how many more times 'switch_behavior' is invoked."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number and returns that number multiplied by 2.0."
    },
    {
        "instruction": "Extend the structure from Task 3. Add a method or operation, let's call it 'switch_behavior'. When 'switch_behavior' is invoked on the structure *for the first time*, any subsequent calls to the structure should execute the second function instead of the first."
    },
    {
        "instruction": "Write a separate function that accepts a single floating-point number and returns that number multiplied by 3.0."
    },
    {
        "instruction": "Write a higher-order function `create_multiplier(factor)`. This function should take a numerical factor and return a *new function*. The returned function should accept a single numerical argument `x` and return `factor * x`."
    },
    {
        "instruction": "Create a structure (e.g., using a class or closures) that represents a base function `f` (computes `2.0*z`) which is linked to its first transform `ft` (computes `3.0*z`) and second transform `ftt` (computes `7.0*z`). Provide methods or mechanisms to invoke the computation associated with `f`, `ft`, and `ftt` given an input `z`."
    },
    {
        "instruction": "Implement a system where a base function can be associated with a sequence of transformed functions. Create a generic 'transform operator' `T`. When `T` is applied to the base function `f`, it yields the first transform `f1`. When applied to `f1`, it yields the second transform `f2`. Subsequent applications of `T` to `f2` should yield `f2` itself (stabilization). The functions should operate on a single float input `z`, returning `2.0*z`, `3.0*z`, and `7.0*z` for `f`, `f1`, and `f2` respectively."
    },
    {
        "instruction": "Define three distinct functions: `f0(z)` returns `2.0*z`, `f1(z)` returns `3.0*z`, `f2(z)` returns `7.0*z`. Write a fourth function `apply_transform(level, z)` that takes a non-negative integer `level` and a float `z`. It should return `f0(z)` if `level` is 0, `f1(z)` if `level` is 1, and `f2(z)` if `level` is 2 or greater."
    },
    {
        "instruction": "Create a function `apply_operation` that takes another function `op` and a value `x`. It should simply call `op(x)` and return the result. This task focuses on passing functions as arguments."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number as input and returns that number multiplied by 2.0."
    },
    {
        "instruction": "Implement a function `get_alternate` that takes one function object (`func_a`) as input. Assume there's a predefined pairing (e.g., function `f` is paired with `g`, and `g` with `f`). If the input function is `f`, return `g`. If the input function is `g`, return `f`. Return an indicator (e.g., None) if the input function is not part of a known pair."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number as input and returns that number multiplied by 3.0."
    },
    {
        "instruction": "Write a function `apply_stateful_transform_repeatedly(initial_state, input_value, num_repeats)` that simulates repeated transformations. It starts with `initial_state`. In each of the `num_repeats` steps, it updates the state by adding 1.0 to it. After all repetitions, it computes and returns `final_state * input_value`."
    },
    {
        "instruction": "Implement a function `define_function_pair(initial_param)` that returns two functions: `base_func(param, input)` which computes `param * input`, and `transformed_func(param, input)` which computes `base_func(param + 1.0, input)`. Both input `param` and `input` are numerical."
    },
    {
        "instruction": "Create a function `apply_offset_transform(func, offset)` that takes a function `func` (which accepts two numerical arguments) and a numerical `offset`. It should return a *new function* that takes two arguments `a` and `b`, and calls the original `func` with the first argument modified: `func(a + offset, b)`."
    },
    {
        "instruction": "Design a function `apply_recursive_transform(initial_param, input_val, depth)` that recursively applies a transformation. The base operation is `result = param * input_val`. The transformation rule before each recursive step is `param = param + 1.0`. If `depth` is 0, return the result using `initial_param`. If `depth` > 0, apply the transformation rule to get `new_param`, then return the result of calling `apply_recursive_transform(new_param, input_val, depth - 1)`."
    },
    {
        "instruction": "Implement a function `create_fixed_arg_func(two_arg_func, fixed_second_arg)`. This function accepts another function `two_arg_func` (which itself takes two numerical arguments) and a numerical value `fixed_second_arg`. It should return a *new function* that takes only one numerical argument `arg1` and internally calls `two_arg_func(arg1, fixed_second_arg)`."
    },
    {
        "instruction": "Create a function that accepts two floating-point numbers, `x` and `y`, and returns the result of the calculation `x + (x / y)`."
    },
    {
        "instruction": "Write a function `check_output_equivalence(func1, func2, input1, input2)`. `func1` and `func2` are functions, each accepting two numerical arguments. This function should call `func1(input1, input2)` and `func2(input1, input2)` and return `True` if their outputs are numerically very close (within a small tolerance, e.g., 1e-5), and `False` otherwise."
    },
    {
        "instruction": "Define two distinct numerical functions, `func_one(a, b)` returning `a / b`, and `func_two(a, c)` returning `c / a`. Both should operate on floating-point numbers."
    },
    {
        "instruction": "Write a function `calculate_f(x, y)` that takes two scalar numerical inputs `x` and `y` and returns the result of the expression `x + x / y`. Ensure appropriate handling for the case where `y` is zero (e.g., return an infinite value or raise a specific error)."
    },
    {
        "instruction": "Create a function `safe_divide(numerator, denominator)` that accepts two scalar numbers and returns their quotient (`numerator / denominator`). If the denominator is zero, it should return a predefined value representing infinity or handle the error gracefully."
    },
    {
        "instruction": "Create two distinct functions, `direct_computation(a, b)` and `indirect_computation(a, b)`, both intended to compute the value `a + a / b`. `indirect_computation` must achieve this by calling a separate helper function for the division part (`a / b`). Write a verification step that confirms, for given scalar inputs `a` and `b`, that both functions produce identical numerical outputs and also yield identical results when their partial derivatives with respect to `b` are calculated and compared."
    },
    {
        "instruction": "Implement a function `value_and_gradient(constant_val, input_val)` that computes two things for the expression `constant_val / input_val`: 1) the value of the expression itself, and 2) the analytical derivative of the expression with respect to `input_val`. The function should return both computed results."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays, `x` and `y`. Inside this function, define and call a nested helper function that takes `y` and `x` and returns `x / y`. The main function should return `x` plus the result of the helper function."
    },
    {
        "instruction": "Implement a function that takes a numerical array and a string identifier ('rule1' or 'rule2'). If 'rule1' is provided, the function should apply a specific element-wise operation (e.g., `element * 2`). If 'rule2' is provided, it should apply a different element-wise operation (e.g., `element / 2`). Return the modified array."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size, `a` and `b`, and returns a new array computed as `a + (a / b)`. Ensure element-wise operations."
    },
    {
        "instruction": "Create a higher-order function `apply_custom_logic(primary_func, secondary_func, data, use_secondary)`. `primary_func` and `secondary_func` are functions that take numerical array data and return transformed data. If the boolean `use_secondary` is false, `apply_custom_logic` should call and return the result of `primary_func(data)`. If `use_secondary` is true, it should call and return the result of `secondary_func(data)`."
    },
    {
        "instruction": "Define a pair of related functions operating on 1D numerical arrays. The first function, `forward(input1, input2)`, performs element-wise division (`input2 / input1`). The second function, `backward(input1, output_gradient)`, calculates a corresponding 'sensitivity' related to `input2`, defined as element-wise `(2 * output_gradient) / input1`. Ensure both functions accept and return 1D numerical arrays of consistent sizes and handle potential division by zero."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays of the same size and returns a new 1D array representing their element-wise sum."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays, `x` and `y`, of the same size. It should compute `x / y` element-wise and then add `x` element-wise to the result. Return the final 1D array."
    },
    {
        "instruction": "Develop a function that takes two 1D numerical arrays, `r` and `t`, of the same size. It should return a new 1D array where each element is calculated as `(2 * t_element) / r_element`. Handle potential division by zero."
    },
    {
        "instruction": "Implement a function `apply_doubled_operation`. It should accept another function `op` (where `op` takes two 1D numerical arrays and returns one) and two 1D numerical arrays `x` and `y`. The function should return the result of `2 * op(y, x)`."
    },
    {
        "instruction": "Write a function `create_partial_application` that takes a function `target_func` (which accepts two 1D numerical arrays) and a fixed 1D numerical array `fixed_array`. `create_partial_application` should return a *new function* that accepts a single 1D numerical array `dynamic_array` and internally calls `target_func(dynamic_array, fixed_array)`, returning its result."
    },
    {
        "instruction": "Create a function `outer_func` that accepts two 1D numerical arrays, `a` and `b`. Inside `outer_func`, define a `nested_func` that takes two 1D arrays, `p` and `q`, and returns their element-wise division `q / p`. `outer_func` should compute and return `a + nested_func(b, a)`."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size, `arr1` and `arr2`, and returns a new array representing `arr1 + (arr1 / arr2)` element-wise. Ensure your function handles potential division by zero gracefully (e.g., by returning infinity or NaN for those elements)."
    },
    {
        "instruction": "Implement a function `conditional_executor` that accepts a boolean condition, two functions (`func_true`, `func_false`), and an input value `x`. If the condition is true, it should call `func_true(x)` and return the result. Otherwise, it should call `func_false(x)` and return its result. Assume `func_true` and `func_false` accept the same type of input `x` and return compatible outputs."
    },
    {
        "instruction": "Implement a higher-order function `apply_transform`. It takes a function `f` (which accepts one numerical array argument and returns a numerical array) and an input array `x`. Assume `f` has an associated transformation rule `f_transform` (provided separately or defined alongside `f`) that computes a 'sensitivity' output based on the sensitivity of `f`'s output. The `apply_transform` function should return the result of applying `f_transform` given `x` and an initial sensitivity array (e.g., an array of ones with the same shape as the output of `f(x)`)."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size, `a` and `b`, and returns a new 1D array where each element is `a[i] / b[i]`. Specify how to handle potential division by zero."
    },
    {
        "instruction": "Create a pair of functions. The first function, `func`, should take two numerical inputs (scalar or array), `r` and `x`, and return `x / r`. The second function, `func_transform`, should represent a transformation rule related to `func`. It takes `r` and a sensitivity value `t` (matching the shape of `x / r`) and returns `2 * t / r`."
    },
    {
        "instruction": "Implement a function that takes a scalar number `p` and a 1D numerical array `v`. If `p` is greater than zero, the function should return a new array containing each element of `v` divided by 3.0. Otherwise, it should return the original array `v` unmodified."
    },
    {
        "instruction": "Define a pair of related functions. The first, `process_data`, takes a 1D numerical array `x` and returns a new array where each element is `x_i / 3.0`. The second, `process_data_alt`, takes the same input `x` and returns a new array where each element is `2.0 * (x_i / 3.0)`."
    },
    {
        "instruction": "Create a function that accepts a boolean condition and two other functions, `func_if_true` and `func_if_false`, along with a single argument `arg`. The function should call `func_if_true(arg)` if the condition is true, and `func_if_false(arg)` otherwise, returning the result."
    },
    {
        "instruction": "Create a higher-order function `conditional_wrapper` that takes two functions, `op` and `op_alt`, as input. `op_alt` performs a transformation related to `op`. `conditional_wrapper` should return *two* new functions: `execute_conditionally` and `execute_alt_conditionally`. Both returned functions accept a boolean flag `cond` and an argument `arg`. `execute_conditionally(cond, arg)` should return `op(arg)` if `cond` is true, else `arg`. `execute_alt_conditionally(cond, arg)` should return `op_alt(arg)` if `cond` is true, else `arg`. Ensure the conditional logic is consistently applied based on the *same* flag value for both returned functions."
    },
    {
        "instruction": "Implement a function that receives a number `x` and a list/tuple of two booleans, `usage_flags`. It should return a list/tuple of two elements. The first element is the exponential of `x` if `usage_flags[0]` is true, otherwise `None`. The second element is the square root of `x` if `usage_flags[1]` is true, otherwise `None`. Handle potential errors if `x` is negative when calculating the square root (e.g., return `None` or a specific indicator like 'Error')."
    },
    {
        "instruction": "Write a function that accepts a single number `x` and returns a tuple containing two mathematically derived values: the sine of `x` and the cosine of `x`."
    },
    {
        "instruction": "Design a function `process_conditionally` that accepts an input number `x` and a list/tuple of two boolean flags `flags`. Internally, define two separate helper functions: `compute_exp(val)` which returns the exponential, and `compute_sqrt(val)` which returns the square root (handle domain errors). `process_conditionally` should call `compute_exp(x)` only if `flags[0]` is true, and `compute_sqrt(x)` only if `flags[1]` is true. It should return a list/tuple containing the results (using `None` if a computation was skipped due to its flag being false)."
    },
    {
        "instruction": "Create a function that takes a number `x` and a boolean `is_needed`. If `is_needed` is true, return the exponential of `x` (e^x). Otherwise, return the Python `None` value."
    },
    {
        "instruction": "Implement a function that receives a list containing exactly two numbers and a corresponding list of two boolean flags. Return a new list of two elements. If the first flag is True, the first element should be double the first input number; otherwise, it should be None. Apply the same logic for the second flag and second number."
    },
    {
        "instruction": "Develop a function that takes a single positive number `x` and a list/tuple of two boolean flags `use_flags`. The function should first compute two derived values: `exp(x)` and `10 * sqrt(x)`. It should then return a list where the i-th element is `2 * derived_value_i` if `use_flags[i]` is True, and `None` otherwise."
    },
    {
        "instruction": "Write a function that accepts a single positive number and returns a pair (e.g., a list or tuple) containing two values: the exponential of the number and ten times its square root."
    },
    {
        "instruction": "Create a function that takes a list of numbers and a parallel list of boolean flags (same length). Return a new list containing only the numbers from the input list where the corresponding flag in the boolean list is True."
    },
    {
        "instruction": "Implement a function `apply_elementwise` that takes two arguments: a function `op` (which accepts a single number and returns a single number) and a list of numbers `data`. The `apply_elementwise` function should return a new list where each element is the result of applying `op` to the corresponding element in `data`. Input: function, list[float]. Output: list[float]."
    },
    {
        "instruction": "Create a function that accepts two lists of numbers, `list1` and `list2`, assumed to be of the same length. It should return a tuple containing two lists: the first list being the element-wise sine of `list1`, and the second list being the element-wise sine of `list2`. Input: list[float], list[float]. Output: tuple[list[float], list[float]]."
    },
    {
        "instruction": "Write a function that takes a list of numbers and returns a new list containing the element-wise sine of each number. Input: list[float]. Output: list[float]."
    },
    {
        "instruction": "Write a function that takes a list of numbers and returns a new list containing the element-wise cosine of each number. Input: list[float]. Output: list[float]."
    },
    {
        "instruction": "Create a function that takes two scalar numerical inputs, `x` and `y`. It should return two items: first, a tuple `(sin(x) * y, x * sin(y))`, and second, a tuple containing intermediate values `(x, cos(x), sin(x), y, cos(y), sin(y))`."
    },
    {
        "instruction": "Write a function that accepts two scalar numerical inputs, `a` and `b`. It should compute and return a tuple containing two results: the sine of `a` multiplied by `b`, and `a` multiplied by the sine of `b`."
    },
    {
        "instruction": "Develop a function simulating a backward gradient calculation step. It accepts two arguments: 1) A tuple of pre-computed intermediate scalar values `(val_x, cos_x, sin_x, val_y, cos_y, sin_y)`. 2) A tuple of incoming scalar gradients `(grad_a, grad_b)`. The function must compute and return a tuple representing derived gradients: `(cos_x * grad_a * val_y + sin_y * grad_b, sin_x * grad_a + val_x * cos_y * grad_b)`."
    },
    {
        "instruction": "Implement a function that computes the symbolic partial derivative of the expression `sin(a) * b` with respect to `a`. The function should take scalar numerical inputs `a` and `b` and return the calculated derivative value `cos(a) * b`."
    },
    {
        "instruction": "Create a function that takes a scalar numerical input `x`, calculates `y = tan(x)`, and returns the value of `y` squared."
    },
    {
        "instruction": "Implement a function that takes two scalar numerical inputs: an intermediate value `c` and an output gradient `g`. It should compute and return the input gradient assuming the forward operation was `tan(x)` and `c` is `cos(x)`. The result should be `g / c**2`. Handle potential division by zero appropriately (e.g., return a very large number or NaN)."
    },
    {
        "instruction": "Write a function that accepts a single scalar numerical input `x` and returns two scalar outputs: the sine of `x` and the cosine of `x`."
    },
    {
        "instruction": "Design a mechanism to define a function with custom forward and backward computation rules. Implement a wrapper or class that takes a forward function `fwd` (input -> result, intermediate_data) and a backward function `bwd` (intermediate_data, output_gradient -> input_gradient). The wrapper should provide a way to call the forward function normally (returning just the result) and a separate way to compute the gradient using the backward function."
    },
    {
        "instruction": "Write a function that accepts a callable `operation` (taking one numerical argument and returning one numerical result) and a numerical value `x`. The function should verify that `operation` is callable and then return the result of calling `operation(x)`."
    },
    {
        "instruction": "Implement a function that takes a list/tuple of numerical values `original_results` and a corresponding list/tuple of booleans `usage_mask` of the same length. It should return a new list where the i-th element is `2 * original_results[i]` if `usage_mask[i]` is true, and `None` otherwise."
    },
    {
        "instruction": "Develop a function that takes a numerical input `num`. Inside the function, apply a fixed mathematical operation (e.g., calculate the exponential) to `num`. Return the result."
    },
    {
        "instruction": "Design a function `selective_processor` that takes three arguments: 1) a `generator_func` which accepts a number and returns a tuple of exactly two numbers, 2) a tuple of two booleans `output_needed`, and 3) an input number `value`. The `selective_processor` should call `generator_func(value)` to get an intermediate tuple `(res1, res2)`. It must then return a list where the first element is `2 * res1` if `output_needed[0]` is true (otherwise `None`), and the second element is `2 * res2` if `output_needed[1]` is true (otherwise `None`)."
    },
    {
        "instruction": "Write a function `verify_conditional_output(original_output, rule_output, is_used)` that takes an `original_output` value, a `rule_output` value (which could be `None`), and a boolean `is_used`. If `is_used` is `False`, return `True`. If `is_used` is `True`, return `True` only if `rule_output` is not `None` and has the same data type and shape (for arrays) as `original_output`. Otherwise (if `is_used` is `True` but `rule_output` is `None` or type/shape mismatches), return `False`."
    },
    {
        "instruction": "Create a function `check_shape(arr1, arr2)` that accepts two multi-dimensional arrays (e.g., lists of lists) and returns `True` if they have identical dimensions and sizes along each dimension, `False` otherwise."
    },
    {
        "instruction": "Develop a function `select_outputs(values, usage_flags)` that takes a list/tuple of data `values` and a corresponding list/tuple of boolean `usage_flags`. Return a new list/tuple of the same size, containing the value from `values` at index `i` if `usage_flags[i]` is `True`, and `None` otherwise."
    },
    {
        "instruction": "Write a function `check_type(val1, val2)` that returns `True` if `val1` and `val2` belong to the same fundamental data type (e.g., integer, float, boolean, string), and `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes an integer index as input and raises a `ValueError` with a message formatted specifically as: 'Error: Output at index {index} was expected but not produced.'"
    },
    {
        "instruction": "Implement a function that calls an internal function which returns multiple values (e.g., a tuple `(a, b)`). The outer function should accept an argument specifying which single value to extract (e.g., index 0 or 1) and return only that specific value."
    },
    {
        "instruction": "Design a function wrapper. The wrapper takes a function `func` (that returns multiple values) and a list/tuple `usage_spec` (booleans indicating which outputs are needed). The wrapper should return a *new* function that, when called, executes `func`, checks if all outputs marked `True` in `usage_spec` were actually produced (assume `None` means not produced), raises a `ValueError` if a needed output is missing, and otherwise returns the results from `func` (or potentially just the needed results)."
    },
    {
        "instruction": "Create a function that takes a list/tuple of pre-computed results (which might contain placeholder values like `None`) and a corresponding list/tuple of booleans indicating if each result is actually needed (`True`) or not (`False`). The function should raise a `ValueError` specifying the index if a needed result has a placeholder value."
    },
    {
        "instruction": "Implement a function that accepts a single numerical input `angle` (presumed to be in radians) and returns a pair containing two values: the sine of the `angle` and the cosine of the `angle`."
    },
    {
        "instruction": "Write a function that takes a scalar number `s`. It should construct and return a 1x1 numerical matrix whose only element is `2.0` multiplied by `s`."
    },
    {
        "instruction": "Implement a function that takes a numerical scalar `input_val` and a list/tuple of two booleans, `usage_flags`. This function simulates conditional computation. Define two internal calculations: `calc1 = 2.0 * exp(input_val)` (represented as a 1x1 matrix) and `calc2 = sqrt(input_val)` (represented as a scalar). The function must return a pair (list/tuple). The first element is `calc1` if `usage_flags[0]` is true, otherwise a null value. The second element is `calc2` if `usage_flags[1]` is true, otherwise a null value."
    },
    {
        "instruction": "Write a function that accepts a single number `x` and a boolean value `compute_it`. If `compute_it` is true, the function should return the exponential of `x`. Otherwise, it should return a designated null value (e.g., None)."
    },
    {
        "instruction": "Write a higher-order function `arg_validator` that takes a target function as input. It should return a new function (a wrapper). When the wrapper is called with some arguments, it must inspect the target function's signature, check if all required arguments are provided and if there are any unexpected keyword arguments (based on the target's signature). If an argument validation rule is violated, it must raise a `TypeError` with a descriptive message. Otherwise, it should call the original target function with the provided arguments."
    },
    {
        "instruction": "Implement a function `validate_args` that takes a list of required argument names (strings) and a dictionary representing keyword arguments provided by a caller. The function should raise a `TypeError` if any name from the required list is *not* present as a key in the dictionary. The error message should clearly state which required argument is missing."
    },
    {
        "instruction": "Develop a function that formats an error message for a missing function argument. It should accept the function name (string) and the missing argument name (string) and return a string formatted as: \"Function '<function_name>' is missing required argument: '<argument_name>'\""
    },
    {
        "instruction": "Write a function that accepts two required numerical arguments (e.g., `val1`, `val2`) and one optional keyword-only numerical argument (e.g., `factor`, default value 1). The function should return the result of `(val1 + val2) * factor`."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new 1D array where each element is the cosine of the corresponding input element."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number and returns its sine."
    },
    {
        "instruction": "Design a callable structure (e.g., a class with `__call__` or a function returning a function) that is initialized with two function references, `scalar_func` and `vector_func`. When the structure is called with a single numerical value, it should execute and return the result of `scalar_func` on that value. When called with a 1D numerical array, it should execute and return the result of applying `vector_func` element-wise to the array. Demonstrate its use with sine as `scalar_func` and cosine as `vector_func`."
    },
    {
        "instruction": "Create a function that takes one argument. If the argument is a single number, the function returns its sine. If the argument is a 1D numerical array, the function returns a new 1D array containing the element-wise cosine of the input array."
    },
    {
        "instruction": "Implement a function that accepts either a single numerical value or a 1D numerical array. If the input is a single value `x`, return `sin(x)`. If the input is a 1D array `xs`, return a new array where each element is the result of applying `cos` to the corresponding element in `xs`."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array `xs` and applies the cosine function element-wise to it. Add the resulting array element-wise to a predefined 1D numerical array `z`. Return the final 1D array."
    },
    {
        "instruction": "Write a function that takes a scalar numerical input `x` and adds the result of `sin(x)` to each element of a predefined 1D numerical array `z`. Return the resulting 1D array."
    },
    {
        "instruction": "Develop a function factory `create_processor(z)` that accepts a 1D numerical array `z`. It should return a *new* function that takes a single scalar number `x`, calculates `sin(x)`, and returns a new 1D array formed by adding this scalar result to every element of the initially provided array `z`."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a new 1D array where each element is the cosine of the corresponding input element."
    },
    {
        "instruction": "Write a function that takes a single number as input and returns a tuple containing two values: the sine of the number and the cosine of the number."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and returns a tuple of two 1D arrays. The first array should contain the cosine of each element of the input array, and the second array should contain the sine of each element."
    },
    {
        "instruction": "Create a function that takes two arguments: a transformation function `op` (which accepts a number and returns a number) and a 1D numerical array `data`. The function should return a tuple of two 1D arrays: the first containing `op` applied to each element of `data`, and the second containing the original `data` elements unchanged."
    },
    {
        "instruction": "Write a function that takes a numerical array and applies the mathematical sine function to each element, returning a new array of the same shape."
    },
    {
        "instruction": "Write a function that takes a base 1D numerical array (e.g., `[0, 1, 2]`) and constructs a complex nested structure containing multiple copies or variations of this array (e.g., `(base, [base+1, base+2], [base+3], base+4)`). Ensure all resulting arrays within the final structure share the same length (size of the first dimension)."
    },
    {
        "instruction": "Implement a function `process_structure(data, apply_alternative)` that operates on a nested data structure containing numerical arrays. If `apply_alternative` is false, apply the `sine` function element-wise to all arrays. If `apply_alternative` is true, apply the `cosine` function element-wise instead. Return the modified nested structure."
    },
    {
        "instruction": "Develop a function that takes a nested structure potentially containing numerical arrays at its leaves. It should check if all leaf arrays, if any exist, have the same size for their first dimension. Return `True` if they do or if there are no leaf arrays, `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a nested structure (lists/tuples) potentially containing `None` values and other elements. Return a new nested structure with the same arrangement, where every non-container, non-`None` element is replaced by the boolean value `True`, and `None` values remain `None`."
    },
    {
        "instruction": "Write a function that accepts a nested structure (lists/tuples) containing numbers and `None`, and another function `op`. It should return a new nested structure of the same shape where `op` has been applied to every number, while `None` values are kept as `None`."
    },
    {
        "instruction": "Create a function that takes a nested structure (lists/tuples) containing numerical arrays and `None`. Apply a specific mathematical function (e.g., element-wise cosine) to every array within the structure. Return a new structure containing the transformed arrays, preserving the original nesting and `None` positions."
    },
    {
        "instruction": "Implement a function that processes nested structures containing numerical arrays and `None`. It should accept the structure, a 'base' function (e.g., element-wise sine), and a 'vectorized' function (e.g., element-wise cosine). If processing a single structure instance, apply the 'base' function element-wise to arrays. If processing a 'batched' structure (where arrays have a leading batch dimension), apply the 'vectorized' function element-wise. Preserve structure and handle `None`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is the sine of the corresponding input element. The output array must have the same length as the input array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a new 1D array where each element is the cosine of the corresponding input element. The output array must have the same length as the input array."
    },
    {
        "instruction": "Write a higher-order function `apply_elementwise` that takes two arguments: a function `op` (which operates on a single number) and a 1D numerical array `data`. `apply_elementwise` should return a new 1D array where each element is the result of applying `op` to the corresponding element in `data`."
    },
    {
        "instruction": "Develop a function that generates a 1D numerical array representing a sequence of integers from 0 up to (but not including) a given positive integer `N`."
    },
    {
        "instruction": "Develop a function that takes two 1D numerical arrays of equal length and a function that accepts two numbers and returns a single number. The main function should apply the provided function element-wise to the corresponding elements of the input arrays and return a new 1D array containing the results."
    },
    {
        "instruction": "Implement a function that generates a 1D numerical array containing a sequence of floating-point numbers starting from 0.0 up to (but not including) a given positive integer `N`, with a step of 1.0."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a single scalar number. It should return a new 1D array where the scalar has been added to every element of the input array."
    },
    {
        "instruction": "Create a function that accepts three 1D numerical arrays, all of the same length. It should return a new 1D array where each element is the sum of the elements at the corresponding positions in the three input arrays."
    },
    {
        "instruction": "Write a function `process_batch` that accepts two arguments: `batch_data` (a list of numerical values) and `fixed_param` (a single numerical value). Internally, define a simple binary operation (e.g., addition). Apply this operation sequentially to each element in `batch_data` using `fixed_param` as the second operand. Return a list containing the results of each operation. Ensure the function processes the batch elements one by one."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical array `data` and a scalar value `scalar`. It should return a new 1D array where each element is the result of adding `scalar` to the corresponding element in `data`."
    },
    {
        "instruction": "Write a function that accepts two numerical scalar inputs and returns their sum."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array (e.g., a list of numbers) and returns a new array of the same size where each element is incremented by 1."
    },
    {
        "instruction": "Create a function `check_function_readiness` that takes a function object as input. It should return `True` if the function object has a specific attribute (e.g., `_config_status`) set to 'ready', and `False` otherwise."
    },
    {
        "instruction": "Design a function `apply_transform` that takes a numerical input `x`. This function relies on an external configuration step. Add a check within the function: if a specific configuration flag (e.g., a boolean variable `TRANSFORM_DEFINED` in the function's scope or global scope) is not `True`, raise an `AttributeError`. If the flag is `True`, return the sine of the input `x`."
    },
    {
        "instruction": "Implement a function `execute_safely` that accepts two arguments: a function `func` and an argument `arg`. This function should check if `func` has an attribute named `_is_set_up` with a value of `True`. If the attribute exists and is `True`, call `func(arg)` and return the result. Otherwise, raise an `AttributeError` indicating that the function is not set up."
    },
    {
        "instruction": "Write a Python decorator `ensure_configured` that checks if a global boolean variable `IS_READY` is True. If `IS_READY` is False, the decorator should cause the decorated function to raise an `AttributeError` with the message 'Configuration missing!' when called. Otherwise, the decorated function should execute normally."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is the cosine of the corresponding input element."
    },
    {
        "instruction": "Write a function that takes a single numerical value and returns its sine."
    },
    {
        "instruction": "Implement a function that accepts one argument. If the argument is a single number, return its sine. If the argument is a 1D numerical array, return a new 1D array containing the cosine of each element from the input array."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array as input. It should return two values: a new 1D array where each element is the cosine of the corresponding input element, and the integer size (number of elements) of the input array."
    },
    {
        "instruction": "Create a function that generates a 1D numerical array containing a specified number of evenly spaced values over a given interval. Inputs: start value, end value, number of points. Output: 1D array."
    },
    {
        "instruction": "Write a function that takes two numerical inputs, `x` and `y` (which can be scalars or arrays of the same shape), and returns the element-wise result of `sin(x) * y`."
    },
    {
        "instruction": "Implement a function simulating a \"forward pass\". Given two numerical inputs `x` and `y` (scalar or array), return two outputs: the primary result `sin(x) * y`, and a tuple containing intermediate values `(cos(x), sin(x), y)` needed for a subsequent calculation. Ensure element-wise operations for arrays."
    },
    {
        "instruction": "Define a function that processes two 1D numerical input arrays, `xs` and `ys`, of the same length using a specific batched operation. For each corresponding pair of elements `xs[i]` and `ys[i]`, compute `cos(xs[i]) * ys[i]`. Return a new 1D array containing these results. Implement this as a single conceptual batch operation rather than iterating."
    },
    {
        "instruction": "Define a function `configure_settings` that takes one positional argument `config_id` (integer) and one keyword-only argument `verbose` (boolean, default False). If any other keyword argument (e.g., `debug=True`) is passed during the call, raise a `TypeError` with a message formatted exactly as \"Error: Unexpected keyword argument: '[argument_name]'\", where [argument_name] is the name of the unexpected argument."
    },
    {
        "instruction": "Implement a function `safe_apply` that takes a function `func` and arguments `*args`, `**kwargs`. Before calling `func(*args, **kwargs)`, check if `func` requires a specific positional argument named 'y' and if it's missing in `args/kwargs`. If 'y' is missing, raise a `TypeError` with the message \"Call Error for [func_name]: Missing 'y'\", where [func_name] is the name of the passed function. Otherwise, call `func` and return its result."
    },
    {
        "instruction": "Write a function `calculate_value` that accepts two positional numerical arguments `a` and `b`, and an optional keyword-only numerical argument `c` (defaulting to 1). The function should return `a + b * c`."
    },
    {
        "instruction": "Develop a general-purpose function argument validator `validate_wrapper`. It should accept a function `target_func` as input. `validate_wrapper` should return a new function (a wrapper). When this wrapper is called with arbitrary arguments (`*args`, `**kwargs`), it must inspect `target_func`'s signature. If a required positional argument is missing, raise `TypeError(\"Validation Error for [func_name]: Missing required argument: '[arg_name]'\")`. If an unexpected keyword argument is provided (one not defined in `target_func`'s signature), raise `TypeError(\"Validation Error for [func_name]: Unrecognized keyword argument: '[arg_name]'\")`. If arguments are valid, call `target_func` with them and return the result. Use the actual function name and argument names in the error messages."
    },
    {
        "instruction": "Write a function that accepts a boolean value and another value of any type. If the boolean is true, the function should return the second value; otherwise, it should return a null or None value."
    },
    {
        "instruction": "Implement a function that receives a boolean condition and two other values (value_A, value_B). Return value_A if the condition is true, and value_B if the condition is false."
    },
    {
        "instruction": "Create a function that takes three arguments: a boolean flag, a primary value, and a default value. The function should return the primary value if the flag is true, and the default value if the flag is false."
    },
    {
        "instruction": "Write a function that takes a single argument of any type and returns `True` if the argument evaluates to true in a boolean context, and `False` otherwise."
    },
    {
        "instruction": "Develop a function `process_if_enabled` that takes a single numerical value `item`. Assume an internal 'enabled' status is permanently set to true. The function should return the `item` if this status is true, otherwise return `None`."
    },
    {
        "instruction": "Write a function that accepts two arguments: a boolean `switch` and a value `data`. The function should return `data` if `switch` is true, and `None` otherwise."
    },
    {
        "instruction": "Create a function that takes a boolean `is_active` and an integer `id_code`. Return the `id_code` only if `is_active` is true; otherwise, return `None`."
    },
    {
        "instruction": "Implement a function `configure_conditional_returner` that accepts a fixed boolean setting `always_return`. This function should return a *new* function. The new function takes one argument `payload`. When called, this new function returns `payload` if `always_return` was true during configuration, otherwise it returns `None`."
    },
    {
        "instruction": "Develop a function that takes a value potentially representing a 64-bit signed integer. The function should conceptually act as an identity function (return the input). However, it must first validate if the input value falls within the valid range for a 64-bit signed integer. If it does not, raise an `OverflowError`. If it does, return the value, ensuring it is represented as a 64-bit signed integer."
    },
    {
        "instruction": "Create a function that takes a numerical value and returns `True` if it can be exactly represented as a standard 64-bit signed integer, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that accepts a numerical value. If the value is outside the range of a standard 64-bit signed integer, it should raise an `OverflowError`. Otherwise, it should return the value unchanged, ensuring the output is specifically represented as a 64-bit signed integer."
    },
    {
        "instruction": "Write a function that returns the minimum and maximum representable values for a standard 64-bit signed integer."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (vector) and computes the sum of the squares of its elements. Input: 1D array. Output: scalar number."
    },
    {
        "instruction": "Given a function `func` that takes a single 1D numerical array `v` of size N and returns a scalar, create a function to compute the second derivative (Hessian) of `func` with respect to `v`. The result should be an N x N numerical matrix."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays, `vec1` and `vec2`. It should return a single scalar value representing the sum of (the sum of squares of `vec1`'s elements) and (the sum of squares of `vec2`'s elements)."
    },
    {
        "instruction": "Given a function `func` that takes a single 1D numerical array `v` of size N and returns a scalar, implement a function that calculates the first derivative (gradient) of `func` with respect to `v`. The output should be a 1D numerical array of size N."
    },
    {
        "instruction": "Implement a function that determines if a numerical array can be unambiguously converted to a boolean value. It should return True if the array has one element (truthiness depends on the element's value, standard Python rules apply), but raise a ValueError if the array is empty or has more than one element."
    },
    {
        "instruction": "Write a function that accepts a numerical array and checks if it contains exactly one element. Return True if it does, False otherwise."
    },
    {
        "instruction": "Create a function that takes a numerical array. If it contains exactly one element and that element is an integer, return the integer value. Otherwise, return a special value (e.g., None or raise a specific custom error) to indicate failure."
    },
    {
        "instruction": "Develop a function that attempts to convert a numerical array to a standard Python integer. It should only succeed if the array contains exactly one numerical element (which can be safely cast to an integer, e.g., 5.0 or 5). Raise a TypeError if the array is not a single element or if the element's type is incompatible (e.g., complex)."
    },
    {
        "instruction": "Implement a function that simulates a system over multiple discrete time steps. It takes an initial state (a pair of 2D numerical arrays `(u_initial, u_t_initial)`), an integer number of steps `n`, a scalar time step `dt`, and a scalar constant `c`. In each step `i` from 0 to `n-1`, update the state using the rule: `u_tt = c**2 * u`, `u_t_new = u_t + u_tt * dt` (where `u` and `u_t` are the state components from the *previous* step). The `u` component remains unchanged throughout the simulation. Return the final state `(u_initial, u_t_final)` after `n` steps."
    },
    {
        "instruction": "Create a function that performs one step of a state update. It accepts a state represented by a pair of 2D numerical arrays `(u, u_t)` of the same shape, a scalar time step `dt`, and a scalar constant `c`. It should calculate an intermediate 2D array `u_tt = c**2 * u` and return the updated state as a new pair `(u, u_t + u_tt * dt)`."
    },
    {
        "instruction": "Develop a function that initializes a simulation state. Given a 2D numerical array `u0`, it should return a pair `(u0, zero_array)`, where `zero_array` is a 2D numerical array with the same shape and data type as `u0` but contains only zeros."
    },
    {
        "instruction": "Write a function to compute a loss value based on mean squared error. It takes two 2D numerical arrays, `predicted_u` and `target_u`, which must have the same shape. Calculate and return the scalar mean of the squared differences between corresponding elements of the two input arrays."
    },
    {
        "instruction": "Write a function that takes another function `f` and an argument `x` as input. Call `f(x)` and return `True` if the result is a single numerical value (integer or float), and `False` otherwise (e.g., if it returns a list, tuple, or array)."
    },
    {
        "instruction": "Implement a function that takes a value as input. It should return `True` if the input is *not* a single scalar number (e.g., it is a list, tuple, array, or None), and `False` if it is a single scalar number."
    },
    {
        "instruction": "Develop a function `attempt_operation(value, op_func)`. If `value` is a single scalar number, apply the function `op_func` to it and return the result. If `value` is not a single scalar number, raise a `TypeError` with the message \"Operation requires a scalar input.\""
    },
    {
        "instruction": "Design a safe wrapper function `safe_apply(operation, func, arg)`. This wrapper first calls `func(arg)`. It must check if the result is a single scalar number. If it is, the wrapper then calls `operation` with this scalar result and returns the outcome. If the result from `func(arg)` is *not* a scalar, the wrapper must raise a `TypeError` indicating that the operation could not be applied due to non-scalar output from `func`."
    },
    {
        "instruction": "Create a function `vector_identity(input_vector)` that takes a 1D numerical array (vector) and returns the exact same vector."
    },
    {
        "instruction": "Develop a function `apply_scalar_restricted_op(func, input_arg)` that first calls `func(input_arg)`. If the result is a scalar number, the function should return this result. If the result is *not* a scalar number (e.g., an array or list), it must raise a `TypeError` with a message indicating that the operation is only defined for functions with scalar outputs."
    },
    {
        "instruction": "Implement a function `check_scalar_output(func, input_arg)` that executes `func(input_arg)` and returns `True` if the result is a single scalar number, and `False` otherwise."
    },
    {
        "instruction": "Create a function `output_validator_wrapper(validation_rule_func, target_func)` that returns a *new* function. This new function, when called with some arguments, should first execute `target_func` with those arguments. It should then pass the result of `target_func` to `validation_rule_func`. If `validation_rule_func` returns `False`, the new function must raise a `ValueError` indicating an output validation failure. Otherwise, it should return the result from `target_func`."
    },
    {
        "instruction": "Implement a function that takes an error message string as input. It should return `True` if the string contains the exact phrase 'The numpy.ndarray conversion' (case-sensitive), and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a list of numbers and returns a new list containing the exponential (`e^x`) of each number in the input list."
    },
    {
        "instruction": "Create a function `check_processor` that takes one argument: a 'processor' function. Inside `check_processor`, define a simple calculation function, `exp_list`, that takes a list of numbers (e.g., `[0.0, 0.0, 0.0]`) and returns a new list with each element exponentiated. Then, `check_processor` should call the 'processor' function, passing `exp_list` as its argument (e.g., `processor(exp_list)`). If this call raises *any* `Exception`, `check_processor` should return `True`. If the call completes without an exception, it should return `False`."
    },
    {
        "instruction": "Create a function that accepts a positive integer `n` and returns a list containing `n` floating-point zeros (0.0)."
    },
    {
        "instruction": "Create a function that accepts two positive integers, `n` and `m`. It should return a message string stating whether arrays of size `n` and `m` are compatible for a dot product (e.g., \"Arrays of size 3 and 3 are compatible.\" or \"Arrays of size 3 and 4 are not compatible.\")."
    },
    {
        "instruction": "Implement a function to compute the dot product of two 1D numerical arrays (vectors). If the vectors do not have the same size, the function should raise a `ValueError` with a message indicating the shape mismatch."
    },
    {
        "instruction": "Develop a function that attempts to multiply a matrix (2D numerical array of shape M x N) by a vector (1D numerical array of shape K). The function should first check if N equals K. If they are not equal, raise a `TypeError` indicating the incompatible dimensions. If compatible, return a placeholder value (e.g., `None` or `0`), as the actual multiplication logic is not required."
    },
    {
        "instruction": "Write a function that accepts two matrices (2D numerical arrays) with shapes (M x N) and (P x Q). Check if they are compatible for standard matrix multiplication (i.e., if N equals P). If not compatible, raise a `ValueError` detailing the mismatch (e.g., \"Incompatible shapes for multiplication: (MxN) and (PxQ)\"). If compatible, return `True`."
    },
    {
        "instruction": "Write a function that takes a nested structure (potentially containing lists, tuples, numerical scalars, and numerical arrays). Calculate the total number of elements K across all leaves. Return a new structure, mirroring the input structure, where each original scalar/array leaf is replaced by a numerical array of shape (K, *original_leaf_shape). Each of these output arrays represents the corresponding segment of a K x K identity matrix, appropriately reshaped."
    },
    {
        "instruction": "Create a function that accepts a potentially nested structure (lists/tuples) containing numerical arrays and numerical scalars. It should return the total count of individual numerical elements across all arrays and scalars within the structure."
    },
    {
        "instruction": "Implement a function that takes three positive integers K, M, and N. It should generate a K x K identity matrix and then reshape it into a 3D numerical array of shape (K, M, N). Assume K = M * N."
    },
    {
        "instruction": "Write a function that takes a positive integer N and returns an N x N identity matrix (a 2D numerical array with 1s on the main diagonal and 0s elsewhere)."
    },
    {
        "instruction": "Develop a function that first creates a 1D numerical array of a fixed size (e.g., length 3) filled entirely with the complex number `1 + 1j`, and then returns the string representation of this specific array."
    },
    {
        "instruction": "Write a function that takes an integer `n` and returns a 1D numerical array (e.g., a list) of length `n` containing only floating-point zeros."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array as input and verifies if all elements within the array are of a specific numerical type (e.g., all complex numbers, or all floating-point numbers). Return `True` if they are, `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array (which could contain integers, floats, or complex numbers) as input and returns a string representation of that array. The string should clearly display the array's contents."
    },
    {
        "instruction": "Implement a function that accepts two scalar numerical inputs, `value` and `rate`. It should return the result of multiplying `1` by the `rate`. Ensure the output is always a floating-point number."
    },
    {
        "instruction": "Develop a function that accepts a single floating-point scalar input named `tangent`. The function should return this `tangent` value unchanged, ensuring the output is also a floating-point scalar."
    },
    {
        "instruction": "Write a function that takes a single numerical input (integer or float) and returns the exact same value, preserving the input type."
    },
    {
        "instruction": "Write a function that takes another function `func` and a single numerical value `input_val` as input. It should apply `func` to `input_val` and return the result. Demonstrate its use with a function that simply returns its input."
    },
    {
        "instruction": "Write a function that accepts a single number as input and returns that number incremented by exactly 1."
    },
    {
        "instruction": "Design a function that simulates applying a directional derivative. It accepts an initial numerical value 'p' and a directional floating-point value 't'. Assume the operation being differentiated is adding a constant (e.g., f(p) = p + 5). Return the result of multiplying the derivative of this operation (which is 1) by the directional value 't'."
    },
    {
        "instruction": "Create a function that takes a single numerical input (integer or float) and returns a floating-point zero (0.0), regardless of the input value."
    },
    {
        "instruction": "Implement a function that calculates the mathematical derivative of the function f(x) = x + C (where C is any constant) with respect to x. The function should return this constant derivative value (which is 1)."
    },
    {
        "instruction": "Implement a function that accepts two arguments: an integer `val` and a float `rate`. It should compute `result = val + 1`. The function should return a tuple containing the integer `result` and the original float `rate`."
    },
    {
        "instruction": "Write a function that accepts a single integer input and returns that integer incremented by exactly one."
    },
    {
        "instruction": "Develop a function that accepts two tuples as input: the first containing a single integer (e.g., `(5,)`) and the second containing a single float (e.g., `(0.0,)`). The function should ignore the first tuple and return the float value contained within the second tuple."
    },
    {
        "instruction": "Write a function that takes an integer `primary_input` and a floating-point `sensitivity_input`. It should calculate `primary_output = primary_input + 1`. Return a floating-point `sensitivity_output` which is calculated as `1.0 * sensitivity_input`."
    },
    {
        "instruction": "Write a function that takes a single floating-point number, converts it to an integer (discarding the fractional part), adds 1 to the integer result, and returns the final integer."
    },
    {
        "instruction": "Develop a function that simulates a floor operation for positive numbers. It should accept a positive floating-point number and return the largest integer value less than or equal to the input."
    },
    {
        "instruction": "Create a function that takes one numerical argument and returns the result of adding the constant value 1 to it. Ensure the output type matches the type after addition."
    },
    {
        "instruction": "Create a function that takes a floating-point number `x`. Define an inner operation that converts `x` to an integer (truncating decimals) and adds 1. The function should return two values: the integer result of this inner operation, and the floating-point value 0.0 (representing the zero rate of change due to the conversion)."
    },
    {
        "instruction": "Develop a function simulating gradient propagation for an indexing operation. It should accept: (1) the shape of an original 1D numerical array, (2) an integer index `i` used in a prior indexing step, and (3) a scalar numerical gradient `g` flowing back from the result of the indexing. The function must return two outputs: first, a 1D numerical array of the input shape representing the gradient w.r.t. the original array (it should have `g` at index `i` and zeros elsewhere), and second, a scalar zero representing the gradient w.r.t. the integer index `i`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and an integer index `i`. It should return the element located at that index. Assume the provided index is always valid within the bounds of the array."
    },
    {
        "instruction": "Implement a function that takes the shape of a 1D numerical array (e.g., `(N,)`), an integer index `i`, and a scalar numerical value `g`. Return a new 1D numerical array of the specified shape, filled with zeros, where the element at index `i` is set to the value `g`. Assume `i` is a valid index."
    },
    {
        "instruction": "Write a function that takes no arguments and returns a single scalar numerical value representing zero (0.0)."
    },
    {
        "instruction": "Develop a function `get_output_spec`. It takes another function `op` (which performs an array transformation like reshape) and an input array `data`. Apply `op` to `data` and return a description (e.g., a tuple) of the resulting array's shape and data type."
    },
    {
        "instruction": "Create a function that accepts a shape tuple (e.g., `(2, 2)`) and a numerical data type identifier (e.g., 'float'). Return a new array filled with zeros, matching the specified shape and data type."
    },
    {
        "instruction": "Write a function that takes a numerical array and a target shape (tuple). Return a new array containing the same elements but rearranged into the target shape. Ensure the total number of elements is conserved."
    },
    {
        "instruction": "Design a function `describe_gradient_properties`. It accepts an array transformation function `func`, an input array `in_arr`, and a 'sensitivity' array `out_sens` (which has the shape and data type of the *output* of `func(in_arr)`). Return the expected *shape* and *data type* of the computed gradient corresponding to `in_arr`. The gradient shape must match `in_arr`'s shape, and its data type should match `out_sens`'s data type."
    },
    {
        "instruction": "Create a function that takes a specific numerical data type description (e.g., 'float', 'int') and returns a scalar zero value of that exact type."
    },
    {
        "instruction": "Develop a function that takes two scalar numerical inputs `x` and `y`, and a scalar numerical 'sensitivity' value `s`. The function should return two results: first, the sum `x + y`, and second, a pair of values `(sx, sy)` where `sx` is `s` propagated back to `x` and `sy` is `s` propagated back to `y` (based on the addition operation). Ensure the types of `sx` and `sy` match the type of `s`."
    },
    {
        "instruction": "Write a function that accepts two numerical scalar inputs (which can be integers or floats) and returns their sum. Ensure the output type accommodates potential floating-point results."
    },
    {
        "instruction": "Write a function that simulates the backward propagation of sensitivities for the addition operation `z = x + y`. Given an incoming scalar sensitivity `s` (representing the influence on `z`), the function should return a pair of corresponding sensitivities for `x` and `y`, calculated using the chain rule."
    },
    {
        "instruction": "Implement a function that calculates the sum of all elements in a given multi-dimensional numerical array and returns the result as a single scalar value."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array `template_arr` and a scalar value `fill_val`. It should return a new array with the same dimensions (shape) as `template_arr` but filled entirely with `fill_val`."
    },
    {
        "instruction": "Write a function that simulates a simplified gradient calculation step. It takes two multi-dimensional numerical arrays of the same shape: `output_gradient` and `original_input_array`. It should return a new array with the same shape as `original_input_array` but filled entirely with zeros. This represents a zero gradient contribution."
    },
    {
        "instruction": "Design a function that takes a multi-dimensional numerical array `output_gradient` and an *integer* scalar `original_fill_value`. The function should simulate calculating a gradient with respect to this integer input, assuming the gradient is structurally zero in this context. It must return a single scalar zero value, irrespective of the `output_gradient` content."
    },
    {
        "instruction": "Implement a function that takes two arguments: another function `func` (which accepts a single numerical argument) and a numerical value `val`. Your function should execute `func` with `val` as input and return the result."
    },
    {
        "instruction": "Design a function named `pseudo_derivative` that accepts two arguments: a function `f` (taking one numerical input) and a numerical value `x`. If `x` is an integer, the function should return a scalar floating-point zero. If `x` is a float, it should return a scalar floating-point one (as a placeholder for a derivative)."
    },
    {
        "instruction": "Create a function that takes no arguments and returns a scalar floating-point value representing zero."
    },
    {
        "instruction": "Write a function that accepts a single numerical input (which can be an integer or a float) and explicitly converts it to a floating-point type before returning it."
    },
    {
        "instruction": "Implement a function that takes a boolean value. Based on the boolean, it internally selects one of two predefined constant floating-point values (1.0 for true, 2.0 for false). The function should return a tuple containing: first, the selected floating-point value, and second, a scalar floating-point zero (`0.0`)."
    },
    {
        "instruction": "Design a function `conditional_processor` that takes a boolean input and returns a numerical output (e.g., 1.0 if true, 2.0 if false). Create a *wrapper* function `analyze_output` that takes `conditional_processor` (or any function following its signature) and a boolean value as input. `analyze_output` should call the provided function with the boolean value and return a pair: the result from the called function, and the scalar float `0.0`."
    },
    {
        "instruction": "Write a function that accepts a single boolean value. If the boolean is true, return the floating-point number `1.0`. Otherwise, return the floating-point number `2.0`."
    },
    {
        "instruction": "Write a higher-order function named `select_and_run`. It accepts three arguments: a boolean value `pred`, a function `func_true`, and a function `func_false`. Both `func_true` and `func_false` take no arguments and return a floating-point number. `select_and_run` should execute `func_true` if `pred` is true, and `func_false` otherwise, returning the result."
    },
    {
        "instruction": "Create a function that accepts the size of a 1D numerical array (let's say `N`) and an integer index `i` (where `0 <= i < N`). It should return a new 1D numerical array of size `N` containing all zeros, except for the element at index `i`, which should be 1.0."
    },
    {
        "instruction": "Design a function that simulates computing the sensitivity of an array indexing operation. It takes a 1D numerical array `arr` and an integer index `idx`. It should return two results: (1) an array of the same shape as `arr` where the element at `idx` is 1.0 and all others are 0.0 (representing the sensitivity of the output `arr[idx]` to changes in each element of `arr`), and (2) a scalar 0.0 (representing the sensitivity of the output `arr[idx]` to a change in the discrete index `idx`)."
    },
    {
        "instruction": "Develop a function that takes any single integer as input and returns a single numerical zero (scalar 0.0)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and an integer index `i`. It should return the element of the array located at index `i`."
    },
    {
        "instruction": "Create a function that accepts a single integer as input and always returns a single floating-point value of 0.0."
    },
    {
        "instruction": "Write a function that simulates sensitivity analysis for an element selection operation. It takes a list of numbers `data` and an integer `index`. It should return two results: (1) A list of the same size as `data` indicating the sensitivity of the output (`data[index]`) to a unit change in each input element (this list will contain `0.0`s and one `1.0`). (2) A float value `0.0` representing the sensitivity of the output with respect to the integer index itself. Assume the index is valid."
    },
    {
        "instruction": "Write a function that takes a list of numbers and an integer index `i`. It should return the number located at that index in the list. Assume the provided index is always valid (within the bounds of the list)."
    },
    {
        "instruction": "Develop a function that accepts a list of floating-point numbers `data` and an integer `index`. The function should return exactly two values: first, a list of the same size as `data` containing `0.0` everywhere except for `1.0` at the given `index`; second, a single floating-point value `0.0`. Assume the index is valid."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix) of shape (M, N) and returns its transpose, which is a new 2D array of shape (N, M) where rows and columns are swapped."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and returns a new 2D numerical array (matrix) of shape (`rows`, `cols`) filled entirely with zeros."
    },
    {
        "instruction": "Write a function that receives a 2D numerical array (matrix) guaranteed to contain only zeros. The function should return the transpose of this input matrix, ensuring the output is also a matrix of zeros but with swapped dimensions."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) and two positive integers representing a new shape (`new_rows`, `new_cols`). Return a new 2D array containing the same elements but rearranged into the specified shape. Assume the total number of elements is preserved."
    },
    {
        "instruction": "Develop a function `apply_binary_op_safely(operation_func, operand1, operand2)` that takes a function `operation_func` (representing a binary arithmetic operation like addition) and two operands. It should first check if either `operand1` or `operand2` is the 'restricted zero' type. If so, raise a `TypeError`. Otherwise, execute `operation_func(operand1, operand2)` and return its result."
    },
    {
        "instruction": "Create a function `raise_if_restricted(value)` that accepts one input. If the input `value` is the special 'restricted zero' type, it must raise a `TypeError`. If the input is any other value, the function should return without error."
    },
    {
        "instruction": "Write a function `verify_operation_restriction(operation_func, restricted_value, normal_value)` that takes a binary operation function, a 'restricted zero' value, and a normal numerical value. It must attempt to execute `operation_func(restricted_value, normal_value)`. The function should return `True` if this specific execution attempt raises a `TypeError`, and `False` otherwise (including cases where no error or a different error occurs)."
    },
    {
        "instruction": "Implement a function `safe_add(a, b)` that takes two numerical inputs. If either `a` or `b` is the special 'restricted zero' type, the function must raise a `TypeError` with the exact message 'Operation not supported for restricted zero'. Otherwise, it returns the standard numerical sum of `a` and `b`."
    },
    {
        "instruction": "Write a function that creates a numerical array initialized with a range of numbers from 0 up to (but not including) an integer `N`. The function accepts `N` and a required data type string (e.g., 'int64', 'float64'). The function must create the array using the *exact* data type specified, even if it's a higher-precision type (like 64-bit) than a potential system default (which might be 32-bit). Return the resulting array."
    },
    {
        "instruction": "Create a function that accepts a list of integers (e.g., `[10, 20, 30]`) and returns a numerical array containing these integers, explicitly ensuring the array uses a 32-bit integer data type."
    },
    {
        "instruction": "Write a function that takes a shape tuple (e.g., `(5,)` or `(3, 4)`) and returns a new numerical array of that shape filled with ones, using the system's default floating-point data type."
    },
    {
        "instruction": "Implement a function that takes an integer `N` and returns an N x N identity matrix (1s on the diagonal, 0s elsewhere). Allow an optional argument to specify the desired numerical data type string (e.g., 'float32', 'float64'). If unspecified, use a default floating-point type."
    },
    {
        "instruction": "Implement a function that takes a processing function `op`, a constant argument `config`, and a 1D numerical array `data`. The `op` function accepts two arguments (`config`, `element`). Your function should apply `op` to each `element` in `data` (passing `config` each time) and return a new 1D array containing the results."
    },
    {
        "instruction": "Create a function that simulates vectorized execution. It takes a function `f`, a dictionary `static_arg`, and two 1D numerical arrays `arr1` and `arr2` of the same length N. The function `f` takes three arguments: the dictionary `static_arg`, an element from `arr1`, and an element from `arr2`. Your function should effectively compute `f(static_arg, arr1[i], arr2[i])` for each index `i` from 0 to N-1. Assume each call to `f` returns a 1D array of a fixed size K. Return a 2D array of shape N x K containing the stacked results."
    },
    {
        "instruction": "Write a function that accepts a dictionary containing two keys: 'scalar_val' (a single number) and 'array_val' (a 1D numerical array). Return the result of adding the scalar value to every element of the 1D array."
    },
    {
        "instruction": "Develop a function that accepts three arguments: a dictionary `params`, a 1D numerical array `x`, and a 1D numerical array `y`. Inside the function, access a scalar value associated with key 'a' and a 1D array value associated with key 'b' from `params`. Return the result of `params['a'] + params['b'] + x + y`, assuming standard element-wise addition and broadcasting rules apply between the arrays."
    },
    {
        "instruction": "Develop a function that takes a dictionary and a string key. Return the value associated with the key within the dictionary. If the key is not found, raise a `KeyError`."
    },
    {
        "instruction": "Create a function that takes two inputs: a sequence (like a list or tuple) representing argument processing rules, and an integer representing the number of arguments a target function takes. Return `True` if the length of the sequence matches the integer, `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts another function as input and returns the count of its required positional arguments."
    },
    {
        "instruction": "Design a higher-level function `setup_operation` that accepts a target function and a configuration specification (e.g., a list or tuple). This specification dictates how the target function's arguments should be handled. Before proceeding, `setup_operation` must validate that the specification's structure (e.g., its length if it's a list/tuple) is compatible with the target function's signature (e.g., number of positional arguments). If incompatible, raise a `ValueError` explaining the incompatibility. If compatible, return a status indicating readiness (e.g., `True`)."
    },
    {
        "instruction": "Write a function that accepts a single parameter. Check if the parameter's type is boolean. If it is, raise a `TypeError` with the message \"Boolean type is not allowed for this parameter.\" Otherwise, return the parameter itself."
    },
    {
        "instruction": "Develop a function that acts as a wrapper. It accepts another function (`target_func`), a configuration value (`config`), and data (`*args`, `**kwargs`) to pass to the `target_func`. Before calling `target_func`, check if `config` is an integer. If not, raise a `TypeError` stating \"Configuration value must be an integer.\". If it is an integer, call `target_func` with `*args` and `**kwargs` and return its result."
    },
    {
        "instruction": "Write a function that accepts one argument. If the argument is not an integer, raise a `TypeError` with the message \"Argument must be an integer.\". Otherwise, return the integer."
    },
    {
        "instruction": "Implement a function that takes a configuration dictionary and a specific key name. It should check if the value associated with that key in the dictionary is an integer. If the key exists and its value is an integer, return the value. If the key exists but the value is not an integer, raise a `TypeError` indicating the key requires an integer value. If the key does not exist, return `None`."
    },
    {
        "instruction": "Develop a function `apply_transform` which accepts a transformation function `func` and a configuration argument `mapping_rule`. Before proceeding, validate that `mapping_rule` is an integer. Raise a `TypeError` with the message \"Mapping rule must be an integer.\" if `mapping_rule` is any non-integer type (pay special attention to boolean types). If valid, the function should return `True` (simulating successful setup)."
    },
    {
        "instruction": "Write a function `validate_parameter_type` that takes a parameter `param`. It should specifically check if `param`'s type is boolean. If it is, raise a `TypeError` indicating that boolean values are not allowed for this parameter and an integer is expected. If `param` is not a boolean, return `True`."
    },
    {
        "instruction": "Create a function `check_index` that takes a single parameter `idx`. Verify that `idx` is an integer. If `idx` is not an integer (including booleans), raise a `TypeError` stating \"Index parameter must be an integer.\" If it is an integer, return the index."
    },
    {
        "instruction": "Write a function that accepts one argument `config_value`. If `config_value` is of boolean type, raise a `TypeError` with the message \"Configuration value must be an integer, not a boolean.\" Otherwise, return `None`."
    },
    {
        "instruction": "Create a function `check_same_length` that takes two 1D numerical sequences (like lists or tuples). If they do not have the same number of elements, raise a `ValueError` with the message \"Sequences must have the same length\". Otherwise, return `True`."
    },
    {
        "instruction": "Design a function `create_validator` that accepts a single argument, `prototype` (which can be a scalar number or a 1D numerical sequence). This function should return a *new* function, let's call it `validate`. The returned `validate` function accepts one argument, `data`. When called, `validate` must check if `data` has the exact same structure (scalar vs. 1D sequence) and shape (length if 1D sequence) as the original `prototype`. It must also ensure `data` represents a floating-point type (scalar float or sequence of floats). If any check fails, `validate` should raise a `ValueError` with the message \"Data inconsistent with prototype\". Otherwise, `validate` should return `None`."
    },
    {
        "instruction": "Write a function `check_float` that accepts two arguments. It should raise a `TypeError` with the message \"Input must be float\" if the *second* argument is not a floating-point number. Otherwise, it should return `True`."
    },
    {
        "instruction": "Write a function `compare_and_validate_float` that takes two arguments, `arg1` and `arg2`. These arguments can be numerical scalars or 1D numerical sequences. The function must first check if `arg1` and `arg2` have the same structure (both scalars, or both 1D sequences of the same length). If the structures differ, it should raise `ValueError(\"Inconsistent structure\")`. If the structures match, it must then check if `arg2` represents a floating-point type (is a float scalar, or is a sequence containing only floats). If this type check fails, it should raise `TypeError(\"Argument 2 must be float type\")`. If both structure and type checks pass, the function should return `True`."
    },
    {
        "instruction": "Write a function `compare_device_sets` that takes two arguments, each representing a collection of device identifiers (e.g., a list or set of strings). Return `True` if both collections contain the exact same device identifiers, irrespective of order, and `False` otherwise."
    },
    {
        "instruction": "Implement a context manager class `TemporaryDefaultDevice`. It should accept a `new_device_id` during initialization. On entering the context (`__enter__`), it should store the *current* default device ID (obtained via a hypothetical `get_current_default_device()`) and set the default device to `new_device_id` (using a hypothetical `set_current_default_device(id)`). On exiting (`__exit__`), it must restore the default device ID to the one stored upon entry."
    },
    {
        "instruction": "Write a function `check_device_context`. It should: 1. Get the initial default device ID using `get_current_default_device()`. 2. Define a `target_device_id`. 3. Use the `TemporaryDefaultDevice` context manager (from Task 3) with `target_device_id`. 4. Inside the context, call `get_current_default_device()` and verify it returns `target_device_id`. 5. After the context block, call `get_current_default_device()` again and verify it returns the initial default device ID. Return `True` if all checks pass, `False` otherwise. (Assume `get_current_default_device` and `set_current_default_device` exist)."
    },
    {
        "instruction": "Write a function `create_array_and_get_device` that simulates creating a 1-element numerical array and returns the identifier of the device it was notionally created on. Assume a function `get_current_default_device()` exists and returns this identifier (e.g., 'cpu:0', 'gpu:1')."
    },
    {
        "instruction": "Create a mechanism (e.g., a class with context management methods or global functions) to set and temporarily override a global default 'accuracy_level' ('low', 'medium', 'high') for computational tasks within a specific code block."
    },
    {
        "instruction": "Develop a matrix multiplication function for two compatible 2D numerical arrays. It should accept an optional 'accuracy_level' parameter ('low', 'medium', 'high'). If provided, this level is used. If omitted, the function must retrieve and use the current global default 'accuracy_level' (as set by a mechanism like in Task 3). Return the matrix product."
    },
    {
        "instruction": "Write a function that simulates inspecting the configuration of a planned computation. It takes an object representing a matrix multiplication task, which has an attribute storing the intended 'accuracy_level' (e.g., 'low', 'medium', 'high', or 'default'), and returns the string value of that accuracy level."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication on two compatible 2D numerical arrays. Include an optional string parameter named 'accuracy_level' which can be 'low', 'medium', or 'high'. The function should simulate using different internal calculation methods based on this parameter and return the resulting matrix."
    },
    {
        "instruction": "Design a function `inspect_operation` that takes another function `func` and its arguments `*args`. The `inspect_operation` function should call `func(*args)`. Based on a predefined rule (e.g., if the name of `func` contains 'dot' or 'matmul'), it should return a descriptive string like 'Precision: HIGH'. Otherwise, return 'Precision: DEFAULT'. Note: This simulates checking internal properties without accessing actual execution details."
    },
    {
        "instruction": "Implement a function to compute the matrix product (dot product) of two given 2D numerical arrays, `matrix_a` (shape M x N) and `matrix_b` (shape N x P). The function should return the resulting 2D array of shape M x P."
    },
    {
        "instruction": "Write a function that accepts two positive integers, `rows` and `cols`, and returns a 2D numerical array (matrix) of shape `(rows, cols)` filled entirely with zeros."
    },
    {
        "instruction": "Develop a function that takes a single positive integer `n`. Inside the function, create an `n x n` matrix filled with zeros. Then, compute the dot product of this matrix with itself. Return the resulting `n x n` matrix."
    },
    {
        "instruction": "Create a function that initializes a mutable container (like a list) with a single numeric value (e.g., 0). Define an inner function that increments this value by 1 each time it's called. The outer function should call the inner function once and return the final value stored in the container."
    },
    {
        "instruction": "Create a function `setup_incrementer`. This function should initialize a list containing a single number (e.g., 0). It should also define and return an inner function `increment` that, when called, modifies the number in the list by adding 1 and returns the new value."
    },
    {
        "instruction": "Create a function `wrap_call` that accepts another function `target_func` as input. `wrap_call` should return a *new* function. This new function, when invoked (e.g., `new_func()`), should simply call the original `target_func()` and return its result."
    },
    {
        "instruction": "Implement a function `detect_external_write`. This function accepts another function `worker_func` as input. `detect_external_write` should execute `worker_func`. If `worker_func`, during its execution, modifies any mutable variable defined *outside* its own scope, `detect_external_write` must raise a specific custom error (e.g., `ExternalWriteError`). Otherwise, it should return the result of `worker_func`."
    },
    {
        "instruction": "Write a function that accepts a single numerical value. It should return a tuple containing exactly three elements in this order: the original input value, the floating-point number `1.0`, and a 1-element numerical array containing the floating-point number `0.0`."
    },
    {
        "instruction": "Write a function that compares two strings, each representing a data structure (like the output of Task 4). The function should return `True` if the strings describe the same structure and types in the same order, ignoring leading/trailing whitespace on each line, and `False` otherwise. The comparison must be case-sensitive."
    },
    {
        "instruction": "Create a function that takes no arguments and returns a 1-dimensional numerical array of size 1, initialized with the value zero. Ensure the element type is a standard 32-bit float."
    },
    {
        "instruction": "Implement a function that takes another function `f` as input. Assume `f` accepts one numerical argument and returns a tuple of at least three elements. Your function should call `f` with a default numerical value (e.g., 0.0) and return the *third* element of the tuple returned by `f`."
    },
    {
        "instruction": "Create a function that analyzes a simple arithmetic operation on a single scalar input (e.g., adding a constant). Given the input's data type (e.g., 'integer', 'float'), return the data type and shape (always 'scalar', represented perhaps as an empty tuple `()`) of the result."
    },
    {
        "instruction": "Write a function that simulates the creation of a constant-filled 1D array. Given a desired length (e.g., 2) and a data type (e.g., 'float'), return a description of the resulting array's shape (e.g., `(2,)`) and its data type."
    },
    {
        "instruction": "Implement a function that takes a shape tuple (e.g., `()`, `(5,)`, `(2, 3)`) and a data type string (e.g., 'integer', 'float', 'boolean') and returns a structured representation (like a dictionary or a simple object) containing these two pieces of information, labeled clearly (e.g., `{'shape': (2,), 'dtype': 'float'}`)."
    },
    {
        "instruction": "Develop a function that analyzes a computation returning multiple values. The computation involves a scalar operation (like increment) on an input scalar and the creation of a fixed-size 1D array. Given the input scalar's type, return a structure (e.g., a list or tuple) describing the shape and data type of *each* of the two results."
    },
    {
        "instruction": "Create a function `create_zero_like` that takes a numerical scalar (integer or float) as input and returns a scalar zero of the *same type* as the input. For example, input `5` (int) returns `0` (int), input `3.14` (float) returns `0.0` (float). If the input represents a special zero-dimensional type, return a corresponding zero value."
    },
    {
        "instruction": "Implement a function `apply_custom_logic` that takes two arguments: `primals` (a pair of numerical input values, e.g., `(float, int)`) and `tangents` (a pair of 'direction' values, where the second element might be a special 'zero-type' scalar). This function should first compute the 'primal output' which is simply the `primals` pair itself. Then, it should compute 'tangent outputs' based on a specific rule: the first tangent output is always the float `2.0`, and the second tangent output is a zero value whose type matches the type of the second element in `primals` (use logic similar to Task 2 to create this zero). Return a pair containing `(primal_output, tangent_outputs)`."
    },
    {
        "instruction": "Write a function that accepts two pairs of numerical scalars as input: `inputs = (val1, val2)` and `directions = (dir1, dir2)`. The function should ignore the `directions` pair and simply return the `inputs` pair unchanged."
    },
    {
        "instruction": "Define a function `process_pair` that takes two numerical inputs `x` and `y`. Define a *separate* function `compute_fixed_outputs` that also takes `x` and `y` but always returns the fixed pair `(2.0, 0.0)`. Write a wrapper function that calls both `process_pair(x, y)` and `compute_fixed_outputs(x, y)` and returns a pair containing both results: `(result_from_process_pair, result_from_compute_fixed_outputs)`."
    },
    {
        "instruction": "Implement a function that simulates returning predefined 'sensitivity' values. It should accept some auxiliary data structure (e.g., a tuple) but ignore its content, always returning the specific tuple `(2.0, 1.0)`."
    },
    {
        "instruction": "Write a function that accepts two scalar arguments, a floating-point number and an integer, and returns the floating-point number unchanged."
    },
    {
        "instruction": "Create a function that takes a scalar float `f` and a scalar integer `i` as input. It should return a tuple containing two elements: the original float `f`, and a predefined constant tuple `(2.0, 1)`."
    },
    {
        "instruction": "Define a pair of functions. The first function (`forward_step`) takes a scalar float `x` and a scalar integer `y`, returning `x` and a fixed auxiliary data structure `aux = (2.0, 1)`. The second function (`backward_step`) takes `aux` as input and returns the tuple `(2.0, 1.0)`. Implement both functions."
    },
    {
        "instruction": "Write a function that accepts two numerical arrays as input, performs no computation with them, and explicitly returns a null or empty value (representing 'None')."
    },
    {
        "instruction": "Create a pair of functions simulating a forward and backward pass for differentiation. The forward function `forward(data)` should return both a computed result and any intermediate values needed for the backward pass. The backward function `backward(intermediates, output_gradient)` should use the intermediate values and the gradient from the next step to compute the gradient with respect to the original input data."
    },
    {
        "instruction": "Write a function that processes a batch of inputs using a helper function with conditional logic. The main function takes a list of input items and an auxiliary value. It applies a helper function `helper(item, aux)` to each item. The `helper` function should return a standard result based on `item` if the auxiliary value meets a specific condition (e.g., is non-zero), but return a predefined placeholder value (e.g., zero or null) otherwise. The main function should return a list of results from these helper calls."
    },
    {
        "instruction": "Develop a function that iteratively updates a state. It takes an initial state (e.g., a numerical array) and a number of steps `N`. In each step, it calls a provided `update_rule` function, passing the current state, and uses the returned value as the state for the next step. The function should return the final state after `N` steps."
    },
    {
        "instruction": "Write a function that compares the shapes (dimensions) of two input numerical arrays. It should return True if the shapes are identical and False otherwise."
    },
    {
        "instruction": "Define a pair of functions simulating a forward and backward pass. The forward function should take two numerical arrays (e.g., shape (M,) and (N,)) and return one (e.g., shape (M,)). The backward function should accept an 'upstream gradient' (matching the forward function's output shape) and return two 'input gradients', but deliberately return arrays with shapes that might *not* match the original inputs (e.g., always return two arrays of shape (3,))."
    },
    {
        "instruction": "Create a function that accepts two numerical arrays as input but only returns the first array, effectively ignoring the second. Specify the expected input shapes and the corresponding output shape."
    },
    {
        "instruction": "Develop a validation function that checks shape consistency for a gradient calculation. It takes a list representing the shapes of the original function inputs and a list representing the shapes of the calculated gradients for those inputs. It should return True if all corresponding shapes match, and raise a specific error (e.g., ValueError) indicating which gradient shape is incorrect if a mismatch is detected."
    },
    {
        "instruction": "Develop a function that accepts an integer `n` and returns a 1D numerical array of length `n` containing only zeros."
    },
    {
        "instruction": "Create a function that takes one numerical array as input but ignores it. The function must always return a tuple containing two newly created 1D numerical arrays, both of shape (3,) and filled entirely with zeros."
    },
    {
        "instruction": "Write a function that accepts two numerical arrays, `arr1` and `arr2`, and simply returns the first array, `arr1`."
    },
    {
        "instruction": "Design a function that accepts two 1D numerical arrays, `data1` of size N and `data2` of size M. This function simulates applying a custom transformation rule. It should return the result of a 'simulated backward pass' corresponding to `data2`. This simulated pass must *always* produce a 1D numerical array of a fixed size, say size 3, filled with zeros, irrespective of the actual size M of `data2`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns two values: a binary array (same size as input) indicating which elements are strictly positive (1 if positive, 0 otherwise), and the total count of positive elements. Input: 1D array. Output: 1D binary array, integer count."
    },
    {
        "instruction": "Develop a function that takes a 1D binary array (containing only 0s and 1s) called 'support'. It should return a 2D square matrix. The matrix is constructed as follows: start with a diagonal matrix having the 'support' array elements on its diagonal, then subtract the outer product of 'support' with itself, divided by the sum of elements in 'support' (handle potential division by zero if the sum is 0, e.g., return the diagonal matrix). Input: 1D binary array. Output: 2D numerical array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array. It should first sort the array in descending order and then compute the cumulative sum of the sorted elements. Return the array of cumulative sums. Input: 1D array. Output: 1D array."
    },
    {
        "instruction": "Write a higher-order function that takes another function `f` (which operates on 1D arrays and returns a 1D array) as input. The higher-order function should accept a 2D numerical array (matrix) and return a new 2D array where `f` has been applied independently to each row of the input matrix. Input: function `f`, 2D array. Output: 2D array."
    },
    {
        "instruction": "Create a higher-order function `create_fixed_arg_func`. This function should accept another function `original_func` (which takes three arguments) and a numerical value `fixed_val`. It should return a *new* function that takes only two arguments, `arg1` and `arg2`, and internally calls `original_func(arg1, arg2, fixed_val)`."
    },
    {
        "instruction": "Write a function that takes two numerical inputs, `val1` and `val2`. Consider the expression `val1 + val2 * 0.1`. Calculate how much this expression changes if `val1` increases by 1 (while `val2` stays constant) and how much it changes if `val2` increases by 1 (while `val1` stays constant). Return these two rates of change as a tuple `(change_due_to_val1, change_due_to_val2)`."
    },
    {
        "instruction": "Implement a function `apply_args` that takes two inputs: a function `target_func` and a tuple `args_tuple`. The function should call `target_func` using the elements of `args_tuple` as its positional arguments and return the result."
    },
    {
        "instruction": "Write a function that accepts two numerical inputs, `x` and `y`. Inside the function, use a predefined constant `a = 0.1`. Return the result of the calculation `x + y * a`."
    },
    {
        "instruction": "Write a function that accepts a list or tuple of numerical values (`args`) and returns a new list where each value is multiplied by 42.0."
    },
    {
        "instruction": "Write a function that calculates the sum of squared differences between two 1D numerical arrays of the same size. Input: two 1D arrays. Output: a single scalar number."
    },
    {
        "instruction": "Create a function `apply_outer_func` that takes another function `inner_func` and a numerical input `x`. `apply_outer_func` should call `inner_func(x)` and then return the cosine of the result."
    },
    {
        "instruction": "Implement a function `create_adder` that takes a numerical value `c`. It should return a *new* function that accepts a numerical value `x` and returns the sum `c + x`."
    },
    {
        "instruction": "Write a function `apply_specific_scaling` that takes two 1D numerical arrays, `arr1` and `arr2`. It should return a tuple containing two new 1D arrays: the first array should be `arr1` with each element multiplied by 17.0, and the second array should be `arr2` with each element multiplied by 42.0."
    },
    {
        "instruction": "Design a function `create_calculator` that accepts two 1D numerical arrays, `param_a` and `param_b`. This function should return a *new* function. The returned function should accept a single 1D numerical array `input_z` (of the same size as `param_a` and `param_b`) and calculate `sum(param_a[i] * (input_z[i] - param_b[i])**2)`. The returned function must use the specific `param_a` and `param_b` provided when `create_calculator` was called."
    },
    {
        "instruction": "Implement a function that takes a numerical scalar `k` and a 1D numerical array `arr`. It should return a new 1D array of the same size where each element is the corresponding element of `arr` multiplied by `k`."
    },
    {
        "instruction": "Create a function that accepts another function `f` (which takes one numerical argument and returns a scalar) and a numerical value `x`. The function should compute `f(x)` and return the cosine of that result."
    },
    {
        "instruction": "Create a function `calculate_ratio` that takes two scalar numbers, `divisor` and `dividend`, and returns the result of `dividend / divisor`. Then, create another function `add_to_original` that takes two scalars `x` and `y`, calls `calculate_ratio` with `y` as the divisor and `x` as the dividend, and returns the sum of `x` and the result from `calculate_ratio`."
    },
    {
        "instruction": "Develop two functions, `direct_compute(val1, val2)` and `indirect_compute(val1, val2)`, both intended to calculate `val1 + val1 / val2` for scalar inputs. `direct_compute` should perform the calculation straightforwardly. `indirect_compute` must use a separate helper function solely for the division part (`val1 / val2`). Write a third function `compare_results(v1, v2)` that calls both compute functions with `v1`, `v2` and returns `True` if their outputs are equal or very close (within a small tolerance), `False` otherwise. Handle potential division by zero."
    },
    {
        "instruction": "Write a function that accepts two numerical scalar inputs, `a` and `b`, and returns the result of the calculation `a + a / b`. Ensure your function handles the case where `b` is zero, perhaps by returning an error indicator or a predefined value like 'infinity'."
    },
    {
        "instruction": "Implement two related functions operating on scalar numbers. The first function, `compute_fwd(r, x)`, should return `x / r`. The second function, `compute_rev(r, t)`, should return `t / r`. Demonstrate their usage with sample inputs."
    },
    {
        "instruction": "Create a class `OperationRegistry` with methods `register_rule(op_name, rule_type, rule_function)` and `get_rule(op_name, rule_type)`. `register_rule` stores the `rule_function` associated with an operation name (string) and a rule type (string, e.g., 'evaluate', 'derivative'). `get_rule` retrieves the function; if the specific `op_name` or `rule_type` isn't registered, it must raise a custom `LookupError` with a message like 'Rule [rule_type] for operation [op_name] not found'."
    },
    {
        "instruction": "Implement a function `check_operation_readiness(op_name, required_rules, registry)` that takes an operation name (string), a list of required rule type strings (e.g., ['evaluate', 'abstract_shape', 'derivative']), and an `OperationRegistry` instance (from Task 2). The function should use the registry's `get_rule` method to check if all required rules are registered for the `op_name`. If any rule is missing, it should raise a `ValueError` listing *all* the missing rule types for that operation. If all rules exist, it should return `True`."
    },
    {
        "instruction": "Create a function `apply_transform(op_registry, op_name, input_val)` that simulates applying a transformation requiring multiple rules. It should first try to retrieve an 'abstract_shape' rule for `op_name` from the `op_registry` (using `get_rule` from Task 2). If it fails (catches `LookupError`), it raises a `ValueError` 'Cannot transform: Abstract shape rule missing'. If successful, it then tries to retrieve a 'transform_specific' rule. If *that* fails, it raises `ValueError` 'Cannot transform: Specific transform rule missing'. If both rules are found, it should call the 'transform_specific' rule function with `input_val` and return its result."
    },
    {
        "instruction": "Write a function `safe_execute(operation_func, input_arg)` that attempts to call `operation_func(input_arg)`. If `operation_func` raises a `NotImplementedError`, the function should catch this specific error and return the string 'Error: Operation rule not defined'. Otherwise, it should return the result of the function call. Assume `input_arg` is a number."
    },
    {
        "instruction": "Create a function `wrap_in_tuple` that takes any single value as input and returns a tuple containing only that value."
    },
    {
        "instruction": "Write a function `validate_single_output` that accepts another function `func` and an argument `arg`. It calls `func(arg)`. If the result returned by `func` is *not* a tuple containing exactly one element, it should raise a `TypeError`. Otherwise, it should return the result from `func(arg)`."
    },
    {
        "instruction": "Implement a function `check_sequence_output` that takes a function `op` and an input `data`. It executes `op(data)`. If the returned value is neither a list nor a tuple, it must raise a `ValueError`. Otherwise, it returns the value."
    },
    {
        "instruction": "Design a function `register_and_validate_rule` that takes an operation name (string) and a rule function. Store this rule associated with the name. Then, create a function `apply_rule` that takes an operation name and input metadata (e.g., a type object). It retrieves the corresponding rule function, calls it with the metadata, and verifies that the rule function returns a tuple. If it doesn't return a tuple, raise a `ValueError`. If valid, return the tuple returned by the rule function."
    },
    {
        "instruction": "Write a function that takes a numerical input, converts it to a 16-bit floating-point representation, then converts it back to a 32-bit floating-point representation, and returns the result."
    },
    {
        "instruction": "Define two functions. The first function, `compute_value`, should take a numerical input `x` and return `x * x`. The second function, `compute_gradient_like`, should take an unrelated numerical input `g` and simply return `g`. This mimics a custom computation rule where the 'backward' pass ignores the original input."
    },
    {
        "instruction": "Implement a function that computes the matrix product of a given square numerical 2D array (matrix) with itself. The function should accept the matrix as input and return the resulting matrix."
    },
    {
        "instruction": "Write a function that accepts a 2x2 numerical array with elements represented in a 16-bit floating-point format. First, compute the matrix product of this array with itself. Then, convert the resulting array's elements to 32-bit floating-point numbers. Finally, sum all elements of the 32-bit float array and return the scalar sum. Ensure the function handles potential precision limitations inherent in the 16-bit format."
    },
    {
        "instruction": "Write a function that accepts a single numerical input and returns the square of that number."
    },
    {
        "instruction": "Develop a function that simulates attempting a derivative calculation. It takes a function `f` and a value `x`. If `f` lacks a specific attribute (e.g., `_derivative_rule`), the function should raise an `AttributeError` with a message like 'Derivative rule not defined for function'. Otherwise, it should return a placeholder value (e.g., 0)."
    },
    {
        "instruction": "Implement a function that accepts a function object as input. Check if this function object has a specific boolean attribute named `has_custom_derivative` set to `True`. Return `True` if the attribute exists and is `True`, otherwise return `False`."
    },
    {
        "instruction": "Create a function that takes another function `f` and an argument `x` as input, and returns the result of calling `f(x)`. Handle potential errors during the call to `f` by raising a generic `ValueError`."
    },
    {
        "instruction": "Write a function that computes the logistic sigmoid `1 / (1 + exp(-x))` for a given numerical input `x`. Ensure it handles scalar inputs."
    },
    {
        "instruction": "Develop a function that takes a sample numerical array (which could be 0D, 1D, 2D, etc.) and returns a new array filled with zeros, having the exact same shape and data type as the sample array."
    },
    {
        "instruction": "Create a function that takes a list or 1D array of numbers `c`. It should return a new list/array where the first element is the sigmoid of `c[0]`, and subsequent elements `i` (for i > 0) are the sum of `c[i-1]` and `c[i]`. Assume the input list/array has at least one element."
    },
    {
        "instruction": "Given a numerical input `x` and the result of applying the sigmoid function `s = sigmoid(x)`, write a function that calculates the derivative value `t * s * (1 - s)`, where `t` is another numerical input representing an incoming tangent/sensitivity."
    },
    {
        "instruction": "Write a function that accepts a single number as input and returns the square of that number."
    },
    {
        "instruction": "Design a simple function registry system. Implement `register_function(name, func, gradient_func=None)`. Then, implement `call_gradient(name, input_val)` which looks up the function by `name`. If the function was registered *without* a `gradient_func` (i.e., it's `None`), `call_gradient` must raise an `AttributeError` stating that the gradient is undefined. If it *was* registered, return a dummy value like `0.0` (simulating gradient calculation is not required, just the check and error)."
    },
    {
        "instruction": "Write a function `check_error_message(callable_action, expected_message_part)` that executes `callable_action()`. If `callable_action` raises an exception, the function must verify that the string representation of the exception contains `expected_message_part`. Return `True` if the correct error with the matching message occurs, and `False` otherwise (if no error, or if the error message doesn't match)."
    },
    {
        "instruction": "Create a function `register_computation(func)` that stores `func`. Create a second function `get_gradient_rule(func)` that checks if a corresponding gradient rule has been registered for `func` (you'll need a way to simulate this registration, perhaps using a dictionary). If no rule is found for `func`, raise a `ValueError` with the message 'Gradient rule not defined for function'. Otherwise, return a placeholder indicating the rule exists."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number and returns its square."
    },
    {
        "instruction": "Develop a function `evaluate_derivative` that takes two arguments: a function `original_func` (assume it's a simple polynomial like `x -> x*x`) and a floating-point value `x`. The `evaluate_derivative` function should return the value of the analytical derivative of `original_func` evaluated at `x`. (e.g., if `original_func` is `x -> x*x`, calling `evaluate_derivative(original_func, 3.0)` should return `6.0`)."
    },
    {
        "instruction": "Implement a function that computes the analytical derivative of the function `f(x) = x^2`. It should take a floating-point number `x` as input and return the derivative value `2*x`."
    },
    {
        "instruction": "Create a function that squares its floating-point input `x`. This function must also have a side effect: appending a fixed value (e.g., `True`) to a list passed as an argument *each time* the function's core logic is executed. Return the squared value."
    },
    {
        "instruction": "Develop a function that accepts three arguments: two 1D numerical arrays (`vec1`, `vec2`) and a processing function `proc` that takes two numbers and returns a single number. Verify that `vec1` and `vec2` have the same length. If they do, return a new 1D array where the i-th element is `proc(vec1[i], vec2[i])`. If lengths differ, raise a `ValueError` clearly stating the inconsistent lengths found."
    },
    {
        "instruction": "Create a function that takes a binary operation function (accepting two scalar numbers, returning one) and two 1D numerical arrays. If the arrays have identical lengths, apply the operation element-wise to corresponding elements and return the resulting 1D array. If the lengths differ, raise a `ValueError`."
    },
    {
        "instruction": "Write a function that accepts two 1D numerical arrays (vectors). It should return `True` if they have the same number of elements, and `False` otherwise."
    },
    {
        "instruction": "Design a function `validate_axes` that takes a list of numerical arrays and a corresponding list specifying an axis index (integer) for each array, or `None`. It must check if all arrays that have an axis index specified (i.e., not `None`) have the *same size* along that particular axis. If all specified axes have matching sizes, return that size. If any mismatch is found, raise a `ValueError` indicating which arrays and axes have inconsistent sizes."
    },
    {
        "instruction": "Implement a function `format_positional_error` that takes a tuple of required positional argument indices (e.g., `(1,)`) and the actual number of positional arguments received (`count`). Return a formatted string: 'Error: Expected arguments at indices (1,) to be positional, but received only {count} positional arguments.'"
    },
    {
        "instruction": "Create a higher-order function `enforce_positional_wrapper`. It takes a function `target_func` and a tuple `required_pos_indices`. It returns a *new* function that accepts arbitrary `*args` and `**kwargs`. When this new function is called, it first checks if `len(args)` is sufficient to cover all indices in `required_pos_indices`. If not, it raises a `ValueError` (using a message similar to Task 3). If the check passes, it calls `target_func(*args, **kwargs)` and returns the result."
    },
    {
        "instruction": "Write a function `check_arg_count` that takes the number of positional arguments received (`num_args`) and a tuple of required positional indices (`required_indices`). Return `True` if `num_args` is sufficient to cover the highest required index (i.e., `num_args > max(required_indices)` if `required_indices` is not empty), `False` otherwise."
    },
    {
        "instruction": "Create a function `validate_call_signature` that accepts: 1) the number of positional arguments given (`num_args`), 2) a dictionary of keyword arguments given (`kwargs`), 3) a tuple of indices that *must* be positional (`required_pos_indices`), and 4) a list of parameter names corresponding to the function's signature (e.g., `['a', 'b']`). Raise a `ValueError` if either `num_args` is insufficient to cover `required_pos_indices`, OR if any key in `kwargs` corresponds to a parameter name whose index is in `required_pos_indices`. The error message should explain the specific violation."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array and returns the sum of all its elements as a single scalar value."
    },
    {
        "instruction": "Implement a function that numerically estimates the gradient of a scalar function `f(x, y)` with respect to its second argument `y` at a given point `(x0, y0)`. The function `f` takes two 2D numerical arrays and returns a scalar. Use a small finite difference `h`. The gradient estimate should be a 2D array with the same shape as `y0`, where each element `(i, j)` is approximated by `(f(x0, y0_perturbed_ij) - f(x0, y0)) / h`, with `y0_perturbed_ij` being `y0` with `h` added only to the element at `(i, j)`."
    },
    {
        "instruction": "Implement a function that takes a list (or tuple) of arguments and an integer index `k`. The function should return the argument located at the `k`-th position. Ensure it correctly handles negative indices (e.g., -1 refers to the last argument). Raise an appropriate error if the index is out of bounds."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays, `X` and `Y`. Analytically compute the gradient of the scalar function `f(X, Y) = sum(X) * sum(Y)` with respect to the entire array `Y`. The result should be a 2D array with the same shape as `Y`. Hint: Consider the derivative of `sum(Y)` with respect to an element `Y[i,j]`."
    },
    {
        "instruction": "Design a function `apply_operation_with_int_factor` that takes three arguments: an operation function (which itself takes two arguments), an initial `value`, and an integer `factor`. The function should first assert that `factor` is indeed an integer, then call the provided operation function with `value` and `factor`, returning the result."
    },
    {
        "instruction": "Create a function that accepts two arguments. It should check if the *second* argument is an integer. If it is, return `True`, otherwise return `False`."
    },
    {
        "instruction": "Write a function that takes another function `func` (expected to accept two arguments) and a fixed first argument `fixed_val`. The function should then iterate three times (for `i` from 0 to 2), calling `func(fixed_val, i)` in each iteration, and return a list containing the three results."
    },
    {
        "instruction": "Implement a function that takes two arguments, `value` and `multiplier`. It must verify that `multiplier` is an integer. If it is, return the product `value * multiplier`. If `multiplier` is not an integer, raise a TypeError."
    },
    {
        "instruction": "Implement a function `caller_func_a` that takes one argument `val`. This function should invoke another *pre-existing* function `process_a(arg)` (assume this function is available, takes one argument, and returns an empty tuple) by passing `val` to it, and then return the result received from `process_a`."
    },
    {
        "instruction": "Write a script that first defines two distinct functions: `func_one` which takes any single argument and returns an empty tuple, and `func_two` which takes a single argument `item` and returns `(item, item)`. After defining them, the script should execute a call to `func_one` with the integer `5` and execute a separate call to `func_two` with the string `'go'`. The return values from these calls don't need to be stored or used."
    },
    {
        "instruction": "Implement a function `caller_func_b` that takes one argument `val`. This function should invoke another *pre-existing* function `process_b(arg)` (assume this function is available, takes one argument `x`, and returns `(x, x)`) by passing `val` to it, and then return the result received from `process_b`."
    },
    {
        "instruction": "Write a function that accepts a single argument of any basic type and always returns an empty tuple `()`."
    },
    {
        "instruction": "Write a function that takes no arguments and returns an empty tuple."
    },
    {
        "instruction": "Write a function that accepts an integer. Inside the function, evaluate and return the result of calling a separate, predefined function `process(x)` which takes the integer `x` and returns `(x, x)`. Then, separately, call another predefined function `get_empty()` which returns `()`."
    },
    {
        "instruction": "Define a function `outer_func` that accepts one argument. Inside `outer_func`, call another function `inner_func` (which you must also define) passing the argument to it. `inner_func` should take one argument and return a tuple containing that argument twice. `outer_func` should return the result of calling `inner_func`."
    },
    {
        "instruction": "Implement a function that takes a single value (e.g., number, string) as input and returns a tuple containing that value repeated exactly twice."
    },
    {
        "instruction": "Implement two functions, `process_forward` and `process_backward`. `process_forward` takes a number, applies a sequence of exactly 2 distinct arithmetic operations (e.g., add 5, then multiply by 3), and returns the result. `process_backward` takes the same initial number, simulates a related but more complex process involving exactly 4 distinct arithmetic operations, and returns its result."
    },
    {
        "instruction": "Write a function that takes a single number as input. Inside the function, apply a predefined mathematical operation (e.g., squaring) to the input twice in sequence. Return the final numerical result."
    },
    {
        "instruction": "Write a function that accepts a multi-line string representing a sequence of computational steps. The function should analyze this string and return `True` if it contains *any* of the keywords \"LOOP\", \"BRANCH\", or \"BARRIER\", and `False` otherwise. The search should be case-sensitive."
    },
    {
        "instruction": "Create a function `outer_func` that calls another function `inner_func`. `inner_func` takes a number, performs two different calculations on it (e.g., `x+1`, `x*2`), and returns both results as a pair. `outer_func` should call `inner_func`, receive the pair, but only return the first element of the pair."
    },
    {
        "instruction": "Create a function that takes a single numerical input, performs a simple mathematical operation (e.g., calculates its sine), and returns a tuple containing two elements: the result of the operation and a predefined constant floating-point value (e.g., 3.0)."
    },
    {
        "instruction": "Write a higher-order function `compose_and_select_first`. This function accepts another function `inner_func` as an argument. `compose_and_select_first` should return a *new* function. This new function, when called with an argument `arg`, will execute `result_pair = inner_func(arg)`, assume `result_pair` is a tuple/pair, and return only the *first* element of that pair."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number `x` and returns the result of applying the sine function twice to it (i.e., calculate `sin(sin(x))`)."
    },
    {
        "instruction": "Implement a function that calculates the derivative of `sin(sin(x))` with respect to `x` using the chain rule manually. The function should take a floating-point number `x` as input and return the computed derivative value, which is `cos(sin(x)) * cos(x)`."
    },
    {
        "instruction": "Create a function `vectorized_group_sum` that takes a 1D numerical array `trigger_array` (whose content doesn't matter, only its size) and a scalar value `input_scalar`. The size of `trigger_array` defines a conceptual 'group size'. The function should compute the sum of `input_scalar` across this group (i.e., `input_scalar * size_of_trigger_array`). Return the single scalar result."
    },
    {
        "instruction": "Implement a function `compute_value_and_tangent` that takes two numerical scalar inputs: `primal` and `tangent`. Inside the function, perform a predefined operation on the `primal` input (e.g., multiply it by 2) to get a `result`. The function must return a pair/tuple containing the computed `result` and the original unmodified `tangent` value."
    },
    {
        "instruction": "Create a function that takes a function `op`, a count `n`, and a constant value `val`. The function `op` takes a single value. Your function should call `op(val)` exactly `n` times and return a list or array containing the `n` results."
    },
    {
        "instruction": "Implement a function `map_array` that takes a function `f` and a 1D numerical array `arr`. It should apply `f` to each element of `arr` and return a new 1D array containing the results. `f` is guaranteed to take one numerical argument and return one numerical value."
    },
    {
        "instruction": "Write a function `create_adder` that takes a number `x`. It should return a *new* function `add_x` which takes a number `y` and returns the sum `x + y`."
    },
    {
        "instruction": "Design a function `setup_custom_op` that takes a numerical value `factor`. It should return *two* functions: 1. `op(value)`: Returns `factor + value`. 2. `op_sensitivity(primals, tangents)`: Takes a tuple `primals` (containing `value`) and a tuple `tangents` (containing the change in `value`) and returns `2 * tangents[0]`, simulating a custom sensitivity rule independent of the actual `op`'s definition."
    },
    {
        "instruction": "Create a function `apply_and_describe`. It takes an initial numerical value `x`. Inside, define a function `operation(y)` that returns `x + y`. `apply_and_describe` should call `operation` with a specific value (e.g., 1.0) and also return a representation of how the result changes with respect to `y` (e.g., return the tuple `(result, 1.0)` where 1.0 represents the constant rate of change)."
    },
    {
        "instruction": "Implement a function `wrapper_func` that accepts a number `a`. Inside it, define a function `inner_op(b)` which calculates `a + b`. `wrapper_func` should return the result of calling `inner_op` with a fixed value (e.g., 5.0)."
    },
    {
        "instruction": "Write a function factory `create_adder(n)` that returns a *new* function. This new function should accept one numerical argument `y` and return the sum `n + y`."
    },
    {
        "instruction": "Write a function `create_and_apply_offset(offset)` that defines an inner function `add_offset(value)` which returns `value + offset`. The outer function should then immediately call `add_offset` with a fixed input (e.g., 10) and return the result."
    },
    {
        "instruction": "Design a function `apply_custom_rules(value_func, derivative_func, input_data)` where `value_func` and `derivative_func` are functions each taking one numerical argument, and `input_data` is a numerical value. The function should compute `result = value_func(input_data)` and `derivative_effect = derivative_func(input_data)` and return them as a tuple `(result, derivative_effect)`."
    },
    {
        "instruction": "Implement a function `conditional_transform(value, transform_flag)` that takes a numerical `value` and a boolean `transform_flag`. If `transform_flag` is true, return `value * 2`. If `transform_flag` is false, return `value` unchanged."
    },
    {
        "instruction": "Create a function `apply_elementwise(func, arr)` that takes a function `func` (accepting a single numerical element) and a 1D numerical array `arr`. It should return a new 1D array where each element is the result of applying `func` to the corresponding element of `arr`."
    },
    {
        "instruction": "Write a function `create_multiplier(factor)` that returns *another* function. The returned function should take one numerical argument `x` and return `factor * x`. Ensure the `factor` is captured correctly from the outer scope."
    },
    {
        "instruction": "Develop a function `vectorized_closure_multiplier(factor, data_array)` that first defines an inner function which multiplies its single numerical input by `factor` (using `factor` from the outer scope). Then, apply this inner function element-wise to the 1D numerical array `data_array` and return the resulting 1D array."
    },
    {
        "instruction": "Implement a function `multiply_and_directional_derivative(a, b, b_direction)` that calculates both the product `a * b` and its directional derivative with respect to `b` in the direction `b_direction`, which is `a * b_direction`. The function should return both results (product, derivative) as a pair. Assume `a`, `b`, and `b_direction` are numerical scalars."
    },
    {
        "instruction": "Implement a function `step_processor` that takes a current state (a number) and an input element (can be ignored). It should update the state based on a predefined rule (e.g., multiply the state by a constant factor like 2) and return the new state. Then, write a function `run_steps` that takes an initial state and a number of steps `N`, and repeatedly calls `step_processor` `N` times, starting with the initial state, and returns the final state."
    },
    {
        "instruction": "Design a function `compute_and_track` that accepts an initial numerical value `v` and a list of operations. Each operation is a function that takes a number and returns a number. The `compute_and_track` function should apply these operations sequentially starting with `v`. It must return two things: the final computed numerical value, and a boolean flag which is `True` if the final value's computation involved the initial value `v` at any step, and `False` otherwise. (Assume simple arithmetic operations)."
    },
    {
        "instruction": "Write a function `multiply_inputs` that accepts two numerical inputs, `factor1` and `factor2`, and returns their product. Ensure it handles standard numerical types."
    },
    {
        "instruction": "Write a function `outer_func` that takes a number `a`. Inside `outer_func`, define another function `inner_func` that takes a number `b` and returns the product `a * b`. `outer_func` should call `inner_func` with a fixed value (e.g., 5) and return the result."
    },
    {
        "instruction": "Write a function `evaluate_representation` that takes an abstract representation of a simple function (e.g., a structure describing an operation like 'sum' or 'identity' and its inputs) and evaluates it. For example, given a representation for 'sum(x)' and a value for 'x', it should return the result of the sum operation."
    },
    {
        "instruction": "Design a function simulating a mapped operation combined with group aggregation. It takes an input array (used only to determine group size), a constant scalar value, and an operation function `op(value, group_size)` which internally calculates the sum of `value` across the group. The main function should conceptually apply `op` using the constant scalar value, informed by the group size derived from the input array's length. Return the single, aggregated scalar result."
    },
    {
        "instruction": "Create a function that maps an operation over a list while broadcasting a second argument. It accepts a list of primary inputs, a single secondary input, and an operation function `op(primary, secondary)`. Apply `op` to each element of the primary list paired with the *same* secondary input. Return a list containing the results."
    },
    {
        "instruction": "Implement a function that defines a custom computation rule. It should take a function `f(x)` and two other functions: `f_fwd(x)` returning `(result, cache_data)` and `f_bwd(cache_data, upstream_derivative)` returning the `downstream_derivative`. Return an object or structure that allows executing the forward pass (getting the result) and separately executing the backward pass (calculating the derivative)."
    },
    {
        "instruction": "Create a function `reverse_gradient` that simulates calculating the gradient with respect to one input (`b`) of a multiplication operation (`p = a * b`). It should accept two arguments: a tuple `saved_inputs` (containing the original `a` and `b`) and an incoming `gradient_signal` (representing the gradient flowing back to `p`). The function should return the calculated gradient with respect to `b`, which is `a * gradient_signal`."
    },
    {
        "instruction": "Design a function `forward_computation` that takes two numerical scalar inputs, `a` and `b`. It should compute their product `p = a * b`. The function must return both the product `p` and a tuple containing the original inputs `(a, b)` needed for potential later calculations."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array as input. It should apply a predefined simple operation (e.g., multiply by 2) to each element independently and then return the sum of all the resulting elements in the transformed array."
    },
    {
        "instruction": "Implement a function `create_multiplier` that takes one numerical scalar `factor`. It should return a *new function* that takes a single numerical scalar argument `value` and returns the product `factor * value`."
    },
    {
        "instruction": "Write a function that generates a 1D numerical array containing a specified number of evenly spaced values between a given start and end point (inclusive)."
    },
    {
        "instruction": "Implement a function that takes a boolean value and a 1D numerical array. If the boolean is true, return an array where each element is the square of the input element. If false, return an array where each element is twice the input element."
    },
    {
        "instruction": "Develop a function that takes a boolean value and a 1D numerical array. Based on the boolean, it performs one of two calculations: either squaring each element or doubling each element. The function should return *two* values: the array resulting from the chosen calculation, and the original input array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and a scalar number. It should return a new array where each element is the corresponding input element multiplied by the scalar."
    },
    {
        "instruction": "Develop a function that compares two tuples, each containing two numerical values, e.g., `(a, b)` and `(c, d)`. The function should return `True` if the first elements (`a` and `c`) are approximately equal AND the second elements (`b` and `d`) are approximately equal (within a small tolerance like 1e-5). Otherwise, return `False`."
    },
    {
        "instruction": "Create a function that takes a single numerical input `x`. It should compute `x * x` and also return the original input `x` itself. The function should return these two values as a tuple: `(x*x, x)`."
    },
    {
        "instruction": "Implement a function to compute the value and the directional derivative of `f(x) = x * x` at a point `x` in the direction `t`. The function should take `x` and `t` as numerical inputs and return a tuple `(value, derivative_value)`, where `value` is `f(x)` and `derivative_value` is `f'(x) * t`."
    },
    {
        "instruction": "Write a function that accepts a single numerical input `x` and returns its square (`x * x`)."
    },
    {
        "instruction": "Implement a function that takes a processing function `op` and two 2D arrays `M1`, `M2` (both N x K). The `op` function accepts two 1D arrays (size K) and returns a 1D array (size K). Your function should apply `op` to each corresponding pair of rows from `M1` and `M2` (i.e., `op(M1[i], M2[i])`) and return a new N x K matrix containing the results."
    },
    {
        "instruction": "Create a function that accepts two 2D numerical arrays (matrices) with identical dimensions (e.g., N rows, M columns). Apply the 'element-wise sum and square' operation (from Task 1) to each corresponding pair of rows. Return a new 2D array of the same dimensions containing the results for each row."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays (vectors) of the same length. It should return a new 1D array where each element is the square of the sum of the corresponding elements from the input arrays. Example: `input1=[1, 2], input2=[3, 1] -> output=[(1+3)**2, (2+1)**2] = [16, 9]`."
    },
    {
        "instruction": "Write a function that takes a numerical array (of any dimension) and a target shape (represented as a tuple of integers). Return `True` if the array's dimensions exactly match the target shape, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a single real number and returns its cosine."
    },
    {
        "instruction": "Write a function that takes a 1D array of complex numbers and a scalar value, returning a new 1D array where each element is multiplied by the scalar."
    },
    {
        "instruction": "Implement a function that computes the L2 norm (Euclidean magnitude) of a 1D array of complex numbers. The input is a 1D complex array, and the output should be a single non-negative real number."
    },
    {
        "instruction": "Develop a function that takes a 1D array of complex numbers, scales it by the constant 2.0, computes the L2 norm of the scaled array, and returns the resulting real scalar value."
    },
    {
        "instruction": "Implement a function that takes a single scalar number as input and returns the result of applying the sine function twice in succession to the input (e.g., sin(sin(input)))."
    },
    {
        "instruction": "Implement a function that calculates the analytical first derivative of `g(x) = sin(sin(x))` with respect to `x`. The function should take a scalar `x` as input and return the computed derivative value."
    },
    {
        "instruction": "Develop a function that numerically verifies the correctness of a computed second derivative for a given function `h(x)` at a point `x0`. The function `h(x)` internally uses a condition (`x > 0`) to choose between two simpler underlying functions. Your verification function should compare the provided analytical second derivative value against a numerical approximation (e.g., using finite differences)."
    },
    {
        "instruction": "Create a function that accepts a single scalar number. If the number is greater than zero, apply a first provided single-argument function to it. Otherwise, apply a second provided single-argument function to it. Return the result."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and applies the sine function element-wise, returning a new array of the same shape."
    },
    {
        "instruction": "Develop a function that takes an initial 1D numerical array `x` and a 2D numerical array `W`. It should iteratively update `x` three times by first performing a matrix-vector multiplication between `W` and the current `x`, and then applying an element-wise sine function to the result. Return the final 1D array. Ensure matrix and vector dimensions are compatible for multiplication."
    },
    {
        "instruction": "Implement a function for matrix-vector multiplication. It should accept a 2D numerical array (matrix M, shape RxC) and a 1D numerical array (vector V, shape C). Return the resulting 1D vector (shape R). Include an option to perform the calculation using the highest available numerical precision."
    },
    {
        "instruction": "Implement a function that computes the gradient of a scalar output of a given computational function `func` with respect to one of its 2D array inputs (`W`). `func` takes a 1D array `x` and the 2D array `W`, involves conditional execution based on `x`, and internally performs repeated matrix-vector multiplications and element-wise operations. The function should return a 2D array representing the gradient, having the same shape as `W`."
    },
    {
        "instruction": "Write a function `verify_computation_steps` that takes another function `target_func`, its inputs, and a dictionary specifying expected counts of operation types (e.g., {'multiply': 5, 'trigonometric': 3}). Execute `target_func` with the inputs. Although you cannot directly inspect the execution trace, simulate this by having `target_func` internally (or via callbacks) report the types of operations it performs. Return `True` if the reported counts match the expected counts, `False` otherwise. (Note: This requires modifying or designing `target_func` to support this reporting)."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns `True` if the sum of its elements is strictly greater than zero, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes a numerical array (1D or 2D) as input and returns a new array of the same shape where each element is the sine of the corresponding element in the input array."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array `v` (shape N) and a 2D numerical array `M` (shape N x N). It should compute the result of applying the following sequence three times: first, perform matrix multiplication (`v @ M`), then apply the element-wise sine function to the result. Return the final 1D array."
    },
    {
        "instruction": "Create a function that simulates processing a list of operations, represented by string names (e.g., `['op1', 'op2', 'op3']`). It also takes an initial numerical value and a 'policy' function. The policy function accepts an operation name (string) and returns `True` if this operation's *result* should be marked as 'saved'. Your function should apply placeholder logic for each operation (e.g., just add 1 to the value for simplicity) and return both the final numerical value and a list containing the names of operations marked as 'saved' by the policy."
    },
    {
        "instruction": "Implement a function that takes a single number `x`. Inside the function, define two simple transformations: `transform_A` (e.g., adds 5) and `transform_B` (e.g., multiplies by 2). If `x` is positive, the function should compute and return `transform_B(transform_A(x))`. If `x` is zero or negative, it should compute and return `transform_A(transform_B(x))`."
    },
    {
        "instruction": "Develop a function that accepts two strings: `main_text` and `search_term`. It should return the total number of non-overlapping occurrences of `search_term` within `main_text`."
    },
    {
        "instruction": "Write a function that takes a number `x` and two single-argument functions, `f_positive` and `f_non_positive`. If `x` is greater than 0, it should return the result of `f_positive(x)`. Otherwise, it should return the result of `f_non_positive(x)`."
    },
    {
        "instruction": "Write a function `get_second_derivative_evaluator`. This function takes two functions as input: `f_prime` (representing the first derivative of some original function `f`) and `f_double_prime` (representing the second derivative of `f`). It should return a *new* function that accepts a scalar input `x` and returns the value of the second derivative at `x` by calling `f_double_prime(x)`."
    },
    {
        "instruction": "Write a function `conditional_apply` that takes a scalar number `x`, function `f1`, and function `f2`. If `x` is positive, it returns the result of `f1(x)`. Otherwise, it returns the result of `f2(x)`."
    },
    {
        "instruction": "Design a function `evaluate_and_derive_with_policy`. It accepts a primary function `func`, its known derivative function `func_prime`, a scalar input `x`, and a boolean flag `cache_intermediate`. It must return both `func(x)` and `func_prime(x)`. If `cache_intermediate` is true, it should print a confirmation message (e.g., \"Intermediate derivative computed and cached.\") before returning the values."
    },
    {
        "instruction": "Create two functions: `compute_trig(x)` that calculates a specific trigonometric function (e.g., sine) of a scalar input `x`, and `compute_trig_derivative(x)` that calculates its analytical derivative (e.g., cosine) at `x`."
    },
    {
        "instruction": "Write a function `check_numerical_derivative(func, analytic_deriv_func, input_val, tolerance=1e-5)` that takes a single-argument numerical function `func`, its known analytical derivative function `analytic_deriv_func`, and an `input_val`. Calculate the numerical derivative of `func` at `input_val` using finite differences (e.g., `(func(input_val + h) - func(input_val - h)) / (2 * h)` for a small `h`). Return `True` if the absolute difference between the numerical and analytical derivatives is within the specified `tolerance`, `False` otherwise."
    },
    {
        "instruction": "Implement two functions: `compute_value(x)` which returns a numerical result based on `x` (e.g., `x * x`), and `compute_derivative(x)` which returns the exact analytical derivative of `compute_value` with respect to `x` (e.g., `2 * x`). Both functions should operate on numerical inputs."
    },
    {
        "instruction": "Implement a function `execute_policy_based(computation_func, input_val, policy_func)`. `computation_func` performs a sequence of named steps (e.g., internally calls helper functions like `step('step_A', data)`). `policy_func` takes a step name (string) and returns `True` if the result of this step should be 'saved' (e.g., added to a list), `False` otherwise. `execute_policy_based` should run the computation and return only the list of 'saved' results according to the policy."
    },
    {
        "instruction": "Create a function `compose(f, g)` that accepts two single-argument functions, `f` and `g`. It should return a *new* function `h` such that calling `h(x)` executes `f(g(x))` for any given input `x`."
    },
    {
        "instruction": "Develop a function that accepts a single scalar floating-point number `x`. If `x` is non-negative, the function should compute `(x + 2.0) - x`. If `x` is negative, it should compute `(x + 1.0) + x`. Return the computed floating-point result."
    },
    {
        "instruction": "Create a function that accepts two scalar floating-point numbers, `a` and `b`, and returns their sum `a + b`."
    },
    {
        "instruction": "Implement a function that takes a single floating-point number `x`. If `x` is greater than or equal to 0.0, it should perform one calculation (e.g., return `x + 2.0`); otherwise, it should perform a different calculation (e.g., return `x + 1.0`). Return the result of the chosen calculation."
    },
    {
        "instruction": "Write a function that takes a 1D array of floating-point numbers. For each element in the array, apply a conditional operation: if the element is non-negative, replace it with a value calculated using the original element (e.g., `element + 2.0 - element`); otherwise, replace it with a different value calculated using the original element (e.g., `element + 1.0 + element`). Return the new 1D array containing the results of these conditional calculations."
    },
    {
        "instruction": "Develop a function that accepts three numerical inputs: `condition_val`, `input1`, `input2`. If `condition_val` is positive, it should return a tuple containing the cosine of `input1` and the cosine of `input2`. If `condition_val` is not positive, it should return a tuple containing the sine of `input1` and the sine of `input2`."
    },
    {
        "instruction": "Implement a function that takes two numbers, `a` and `b`. If `a` is greater than zero, return the pair `(a*a, b*b)`. Otherwise, return the pair `(a+1, b+1)`."
    },
    {
        "instruction": "Create a function that accepts a single number and returns its sine. Ensure it handles standard numerical types."
    },
    {
        "instruction": "Write a function that takes a numerical value `x` and a list of numbers `coeffs`. If `x` is positive, calculate the polynomial value using `coeffs` at point `x` (e.g., `coeffs[0] + coeffs[1]*x + coeffs[2]*x**2 + ...`). If `x` is not positive, return the sum of the absolute values of the numbers in `coeffs`. The function should return a single numerical result."
    },
    {
        "instruction": "Develop a function that accepts a boolean `condition` and two numerical inputs `x1`, `x2`. If `condition` is true, return a pair (e.g., tuple or list) containing the sine of `x1` and the sine of `x2`. If `condition` is false, return a pair containing the sine of `x2` and the sine of `x1`."
    },
    {
        "instruction": "Write a function that takes a boolean value `condition` and two numerical values `val_true` and `val_false`. It should return `val_true` if `condition` is true, and `val_false` otherwise."
    },
    {
        "instruction": "Implement a function that takes a boolean `condition` and two numerical inputs `x1`, `x2`. If `condition` is true, it returns the sine of `x1`. If `condition` is false, it returns the sine of `x2`."
    },
    {
        "instruction": "Write a higher-order function named `apply_conditional_funcs`. It should accept a boolean condition, two functions (`func_true`, `func_false`), and two numerical arguments (`arg1`, `arg2`). If the condition is true, it calls `func_true` with `arg1` and `arg2` and returns its result. Otherwise, it calls `func_false` with `arg1` and `arg2` and returns its result. Assume both functions return a pair of numerical values."
    },
    {
        "instruction": "Implement a function `modify_via_nested` that initializes an integer counter to 0. It should contain a *nested* function `incrementer` that increases the counter by 1. Call `incrementer` 5 times within `modify_via_nested`. Return the final value of the counter. Ensure the nested function correctly modifies the variable from the outer scope."
    },
    {
        "instruction": "Develop a function `safe_add` that takes two numerical inputs. Return their sum. If either input is not a standard number (e.g., integer, float), return a designated error value like `None`."
    },
    {
        "instruction": "Implement a function `iterative_process_check` that takes an initial numerical `value` and applies a fixed sequence of internal operations (e.g., increment twice). After the sequence, the function must check if the resulting `value` is still a simple numerical type. Return a tuple containing the final `value` and a boolean flag (`True` if simple, `False` otherwise). This simulates checking if a result from an iterative process remains suitable for direct use."
    },
    {
        "instruction": "Write a function `increment_loop` that accepts an initial integer `start_value` and an integer `num_iterations`. The function should increment the value by 1 in each iteration of a loop running `num_iterations` times. Return the final integer value."
    },
    {
        "instruction": "Write a function that takes an initial numerical value (carry) and a sequence of numbers. For each number in the sequence, update the carry by applying the sine function to the current carry. Return the final carry value after processing the entire sequence."
    },
    {
        "instruction": "Develop a function that takes a numerical input `x` and a list `output_list`. The function should calculate the sine of `x` and append the original value `x` to `output_list`. The function should return the calculated sine value."
    },
    {
        "instruction": "Create a function that simulates an iterative process. It accepts an initial state, a sequence of inputs, and an update function. The update function takes the current state and one input element, returning a new state and an output value. Your simulator should apply the update function iteratively, collecting the output values at each step. Return both the final state and the list of collected output values."
    },
    {
        "instruction": "Design a higher-order function `scan_with_side_effect_check`. It takes an initial state, an input sequence, an update function, and a list `external_list` to monitor. The update function takes the current state and an input element, returning a new state and an output element (which can be ignored for this task). `scan_with_side_effect_check` should iteratively apply the update function. If, at any step, the update function appends to `external_list`, the process should stop immediately and return `(None, True)` indicating a detected side effect. If the iteration completes without modification to `external_list`, return `(final_state, False)`."
    },
    {
        "instruction": "Create a function that performs a cumulative operation. It takes an initial scalar value ('carry') and a 1D numerical array ('inputs'). It iterates through 'inputs', applying a function `update(carry, input_element)` at each step. For this task, the `update` function should simply return `sin(carry)` as the new carry, ignoring the `input_element`. The function should return the final carry value after iterating through all inputs."
    },
    {
        "instruction": "Implement a function that performs a sequential state update. It takes an initial numerical scalar state and an integer N. The function should apply the sine operation to the state N times, updating the state in each step (i.e., state = sin(state)), and return the final state."
    },
    {
        "instruction": "Implement a general 'scan' operation. This function accepts an update function `f`, an initial state `initial_carry`, and a 1D input array `elements`. The update function `f` takes the current state and one element, returning a tuple `(new_state, step_result)`. Your 'scan' function should iterate through `elements`, applying `f` at each step to update the state and collect `step_result`. It must return a tuple containing the final state and a 1D array of all collected `step_result` values."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Write a function that takes an initial numerical value `carry` and an integer `n`. Simulate applying a process `n` times where the value is passed unchanged in each step. Return the final value."
    },
    {
        "instruction": "Implement a function that performs a cumulative operation. It accepts an initial `carry` value and a list of `inputs`. It iterates through the inputs, applying a function `update(current_carry, current_input)` at each step to get the `next_carry`. For this task, use addition for the update: `next_carry = current_carry + current_input`. Return the final carry value."
    },
    {
        "instruction": "Implement a function simulating forward-mode differentiation for an iterative sum. Given an initial primal state `p_state` (number), an initial tangent state `t_state` (number), and a list of primal inputs `p_inputs` (list of numbers). Assume corresponding tangent inputs `t_inputs` are all 1.0. Iterate through `p_inputs`, updating `p_state = p_state + p_input` and `t_state = t_state + t_input` at each step. Return the final primal and tangent states as a pair `(final_p_state, final_t_state)`."
    },
    {
        "instruction": "Create a function that computes the value and directional derivative of `f(x) = x * x` at a point `x`. It should take the primal input `x` (a number) and a tangent input `t` (a number), and return a pair: the function's value `f(x)` and the result of the derivative `df/dx` multiplied by the tangent `t`."
    },
    {
        "instruction": "Create a function that processes a sequence. It takes an initial numerical carry value and a list of numbers. It iterates through the list, updating the carry at each step using the formula: `new_carry = sin(current_carry)`. The function should return only the final carry value."
    },
    {
        "instruction": "Write a function to calculate the sensitivity of the output of a sequential process to its initial input. The process starts with a value 'x' and applies the function `y = sin(x)` repeatedly 3 times. Calculate and return the rate of change of the final output with respect to the initial input 'x'."
    },
    {
        "instruction": "Develop a function that simulates a stateful sequential process. It takes an initial numerical state and a count 'n'. It applies an update rule `state = sin(state)` for 'n' steps. The function must return a list containing the state value *before* each update step (including the initial state)."
    },
    {
        "instruction": "Implement a function that performs a cumulative operation. It accepts an initial numerical state and a list of numbers. For each number in the list, update the state by taking the sine of the current state. Return the final state after processing all numbers."
    },
    {
        "instruction": "Develop a function that performs a fixed number of iterations (e.g., 2). It starts with an initial 2D numerical array `R0` and a scalar `D`. In each iteration, update `R` using the rule: `R_next = R + 0.001 * (D * R)`. Return the final 2D array `R` after all iterations."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar value. Return a new 2D array where each element of the input array is multiplied by the scalar."
    },
    {
        "instruction": "Create a function that accepts two 2D numerical arrays, `A` and `B`, of the same shape. Return a new 2D array representing `A + c * B`, where `c` is a fixed small constant scalar (e.g., 0.001)."
    },
    {
        "instruction": "Write a function that computes the *gradient* of a simple iterative process output with respect to an input scalar. The process is: start with `R0` (a 2D array, e.g., shape (5,3)), iterate twice using `R_next = R + 0.001 * (D * R)`, and the final output is `scalar_output = R_final[0, 0]`. Your function should take the scalar `D` and the initial array `R0` and return the numerical value of the gradient `d(scalar_output) / dD`."
    },
    {
        "instruction": "Develop a function that takes an initial numerical value `x`, a function `f` (which accepts one numerical argument and returns one numerical value), and a positive integer `n`. Apply the function `f` repeatedly `n` times, starting with `x`, using the output of each step as the input for the next. Return the final numerical result."
    },
    {
        "instruction": "Write a function that accepts a single numerical input and returns that number incremented by 1."
    },
    {
        "instruction": "Implement a function that takes an initial numerical value `start_value`. Inside this function, define a simple transformation (e.g., add 1). Apply this transformation exactly once to `start_value` and return the final numerical value."
    },
    {
        "instruction": "Create a function that takes two arguments: another function `f` (which accepts one numerical argument and returns one numerical value) and an initial numerical value `x`. Your function should call `f` exactly once with `x` and return the result."
    },
    {
        "instruction": "Develop a function that calculates the derivative of a 3-step iterative sine application. Given an initial floating-point input `x`, the process computes `y1=sin(x)`, `y2=sin(y1)`, `y3=sin(y2)`. The function should return the derivative `dy3/dx` evaluated at the given `x` using the chain rule."
    },
    {
        "instruction": "Implement a function that takes an initial floating-point scalar `carry` and an integer `n`. It should iteratively apply the sine function `n` times, updating the `carry` with the result at each step. Return the final `carry` value after `n` iterations."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number and returns its cosine value."
    },
    {
        "instruction": "Create a function that takes an initial floating-point scalar `start_value` and an integer `n`. It should apply the sine function `n` times iteratively, using the previous result as the input for the next step. Return a sequence (e.g., list, array) containing the result obtained at each of the `n` steps."
    },
    {
        "instruction": "Implement a function `iterative_update(initial_state, num_steps)` that takes a numerical scalar `initial_state` and a positive integer `num_steps`. In each step, update the state using the formula: `new_state = sin(current_state)`. Return the final state after `num_steps` iterations."
    },
    {
        "instruction": "Write a function `apply_sin_repeatedly(value, n)` that takes a numerical scalar `value` and a positive integer `n`. Return the result of applying the sine function `n` times sequentially to the initial `value` (e.g., for n=3, return sin(sin(sin(value))))."
    },
    {
        "instruction": "Create a function `compute_sin_cos(x)` that accepts a numerical scalar `x` and returns a tuple containing two elements: the sine of `x` and the cosine of `x`."
    },
    {
        "instruction": "Write a function `scan_and_filter(step_func, initial_value, length, filter_func)`. It takes a function `step_func` (scalar -> scalar), an `initial_value` (scalar), a positive integer `length`, and a `filter_func` (scalar -> boolean). Apply `step_func` repeatedly `length` times, starting with `initial_value`, where the output of one step is the input to the next. Collect and return a list containing only those intermediate results (the output of `step_func` at each step, *not* the initial value) for which `filter_func` returns true when applied to that result."
    },
    {
        "instruction": "Develop a function that accepts a list and a second list containing indices. Return a new list composed only of the elements from the first list located at the specified indices given in the second list."
    },
    {
        "instruction": "Given an initial list of numbers, a number of iterations `n`, and a list of target output indices, implement the iterative process from Task 3. However, optimize the process to minimize calculations, only computing what's necessary to determine the values at the specified target indices in the final list after `n` iterations. Return a list containing only the computed values for those target indices."
    },
    {
        "instruction": "Write a function that takes a list of numbers and returns a new list containing the sums of adjacent pairs of elements from the input list. For example, input `[a, b, c, d]` should produce `[a+b, b+c, c+d]`."
    },
    {
        "instruction": "Implement a function that takes an initial list of numbers and a positive integer `n`. Apply the list transformation described in Task 2 repeatedly, `n` times, where the output of one step becomes the input for the next. Return the final list after `n` iterations."
    },
    {
        "instruction": "Develop a function simulating a state update step. It accepts a list of numbers (`current_state`) and a fixed list of integer indices (`update_indices`). The function should: 1. Extract elements from `current_state` at `update_indices`. 2. Compute 'derived values': the first is the first extracted element; subsequent elements are products of adjacent pairs from the extracted list (e.g., extracted `[e1, e2, e3]` -> derived `[e1, e1*e2, e2*e3]`). 3. Return a *new* list, copying `current_state` but updating values at `update_indices` with the 'derived values'."
    },
    {
        "instruction": "Write a function that takes a non-negative integer `n` and returns a list containing floating-point numbers sequentially from 0.0 up to (but not including) `n`. For example, input `5` should produce `[0.0, 1.0, 2.0, 3.0, 4.0]`."
    },
    {
        "instruction": "Implement a function that takes three arguments: an original list of items, a list of integer indices, and a list of replacement items (of the same length as the indices list). The function should return a *new* list that is a copy of the original list, but with the items at the specified indices replaced by the corresponding replacement items."
    },
    {
        "instruction": "Write a function that takes a list of numbers and a list of integer indices. It should return a new list containing only the elements from the input list at the specified indices, maintaining the order given by the indices list."
    },
    {
        "instruction": "Develop a function that iteratively processes a list. It should run for a number of iterations equal to the initial length of the list. In each iteration, it should record the list's last element and then update the list by performing a right circular shift. The function should return an ordered collection (e.g., a list) of the elements recorded in each iteration. Input: `initial_list`. Output: `list_of_recorded_elements`."
    },
    {
        "instruction": "Create a function that accepts a list and returns its last element without altering the original list. If the list is empty, it should handle this gracefully (e.g., return None or raise an appropriate error). Input: `list`. Output: `item` or `None`."
    },
    {
        "instruction": "Write a function that takes a list of items and performs a single right circular shift, moving the last element to the beginning. The function should return the modified list. Input: `list`. Output: `list`."
    },
    {
        "instruction": "Implement a function that simulates one step of an iterative process. It takes a list as input, identifies the element currently at the end of the list, performs a right circular shift on the list (moving the last element to the front), and returns both the shifted list and the element that was originally at the end. Input: `list`. Output: `(shifted_list, original_last_element)`."
    },
    {
        "instruction": "Develop a function `process_sequence` that takes a 1D numerical array. Internally, it should compute both the final product of all elements (initial value 1.0) and the sequence of intermediate cumulative products. The function must also accept two boolean flags: `need_final` and `need_sequence`. Based ONLY on these flags, it should return: the final product if `need_final` is true and `need_sequence` is false; the sequence array if `need_final` is false and `need_sequence` is true; a tuple `(final_product, sequence_array)` if both are true; or `None` if both are false."
    },
    {
        "instruction": "Create a function `cumulative_product` that accepts a 1D numerical array. It should return a tuple containing two elements: the final product of all elements in the array (starting with an initial value of 1.0) and a new 1D array of the same size containing the cumulative products at each position (inclusive). Handle empty input arrays appropriately (e.g., return (1.0, empty_array))."
    },
    {
        "instruction": "Implement a generic `scan_operation` function. It takes an initial `carry` value, a 1D input `array`, and a `step_function`. The `step_function` must accept two arguments (current carry, current array element) and return a tuple of two values (new carry, step output). `scan_operation` should iterate through the input array, applying the `step_function` at each element, and return a tuple containing the final carry value and a 1D array of all the step outputs."
    },
    {
        "instruction": "Write a function `update_state` that takes two numerical inputs: `current_state` and `new_value`. It should return a tuple containing two values: the product (`current_state * new_value`) and the `current_state` before the multiplication."
    },
    {
        "instruction": "Write a function that takes a positive integer `N` and returns a 1D numerical array containing the sequence of floating-point numbers 0.0, 1.0, ..., N-1.0."
    },
    {
        "instruction": "Create a function that performs a scan operation. It accepts an initial scalar carry, a 1D numerical array `xs`, and an operation function `op`. The `op` function takes `(carry, x)` and returns `(new_carry, y)`. The scan function should iterate through `xs`, applying `op` at each step using the updated carry, and return the final carry and a 1D array containing all the `y` values generated at each step."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new 1D array where each element is the hyperbolic tangent (tanh) of the corresponding element in the input array."
    },
    {
        "instruction": "Implement a function that takes a scalar numerical value `c` and a scalar numerical value `x`. It should compute the hyperbolic tangent of their product (`c * x`) and return this result twice as a tuple: `(result, result)`."
    },
    {
        "instruction": "Write a function that simulates an iterative process with a multi-part state. Input: an initial state tuple (e.g., containing two numbers and a 1D numerical array) and a sequence of items. For each item in the sequence, update the state tuple based on a fixed rule involving elements of the current state (e.g., `new_state = (state[0], state[0] + state[1], fixed_array)`). Return the final state tuple after processing the entire sequence."
    },
    {
        "instruction": "Implement a function that takes a sequence (e.g., a list or tuple) and returns a new sequence containing only the elements at even indices (0, 2, 4, ...) from the input."
    },
    {
        "instruction": "Develop a function that iteratively updates a numerical value. It should take an initial numerical 'carry' value and a list of input numbers. For each input number, update the carry by adding the input number to it. Return the final carry value after processing all inputs."
    },
    {
        "instruction": "Write a function that creates a 1D numerical array containing floating-point numbers starting from 0.0 up to (but not including) a specified integer N."
    },
    {
        "instruction": "Implement a function that takes a list of numerical arrays `c` (length N >= 2). Return a new list containing N-1 arrays, where the array at index `j` (0-based) in the new list is the element-wise sum of `c[j]` and `c[j+1]` from the input list. Assume arrays have compatible shapes for addition."
    },
    {
        "instruction": "Design a function simulating one step of a sequence transformation. It accepts a list of numerical arrays `state`. It returns a new list `next_state` where `next_state[0]` is `max(state[0], 0)` element-wise, and `next_state[i] = state[i-1] + state[i]` for `i > 0`. Assume compatible shapes."
    },
    {
        "instruction": "Write a higher-order function `vectorize` that takes a function `f` (which operates on single data points) and returns a new function `vectorized_f`. `vectorized_f` should accept a 1D array and return a new 1D array where each element is the result of applying `f` to the corresponding element of the input array."
    },
    {
        "instruction": "Create a function that computes the element-wise derivative of the ReLU function for a given input array `x`, scaled by a corresponding \"sensitivity\" array `t`. The output array should have elements equal to `t` where `x > 0`, and 0 otherwise, maintaining the shape of `t`."
    },
    {
        "instruction": "Create a function that calculates the sum of all elements in a 1D numerical array. Input: 1D numerical array. Output: A single scalar number representing the sum."
    },
    {
        "instruction": "Write a function that computes the element-wise sigmoid activation for a given numerical array. Input: 1D numerical array. Output: 1D numerical array of the same shape."
    },
    {
        "instruction": "Design a function that simulates a stateful sequence update step. It accepts a 'previous state' (can be any data type, initially null or empty), a 'current input' value (number), and a 'parameter' (number). It should return a tuple containing the 'next state' and an 'output value'. Define the update logic such that the output value is calculated using the parameter and current input (e.g., `output = sigmoid(parameter * current_input)`), and the next state is determined (e.g., it could simply be the previous state passed along)."
    },
    {
        "instruction": "Implement a function that processes a sequence. It takes a scalar parameter `p` and a 1D numerical array `seq`. For each element `x` in `seq`, it calculates `sigmoid(p * x)`. Return a new 1D array containing these calculated values."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array (e.g., shape N x M) and another function `f` which operates on 1D arrays of size M. Apply function `f` to each row of the input array and return a 1D array containing the N results."
    },
    {
        "instruction": "Implement two functions to simulate a custom operation: `forward_op` takes a 1D numerical array, returns its sum and the original array (as context). `backward_op` takes the context (original array) and an upstream scalar value, returning a new 1D array of the same shape as the context, where each element equals the upstream scalar."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array. For each row, calculate its sum. Then, sum these individual row sums to get a final single scalar result. Return this final scalar value."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array and returns a single scalar value representing the sum of all its elements."
    },
    {
        "instruction": "Write a function that takes a numerical array and a scalar value. Return a new array where each element of the input array is multiplied by the scalar value."
    },
    {
        "instruction": "Develop a function that processes a batch of data using an iterative operation. It accepts a 2D numerical array (where each row is an independent data sample), a scalar coefficient `c`, and a fixed number of iterations (e.g., 3). Apply the iterative update process (multiply by `c` at each step) independently to each row. Return a 2D array containing the final results for each row, maintaining the batch dimension."
    },
    {
        "instruction": "Write a function to compute the gradient for a batched iterative process. Input: an initial batch of arrays (2D array `X`), a scalar coefficient `c`, a fixed number of iterations (e.g., 3), and a batch of output gradients `G` (same shape as the result of Task 4). Calculate the gradient with respect to the initial batch `X` by applying the chain rule backwards through the iterative multiplication steps for each item in the batch independently. Return the resulting gradient for `X` (a 2D array)."
    },
    {
        "instruction": "Implement a function that iteratively updates an array. It takes an initial numerical array `x`, a scalar coefficient `c`, and a number of iterations `N`. In each iteration `i` (from 0 to N-1), it updates the array by multiplying its current value element-wise by `c`. Return the final array after `N` iterations."
    },
    {
        "instruction": "Create a function `check_flag` that accepts two boolean arguments, `must_be_true` and `ignored`. If `must_be_true` is `False`, the function should raise a value error. Otherwise, the function completes without returning any value. The `ignored` argument does not affect the function's behavior."
    },
    {
        "instruction": "Design a function `execute_based_on_flag` that takes a dictionary `execution_log` (mapping integer IDs to their last execution details), an integer `id`, an integer `data`, and a boolean `flag`. The function should perform a calculation (e.g., `id * data`). It should only record the execution (e.g., update `execution_log[id] = {'data': data, 'flag': flag, 'result': calculated_value}`) if this `id` has never been seen before OR if the provided `flag` is different from the stored `flag` for this `id` in `execution_log`. Return the calculated value, whether it was newly computed or retrieved from a hypothetical cache based on the log."
    },
    {
        "instruction": "Implement a function `compute_and_log` that takes a list `log_list` and three integer arguments `a`, `b`, `c`. The function must append the integer `1` to `log_list` *before* calculating and returning the value `100*a + 10*b + c`."
    },
    {
        "instruction": "Develop a function `process_conditionally` that takes a list `history` and two arguments: an identifier `id` (integer) and a value `data` (integer). If `history` is empty or if the provided `id` is different from the `id` recorded in the last entry of `history`, append the tuple `(id, data)` to `history`. The function should always return `id + data`."
    },
    {
        "instruction": "Write a function `compose(f, g)` that takes two single-argument numerical functions, `f` and `g`, and returns a *new* function `h` such that calling `h(x)` computes `f(g(x))`."
    },
    {
        "instruction": "Develop a function `apply_n_times(func, n, x)` that takes a single-argument numerical function `func`, a non-negative integer `n`, and a numerical value `x`. It should return the result of applying `func` to `x` exactly `n` times. If `n=0`, it should return `x`."
    },
    {
        "instruction": "Create a function `chain_apply(funcs, x)` that accepts a list of single-argument numerical functions `funcs = [f1, f2, ..., fn]` and a numerical value `x`. It should apply the functions sequentially from right to left, returning `f1(f2(...(fn(x))...))`. Handle an empty list of functions by returning `x`."
    },
    {
        "instruction": "Write a function `verify_composition_strategy(funcs, x, tolerance)` that takes a list of single-argument numerical functions `funcs`, a numerical input `x`, and a small positive numerical `tolerance`. It should compute the result using both direct sequential application (Task 3 logic) and the recursive composition strategy (Task 4 logic). Return `True` if the absolute difference between the two results is within the specified `tolerance`, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes two scalar numerical inputs, `a` and `b`, and computes the value `log(exp(a) + exp(b))`, ensuring numerical stability."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns the scalar sum of all its elements."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array `arr` and a scalar value `s`. It should first compute the sum of the elements in `arr`, add `s` to this sum, and then compute `log(exp(s) + exp(sum_result + s))`, returning the final scalar result."
    },
    {
        "instruction": "Develop a function that accepts a 2D numerical array (M rows, N columns), a scalar value `s`, and another function `row_func`. `row_func` takes a 1D array (N elements) and the scalar `s` and returns a scalar. Your function should apply `row_func` to each row of the 2D array using the same scalar `s` for every row, and return the scalar sum of all results produced by `row_func`."
    },
    {
        "instruction": "Develop a function `validate_spec_object` that takes one argument. It should return `True` if the argument possesses both a `shape` attribute (which must be a tuple) and a `dtype` attribute, and `False` otherwise."
    },
    {
        "instruction": "Implement a class `AttributeDict` that behaves like a standard dictionary but also allows accessing its keys as attributes. For instance, if `d = AttributeDict({'value': 10})`, then `d.value` should return `10`."
    },
    {
        "instruction": "Write a function that accepts an object. If the object has an attribute named `shape`, return the value of that attribute. Otherwise, return `None`."
    },
    {
        "instruction": "Create a function `get_identity_output_spec` that takes an input specification object. This object is guaranteed to have a `shape` attribute (a tuple of integers). The function should return a new object that also has a `shape` attribute with the exact same value as the input object's `shape`."
    },
    {
        "instruction": "Write a function that accepts a list containing exactly two 32-bit unsigned integers and a boolean flag. If the flag is true, return a simple object or structure encapsulating the list; otherwise, return the original list."
    },
    {
        "instruction": "Create a function that accepts a state representing a pseudo-random number generator key (e.g., a list of two 32-bit unsigned integers) and returns a single floating-point number simulating a draw from a standard normal distribution based on the key state."
    },
    {
        "instruction": "Implement a function that takes a state representing a pseudo-random number generator key (e.g., a list of two 32-bit unsigned integers) and deterministically generates two new, distinct key states from it using a defined splitting algorithm. Return the two new key states as a pair."
    },
    {
        "instruction": "Write a function `process_key` that accepts a mutable list containing a single generator key state (e.g., list of two uint32). Inside `process_key`, define and immediately call an inner function. This inner function should split the key from the list, generate a scalar value using one part, and update the key in the list with the other part. The `process_key` function should then modify the key state in the list to indicate it has been 'processed' (e.g., wrap it in a simple object or convert its type) and return this modified state."
    },
    {
        "instruction": "Design a function that analyzes a list of strings, where each string represents an instruction like \"LOAD_CONST C1 [7, 14]\" or \"ADD R1 X C1\". Identify and return a list of unique constant value strings (e.g., \"[7, 14]\") that appear in \"LOAD_CONST\" instructions more than once across the entire list."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays, `input_arr` and `constant_arr`, of the same shape. Return a new array representing the element-wise sum `input_arr + constant_arr + constant_arr`."
    },
    {
        "instruction": "Develop a function that takes a multi-line string (e.g., representing configuration or code) and a target pattern string. Return `True` if the target pattern appears as a complete line exactly once within the input string (ignoring leading/trailing whitespace on each line), and `False` otherwise."
    },
    {
        "instruction": "Create a function `create_adder` that accepts a 1D numerical array `constant_val`. This function should return a *new function* called `adder`. The returned `adder` function must take one argument, a 1D numerical array `input_arr` (compatible shape with `constant_val`), and return the element-wise sum `input_arr + constant_val`."
    },
    {
        "instruction": "Write a function that takes a shape (tuple of positive integers), a scalar numerical parameter `p`, and a seed value. It should return a numerical array of the given shape, filled with pseudo-random values determined by `p` and the seed. *Focus on the generation based on inputs, not complex seeding algorithms.*"
    },
    {
        "instruction": "Create a function that takes a numerical scalar `value` and a target shape `shape` (tuple of positive integers). Return a new numerical array of shape `shape` where all elements are equal to `value`. This simulates broadcasting a scalar."
    },
    {
        "instruction": "Define a function that simulates a custom forward-mode automatic differentiation rule. It should accept: a shape `s` (tuple), a scalar parameter `p`, and a scalar tangent `dp` (representing the derivative of `p`). The function should first compute a 'primal' output array `y` (e.g., using a hypothetical random generation based on `s` and `p`). Then, it should compute the 'tangent' output array `dy` by element-wise multiplying the primal output `y` with the input tangent `dp` (after broadcasting `dp` to shape `s`). The function must return both `y` and `dy`. Treat `s` as non-differentiable data."
    },
    {
        "instruction": "Implement a function that accepts two numerical arrays, `arr1` and `arr2`, which must have the exact same shape. Return a new array of the same shape where each element is the product of the corresponding elements from `arr1` and `arr2`."
    },
    {
        "instruction": "Develop a function that accepts two 1D numerical arrays, `x` of size `M` and `y` of size `N`. It should compute and return a 3D numerical array of shape `(M, N, M)`. This 3D array represents the sensitivity of the outer product `outer(x, y)` with respect to changes in `x`. Specifically, the element `(i, j, k)` of the output array should be equal to the `j`-th element of `y` if `i == k`, and 0.0 otherwise."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array (vector) of length `L` and an integer `N` (where `N <= L`). It should return a 2D numerical array (matrix) of shape `N x L`. The element `(i, j)` of the output matrix should be 1.0 if `i == j` and 0.0 otherwise. This matrix represents the mapping from the full input vector to its first `N` elements."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays, `x` of size `M` and `y` of size `N`. It should return a dictionary containing two keys: 'identity_map' and 'outer_product_sensitivity_x'. The value for 'identity_map' should be an `M x M` identity matrix. The value for 'outer_product_sensitivity_x' should be the 3D array of shape `(M, N, M)` as described in Task 4."
    },
    {
        "instruction": "Create a function that takes two scalar numerical inputs. It should return a nested tuple `((1.0, 0.0), (0.0, 1.0))`. This structure represents the sensitivity matrix for a function that simply returns its two inputs as outputs."
    },
    {
        "instruction": "Create a function `process_input` that accepts a single numerical value `x`. Inside this function, call a helper function `calculate_pair` which takes `0.0` and `x` and returns the pair `(0.0, e^x)`. The `process_input` function must return only the *first* element from the pair returned by `calculate_pair`."
    },
    {
        "instruction": "Write a function that takes two numerical inputs, `a` and `x`. It should return a two-element structure (like a tuple or list) containing `a` as the first element and the exponential of `x` (`e^x`) as the second element."
    },
    {
        "instruction": "Develop a function that takes a scalar number `v`. Inside, it calls an internal routine that accepts `0.0` and `v`, returning a two-item sequence `(0.0, v * v)`. The outer function should extract and return only the first item from this sequence."
    },
    {
        "instruction": "Consider a function `get_first(x)` that internally computes a pair `(0.0, some_calculation(x))` and always returns the first element (0.0). Write a *new* function `analyze_sensitivity(x)` that determines the rate of change of the output of `get_first` with respect to its input `x`."
    },
    {
        "instruction": "Implement a function `safe_add` that takes two arguments. If both arguments are numerical (integer or float), return their sum. If they are not both numerical, return the string \"Error: Incompatible types for addition\"."
    },
    {
        "instruction": "Develop a function that takes two arguments. Check if both arguments are numerical (integer or float). If they are, return their product. If not, raise a `TypeError` with the message \"Invalid argument type for multiplication\"."
    },
    {
        "instruction": "Write a function that takes two arguments. Return `True` if both arguments are numerical types (integer or float), and `False` otherwise."
    },
    {
        "instruction": "Write a function `apply_or_handle_error` that takes three arguments: a binary function `op`, and two potential operands `arg1`, `arg2`. The function should attempt to call `op(arg1, arg2)`. If a `TypeError` occurs during the call, it should return the string \"Operation failed due to type mismatch\". Otherwise, it should return the result of the operation."
    },
    {
        "instruction": "Create a registry mechanism using a set data structure to store unique string identifiers. Write a function `register_id(identifier)` that adds the string `identifier` to the set. Write another function `get_registry_size()` that returns the total number of unique identifiers currently in the set."
    },
    {
        "instruction": "Implement a function `execute_and_log_first(operation_id, func, arg1, arg2)`. This function takes a string `operation_id`, a function `func` that accepts two arguments, and two arguments `arg1`, `arg2`. It should use a global or shared registry (like in Task 3) to track `operation_id`s. If the `operation_id` is not yet in the registry, add it. Then, execute `func(arg1, arg2)` and return its result. Ensure the registry only stores each unique `operation_id` once."
    },
    {
        "instruction": "Design an `OperationCacheChecker` class. It should have a method `execute(op_name, function_ref, input1, input2)`. Internally, it must maintain a record (e.g., a set) of `op_name` strings that have been passed to `execute` previously. The first time `execute` is called with a *new* `op_name`, it should increment an internal counter. It should always call `function_ref(input1, input2)` and return the result. Provide a method `get_unique_op_count()` that returns the value of the internal counter."
    },
    {
        "instruction": "Write a function `perform_add(a, b)` that accepts two numerical scalar inputs and returns their sum."
    },
    {
        "instruction": "Create a system involving a function `process_data` (e.g., one that doubles elements in a list) and a `manager`. The `manager` should have methods to: (a) execute `process_data` on given input, logging a 'processing started' message each time it begins execution, and (b) clear any internal state that might affect subsequent executions. Write a script that uses the manager to execute `process_data` once, then clears the state, then executes it again, and finally returns the total count of 'processing started' messages logged (expected count: 2)."
    },
    {
        "instruction": "Implement a class `FunctionTracker` that wraps a given function. The tracker should have a `call` method that executes the wrapped function with provided arguments, increments an internal counter for each call, and returns the function's result. Include a method to retrieve the current call count."
    },
    {
        "instruction": "Develop a function `apply_and_reset` that takes another function `func` and an input `data`. It calls `func(data)`, then simulates a reset operation (conceptually clearing any state associated with the last call), and finally calls `func(data)` again. It should return the result of the *second* call."
    },
    {
        "instruction": "Create a function that takes a positive integer `N` and returns a 1D numerical array containing the sequence of integers from 0 up to (but not including) `N`."
    },
    {
        "instruction": "Design a basic registry. Implement functions `register_item(item)`, `deregister_item(item)`, and `get_registry_size()`. `register_item` should add an item to the registry only if it's not already present. `deregister_item` should remove an item if it exists. `get_registry_size` should return the current number of items in the registry."
    },
    {
        "instruction": "Write a function that accepts one argument of any type and returns that argument exactly as it was received, without any changes."
    },
    {
        "instruction": "Create a function `execute_pipeline_and_track_first_calls` that takes a list of functions `[func1, func2, ...]` and an initial input value. It should execute the functions sequentially, passing the output of one as the input to the next (i.e., compute `funcN(...func2(func1(initial_value))...)`). During execution, it must also count how many *unique* functions from the list were called for the *very first time* within this specific execution run. Return both the final computed value and this count of unique first-time function calls."
    },
    {
        "instruction": "Create a function `apply_twice` that takes two arguments: another function `f` and a value `x`. Your function should call `f` with `x` as input, take the result, and then call `f` again with that result. Return the final output."
    },
    {
        "instruction": "Develop a higher-order function named `apply_and_extract_aux`. This function should accept two arguments: another function `target_func` and a floating-point number `x`. Assume `target_func` takes `x` and returns a tuple `(result, auxiliary_list)`. Your `apply_and_extract_aux` function should call `target_func(x)` and return the *first element* of the `auxiliary_list`."
    },
    {
        "instruction": "Implement a function that receives a single floating-point number `x` and calculates the product of its cube and its sine (i.e., `x**3 * sin(x)`)."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number and returns its cube."
    },
    {
        "instruction": "Create a function that takes a single floating-point number `x` and returns a tuple containing two elements: the first element is `x` cubed, and the second element is a list containing only `x` cubed."
    },
    {
        "instruction": "Create a function that accepts a scalar number `x` and returns two values: the number cubed (`x**3`) and a list containing only the number cubed (`[x**3]`)."
    },
    {
        "instruction": "Write a function that takes a single floating-point number `x` and returns its cube (`x**3`)."
    },
    {
        "instruction": "Implement a function that calculates the mathematical derivative of `f(x) = x^3 * sin(x)` with respect to `x`. The function should take a floating-point number `x` as input and return the value of the derivative at that point."
    },
    {
        "instruction": "Write a function that accepts a scalar number `x`. This function should internally compute two intermediate values based on `x`: `val1 = x**3` and `val2 = [x**3]`. The function should then return `val2[0] * sin(x)`."
    },
    {
        "instruction": "Implement a function `process_data(x)` that internally calls another function `get_data(x)`. `get_data(x)` returns two numerical values, `value1` and `value2`. The `process_data` function should return only `value2`."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x` and returns its cube (x raised to the power of 3)."
    },
    {
        "instruction": "Create a function that accepts a single numerical input `x` and returns two separate numerical outputs: the original input `x` and its cube (`x**3`)."
    },
    {
        "instruction": "Develop a function `calculate_product(x)` that calls an inner helper function `get_components(x)`. `get_components(x)` returns two numerical values, `component_a` and `component_b`. `calculate_product(x)` should compute and return the product of `component_b` and the sine of the original input `x`."
    },
    {
        "instruction": "Create a function that takes two arguments: another function `f` (which expects a single numerical input) and a value `x`. The function should call `f(x)` but specifically raise a `ValueError` if the input `x` is a complex number, otherwise return the result of `f(x)`."
    },
    {
        "instruction": "Implement a function that calculates the sine of a given numerical input (which could be real or complex). Return the calculated value."
    },
    {
        "instruction": "Write a function that accepts a single argument and returns `True` if the argument is a complex number, and `False` otherwise."
    },
    {
        "instruction": "Write a higher-order function that takes a function `func` as input. This `func` is assumed to operate on numerical inputs. The higher-order function should return a *new* function. This new function, when called with an argument `arg`, should first check if `arg` is complex. If it is complex, the new function must raise a `TypeError`. If `arg` is not complex, the new function should return the result of `func(arg)`."
    },
    {
        "instruction": "Create a function that takes a complex number `z` as input, calculates the complex sine of `z`, and returns the complex sum of the original input `z` and the calculated sine value."
    },
    {
        "instruction": "Write a function that numerically approximates the derivative of a real-valued function f(x) at a real point x0 using the central difference formula: (f(x0 + h) - f(x0 - h)) / (2h). The function should accept the function f, the point x0, and a small step h as input."
    },
    {
        "instruction": "Implement a function that calculates the mathematical sine of a given complex number input and returns the resulting complex number. Use the standard definition: sin(a + bi) = sin(a)cosh(b) + i*cos(a)sinh(b)."
    },
    {
        "instruction": "Implement a function that computes the exact mathematical derivative of the complex sine function evaluated at a specific complex input point `z0`. The function should take `z0` as input and return the resulting complex number. (Mathematical hint: the derivative of sin(z) is cos(z))."
    },
    {
        "instruction": "Write a function `assert_type_error` that takes a function `func` and an argument `arg`. It should call `func(arg)` and return `True` if a `TypeError` is raised during the call, and `False` otherwise (if no error or a different error occurs)."
    },
    {
        "instruction": "Write a function that accepts a single numerical argument. If the argument is a complex number, the function should raise a `TypeError`. Otherwise, it should return the argument unchanged."
    },
    {
        "instruction": "Design a function `apply_restricted_func` that takes a function `op` (expected to work only on real numbers) and a numerical input `x`. If `x` is complex, raise a `TypeError` immediately. If `x` is real, call `op(x)`. If `op(x)` returns a complex number, raise a `ValueError`. Otherwise, return the real result from `op(x)`."
    },
    {
        "instruction": "Implement a function `check_if_complex` that takes one argument. Return `True` if the argument is a complex number, and `False` otherwise."
    },
    {
        "instruction": "Design a function that accepts two functions, `op1` and `op2`, and an initial input value `x`. The function's goal is to compute `op2(op1(x))`. However, it must first validate that the initial input `x` is not a complex number. If `x` is complex, the function must raise a `TypeError` immediately, without calling `op1` or `op2`. Otherwise, it computes and returns the result of `op2(op1(x))`."
    },
    {
        "instruction": "Develop a function wrapper `guard_complex`. This wrapper accepts a function `func` and returns a *new* function. When the new function is called with an argument `arg`, it must first check if `arg` is a complex number. If it is, the new function must raise a `TypeError`. If `arg` is not complex, the new function should then call the original `func(arg)` and return its result."
    },
    {
        "instruction": "Create a function that takes another function `f` and a value `x` as input. It should attempt to call `f(x)`. If this call specifically raises a `TypeError`, the function should catch it and return the boolean `True`. In all other situations (successful call or different error), it should return `False`."
    },
    {
        "instruction": "Implement a function that calculates the sine of a given numerical input. Add a specific check: if the input number is complex, raise a `TypeError`. The function should only proceed with the calculation for non-complex (e.g., real) numbers."
    },
    {
        "instruction": "Write a function that takes two arguments: another function `func` (which itself takes a single numerical input and returns a numerical output) and a numerical value `val`. The function should execute `func(val)` and return a list of strings describing the sequence of fundamental mathematical operations (e.g., \"cosine\", \"sine\") conceptually performed within `func`. For example, if `func` computes sin(cos(val)), the output might be [\"cosine\", \"sine\"]."
    },
    {
        "instruction": "Develop a function that accepts a string of text and checks if it contains both the substring \"sine\" and the substring \"cosine\". It should return `True` if both are present, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a single numerical input `y` and returns its sine."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x` and returns its cosine."
    },
    {
        "instruction": "Write a function that approximates the derivative of a given mathematical function `f` at a point `x` using the central difference formula: `(f(x + h) - f(x - h)) / (2 * h)`, where `h` is a small positive number (e.g., 1e-6). The function should take `f`, `x`, and `h` as input and return the approximate derivative (float)."
    },
    {
        "instruction": "Create a function that takes another function `f` (which accepts a float and returns a float), an input value `x` (float), and an expected output value `y` (float). The function should return `True` if the absolute difference between `f(x)` and `y` is within a small tolerance (e.g., 1e-5), and `False` otherwise."
    },
    {
        "instruction": "Write a function that computes the mathematical sine of a single floating-point number. Input: float, Output: float."
    },
    {
        "instruction": "Write a function that computes the mathematical cosine of a single floating-point number. Input: float, Output: float."
    },
    {
        "instruction": "Develop a function that takes two arguments: a function `func` (which accepts one numerical scalar argument) and a numerical scalar value `val`. Your function should call `func` with `val` and return the scalar result."
    },
    {
        "instruction": "Write a function that implements the mathematical identity function. It should accept a single numerical scalar input and return the same value."
    },
    {
        "instruction": "Create a higher-order function that accepts a single-variable function `original_func` (taking one numerical scalar and returning one) as input. This higher-order function should return a *new* function. The returned function, when called with a numerical scalar `p`, should compute and return the first derivative of `original_func` evaluated at `p`."
    },
    {
        "instruction": "Implement a function that numerically estimates the first derivative of a given single-variable function `f` at a specific point `x`. Inputs are the function `f` and the numerical scalar `x`. Output should be the estimated numerical scalar derivative."
    },
    {
        "instruction": "Write a function that takes a boolean flag `use_alt_logic` and an integer `num_runs`. The function simulates running a process `num_runs` times, recording a standard \"Process Ran\" message each time. If `use_alt_logic` is True, it records one additional, different message (e.g., \"Alt Logic Used\"). The function must return `True` only if the total number of recorded messages matches the expected count based on the flag (`num_runs` or `num_runs + 1`), otherwise return `False`."
    },
    {
        "instruction": "Write a function that accepts a single numerical input x and returns the value 2 * x."
    },
    {
        "instruction": "Implement a function that takes an integer `n`. Inside a loop running `n` times, it should execute a predefined simple calculation (e.g., multiply a fixed number like 3 by 2). The function should return a list containing the result obtained in each iteration."
    },
    {
        "instruction": "Create a function that takes two strings, `main_string` and `sub_string`, and returns `True` if `sub_string` is found anywhere within `main_string`, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts: 1) a list of exactly 3 numerical values, 2) an 'input permutation' list (e.g., [1, 2, 0]), 3) an 'output permutation' list (e.g., [2, 0, 1]), 4) an integer `n_pass`, and 5) an integer `n_exp`. First, reorder the input list using the 'input permutation'. Then, create an intermediate result list: take the first `n_pass` elements from the reordered list directly; for the remaining elements, apply the exponential function to the next `n_exp` of them and the sine function to any thereafter. Finally, reorder this intermediate list using the 'output permutation' and return the final list."
    },
    {
        "instruction": "Develop a function that processes a list of numerical values based on two integer parameters, `n_pass` and `n_exp`. Return a new list where the first `n_pass` elements are identical to the input list's first `n_pass` elements. For the elements *after* the first `n_pass`, apply the exponential function to the next `n_exp` of them, and apply the sine function to any remaining elements."
    },
    {
        "instruction": "Write a function that takes an integer `n` and a seed value, and returns a random permutation of the integers from 0 to `n-1`. The output should be a list or array of these `n` integers in a shuffled order."
    },
    {
        "instruction": "Create a function that reorders a given list based on a provided list of indices (a permutation). It should accept the input list and the permutation list, returning a new list with elements rearranged according to the permutation indices."
    },
    {
        "instruction": "Develop two distinct functions, `direct_calc` and `stepwise_calc`, both intended to compute the same result for a given numerical input `x`. `direct_calc(x)` should compute `cos(x) * sin(2 * sin(x))` in a single expression. `stepwise_calc(x)` should first compute `y = 2 * sin(x)` and then compute `z = cos(x) * sin(y)`. Write a third function `check_equivalence` that takes `x`, calls both functions, and returns `True` if their outputs are numerically very close (e.g., absolute difference less than 1e-6), `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x`. Inside the function, calculate an intermediate value `y` as twice the sine of `x`. Then, return the product of the cosine of `x` and the sine of `y`."
    },
    {
        "instruction": "Implement a function `calculate_z` that takes two numerical inputs, `x` and `y`. It should return the product of the cosine of `x` and the sine of `y`. Now, create another function `compute_with_intermediate` that takes a single numerical input `x`, calculates `y = 2 * sin(x)`, and then calls `calculate_z(x, y)` to get the final result, which it returns."
    },
    {
        "instruction": "Create a function that accepts a single number and returns the result of applying the sine function to it, then multiplying the result by 2."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and applies the sine function twice to each element (e.g., `sin(sin(element))`), returning a new array of the same shape."
    },
    {
        "instruction": "Develop a function that computes the Jacobian matrix for a function `f` applied element-wise to a 1D input array `x`, where `f(y) = sin(sin(y))`. The function should take the 1D array `x` and return the corresponding 2D Jacobian matrix."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array `x` and computes the element-wise derivative of `sin(sin(x))` with respect to `x`, returning a new array of the same shape containing the derivative values."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `x` and returns a new 1D array where the i-th element of the output is the i-th element of `x` plus the index `i`."
    },
    {
        "instruction": "Implement a function `apply_elementwise(func, matrix)` that takes a callable `func` (representing a unary mathematical operation like sine) and a 2D numerical array `matrix`. It should return a new 2D array of the same dimensions where `func` has been applied to each element individually."
    },
    {
        "instruction": "Write a function `map_and_transpose_transform(matrix)` that takes a 2D numerical array `matrix` of shape (M, N). It should first apply the transformation `y = sin(sin(x))` to every element `x` in the input matrix. Then, it should return the transpose of the resulting matrix, yielding an output array of shape (N, M)."
    },
    {
        "instruction": "Write a function `nested_sine(arr)` that takes a numerical array `arr` of any shape. It should return a new array of the same shape where each element is the result of applying the sine function twice (sin(sin(element))) to the corresponding input element."
    },
    {
        "instruction": "Develop a function `generate_sequential_matrix(rows, cols)` that creates a 2D numerical array (matrix) with the specified number of `rows` and `cols`. The elements should be sequential floating-point numbers starting from 0.0 (e.g., for 3 rows, 5 cols, the elements would be 0.0, 1.0, ..., 14.0, arranged row-wise)."
    },
    {
        "instruction": "Write a function that takes two single-argument numerical functions, `func1` and `func2`, and a numerical value `x`. It should return the result of applying `func2` to `x` and then applying `func1` to that result, effectively computing `func1(func2(x))`."
    },
    {
        "instruction": "Develop a higher-order function called `transform_function` that accepts a single-argument numerical function `original_func` as input. It should return a *new* function that, when called with an argument `x`, computes `original_func(x)` and then returns the result. (This task focuses on the concept of wrapping a function without changing its core behavior initially)."
    },
    {
        "instruction": "Create a function to numerically approximate the second derivative of a given single-variable function `f` at a point `x`. Use the finite difference formula `(f(x + h) - 2*f(x) + f(x - h)) / h**2` with a small step `h` (e.g., 1e-5). The input function `f` accepts and returns a single floating-point number."
    },
    {
        "instruction": "Implement a function to numerically approximate the first derivative of a given single-variable function `f` at a point `x`. Use the central difference formula `(f(x + h) - f(x - h)) / (2 * h)` with a small step `h` (e.g., 1e-5). The input function `f` accepts and returns a single floating-point number."
    },
    {
        "instruction": "Create a function `apply_sequence_with_filter`. It takes an initial numerical value `x`, a list of function objects `[f1, f2, f3]`, and a `filter_func`. It applies the functions sequentially: `intermediate1 = f1(x)`, `intermediate2 = f2(intermediate1)`, `result = f3(intermediate2)`. It should return the final `result` and a list containing only those functions from the input list for which `filter_func(function_object)` returned `True`."
    },
    {
        "instruction": "Create a function that accepts a single numerical input and returns its square (the number multiplied by itself)."
    },
    {
        "instruction": "Implement a function `trace_computation_and_derivative`. It takes a composite function `f` (e.g., representing `sin(square(sin(x)))`), an input value `x`, and a tangent value `t`. It should compute both `y = f(x)` and the directional derivative `ydot` (the result of the derivative of `f` at `x` applied to `t`). Additionally, it should accept a `policy` function. During the computation, whenever an intermediate operation (conceptually, 'sin' or 'square') is performed, the `policy` function is called with a description of that operation (e.g., the string 'sin' or 'square'). The function should return `y`, `ydot`, and a list of the descriptions for which the `policy` returned `True`."
    },
    {
        "instruction": "Write a function that takes a number `x` as input. Calculate `sin(x)`, then square the result, then calculate the sine of the squared result. Return the final numerical value."
    },
    {
        "instruction": "Implement a function that simulates applying a sequence of named operations (provided as a list of strings, e.g., [\"negate\", \"square\", \"add_one\"]) to an initial scalar value. The function also accepts a `policy` function (which takes an operation name string and returns boolean). Return a tuple containing the final scalar result and a list of the names of operations for which the `policy` function returned `True` during the sequence execution."
    },
    {
        "instruction": "Develop a function that takes a string representing a simple nested function call (e.g., \"func_a(func_b(input))\", \"op1(op2(op3(x)))\"). Parse this string and return a list containing the unique names of all functions/operations called within the expression (e.g., [\"func_a\", \"func_b\"] or [\"op1\", \"op2\", \"op3\"])."
    },
    {
        "instruction": "Write a function to numerically approximate the derivative of a given single-variable scalar function `f` at a point `x`. Use the central difference formula: `(f(x + h) - f(x - h)) / (2 * h)`, where `h` is a small positive value provided as input. Return the calculated approximation."
    },
    {
        "instruction": "Create a function that acts as a simple execution policy. It should accept a string representing an operation's name (e.g., \"add\", \"multiply\", \"transform\") and a list of its arguments. The function should return `True` if the operation name is exactly \"multiply\", and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and returns a new matrix where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Implement matrix multiplication for two compatible 2D numerical arrays (e.g., shape (M, K) and (K, N)). The function should prioritize numerical accuracy in the intermediate calculations to produce a high-precision result. Return the resulting matrix of shape (M, N)."
    },
    {
        "instruction": "Develop a function that applies the following sequence of operations to an input square 2D numerical array: (1) square it, (2) apply element-wise sine, (3) square it, (4) apply element-wise sine, (5) square it, (6) apply element-wise sine. Return the final matrix."
    },
    {
        "instruction": "Implement a function that takes a square 2D numerical array, squares it using matrix multiplication, and then applies the sine function element-wise to the result. Return the final matrix."
    },
    {
        "instruction": "Create a function that performs matrix multiplication of a square 2D numerical array (matrix) with itself. Input shape (N, N) should result in output shape (N, N)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and applies the sine function element-wise to all its entries. Return the resulting matrix of the same shape."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and two other functions, `func_a` and `func_b`, as input. Apply `func_a` to the matrix, then apply `func_b` to the result, then apply `func_a` again, then `func_b` again, then `func_a` again, and finally `func_b` again. Return the final matrix. Assume `func_a` and `func_b` are compatible for sequential application."
    },
    {
        "instruction": "Implement a function that takes a square 2D numerical array (matrix), multiplies it by itself, and then applies the sine function element-wise to the result. Return the final matrix."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and returns a new array of the same shape where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Create a function that takes a single 3D numerical array `X` with shape `(N, M, M)` and returns a new 3D array `Y` of the same shape, where each 2D slice `Y[n, :, :]` is the result of multiplying the corresponding slice `X[n, :, :]` by itself."
    },
    {
        "instruction": "Develop a function that applies a specific two-step transformation to a 3D numerical array `X` of shape `(N, M, M)`. First, compute the batch matrix product of `X` with itself. Second, apply the element-wise sine function to the result of the first step. Return the final 3D array."
    },
    {
        "instruction": "Write a function that repeatedly applies a transformation sequence to a 3D numerical array `X` of shape `(N, M, M)`. The sequence consists of: (1) computing the batch matrix product of the current array with itself, and (2) applying the element-wise sine function to the result. The function should take the initial array `X` and an integer `k` as input, apply this two-step sequence exactly `k` times, and return the final 3D array. Maintain numerical accuracy throughout the process."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `M` and a positive integer `N`. The function should repeatedly apply a transformation to `M` exactly `N` times. The transformation consists of: first, squaring the matrix (`M` becomes `M` multiplied by `M`), and second, applying an element-wise function `f(x) = sin(0.001 * x)` to the result. Return the final matrix after `N` applications of this two-step transformation."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array. It should scale each element by 0.001 and then compute the sine of each element. Return the resulting 2D array with the same shape as the input."
    },
    {
        "instruction": "Develop a function that takes a square 2D numerical array. It should perform the following sequence exactly three times: 1. Multiply the current array by itself. 2. Scale the result by 0.001 and apply the sine function element-wise. Return the final 2D array after the three repetitions."
    },
    {
        "instruction": "Create a function that accepts a square 2D numerical array (matrix) and returns the result of multiplying the matrix by itself. The output should have the same dimensions as the input."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns a new 2D array of the same shape filled entirely with zeros."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array and returns a new 2D array where each element is the sine of the corresponding element in the input array."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array. It should compute the element-wise sine of the input array, create a second array of zeros with the same shape, and return the element-wise product of these two resulting arrays."
    },
    {
        "instruction": "Implement a function that extracts the main diagonal from a given square 2D numerical array (matrix) and returns it as a 1D array (vector)."
    },
    {
        "instruction": "Design a function `trace_origins` that accepts a target function `target_func` and its arguments (`*args`, `**kwargs`). Assume `target_func` performs calculations using constants, its arguments, and potentially calls a hypothetical `record_intermediate(value, name)` function. `trace_origins` should execute `target_func` and return an ordered list summarizing the origins of values involved. Each item should be a tuple: `(shape, description)`, where description indicates the source (e.g., 'from a constant', 'from argument 0', 'from argument \"y\"', 'named intermediate \"z\"'). The list should reflect a plausible order of value usage or definition."
    },
    {
        "instruction": "Create a function that takes a simple calculation function `calc` as input. Assume `calc` uses exactly one hardcoded numerical constant internally. Your function should execute `calc` (with no arguments) and return the shape of that constant value (e.g., `()` for a scalar, `(N,)` for a 1D array of length N)."
    },
    {
        "instruction": "Write a function that accepts another function `f`, a tuple of positional arguments `args`, and a dictionary of keyword arguments `kwargs`. The function should return a list containing descriptive strings for each argument provided, indicating whether it was positional (e.g., 'from positional argument 0') or keyword (e.g., 'from keyword argument \"y\"')."
    },
    {
        "instruction": "Implement a function that receives another function `compute`, its positional arguments `args`, and keyword arguments `kwargs`. Execute `compute(*args, **kwargs)`. Return a list where each element corresponds to an input argument and is a tuple containing the shape of the argument's value and a string identifying its source (e.g., `[ ((), 'argument 0'), ((), 'argument 1'), ((), 'argument \"y\"') ]`)."
    },
    {
        "instruction": "Develop a function that takes another function `func` and its arguments (`args`, `kwargs`). Execute `func(*args, **kwargs)` and return a list describing the shape of the output(s). For a scalar output, represent its shape as `()`; for a 1D array of size N, use `(N,)`."
    },
    {
        "instruction": "Implement a utility that inspects a function call. Given a function `func`, a tuple/list of positional arguments `args`, and a dictionary of keyword arguments `kwargs`, return a list of strings describing each input argument's source (e.g., \"Input from positional arg 0\", \"Input from keyword arg 'y'\")."
    },
    {
        "instruction": "Write a function that takes three scalar numerical inputs (a, b, c) and returns their product multiplied by the sine of a fixed number (e.g., sin(3.0))."
    },
    {
        "instruction": "Create a function analysis tool. It accepts a target function `func`, positional arguments `args` (as a tuple/list), and keyword arguments `kwargs` (as a dictionary). It should execute the function and return a list of pairs. Each pair should contain: (1) the shape of a value (e.g., `()` for scalar, `(N,)` for 1D array) and (2) a string describing its origin. The list must include entries for each input argument (positional and keyword) and the final output(s) of the function (e.g., `[ ( (), 'Input arg 0' ), ( (), \"Input kwarg 'y'\" ), ( (1,), 'Function output' ) ]`)."
    },
    {
        "instruction": "Write a function that takes an integer counter `i` and returns `True` if `i` is less than 3, and `False` otherwise. Input: integer. Output: boolean."
    },
    {
        "instruction": "Write a function that calculates the numerical value of the first derivative of the function g(x) = sin(sin(sin(x))) at a given point `x`. Input: number `x`. Output: number (the derivative value g'(x))."
    },
    {
        "instruction": "Implement a function that takes a numerical value `x` as input. It should apply the sine function to this value exactly 3 times in sequence (i.e., calculate sin(sin(sin(x)))) and return the final numerical result. Input: number. Output: number."
    },
    {
        "instruction": "Develop a function that takes an initial numerical value `start_value`. It should simulate a loop that runs exactly 3 times. In each iteration, it applies the sine function to the current value. The function should return the value obtained after the 3rd application of sine. Input: number. Output: number."
    },
    {
        "instruction": "Implement a function that takes an initial numerical scalar value. Simulate a loop that iterates exactly 3 times. In each iteration, update the scalar value by applying the sine function to it. Return the final scalar value after 3 iterations."
    },
    {
        "instruction": "Write a function that takes an initial numerical value `x` and an integer `n`. Implement a loop that runs `n` times. Inside the loop, maintain a state consisting of the current iteration number and the current value derived from `x`. In each iteration, update the value by applying the sine function. Return the final value after `n` iterations."
    },
    {
        "instruction": "Write a function that takes a tuple containing an integer counter and any other value. It should return `True` if the counter is strictly less than a predefined limit (e.g., 3), and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a tuple `(counter, value)` where `value` is a numerical scalar. It should return a new tuple where the counter is incremented by 1 and the value is replaced by its sine."
    },
    {
        "instruction": "Write a function `process_with_policy` that takes an initial data value and a list of functions `[step1_func, step2_func, ...]`. It applies these functions sequentially (output of step N is input to step N+1). It also takes a `policy_func` which accepts a function object (e.g., `step2_func`) and returns `True` or `False`. `process_with_policy` should execute the sequence and return two things: the final result and a list of strings. For each step where `policy_func` returned `True` for the corresponding function, add a string like 'Step X: Intermediate result saved.' to the list."
    },
    {
        "instruction": "Develop a function wrapper `execute_and_report` that takes another function `compute_func`, an input value `data`, and a reporting policy string ('full', 'input_only', 'none'). The wrapper should call `compute_func(data)`. If the policy is 'full', it should print 'Reporting: Saving inputs and intermediates.' If the policy is 'input_only', it should print 'Reporting: Saving inputs only.' If the policy is 'none', it should print nothing. The wrapper should return the result of `compute_func(data)`."
    },
    {
        "instruction": "Create a function that accepts a list of strings (representing log lines) and two keywords: `required_keyword` and `forbidden_keyword`. The function should return `True` if at least one string in the list contains the `required_keyword` AND no string in the list contains the `forbidden_keyword`. Otherwise, it should return `False`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array as input. It should compute the element-wise sine of the array, then calculate the sum of the resulting array, and finally return the cosine of that sum."
    },
    {
        "instruction": "Create a function that accepts two numerical inputs: 'saved_value' and 'multiplier'. It should calculate the cosine of 'saved_value' and multiply the result by 'multiplier'. Return the final product."
    },
    {
        "instruction": "Implement a function that takes one numerical input 'x'. It should compute two results: the sine of 'x', and the original input 'x' itself. Return both values, perhaps as a tuple or list."
    },
    {
        "instruction": "Write a function that accepts a single numerical value and returns its tangent."
    },
    {
        "instruction": "Design a function that takes two numerical inputs: 'x' and 'factor'. It should perform two distinct calculations based on 'x': first, compute the primary result 'y = tan(x)'; second, compute a related secondary result 'z = cos(x) * factor'. Return both 'y' and 'z'."
    },
    {
        "instruction": "Create a function that simulates input dependency. It accepts a list of booleans representing which outputs of a hypothetical multi-output function are used. Assuming output `i` depends only on input `i`, return a list of booleans indicating which inputs are required to compute the used outputs."
    },
    {
        "instruction": "Define a function that accepts exactly three numerical inputs (e.g., `a`, `b`, `c`) and returns a tuple containing exactly three corresponding numerical outputs, where each output is the result of applying a simple, independent mathematical operation (e.g., trigonometric function) to the respective input."
    },
    {
        "instruction": "Write a function that takes two lists of equal length: a list of data items and a list of booleans (a mask). Return a new list containing only those data items for which the corresponding boolean in the mask is `True`."
    },
    {
        "instruction": "Implement a function that processes a list of numerical values based on a corresponding boolean mask of the same length. For each value, if the corresponding mask element is `True`, apply function `f1` (e.g., `x -> x * 2`); if `False`, return `None` (or a placeholder). Return the list containing results or placeholders."
    },
    {
        "instruction": "Create a function `apply_elementwise` that takes another function `op`, and two 1D numerical arrays `vec1`, `vec2` (of the same length) as input. `apply_elementwise` should apply the function `op` to corresponding elements `(vec1[i], vec2[i])` and return a new array containing the results. The function `op` takes two numbers and returns one number."
    },
    {
        "instruction": "Design a function `vectorized_override` that takes two functions, `func_orig` and `func_vectorized`, and two 1D numerical arrays, `input1` and `input2` (of equal size). `vectorized_override` should ignore `func_orig` and instead apply `func_vectorized` element-wise to pairs `(input1[i], input2[i])`, returning an array of the results. Both `func_orig` and `func_vectorized` accept two scalar numbers and return a scalar number."
    },
    {
        "instruction": "Implement a function that accepts two 1D numerical arrays of equal length, `arr1` and `arr2`. It should compute and return a new array where the i-th element is `cos(arr1[i]) + arr2[i]**2`."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size, `x` and `y`, and returns a new array where each element is `x[i] + y[i]**2`."
    },
    {
        "instruction": "Create a function that takes a list and an integer `n` as input. Return `True` if the list contains exactly `n` elements, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array as input and returns a new 1D array containing the element-wise cosine of the input array."
    },
    {
        "instruction": "Write a function that takes three arguments: an integer `axis_info`, a list `batch_flags`, and a 1D numerical array `input_array`. The function should first verify that `axis_info` is indeed an integer and `batch_flags` is a list. If the checks pass, it should apply an element-wise sine function to `input_array` and return the result; otherwise, it should raise a type error."
    },
    {
        "instruction": "Design a function `apply_and_record` that accepts another function `rule_func` and some input data `data`. When `apply_and_record` is called, it should invoke `rule_func`, passing it specific predefined arguments (e.g., an integer `size=5` and a list `batched=[True]`) along with the `data`. The function should capture the arguments passed to `rule_func` (size, batched) into a globally accessible list before returning the result of `rule_func(data)`. Ensure the capture mechanism works."
    },
    {
        "instruction": "Implement a function that takes two arguments: an 'actual output' (which could be a single numerical array or a list/tuple of numerical arrays) and an 'expected structure description' (e.g., a string like 'single_array' or 'list_of_two_arrays'). Return `True` if the structure of the 'actual output' matches the description, `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a tuple containing two new 1D arrays: one with the sine of each input element and one with the cosine of each input element."
    },
    {
        "instruction": "Develop a function that applies a custom transformation rule to a 1D numerical array. The rule itself is provided as another function. This rule function takes the array and returns a *pair*: the transformed data (e.g., a single array or a list/tuple of arrays) and a *description* of the transformed data's structure (e.g., a string like 'single_array'). Your main function should call the rule and return the resulting pair."
    },
    {
        "instruction": "Write a higher-order function that orchestrates vectorized execution with a structural check. It takes an input array, an 'original function' (which processes a single element), and a 'custom batch rule' function (like in Task 4). Apply the 'custom batch rule' to the input array to get the processed data and its structure description. Determine the expected structure based on the 'original function' (assume it always returns a single value, so the expected batch structure is 'single_array'). Compare the actual structure description from the rule with the expected structure. If they don't match, raise a custom `StructureError`. Otherwise, return the processed data."
    },
    {
        "instruction": "Implement a function `check_structure` that takes two arbitrary data structures (potentially nested lists/tuples containing basic types). It should return `True` if the nesting pattern and types of non-container elements are identical, and `False` otherwise. Do not compare the actual values, only the structure."
    },
    {
        "instruction": "Develop a function `process_batch` that takes an element-wise operation `op`, a custom batch transformation rule `rule`, and a 1D numerical array `data`. The `rule` takes the whole array `data` and returns a result. `process_batch` must first determine the expected structure of applying `op` to a single element. Then, it executes `rule(data)`. If the structure of the result from `rule` matches the expected single-element structure (applied element-wise), return the result. Otherwise, raise an error indicating a structural mismatch between the rule's output and the expected output."
    },
    {
        "instruction": "Create a function that takes another function `g` and a list `L`. It should apply `g` to each element in `L` and return a new list containing the results in the corresponding order."
    },
    {
        "instruction": "Write a function that applies the mathematical sine operation element-wise to a 1D numerical array. Input: 1D array. Output: A new 1D array of the same size containing the sine of each element."
    },
    {
        "instruction": "Create a function that calculates the value and the directional derivative (Jacobian-vector product) for the sine function. It should accept a floating-point input `x` and a tangent direction `tx`, returning a pair `(sin(x), cos(x) * tx)`."
    },
    {
        "instruction": "Implement a function that applies a given single-input, single-output numerical function element-wise to a 1D array of numbers. It takes the function and the array as input and returns a new array of the results."
    },
    {
        "instruction": "Develop a function that performs element-wise Jacobian-vector product calculation for the sine function on 1D arrays. It accepts a 1D array of inputs `xs` and a 1D array of tangent vectors `txs` (of the same size). It should return two 1D arrays: the first containing `sin(x)` for each `x` in `xs`, and the second containing `cos(x) * tx` for each corresponding `(x, tx)` pair from `xs` and `txs`."
    },
    {
        "instruction": "Write a function that computes the cosine of a single floating-point number."
    },
    {
        "instruction": "Create a function that accepts two numerical arrays, `v1` and `v2`, which are guaranteed to have the same shape. It should return a new array of the same shape containing the element-wise product of `v1` and `v2`."
    },
    {
        "instruction": "Write a function that takes a numerical scalar or array `x` and a fixed numerical array `A`. It should return the result of `A + sin(x)`, applying the sine element-wise and using broadcasting rules for the addition if `x` is an array."
    },
    {
        "instruction": "Develop a higher-order function `vectorize_scalar_func` that takes a function `f` (which accepts a single scalar number and returns a single scalar number) as input. It should return a *new* function that accepts a 1D numerical array `xs` and returns a new 1D array where the i-th element is the result of applying the original function `f` to the i-th element of `xs`."
    },
    {
        "instruction": "Create a function that processes batches of inputs and tangents for a given \"value-and-derivative\" function. It takes three arguments: a function `func_val_deriv` (which accepts a scalar `x` and scalar tangent `tx`, returning a pair `(y, ty)`), a 1D numerical array of inputs `xs`, and a 1D numerical array of tangents `txs` (same size as `xs`). The function should apply `func_val_deriv` to each corresponding pair `(xs[i], txs[i])` and return two 1D arrays: one containing all the `y` values and one containing all the `ty` values."
    },
    {
        "instruction": "Create a function that applies a given two-argument scalar function element-wise to corresponding elements of two input 1D numerical arrays. The function should accept the two 1D arrays (`arr1`, `arr2`, of equal length N) and the scalar function `func`. It should return a new 1D array of length N where the i-th element is `func(arr1[i], arr2[i])`."
    },
    {
        "instruction": "Write a function that generates a 1D numerical array containing a sequence of `N * M` consecutive numbers starting from `start_value` (with a step of 1.0), and then reshapes this sequence into a 2D array with `N` rows and `M` columns. The function should accept `start_value`, `N`, and `M` as input."
    },
    {
        "instruction": "Write a function that takes two numerical arrays, `x` and `y`, of the same shape, and returns a new array where each element is `sin(x_i) + y_i`. Ensure it handles element-wise operations correctly."
    },
    {
        "instruction": "Implement a function that computes the \"forward derivative\" information for `f(x, y) = sin(x) + y`. It should accept four scalar numerical inputs `x, y, tx, ty` (where `tx`, `ty` represent input perturbations) and return two scalar outputs: the original function result `sin(x) + y`, and the propagated perturbation `cos(x) * tx + ty`."
    },
    {
        "instruction": "Implement a function that calculates the derivative of the cosine function. It should accept a single scalar numerical input `x` and return the value of the derivative (`-sine(x)`) at that point."
    },
    {
        "instruction": "Develop a function that computes both the value of `cosine(x)` and its directional derivative scaled by a factor `tx`. The function should accept two scalar numerical inputs, `x` and `tx`, and return a pair `(value, scaled_derivative)`, specifically `(cosine(x), -sine(x) * tx)`."
    },
    {
        "instruction": "Write a function that processes a scalar numerical input `x` and a 1D numerical array of scaling factors `txs`. It should compute the value `cosine(x)` once. Then, for each element `tx` in `txs`, it should compute the scaled derivative `-sine(x) * tx`. The function must return a pair: the single computed value `cosine(x)`, and a new 1D numerical array containing the scaled derivative corresponding to each element in `txs`."
    },
    {
        "instruction": "Create a function that takes a scalar numerical value `a` and a 1D numerical array `v`. It should return a new 1D numerical array of the same size as `v`, where each element is the product of `a` and the corresponding element in `v`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Write a function to compute the Jacobian matrix of an element-wise function `f`. The function should accept two arguments: a 1D numerical input array `x` and another function `f_prime` which computes the element-wise derivative of `f`. Return the Jacobian matrix evaluated at `x`, which should be a 2D array. (Hint: The Jacobian of an element-wise function applied to a vector is a diagonal matrix)."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array (vector) of length N and returns an N x N 2D array (matrix) where the diagonal elements are taken from the input vector and all off-diagonal elements are zero."
    },
    {
        "instruction": "Develop a function that simulates a custom transformation rule. It should accept an expected size (integer), a list of booleans indicating input properties (e.g., `[False]`), and a 1D numerical input array. The function must first validate that the input array's size matches the expected size and the properties list matches a predefined pattern. If validation passes, it applies an element-wise cosine transformation to the input array and returns the transformed array along with the first element of the properties list."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new 1D array where each element is the sine of the corresponding element in the input array."
    },
    {
        "instruction": "Implement a function that computes the element-wise product of the cosine of a 1D numerical array `x` and a scalar `t`. That is, for each element `x_i` in `x`, calculate `cos(x_i) * t`. Return the resulting 1D array."
    },
    {
        "instruction": "Develop a function `apply_elementwise` that takes two arguments: a function `g` (which accepts a single number and returns a single number) and a 1D numerical array `arr`. The `apply_elementwise` function should return a new 1D array where the i-th element is the result of applying `g` to the i-th element of `arr`."
    },
    {
        "instruction": "Write a function that simulates applying a function and its derivative calculation element-wise across a batch. It takes a base function `g` (scalar input/output), its derivative function `g_prime` (scalar input/output), a 1D numerical array `xs`, and a scalar tangent `t`. It must return two 1D arrays: `ys` where `ys[i] = g(xs[i])`, and `ts` where `ts[i] = g_prime(xs[i]) * t`."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and applies the mathematical sine function to each element, returning a new 1D array of the same size with the results."
    },
    {
        "instruction": "Write a function `compute_value_and_scaled_derivative(f, f_prime, x, v)`. It takes a function `f`, its derivative function `f_prime`, a scalar input point `x`, and a scalar direction `v`. It should return a pair `(y, dy)`, where `y = f(x)` and `dy = f_prime(x) * v`."
    },
    {
        "instruction": "Write a function that takes a single numerical scalar input `x` and returns the value `7.0 * x`."
    },
    {
        "instruction": "Develop a function `vectorize_paired_output(func_pair, array_x, scalar_t)`. This function takes another function `func_pair` (which accepts two scalar arguments `x` and `t`, and returns a pair of scalars `(y, dy)`), a 1D numerical array `array_x`, and a scalar `scalar_t`. It should apply `func_pair` to each element `xi` from `array_x` along with the fixed `scalar_t`, producing pairs `(yi, dyi)`. The function must return a pair `(collected_y, single_dy)`, where `collected_y` is a 1D array of all `yi` values, and `single_dy` is the `dy` value produced (assuming or verifying it's the same for all elements `xi`)."
    },
    {
        "instruction": "Create a function that takes two numerical inputs: a scalar `s` and a 1D array `v`. It should return a new 1D array where the i-th element is the cosine of the product of `s` and the i-th element of `v`."
    },
    {
        "instruction": "Implement a function that accepts a scalar `s` and a 1D array `v`. It simulates applying a paired operation element-wise. For each element `v_i` in `v`, it calculates two values: `output1_i = sin(s)` and `output2_i = cos(s) * v_i`. The function should return two 1D arrays: the first containing all `output1_i` values (this will be a constant array), and the second containing all `output2_i` values."
    },
    {
        "instruction": "Write a function that takes a numerical array and returns a new array where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Implement a function that takes a scalar `s` and a 1D array `v`. It applies a transformation based on `s` and each element `v_i` in `v`. The function returns two 1D arrays of the same size as `v`. The first output array should contain `cos(s * v_i)` at index `i`. The second output array should be identical to the input array `v`."
    },
    {
        "instruction": "Write a function `batch_cosine_rule(xs)` that accepts a 1D numerical array `xs` and returns a tuple. The first element of the tuple must be a new 1D array containing the element-wise cosine of `xs`. The second element must be the boolean value `True`."
    },
    {
        "instruction": "Write a function `attempt_and_catch(operation_func, input_val)` that executes `operation_func(input_val)`. If the execution raises a `ValueError` with the exact message 'Linearization failed', the function must catch this specific error and return the string 'Caught expected error'. For any other return value or error, it should return the original result or raise the original error."
    },
    {
        "instruction": "Implement a function `check_transform_conflict(base_operation, batch_operation_result)` that simulates detecting incompatibility for a gradient transformation. It takes descriptions or representations of the base function's core math (e.g., 'sine') and the result of the batch rule (e.g., 'cosine'). If the operations are fundamentally different (like 'sine' vs. 'cosine'), return `True` (indicating a conflict). Otherwise, return `False`."
    },
    {
        "instruction": "Create a function `apply_custom_batching(func, batch_rule, data)`. If `data` is a single number, return the result of `func(data)`. If `data` is a 1D array, return the result of `batch_rule(data)`. Assume `func` takes a number and returns a number, and `batch_rule` takes a 1D array and returns a tuple (as defined in Task 2)."
    },
    {
        "instruction": "Design a pair of functions. The first function ('forward_pass') should accept inputs `x` and `y`, compute a primary result (e.g., `sin(x) * y`), and return this result along with auxiliary data `(x, y)`. The second function ('backward_pass') should accept the auxiliary data `(x, y)` and a 'sensitivity' value `ct`, and return derived values `(x * ct, y * ct)`."
    },
    {
        "instruction": "Create a function that accepts auxiliary data `(x, y)` (representing saved values from a previous computation) and a numerical value `ct`. It should compute and return two results based on these inputs: `x * ct` and `y * ct`."
    },
    {
        "instruction": "Write a function that takes two numerical inputs, `x` and `y` (where `x` could be an array element and `y` a scalar), calculates `sin(x) * y`, and returns both the result and the original inputs `(x, y)` as auxiliary data for potential later use."
    },
    {
        "instruction": "Implement a function that takes another function `g` (which accepts a scalar and returns a scalar), a 1D numerical array `arr`, and a scalar `val`. It should apply `g` to each element of `arr` paired with the constant `val`, returning a new 1D array containing the results of each application."
    },
    {
        "instruction": "Write a function that performs element-wise multiplication between two numerical arrays, handling broadcasting. Input: Array `A` of shape (M, N) and Array `B` of shape (1, N). Output: Array `C` of shape (M, N) where `C[i, j] = A[i, j] * B[0, j]`."
    },
    {
        "instruction": "Implement a function that applies the sigmoid activation `1 / (1 + exp(-z))` element-wise to a given numerical array. Input: a numerical array of any shape. Output: a numerical array of the same shape with the sigmoid function applied to each element."
    },
    {
        "instruction": "Create a function that calculates the sum of squared differences between two numerical arrays, handling broadcasting. Input: Array `H` of shape (M, N) and Array `X` of shape (1, N). Output: A single scalar value representing the sum of `(H[i, j] - X[0, j])**2` over all `i` and `j`."
    },
    {
        "instruction": "Implement a function that estimates the sensitivity of a scalar output of another function to small changes in each element of its matrix input. Input: A function `compute_scalar(matrix)` that takes a 2D numerical array and returns a scalar, and a specific input matrix `M`. Output: A 2D numerical array of the same shape as `M`, where each element `(i, j)` approximates how much the scalar output changes if `M[i, j]` is slightly perturbed (e.g., using a small delta)."
    },
    {
        "instruction": "Create a function that takes a Python object as input. Inside the function, create a weak reference `w` to the object. Then, remove the strong reference to the input object. Finally, return the result of dereferencing `w`."
    },
    {
        "instruction": "Write a function that accepts any Python object. It should create a weak reference to this object and return the result of immediately dereferencing this weak reference."
    },
    {
        "instruction": "Design a function that takes an object and a callback function (which takes no arguments). Create a weak reference to the object, registering the callback to be invoked when the object is finalized. Delete the strong reference to the object to allow potential finalization. The function itself should return nothing."
    },
    {
        "instruction": "Implement a function that receives a Python object. It should create a weak reference to it. Verify that the weak reference initially resolves to the object. Then, delete the strong reference to the object. Return `True` if the weak reference now resolves to `None`, and `False` otherwise."
    },
    {
        "instruction": "Create a class with an `__init__` method and another method, `method_a`. Inside `__init__`, store a direct reference to the bound method `self.method_a` in an instance attribute `self._method_ref`. Write a function to instantiate this class and return the instance."
    },
    {
        "instruction": "Write a function `check_self_reference(obj)` that takes an object instance `obj`. Inspect the instance's attributes. If any attribute holds a reference to a method belonging to the *same* instance `obj`, return `True`. Otherwise, return `False`."
    },
    {
        "instruction": "Write a function that takes any object and an attribute name (string) as input. Return `True` if the object has an attribute with that name and the attribute's value is callable, `False` otherwise."
    },
    {
        "instruction": "Define a simple Python class with an `__init__` method that initializes an instance variable and another method that does nothing (`pass`). Write a function that creates and returns an instance of this class."
    },
    {
        "instruction": "Implement a function that accepts any Python object as an argument and returns a weak reference to that object. Ensure the original object is not modified."
    },
    {
        "instruction": "Write a function that takes a positive integer `N` as input and returns a list containing the sequence of integers starting from 0 up to (but not including) `N`."
    },
    {
        "instruction": "Implement a function `create_and_track_object(object_creation_func)`. This function should accept one argument: `object_creation_func`, which is a function that, when called with no arguments, returns a new object. Inside `create_and_track_object`, call `object_creation_func` once to get an object, create a weak reference to this object, discard the strong reference to the object (e.g., by reassigning the variable or letting it go out of scope), and then return the weak reference."
    },
    {
        "instruction": "Create a function that takes a weak reference object as input and returns `True` if the reference is no longer valid (i.e., the object it referred to has been potentially garbage collected), and `False` otherwise."
    },
    {
        "instruction": "Create a simple memoization wrapper function `memoize_static(func, static_arg_index)`. This wrapper takes a function `func` and an index `static_arg_index`. It returns a new function that caches results based on the argument at `static_arg_index`. When the wrapped function is called, if an object equal (using `==`) to the argument at `static_arg_index` has been seen before, return the cached result; otherwise, execute `func`, cache the result against that argument, and return it. Assume the function `func` only depends on the static argument for caching purposes."
    },
    {
        "instruction": "Define a class `ConfigObject` such that any two instances are considered equal using the `==` operator, regardless of their internal attributes, but only if they are both of type `ConfigObject`. Implement the necessary special methods (`__eq__`, `__hash__`) for this behavior, ensuring all instances hash to the same value."
    },
    {
        "instruction": "Design a class `CallTracker` that simulates tracking function calls based on a specific argument. It should have a method `record_call(key)` which adds the `key` to an internal collection only if an equal key is not already present. It should also have a method `get_unique_call_count()` that returns the number of unique keys recorded. Use a dictionary or set internally."
    },
    {
        "instruction": "Implement a function `transform(data, metadata)` which takes numerical `data` and an arbitrary `metadata` object. The function must return the `data` multiplied by 50, completely ignoring the `metadata` argument in its calculation."
    },
    {
        "instruction": "Implement a function that receives a list representing function arguments (these could be simple values or complex structures) and an integer index. The function should return a list of booleans, with the boolean at the specified index being `True` and all others `False`, indicating which argument position is \"selected\"."
    },
    {
        "instruction": "Develop a function that takes a list representing function arguments (potentially including dictionaries with numerical arrays as values) and an integer index. Return a *metadata structure* mirroring the input arguments' structure, where each leaf element (numerical array or simple value) has an associated boolean flag. This flag should be `True` if the leaf element belongs to the top-level argument specified by the index, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a single numerical array and returns a new array where every element is doubled."
    },
    {
        "instruction": "Write a function that takes a nested data structure representing argument metadata (e.g., a list containing dictionaries which map keys to boolean values, like `[{'A': False, 'B': False}, True]`) and returns the boolean value found at a specific path (e.g., for the path corresponding to the first argument's 'A' key)."
    },
    {
        "instruction": "Write a function that takes three dictionaries (`d1`, `d2`, `d3`) as input. The function should simulate resource handling by returning the original `d1` and `d2`, and a *copy* of `d3`. Ensure that modifications to the returned copy of `d3` do not affect the original `d3` passed to the function."
    },
    {
        "instruction": "Implement a function that accepts multiple arguments (which could be dictionaries or other types) and a list of argument *names* (strings) intended for special handling. The function should return a data structure (e.g., a dictionary) mapping each provided name to a boolean value indicating whether an argument with that exact name was passed to the function."
    },
    {
        "instruction": "Write a function that accepts three dictionaries as input arguments (e.g., `dict1`, `dict2`, `dict3`). The function should return the first and second dictionaries it received, packaged together (e.g., in a tuple)."
    },
    {
        "instruction": "Develop a function that takes several positional arguments (which can be dictionaries) and a tuple of integer *indices*. The function should return a data structure (e.g., a dictionary or list) indicating for each index in the input tuple whether a positional argument was present at that position (0-based index)."
    },
    {
        "instruction": "Develop a function that analyzes a dictionary representing keyword arguments passed to another function. Given a list of argument names (e.g., `['name', 'value']`), return a new dictionary where keys are the argument names from the input dictionary, and values are boolean flags indicating if the key was present in the provided list of names."
    },
    {
        "instruction": "Write a function that accepts three dictionary arguments: `arg1` (positional), `arg2` (keyword), and `arg3` (keyword). The function should return a tuple containing these three dictionaries in the order they were defined in the function signature (`arg1`, `arg2`, `arg3`)."
    },
    {
        "instruction": "Implement a function that analyzes a list representing positional arguments passed to another function. Given a list of argument indices (e.g., `[0, 2]`), return a new list containing boolean flags indicating whether the argument at each corresponding index in the input list was specified in the index list."
    },
    {
        "instruction": "Write a function that processes function arguments. It accepts: a) a list of positional arguments, b) a dictionary of keyword arguments, c) a list of positional indices to \"flag\", and d) a list of keyword names to \"flag\". Return two data structures: a list for positional arguments and a dictionary for keyword arguments. Each element/value in the returned structures should indicate whether the corresponding original argument was flagged based on the provided indices or names (e.g., using a boolean flag)."
    },
    {
        "instruction": "Create a function that calculates the absolute value of a single floating-point number `x` and adds 1.0 to it. Return the resulting floating-point number."
    },
    {
        "instruction": "Write a function that takes a floating-point number `x` and a floating-point constant `c`. The function should return the absolute value of `x` plus `c`."
    },
    {
        "instruction": "Implement a function that accepts one numerical input `x`. Inside the function, calculate `y = x * x`, then `z = sqrt(y)`, and finally return `z + 1.0`. Ensure the return type is a floating-point number."
    },
    {
        "instruction": "Develop a function that takes a single number `x`, squares it, adds 1.0, and returns the result."
    },
    {
        "instruction": "Design a function `apply_operation` that takes two arguments: another function `op` (which is guaranteed to perform a calculation on a single scalar float) and a scalar float `value`. The `apply_operation` function should execute `op(value)` and return the result."
    },
    {
        "instruction": "Implement a function factory `create_typed_processor`. This factory function should accept a type specification (e.g., 'scalar_float'). It returns a *new* function. This new function takes one argument; it first checks if the argument matches the specified type. If it matches, it applies a fixed operation (multiply by 2) and returns the result; otherwise, it should raise a type mismatch error."
    },
    {
        "instruction": "Write a function to compare two scalar floating-point numbers for near-equality. It should take the two numbers and return `True` if their absolute difference is below a very small predefined threshold (e.g., 1e-5), and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes one argument. It should verify if the input is specifically a scalar floating-point number (not an integer or string). If it is, return `True`, otherwise return `False`."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x`, calculates the square root of `x` squared, adds 1.0, and returns the result."
    },
    {
        "instruction": "Implement a function that receives a list of numbers. For each number `x` in the list, it should compute `sqrt(x*x) + 1.0`. Return a new list containing all the computed results."
    },
    {
        "instruction": "Create a function `setup_checker(example_input)` that takes an example input (e.g., a number like `5.0` or a list like `[1.0, 2.0]`). This function should return a *new* function, let's call it `check_and_process`. The `check_and_process` function accepts one argument `data`. If the basic type/structure of `data` (e.g., is it a single number, or a list?) matches that of `example_input`, `check_and_process` should calculate `sqrt(val*val) + 1.0` for the number or for each number in the list and return the result(s). If the structure doesn't match, it must raise a `TypeError`."
    },
    {
        "instruction": "Create a function that accepts a single number `x`, calculates its absolute value, adds 1.0, and returns the sum."
    },
    {
        "instruction": "Create a function that takes a single argument of any basic data type (number, string, boolean) and returns it unchanged."
    },
    {
        "instruction": "Write a function that accepts a single numerical value (integer or float) and returns the exact same value."
    },
    {
        "instruction": "Develop a function that receives a single floating-point number and returns the same floating-point number."
    },
    {
        "instruction": "Write a function that accepts two arguments: another function `func` (which takes one numerical argument and returns one numerical argument) and a numerical value `x`. Your function should execute `func(x)` and return the result."
    },
    {
        "instruction": "Write a function that takes a number, performs an internal validation step based on a predefined policy (e.g., checking if it adheres to 'standard processing'), and then returns the number as is, assuming validation passes."
    },
    {
        "instruction": "Create a function that accepts any numerical value (integer or float) and returns it unmodified."
    },
    {
        "instruction": "Write a function that takes a single floating-point number as input and returns the exact same floating-point number."
    },
    {
        "instruction": "Develop a function that receives a numerical input. Internally, it should apply a specific processing directive (represented abstractly, e.g., as a tag or metadata) to the input but must return the original numerical value unchanged."
    },
    {
        "instruction": "Write a function `validate_list_input(data)` that checks if the input `data` is specifically a list containing exactly one numerical element. It should return `True` if it matches this structure, and `False` otherwise."
    },
    {
        "instruction": "Design a function `create_strict_executor(func, template_arg)` that takes a function `func` and a `template_arg`. It should return a *new* function. This new function accepts one argument `call_arg`. Inside this new function, first check if `call_arg` has the *exact same structure type* (using the logic from Task 3: 'scalar' or 'list') as `template_arg`. If the structures match, call `func(call_arg)` and return its result. If they don't match, raise a `TypeError` with the message 'Input structure mismatch'."
    },
    {
        "instruction": "Implement a function `apply_identity(data)` that accepts any single argument `data` and returns it unchanged."
    },
    {
        "instruction": "Create a function `get_structure_type(data)` that takes an argument `data` and returns a string describing its basic structure. It should return 'scalar' for single numbers, 'list' for lists, and 'unknown' for other types."
    },
    {
        "instruction": "Write a function that accepts a single numerical input `x`. Calculate the square root of `x` squared, add 1.0 to the result, and return this final value as a floating-point number."
    },
    {
        "instruction": "Create a function that takes a numerical value and a string representing a target data type (e.g., 'int32', 'float32'). Return the value converted to the specified data type. Ensure the function handles basic numeric types."
    },
    {
        "instruction": "Develop a function that accepts a numerical value. Convert this value first to an integer type (e.g., 32-bit integer) and then separately convert the original value to a floating-point type (e.g., 32-bit float). Return both converted values."
    },
    {
        "instruction": "Implement a function `validate_input_type` that takes two arguments: an input value and a string representing the expected data type (e.g., 'int32', 'float32'). The function should return `True` if the input value's type matches the expected type string, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that accepts any number of positional arguments. If at least one argument is provided, it should take the first argument, square it, calculate the non-negative square root of the result, add 1.0, and return this value. Otherwise, it should indicate an error or return a specific value like 0.0."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x` and returns the result of calculating the absolute value of `x` plus 1.0."
    },
    {
        "instruction": "Write a function that accepts multiple numerical arguments but performs a calculation using only the first one. The function should return `(first_argument * 2) + 5`. Ensure it handles receiving zero arguments appropriately."
    },
    {
        "instruction": "Implement a function that takes a variable number of numerical arguments. It must use only the first argument (`x`) to compute `sqrt(x*x) + 1.0` and return the floating-point result. All subsequent arguments must be ignored."
    },
    {
        "instruction": "Implement a function that accepts a variable number of positional arguments and returns the *last* argument provided. Assume at least one argument is always given."
    },
    {
        "instruction": "Write a function that takes any number of positional arguments (at least one) and returns the first argument, explicitly ignoring all subsequent arguments."
    },
    {
        "instruction": "Write a function that accepts a variable number of positional arguments and returns the first argument provided. Assume at least one argument is always given."
    },
    {
        "instruction": "Develop a function that accepts a variable number of positional arguments. It should return the *second* argument if at least two arguments are provided, otherwise, it should return a specific indicator (e.g., None)."
    },
    {
        "instruction": "Write a function that takes two inputs: a constant floating-point value `c` and a variable number of numerical arguments `*nums`. The function should return the sum of the *first* number in `*nums` and the constant `c`."
    },
    {
        "instruction": "Write a function that takes a single floating-point number as input and returns that number plus 4.0."
    },
    {
        "instruction": "Create a function that accepts a variable number of arguments (*args). The function should return the *first* argument it receives, ignoring any subsequent arguments. Ensure it handles cases where at least one argument is provided."
    },
    {
        "instruction": "Develop a function that receives a sequence (like a list or tuple) of numbers. It should return the first element of the sequence. Assume the sequence is non-empty."
    },
    {
        "instruction": "Design a function `prepare(operation, sample_value)` which takes a simple mathematical function `operation` (accepting one numerical argument) and a `sample_value`. It should return an intermediate representation object encapsulating the operation specialized for the type of `sample_value`."
    },
    {
        "instruction": "Implement a function `get_specific_description(prepared_object, format_style)` that takes the intermediate representation object (from Task 2) and a `format_style` string (e.g., \"style1\", \"style2\"). It should return a textual description (string) specific to the given `format_style`. Ensure the output is always a string."
    },
    {
        "instruction": "Create a function `get_default_description(prepared_object)` that takes the intermediate representation object from Task 2 and returns a textual description (as a string) of the prepared operation. Ensure the output is always a string."
    },
    {
        "instruction": "Write a utility function `is_string(value)` that takes any input `value` and returns `True` if the value is a string, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a single numerical input and returns the result of adding 4 to it."
    },
    {
        "instruction": "Extend the system from Task 2. The object representing the prepared function should have a method `get_internal_data(representation_type: str)`. This method should return some data (e.g., a descriptive string or a placeholder structure) if `representation_type` is a recognized key (e.g., 'standard', 'type_x', 'type_y'), and indicate failure (e.g., return None) otherwise."
    },
    {
        "instruction": "Create a function `verify_outputs(results: dict, required_keys: list[str]) -> bool`. It should take a dictionary where keys are strings and values can be anything. The function must return `True` if and only if all keys specified in `required_keys` are present in the dictionary and their corresponding values are not None. Otherwise, it returns `False`."
    },
    {
        "instruction": "Implement a function `analyze_computation(computation, sample_value, analysis_types: list[str]) -> bool`. This function should simulate analyzing the `computation` (a simple function) using the `sample_value`. It must then check if specific internal analysis results, identified by keys in `analysis_types`, are available (not None). Return `True` if all specified analysis types yield a non-None result, `False` otherwise."
    },
    {
        "instruction": "Implement a function `analyze_operation(operation_func, example_value)` that attempts to generate a textual description of what `operation_func` does based on the `example_value`. Return the description as a string, or `None` if a description cannot be generated."
    },
    {
        "instruction": "Write a function that accepts a single argument of any type and returns that argument unchanged."
    },
    {
        "instruction": "Create a function that takes two arguments: another function `op` and a value `val`. It should return the result of calling `op` with `val`."
    },
    {
        "instruction": "Write a function `is_valid_description(desc)` that takes one argument `desc`. It should return `True` if `desc` is a non-empty string, and `False` otherwise (including if `desc` is `None` or an empty string)."
    },
    {
        "instruction": "Write a function that takes a dictionary (e.g., {'config_A': 1, 'config_B': 'on'}) and a list of required configuration strings (e.g., ['config_A = 1', 'config_B = on']). The function should first generate a multi-line string representation of the dictionary (one 'key = value' per line), and then return True if all the required strings from the list are found as exact lines within the generated string, False otherwise."
    },
    {
        "instruction": "Write a function that accepts a single numerical input and returns the result of adding the constant value 4 to it."
    },
    {
        "instruction": "Develop a function that accepts a dictionary containing key-value pairs. It should return a single string where each key-value pair from the dictionary is represented on a new line in the format 'key = value'."
    },
    {
        "instruction": "Implement a function that takes three arguments: a main string and two separate substrings. It should return True only if *both* of the specified substrings are present within the main string, otherwise return False."
    },
    {
        "instruction": "Design a function `track_unique_calls(target_function)`. This function takes another function `target_function` as input. It returns a *new* function that acts as a wrapper around `target_function`. This wrapper, when called with arguments, should execute `target_function` with those arguments. Additionally, it must maintain an internal counter that increments only the *first* time it's called with a specific unique combination of arguments. The wrapper should provide a way to access this counter (e.g., via an attribute or a separate method). Assume arguments are hashable."
    },
    {
        "instruction": "Write a function that accepts two numerical inputs, `x` and `y`, but performs a calculation solely based on `x` (e.g., returns `x` multiplied by 2)."
    },
    {
        "instruction": "Implement a function `describe_inputs(expected_input_count, kept_indices)` that takes the total number of potential inputs (`expected_input_count`) and a set of integer indices (`kept_indices`) for inputs that are actually required. It should return a simple data structure (like a dictionary or tuple) containing the count of effectively used inputs based on the size of `kept_indices` and the set of `kept_indices` itself."
    },
    {
        "instruction": "Create a function `get_kept_indices(total_args, used_args_mask, keep_unused_flag)` that simulates argument tracking. It takes the total number of arguments (`total_args`), a boolean list/tuple `used_args_mask` (length `total_args`, where `True` means the argument at that index is used), and a boolean `keep_unused_flag`. It should return a set of integer indices representing the arguments that are 'kept'. If `keep_unused_flag` is true, all indices `0` to `total_args - 1` are kept. If false, only indices where `used_args_mask` is true are kept."
    },
    {
        "instruction": "Write a function that accepts a single numerical input and returns that number plus 4."
    },
    {
        "instruction": "Write a function that takes one numerical argument `x` and returns `x + 4`. Ensure the function definition itself is considered the primary output."
    },
    {
        "instruction": "Develop a function `check_validity` that accepts an arbitrary object. It should return `True` if the object represents a successfully prepared computational routine (e.g., not null or invalid), and `False` otherwise. (Simulate checking if a function handle is valid)."
    },
    {
        "instruction": "Implement a function that receives another function `f` (which takes one numerical argument) and a value `v`. The function should execute `f(v)` and return the result."
    },
    {
        "instruction": "Create a function that takes another function `f` and a value `v` as input. It should return the result of calling `f(v)`."
    },
    {
        "instruction": "Implement a function that receives a function `g` and an example input value `ex`. The function should analyze `g` based on the type of `ex` and return a string describing the input type expected by `g` (e.g., 'number', 'string')."
    },
    {
        "instruction": "Develop a function that takes a function `h` and an example input value `val`. It should simulate a 'preparation' step for `h` based on `val`'s type. Return `True` if the preparation is successful (e.g., the function is valid for the type), and `False` otherwise."
    },
    {
        "instruction": "Design a function that accepts a function `func` and an example input `inp`. It should return a simple object or dictionary representing a 'prepared plan' for executing `func` with inputs of the same type as `inp`. This plan should include metadata like the inferred input type and output type (you can assume basic types)."
    },
    {
        "instruction": "Implement a function `get_representation` that accepts another function `op` (which takes one numerical argument) as input. The `get_representation` function should simulate obtaining a textual form of `op` and return either a placeholder string (e.g., \"Textual form of the operation\") or `None`."
    },
    {
        "instruction": "Write a function that accepts a single argument of any type and returns that argument unchanged."
    },
    {
        "instruction": "Create a function that takes one numerical input and returns the result of adding the integer 4 to it."
    },
    {
        "instruction": "Write a function that takes any value as input and returns `True` if the input is a string or if the input is `None`, and `False` otherwise."
    },
    {
        "instruction": "Implement a function `check_operation_definition` that accepts an operation representation structure (from Task 3). The function should verify if the structure is well-formed: it must contain a valid operation type (\"identity\" or \"add_constant\") and, if the type is \"add_constant\", it must also contain a numerical constant value. Return `True` if valid, `False` otherwise."
    },
    {
        "instruction": "Write a function `identity_op` that accepts a single numerical input and returns the exact same numerical value."
    },
    {
        "instruction": "Write a function `describe_operation` that takes an operation representation structure (from Task 3) as input. It should return a human-readable string describing the operation (e.g., \"Performs identity transformation\" or \"Adds the constant 4\"). Handle the two types defined in Task 3."
    },
    {
        "instruction": "Design a data structure (e.g., a dictionary or a simple class) to represent a basic mathematical operation. It should store the type of operation (e.g., \"identity\", \"add_constant\") and any associated value (e.g., the constant to add). Create one instance representing an identity operation and another representing adding the constant 4."
    },
    {
        "instruction": "Implement a function that accepts a single numerical argument and returns it unchanged."
    },
    {
        "instruction": "Write a function `get_metadata` that accepts a function previously processed by the `prepare` mechanism (from Task 3). It should retrieve and return the associated metadata."
    },
    {
        "instruction": "Design a function or class `prepare` that takes any simple function (like one that takes a number and returns a number) as input. This `prepare` mechanism should associate some non-null metadata (e.g., a dictionary `{'status': 'ready'}`) with the function."
    },
    {
        "instruction": "Write a script that defines two distinct simple numerical functions (e.g., identity and add 4). Use the `prepare` mechanism (from Task 3) on both. Then, use the `get_metadata` function (from Task 4) to retrieve the metadata for each prepared function and verify that neither retrieved metadata is null or empty."
    },
    {
        "instruction": "Write a function `analyze_prepared_func` that accepts a 'prepared' function object (as returned by Task 3's `prepare_func`). This function should simulate performing an analysis and return a simple dictionary containing placeholder analysis results, like `{'status': 'analyzed', 'complexity': 'simple'}`."
    },
    {
        "instruction": "Create a function that takes a single numerical input (integer or float) and returns the result of adding the constant value 4 to it."
    },
    {
        "instruction": "Implement a function `prepare_func` that takes another function `f` (which accepts one numerical argument) as input. `prepare_func` should return a new object or structure that represents the 'prepared' version of `f`, ready for potential analysis. The exact nature of the returned object isn't critical, but it should encapsulate the original function."
    },
    {
        "instruction": "Write a function that accepts a single numerical input (integer or float) and returns the exact same value."
    },
    {
        "instruction": "Implement a function that takes a simple mathematical operation (defined as a function accepting one numerical argument) and a sample numerical input. Return `True` if this operation can be successfully 'prepared' or 'validated' based on the sample input, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes two simple function objects, `op1` and `op2` (each accepting one numerical argument), and a sample numerical value. It should internally 'prepare' or 'validate' both `op1` and `op2` based on the sample value. Return `True` only if *both* preparations are successful, `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a single numerical input and returns the input value incremented by 4."
    },
    {
        "instruction": "Develop a function `is_valid_output` that accepts any single value. It should return `True` if the value is considered valid (specifically, not `None`), and `False` if it is `None`."
    },
    {
        "instruction": "Implement a function that takes a single non-negative numerical input `y` and returns its square root."
    },
    {
        "instruction": "Create a function that takes a single numerical input `x` and returns its square (`x * x`)."
    },
    {
        "instruction": "Develop a function that takes a dictionary representing configuration parameters. It should verify that the dictionary contains at least three specific keys: 'option_a' (expecting a boolean), 'option_b' (expecting a positive integer), and 'option_c' (expecting a float between 0.0 and 1.0 inclusive). Return `True` if all keys exist and their values have the expected type/range, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x`, calculates its absolute value, adds 1.0 to the result, and returns the final floating-point value."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x`, calculates the square root of `x` squared, adds 1.0, and returns the floating-point result."
    },
    {
        "instruction": "Write a function to validate a dictionary of configuration settings against a schema. The schema is a dictionary where keys are valid setting names (strings) and values are expected type names (strings like 'boolean', 'string', 'number'). The function should iterate through the input settings dictionary. If it finds a key not present in the schema, return the error message string: \"No such option: '[key_name]'\". If it finds a key whose value's type doesn't match the schema's expected type, return the error message string: \"Option '[key_name]' value is not a valid [expected_type_name] value.\". If all settings are valid according to the schema, return `None`."
    },
    {
        "instruction": "Implement a function that checks the type of a specific configuration value. It takes a dictionary of settings and a key string. It should return `True` if the key exists in the dictionary and its corresponding value is a boolean (True or False), otherwise return `False`."
    },
    {
        "instruction": "Create a function that validates configuration keys. It accepts a dictionary representing configuration settings and a list of valid key strings. The function should return `True` if all keys in the input dictionary are present in the list of valid keys, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that accepts a dictionary representing configuration settings. It should validate the dictionary against a predefined set of allowed keys (e.g., ['option_a', 'option_b']). If any key in the input dictionary is not in the allowed set, the function should raise a specific error (e.g., ValueError) indicating the invalid key."
    },
    {
        "instruction": "Write a function that takes two dictionaries, `base_config` and `custom_options`. It should return a *new* dictionary containing all items from `base_config` updated with items from `custom_options`. Ensure the original `base_config` dictionary is not modified."
    },
    {
        "instruction": "Design a function `apply_processing(value, settings)` where `value` is a number and `settings` is a dictionary. The function should compute `abs(value) + 1.0`. If `settings` contains `'mode': 'enhanced'`, return the result potentially modified (e.g., converted to a specific string format like 'Result: {value}'). If `settings` is empty or contains other keys, return the numerical result directly. Ensure calling the function with different valid `settings` can produce distinct outputs (e.g., a number vs. a string). Raise an error if `settings` contains unknown keys."
    },
    {
        "instruction": "Create a function that takes two input arguments of any type and returns `True` if they refer to distinct objects in memory, and `False` if they refer to the same object."
    },
    {
        "instruction": "Implement a function that performs element-wise multiplication by a scalar on a 2D numerical array (like a list of lists). It takes the 2D array and a scalar number, returning a new 2D array with the same dimensions, where each element has been multiplied by the scalar."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and a single scalar number. It should return a new 1D array where each element is the result of multiplying the corresponding input array element by the scalar."
    },
    {
        "instruction": "Write a function that takes a positive integer 'N'. Inside the function, first generate a 1D array containing integers from 0 to N-1. Then, create and return a second 1D array where each element is double the value of the corresponding element in the first generated array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (list or similar sequence of numbers) and returns a new 1D array of the same size where each element is twice the value of the corresponding element in the input array."
    },
    {
        "instruction": "Simulate a basic operation filtering process. Write a function that accepts a list of operation names (strings) and a set of 'skip' rules (a set containing operation names to ignore). The function should return a new list containing only the operations from the input list that are *not* present in the 'skip' rules set, preserving the original relative order."
    },
    {
        "instruction": "Implement a function that takes an input value `data` and a processing function `process_func`. Add a boolean flag `skip_processing`. If `skip_processing` is true, the function should return `data` directly without calling `process_func`; otherwise, it should return the result of `process_func(data)`."
    },
    {
        "instruction": "Write a function that accepts a single argument of any type and returns that argument unmodified."
    },
    {
        "instruction": "Create a function that takes a potentially multi-line string and a search substring. Return `True` if the search substring does *not* appear anywhere within the main string, and `False` otherwise."
    },
    {
        "instruction": "Design an execution system with function overrides. Implement: (a) A way to define 'base' functions (e.g., `base_op`). (b) A way to define 'override' functions (e.g., `override_op`). (c) A mechanism (like a dictionary mapping base functions to override functions) to register an 'override' function for a 'base' function. (d) An `execute(base_func, input_val)` function that looks up the registered override for `base_func` and executes *it* (the override) with `input_val`, returning the override's result. Assume an override is always registered for this task."
    },
    {
        "instruction": "Write a function that accepts one argument of any basic data type (e.g., number, string) and returns it unchanged."
    },
    {
        "instruction": "Define a function that accepts two numerical arguments, let's call them `val1` and `val2`, but performs no operations within its body and returns no explicit value (e.g., returns `None` or equivalent)."
    },
    {
        "instruction": "Write a function `execute_wrapper` that takes two arguments: another function `target_func` and a value `input_val`. This wrapper function should simply call `target_func(input_val)` and return whatever `target_func` returns."
    },
    {
        "instruction": "Implement a function that performs linearization of a given single-variable scalar function `g` at a point `a`. It should take `g` and `a` as input and return both the value `g(a)` and the derivative `g'(a)`. Assume `g` is mathematically differentiable."
    },
    {
        "instruction": "Write a higher-order function that takes a two-argument function `k(arg1, arg2)` and a fixed value `val`. It should return a new one-argument function `k_fixed(arg1)` that computes `k(arg1, val)`."
    },
    {
        "instruction": "Design a mechanism to compute the gradient of a function `f(x, y)` using custom forward and backward propagation rules. The backward rule should accept the output gradient and return the input gradients. Implement this for a simple multiplication function `f(x, y) = x * y`, where the backward rule specifically returns zero gradient for `y`."
    },
    {
        "instruction": "Create a function that takes another function `h` (operating on two scalar inputs) and example scalar inputs `x_ex`, `y_ex`. Return a new function object that behaves identically to `h(x, y)`. (The internal representation might differ, but the input/output behavior must match)."
    },
    {
        "instruction": "Develop a function that takes two scalar numerical inputs, `param1` and `param2`. Inside the function, compute an intermediate value `temp = param1 * param2`, then compute `result = temp * temp`, and finally return `result`."
    },
    {
        "instruction": "Write a function that accepts a numerical array of any dimension and returns the sum of all its elements as a single scalar value."
    },
    {
        "instruction": "Create a function that performs tensor contraction. It should accept two 3D numerical arrays, `Tensor1` with shape (Batch, Dim1, Common) and `Tensor2` with shape (Batch, Dim2, Common). It should return a 3D array with shape (Batch, Dim1, Dim2) by summing the element-wise product over the `Common` dimension for each element in `Batch`, `Dim1`, and `Dim2`."
    },
    {
        "instruction": "Implement a function to compute the standard matrix product of two 2D numerical arrays. It should take array `A` (shape M x K) and array `B` (shape K x N) and return array `C` (shape M x N)."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical list and returns a completely independent copy of it. Modifying the returned list should not affect the original."
    },
    {
        "instruction": "Write a function that takes a 1D numerical list and returns the value of its first element."
    },
    {
        "instruction": "Create a function that takes a 1D numerical list and modifies its first element to the value 77 *in-place*. The function doesn't need to return anything."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical list, an index `i`, and a value `v`. It should return a *new* list where the element at index `i` is `v`, but all other elements are the same as the input list. The original list must not be changed."
    },
    {
        "instruction": "Write a function that accepts a single integer and returns that integer incremented by 1."
    },
    {
        "instruction": "Develop a function that receives an integer `n` and returns a tuple containing two integers: the original integer and the integer incremented by one."
    },
    {
        "instruction": "Create a function that takes one numerical value as input and returns a tuple containing that value repeated twice."
    },
    {
        "instruction": "Implement a function that takes an integer. Inside this function, call a separate helper function (which you also define) that adds 1 to an integer. The main function should return a tuple containing the result from the helper function duplicated."
    },
    {
        "instruction": "Write a function that accepts a standard Python function object and returns its defined name (e.g., the string associated with its definition)."
    },
    {
        "instruction": "Develop a function that accepts a callable wrapper object. If the wrapper itself has been explicitly assigned a name attribute, return that assigned name. Otherwise, attempt to return the name of the function it wraps."
    },
    {
        "instruction": "Write a function that takes any callable object as input. If the object is recognized as an anonymous function (like a lambda), return the specific string '<lambda>'. For other named functions, return their actual name."
    },
    {
        "instruction": "Create a function that takes a callable object which acts as a simple wrapper around another function (e.g., like functools.partial without arguments). The function should return the name of the *original* wrapped function."
    },
    {
        "instruction": "Write a function that accepts two arguments: a numerical value `data` and a boolean `use_data`. Return `data` if `use_data` is true, otherwise return a zero value that matches the type of `data` (e.g., 0 for integers, 0.0 for floating-point numbers)."
    },
    {
        "instruction": "Create a function that accepts a numerical array (e.g., a list or multi-dimensional structure) and returns a new array of the exact same dimensions but filled entirely with zeros, preserving the original data type if possible."
    },
    {
        "instruction": "Write a function that takes a single number `x` and a boolean `flag`. If `flag` is true, return `x`. If `flag` is false, return the numerical value 0."
    },
    {
        "instruction": "Design a function `conditional_return` that takes a numerical value `value` and a boolean `condition`. The function should return the `value` itself if `condition` is true, and the additive inverse (negation) of `value` if `condition` is false."
    },
    {
        "instruction": "Write a function that attempts to locate and return the absolute path string of the executable interpreter running the current script. If the path cannot be determined, return None."
    },
    {
        "instruction": "Create a function that executes an external command provided as a list of string arguments (e.g., ['command', 'arg1']). It should capture and return the standard output of the command as a single string. Handle potential execution errors gracefully (e.g., return an empty string or specific error indicator)."
    },
    {
        "instruction": "Implement a function that runs a given string containing a short code snippet in a separate process using the system's default interpreter for that language. Capture any output sent to the standard error stream and return it as a single string."
    },
    {
        "instruction": "Develop a function that takes two string inputs: `code_snippet` and `forbidden_text`. Execute the `code_snippet` in a separate process. The function must return `True` only if the execution completes without errors AND the `forbidden_text` is *not* found within the standard error output. Otherwise, return `False`."
    },
    {
        "instruction": "Write a function `has_special_zerodim_type(array)` that checks if a numerical array has a specific, designated \"zero-dimension\" or \"placeholder\" data type (distinct from standard types like float or int). Return `True` if it has this specific type, `False` otherwise."
    },
    {
        "instruction": "Write a function `is_numeric_array(data)` that returns `True` if the input `data` is a multi-dimensional numerical array, and `False` otherwise."
    },
    {
        "instruction": "Implement a function `check_array_dtype(array, dtype_specifier)` that takes a numerical array and a data type specifier (e.g., a string like \"float32\", \"int64\", or a special code). Return `True` if the array's data type matches the specifier, `False` otherwise."
    },
    {
        "instruction": "Create a function `is_default_float(array)` that takes a numerical array and returns `True` if its data type is the default floating-point type for the system, `False` otherwise."
    },
    {
        "instruction": "Implement a function that compares two multi-dimensional numerical arrays. It should return `True` if and only if both arrays have the exact same shape, the same data type, and all corresponding elements have identical values. Otherwise, it should return `False`."
    },
    {
        "instruction": "Write a function that validates the properties of an array representation (like the one returned by Task 4). This function takes the representation structure, an expected shape (tuple), and an expected data type (string). It should return `True` if the shape and data type within the structure exactly match the expected ones, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that simulates placing data onto a logical resource. It accepts a multi-dimensional numerical array. It should return a structure (like a dictionary or simple object) containing three pieces of information: the array's shape (as a tuple), its data type (as a string), and a copy of its numerical values."
    },
    {
        "instruction": "Create a function that takes a string representing a numerical data type (e.g., 'int', 'float', 'complex64') and returns its standardized or canonical string representation based on a predefined mapping (e.g., 'int' -> 'int32', 'float' -> 'float64'). Handle unknown types gracefully (e.g., return the original string or raise an error)."
    },
    {
        "instruction": "Implement a function that accepts a multi-dimensional numerical array. It should return a tuple containing two elements: the array's shape (as a tuple of integers) and a string representing its fundamental data type (e.g., \"int32\", \"float64\", \"complex128\")."
    },
    {
        "instruction": "Write a function that analyzes an input value, which can be a Python scalar (int, float, complex, bool) or a multi-dimensional numerical array. The function should return a structure (e.g., a dictionary or custom object) containing three pieces of information: the value's shape (tuple), its canonical data type (string like \"int64\", \"float64\", \"complex128\", \"bool\", or the array's specific type string), and a boolean indicating if the type is considered \"weak\" (True for Python scalars, False for arrays)."
    },
    {
        "instruction": "Develop a function that determines if an input value represents a \"weakly typed\" number or boolean. It should return `True` if the input is a standard Python integer, float, complex number, or boolean, and `False` if it's a pre-defined numerical array object."
    },
    {
        "instruction": "Write a function that accepts either a single numerical/boolean value or a multi-dimensional array. It should return a tuple representing the dimensions (shape) of the input. For a single value (scalar), return an empty tuple `()`."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array `v` of size 3 and returns a new 1D array of size 4 by appending the numerical value 1.0 to the end of `v`."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array `x` of size 3. It should construct and return a 4x4 matrix where the top-left 3x3 submatrix is a diagonal matrix with elements `x[0]`, `x[1]`, `x[2]` on the diagonal, the element at index (3, 3) is 1.0, and all other elements are 0."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `x` of size 3 and returns a 3x3 matrix where the diagonal elements are all equal to the first element of `x` (`x[0]`), and off-diagonal elements are zero."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array `x` of size 3 and returns a 3x3 diagonal matrix where the diagonal elements correspond to the elements of `x` (i.e., `x[0]`, `x[1]`, `x[2]`)."
    },
    {
        "instruction": "Write a function that accepts any standard Python scalar (integer, float, boolean, or complex). The function should return a tuple containing two elements: the original scalar value and its corresponding standard numerical array data type (64-bit for int/float, 128-bit for complex, boolean for bool)."
    },
    {
        "instruction": "Create a function that takes a single Python floating-point number. It should return the standard 64-bit floating-point data type that represents this input within a numerical array context."
    },
    {
        "instruction": "Write a function that accepts a single Python integer. The function should return the standard 64-bit integer data type associated with this input when represented as a numerical array element."
    },
    {
        "instruction": "Develop a function that accepts a single Python boolean value (True or False). The function must return the standard boolean data type used for representing this value in a numerical array."
    },
    {
        "instruction": "Develop a function to compute the vector dot product of two numerical arrays (`arr1`, `arr2`) along a specified `axis`. The function must support broadcasting for dimensions *not* specified by `axis`. The arrays must have the same size along the `axis` dimension, and their other dimensions must be broadcast-compatible. Return the resulting array."
    },
    {
        "instruction": "Implement a function that accepts two 2D numerical arrays, `A` of shape (M, N) and `B` of shape (M, N), and computes their vector dot product along the second axis (axis=1). The output should be a 1D array of shape (M,)."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays (vectors) of the same size and computes their dot product (sum of element-wise products). If the arrays contain complex numbers, conjugate the elements of the first array before multiplying. Return the resulting scalar value."
    },
    {
        "instruction": "Write a function that computes the vector dot product of two numerical arrays along the *last* dimension. Ensure that if the arrays contain complex numbers, the elements from the first array are conjugated before multiplication. Assume the last dimensions are compatible."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix, M x N) and a 1D numerical array (vector, N) and returns their product, a 1D array (vector, M). Ensure the inner dimensions (N) match."
    },
    {
        "instruction": "Create a function that accepts two tuples representing the shapes of the batch dimensions of two arrays (e.g., (2, 1, 3) and (5, 3)). It should return the resulting broadcasted shape tuple (e.g., (2, 5, 3)) if they are compatible according to broadcasting rules, or raise an error/return None if they are not."
    },
    {
        "instruction": "Develop a function that performs matrix-vector multiplication on two inputs with potentially different, but broadcast-compatible, leading batch dimensions. Input 1 shape: (*batch1, M, N), Input 2 shape: (*batch2, N). The function should return an array with shape (*broadcasted_batch, M), where *broadcasted_batch is the result of broadcasting *batch1 and *batch2."
    },
    {
        "instruction": "Write a function that validates the shapes for a matrix-vector multiplication. It takes two shape tuples (e.g., `(M, N)` and `(N,)` or `(*batch1, M, N)` and `(*batch2, N)`) and returns `True` if the matrix's last dimension matches the vector's last dimension, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that computes the product of a 1D numerical array (vector) `v` and a 2D numerical array (matrix) `M`. The function should take `v` of shape `(K,)` and `M` of shape `(K, N)` and return a 1D array representing `conjugate(v) @ M`, which will have shape `(N,)`. Handle complex numbers appropriately."
    },
    {
        "instruction": "Write a function that checks if two shapes, represented as tuples of positive integers, are broadcast-compatible according to standard broadcasting rules (e.g., aligning dimensions from the right, dimensions must match or one must be 1). Return `True` if compatible, `False` otherwise."
    },
    {
        "instruction": "Create a function that performs matrix multiplication between a 1D numerical array (vector) `v` and a 2D numerical array (matrix) `M`. It takes `v` of shape `(N,)` and `M` of shape `(N, M)` and returns a 1D array (vector) of shape `(M,)` representing `v @ M`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array, potentially containing complex numbers, and returns a new 1D array of the same size where each element is the complex conjugate of the corresponding input element."
    },
    {
        "instruction": "Implement a function to numerically approximate the first derivative of a given single-variable mathematical function `f` at a specific point `x`. The function should take `f` (a callable function) and `x` (a scalar number) as input and return the estimated derivative value (a scalar number). You can use a simple finite difference method."
    },
    {
        "instruction": "Write a function that computes the mathematical sinc function, defined as sin(pi*x) / (pi*x), for a given scalar floating-point input `x`. Ensure it correctly handles the special case at x=0, where the function value is 1."
    },
    {
        "instruction": "Develop a function that computes the second derivative of a single-variable function `f` at a point `x`. Assume you have access to a method for computing the first derivative (like the one from Task 3). Apply the differentiation process twice sequentially. The function should accept `f` (a callable function) and `x` (a scalar number) and return the computed second derivative value."
    },
    {
        "instruction": "Create a function `apply_sequence` that accepts a list of single-argument functions and an initial scalar value. The function should apply each function in the list sequentially to the value, using the output of one function as the input for the next. Return the final scalar result after all functions have been applied."
    },
    {
        "instruction": "Write a function that takes a list of numbers and converts it into a 1D numerical array. The function should allow specifying the desired numerical data type (e.g., integer, float) for the elements in the output array."
    },
    {
        "instruction": "Write a function that generates a sequence of integers starting from 0 up to (but not including) a given end value `N`. The function should return a 1D numerical array."
    },
    {
        "instruction": "Create a function that produces a 2D numerical array of shape `M x N` where the diagonal elements (from top-left) are 1 and all other elements are 0. Handle cases where `M != N`."
    },
    {
        "instruction": "Develop a function that generates `num` evenly spaced numerical values between `start` and `stop` (inclusive). It must return *two* values: the 1D numerical array containing the sequence, and the numerical step size used between consecutive elements."
    },
    {
        "instruction": "Write a function that accepts a list of numbers and an optional desired numerical data type. It should return a new 1D numerical array containing the elements from the input list, converted to the specified data type if provided."
    },
    {
        "instruction": "Create a function that accepts two integers, `M` and `N`, and returns a 2D numerical array of shape `M x N` with ones on the main diagonal (where row index equals column index, up to min(M,N)-1) and zeros elsewhere."
    },
    {
        "instruction": "Develop a function that takes a start value, an end value, and an integer count `N` (where N >= 2). It should return two values: first, a 1D numerical array containing `N` evenly spaced numbers from start to end (inclusive), and second, the calculated constant step size between consecutive numbers in the array."
    },
    {
        "instruction": "Write a function that takes an integer `N` and returns a 1D numerical array containing integers from 0 up to (but not including) `N`."
    },
    {
        "instruction": "Generalize the previous task. Write a function that takes a numerical array, a boolean mask array (same shape), and an explicit integer `output_size`. Extract elements from the numerical array where the mask is true. Return a new 1D array of length `output_size`, filled with the extracted elements. Apply zero-padding if fewer elements are extracted than `output_size`, and truncate if more elements are extracted."
    },
    {
        "instruction": "Implement a function that accepts a 1D numerical array and a target integer size. Return a new 1D array of exactly the target size. If the input array is shorter than the target size, pad the end of the new array with zeros. If the input array is longer, truncate it to the target size."
    },
    {
        "instruction": "Develop a function that takes a multi-dimensional numerical array and a multi-dimensional boolean array of the same shape. Calculate a target size equal to the total number of elements in the input array minus one. Extract elements from the numerical array where the boolean array is true. Return a new 1D array of the calculated target size, populated with the extracted elements (padded with zeros or truncated as necessary)."
    },
    {
        "instruction": "Write a function that accepts the shape of a multi-dimensional array (e.g., a tuple like `(3, 4, 2)`) and returns an integer representing the total number of elements in such an array minus one."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array, a 1D boolean mask, and an integer axis index. The length of the mask must match the size of the array's dimension specified by the axis index. Return a new array with the same number of dimensions, but with slices along the specified axis removed where the corresponding mask element is True."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array (matrix) and a 1D boolean mask whose length matches the number of rows in the matrix. Return a new 2D array containing only the rows corresponding to False values in the mask."
    },
    {
        "instruction": "Implement a function that receives a 2D numerical array (matrix) and a 1D boolean mask whose length matches the number of columns in the matrix. Return a new 2D array containing only the columns corresponding to False values in the mask."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and a 1D boolean array (mask) of the same length. Return a new 1D array containing only the elements from the input array where the corresponding mask element is False."
    },
    {
        "instruction": "Write a function `broadcast_array_checked(array, target_shape)` taking a multi-dimensional numerical array and a target shape tuple. First, validate that the `target_shape` does not have fewer dimensions than the `array`. If it does, raise a `ValueError`. If the validation passes, return a *new* array of the `target_shape` (for this task, the contents can be arbitrary, like all zeros, focus is on the check and shape)."
    },
    {
        "instruction": "Implement a function that receives a multi-dimensional numerical array and a target shape (tuple of integers). It must raise a `ValueError` if the target shape tuple has fewer elements than the array's shape tuple. Otherwise, the function should complete without error (e.g., return `None`)."
    },
    {
        "instruction": "Develop a function `validate_broadcast_dimensions(array_shape, target_shape)` which takes two shape tuples. Return `True` if the number of dimensions in `target_shape` is greater than or equal to the number of dimensions in `array_shape`, otherwise return `False`."
    },
    {
        "instruction": "Create a function that takes a shape tuple (e.g., `(3, 4, 5)`) and returns a new multi-dimensional numerical array filled entirely with zeros, matching the provided shape."
    },
    {
        "instruction": "Modify the function from Task 2 (or create a new one) to include a `side` parameter ('left' or 'right'). If `side` is 'left', return the index of the first suitable location for insertion. If `side` is 'right', return the index of the last suitable location."
    },
    {
        "instruction": "Implement a function `find_insertion_indices(sorted_array, values_to_insert)` that takes a 1D sorted array of numbers and another 1D array of numbers. It should return an array of indices where each value from `values_to_insert` should be inserted into `sorted_array` to maintain order. Assume standard numerical comparison and no special float values for simplicity."
    },
    {
        "instruction": "Write a function that takes a single floating-point number and returns a string indicating if it's positive infinity, negative infinity, NaN, zero, or a regular finite number."
    },
    {
        "instruction": "Create a function `find_insertion_indices_special(sorted_array_with_specials, values_to_insert)` that works like Task 2 but correctly handles input arrays containing `-inf`, `+inf`, and `NaN` values. Assume a consistent ordering rule: `-inf` < finite numbers < `+inf` < `NaN`. The function should return insertion indices based on this defined order."
    },
    {
        "instruction": "Create a function that accepts a numerical array `template_arr`. It should return a *new* array filled with the value `1`, having the exact same shape and data type as `template_arr`."
    },
    {
        "instruction": "Design a function that takes: 1) a template numerical array, 2) a boolean `is_template_type_implicit`, 3) a fill value, 4) an optional target data type (`out_dtype`), and 5) an optional target shape (`out_shape`). Create a new array using `out_shape` (or template's shape if `out_shape` is None) and `out_dtype` (or template's data type if `out_dtype` is None). Return the new array and a boolean flag indicating if the output type is considered implicit. This flag is `True` only if `is_template_type_implicit` is `True` AND `out_dtype` was *not* provided; otherwise, it's `False`."
    },
    {
        "instruction": "Write a function that takes a numerical array `template_arr` and a scalar value `fill_value`. It should return a *new* array with the same shape and data type as `template_arr`, filled entirely with `fill_value`."
    },
    {
        "instruction": "Write a function that takes a numerical array `template_arr` and an optional `output_shape` tuple. It should return a new array filled with zeros. If `output_shape` is provided, the returned array must have this shape; otherwise, it must match the shape of `template_arr`. The data type should always match `template_arr`."
    },
    {
        "instruction": "Design a function `check_weak_type` which takes an abstract numerical array object. Assume the object has associated metadata. The function should return `True` if the array's type originated from a single scalar Python number, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a single Python number (int, float, or complex). Return the name of the default high-precision data type it corresponds to (e.g., 'int64', 'float64', 'complex128') and indicate that this type is 'weakly' held."
    },
    {
        "instruction": "Create a function that takes a list of Python numbers, all of the same basic type (e.g., all integers or all floats). Return the name of the default high-precision data type for an array made from this list (e.g., 'int64', 'float64') and indicate the type is 'strongly' held."
    },
    {
        "instruction": "Develop a function that accepts a list containing various numerical values (integers, floats, potentially with specified precisions like float16). Determine and return the single unifying data type name (e.g., 'int16', 'float32', 'float64') capable of representing all elements according to standard type promotion rules (e.g., int + float -> float, float16 + float64 -> float64)."
    },
    {
        "instruction": "Write a function to generate a Vandermonde matrix. Input: a 1D numerical array of size N and an integer degree `deg`. Output: a 2D numerical array of shape (N, deg + 1) where each row corresponds to an element from the input array raised to powers from `deg` down to 0."
    },
    {
        "instruction": "Write a function that evaluates a polynomial given its coefficients and a set of points. Input: a 1D numerical array of coefficients (highest power first) and a 1D numerical array of x-values. Output: a 1D numerical array of the polynomial evaluated at each x-value."
    },
    {
        "instruction": "Develop a function for polynomial fitting that returns extended diagnostic information. Input: 1D numerical array x, 1D numerical array y, integer degree. Output: A structure or tuple containing (1) 1D array of coefficients, (2) the rank of the matrix used in the least-squares fit, and (3) the singular values of that matrix. Consider using a threshold for determining rank based on singular values."
    },
    {
        "instruction": "Implement a function to find the coefficients of a polynomial of a given degree that best fits a set of 1D data points (x, y) using unweighted least-squares. Input: 1D numerical array x, 1D numerical array y (same size as x), integer degree. Output: 1D numerical array of polynomial coefficients."
    },
    {
        "instruction": "Implement a function that generates `N` geometrically spaced numbers between `start` and `stop` along a specified `axis`. Inputs are `start`, `stop` (broadcastable numerical arrays), `N` (integer >= 2), `endpoint` (boolean), and `axis` (integer). Return an array with the sequence inserted along the specified axis, respecting the `endpoint` flag."
    },
    {
        "instruction": "Create a function that accepts two numerical arrays, `start` and `stop`, which are broadcastable to a common shape, and an integer `N` (>= 2). Return a numerical array where the initial dimensions match the broadcasted shape, and a new final dimension has size `N`, containing geometrically spaced numbers (inclusive) for each corresponding pair in the broadcasted `start` and `stop`."
    },
    {
        "instruction": "Write a function that takes two positive scalar numbers, `start` and `stop`, and an integer `N` (>= 2). Return a 1D numerical array of length `N` containing numbers geometrically spaced between `start` and `stop` (inclusive)."
    },
    {
        "instruction": "Develop a function that generates `N` (>= 2) geometrically spaced numbers between `start` and `stop` (inclusive), where `start` and `stop` can be complex scalar numbers. Return a 1D array of complex numbers representing the sequence."
    },
    {
        "instruction": "Create a function that computes the approximate partial derivative of a 2D numerical array along its first axis (rows) using central differences where possible, and forward/backward differences at the boundaries. Input: 2D array. Output: 2D array of the same shape."
    },
    {
        "instruction": "Develop a function that calculates the approximate gradient for a multi-dimensional numerical array (e.g., 1D, 2D, or 3D) along a specified axis. Use central differences for interior points and appropriate forward/backward differences for boundary points along that axis. Input: N-dimensional array, axis index. Output: N-dimensional array of the same shape."
    },
    {
        "instruction": "Implement a function to calculate the approximate derivative of a 1D numerical array using central differences. For an element `x[i]`, the approximation is `(x[i+1] - x[i-1]) / 2`. Use forward/backward differences for the first/last elements. Input: 1D array. Output: 1D array of the same size."
    },
    {
        "instruction": "Write a function that accepts a numerical array (1D, 2D, or 3D) and verifies if its data type is a floating-point type (like single or double precision). Return `True` if it is a float type, `False` otherwise. Input: Numerical array. Output: Boolean."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a positive integer `k`. It should return a new 1D array where each element of the input array is repeated `k` times consecutively."
    },
    {
        "instruction": "Write a function that takes a numerical array (can be 1D or 2D) and a positive integer `k`. It should return a new 1D array formed by first flattening the input array into a 1D sequence and then repeating each element of the sequence `k` times consecutively."
    },
    {
        "instruction": "Develop a function that accepts a 2D numerical array `mat` (shape M x N) and a 1D integer array `repeats` of length N. It should return a new 2D array where the j-th *column* of `mat` is repeated `repeats[j]` times. Handle cases where `repeats[j]` can be zero. The output shape will be M x sum(repeats)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array `arr` and a 1D integer array `repeats` of the same length. It should return a new 1D array where the i-th element of `arr` is repeated `repeats[i]` times. Handle cases where `repeats[i]` can be zero."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is the result of subtracting 1.0 from the corresponding element in the input array."
    },
    {
        "instruction": "Develop a function that takes a list containing a single 1D numerical array. The function should extract the array, perform an element-wise subtraction of a scalar value (e.g., 1.0) on it, and return the resulting 1D array."
    },
    {
        "instruction": "Write a function that accepts a list containing exactly one 1D numerical array. The function should return the 1D numerical array itself, effectively extracting it from the list."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical array and returns a new, independent copy of that array. Changes to the returned array should not affect the original array."
    },
    {
        "instruction": "Write a function that attempts to convert input data (like a list) into a standard numerical array representation. The function should specifically check if the input represents masked data (e.g., contains associated boolean flags indicating validity). If masked data is detected, it must raise a `ValueError`. Otherwise, it returns the standard array representation."
    },
    {
        "instruction": "Implement a function that receives a list of data and an optional list of booleans (mask). If the mask is provided and contains any `True` values, raise a `ValueError` with the exact message \"Masked data is not supported\". Otherwise, return the original data list."
    },
    {
        "instruction": "Create a function that takes a list of booleans representing a mask. Return `True` if at least one `True` value exists in the list (indicating at least one masked item), and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a list of numbers and a corresponding list of booleans (True indicates the number at the same position is invalid/masked). Return a new list containing only the valid numbers (where the mask is False)."
    },
    {
        "instruction": "Implement a function to convert multi-dimensional coordinates to a flat index, clipping out-of-bounds values. Input: a tuple of coordinate arrays, the space dimensions, and an ordering ('C' or 'F'). If a coordinate for a dimension is less than 0, treat it as 0. If it's greater than or equal to the dimension size, treat it as size-1. Return the 1D array of flat indices."
    },
    {
        "instruction": "Create a function that converts multiple sets of multi-dimensional coordinates into flat indices. Input: a tuple of 1D integer arrays (where each array represents indices along one dimension for several points) and the dimensions of the space. Add a parameter to specify either row-major ('C') or column-major ('F') ordering for flattening. Return a 1D array of flat indices. Assume coordinates are always within bounds."
    },
    {
        "instruction": "Write a function that converts multi-dimensional coordinates (given as a tuple of 1D integer arrays) to flat indices based on space dimensions and ordering ('C' or 'F'). Before calculation, validate each coordinate set. If any coordinate in a set is out of bounds (negative or >= dimension size), the function should return a specific integer flag (e.g., -999) for that set's flat index. Otherwise, compute and return the valid flat index. Return a 1D array containing either the flat indices or the flag value for each input coordinate set."
    },
    {
        "instruction": "Write a function that takes a tuple of integer coordinates (e.g., `(c1, c2, ..., cN)`) and the dimensions of a multi-dimensional space (e.g., `(d1, d2, ..., dN)`). Calculate and return the corresponding single flat index assuming row-major (C-style) ordering. Assume coordinates are always within bounds."
    },
    {
        "instruction": "Design a function that takes an integer array `indices` and a list of numerical arrays `choices`. Ensure the function works correctly when `indices` is a scalar (0D array), a 1D array, or a 2D array. The output array must always have the same shape as the `indices` array. Use the \"clip\" mode for handling out-of-bounds indices (indices less than 0 select the first choice, indices greater than or equal to the number of choices select the last choice)."
    },
    {
        "instruction": "Create a function that selects elements from a list of `choices` arrays based on an `indices` array. If an index is less than 0, use the first choice array (index 0). If an index is greater than or equal to the number of choices, use the last choice array. The output array must have the same shape as the `indices` array."
    },
    {
        "instruction": "Implement a function that selects elements from a list of `choices` arrays based on an `indices` array. If any index in `indices` is outside the valid range `[0, num_choices - 1]`, the function must raise a `ValueError` indicating an invalid index was encountered. Otherwise, return the array of selected elements, shaped like the `indices` array."
    },
    {
        "instruction": "Write a function that takes an integer array `indices` and a list of `choices` arrays. Return a new array shaped like `indices`, where each element is selected from the `choices` list using the corresponding value in `indices` as the index. Assume all index values are valid (within the bounds of the `choices` list)."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and a single non-negative integer index. Return the scalar value located at that index if the array were flattened into a 1D sequence. Assume the index is always within bounds."
    },
    {
        "instruction": "Create a function that receives a multi-dimensional numerical array and a tuple of integer indices (one index per dimension). Return the scalar value at the precise location specified by the index tuple. Assume the index tuple is valid and matches the array's rank."
    },
    {
        "instruction": "Write a function that accepts a tuple representing the dimensions (shape) of a potential multi-dimensional array and returns the total number of elements it would contain. For example, input (2, 3, 4) should return 24."
    },
    {
        "instruction": "Develop a function that extracts a single scalar value from a given multi-dimensional numerical array *without* explicit index arguments. If the array contains exactly one element, return that element. If it contains more than one element, raise a ValueError."
    },
    {
        "instruction": "Create a function that computes the cumulative product of a multi-dimensional numerical array along a given axis. The function accepts the array and the axis index, returning an array of the same shape with the cumulative products calculated along the specified dimension."
    },
    {
        "instruction": "Implement a function that calculates the cumulative sum of a 2D numerical array along a specified axis (e.g., 0 for columns, 1 for rows). It should take the array and the axis index as input and return a new 2D array of the same shape with the cumulative sums along that axis."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and computes its cumulative product. The output should be a 1D array of the same size containing the cumulative products."
    },
    {
        "instruction": "Develop a function that computes the cumulative sum or product of all elements in a numerical array (regardless of its original dimensions), effectively operating on a flattened version. The function should take the array as input and return a 1D array containing the cumulative result."
    },
    {
        "instruction": "Create a function that accepts a string representing a common mathematical operation ('sin', 'log', 'exp') and a single floating-point number. The function should apply the named operation to the number and return the floating-point result. Handle cases where the operation is undefined for the input (e.g., 'log' of a negative number) by returning an appropriate special value like NaN or infinity."
    },
    {
        "instruction": "Develop a function that takes a list of floating-point numbers and applies a specific mathematical function (e.g., the exponential function `e^x`) to each element. The function should return a new list containing the results for each input number, preserving the order. Ensure it handles special values like NaN and infinities correctly according to the function's definition (e.g., `exp(inf)` is `inf`, `exp(-inf)` is `0`, `exp(nan)` is `nan`)."
    },
    {
        "instruction": "Write a function that takes the name of a unary mathematical function (e.g., 'sqrt', 'log', 'tanh') as a string and a list of diverse floating-point numbers (including positive, negative, zero, very large/small values, infinity, and NaN). The function must apply the specified mathematical operation to each number in the list, returning a corresponding list of results. It should produce the mathematically correct special values (NaN, +/- Inf) for inputs where the operation results in them (e.g., `sqrt(-1)`, `log(0)`) without raising errors."
    },
    {
        "instruction": "Implement a function that checks if two floating-point numbers are approximately equal. It should take the two numbers, an absolute tolerance, and a relative tolerance as input. Return `True` if they are close based on standard tolerance checks, `False` otherwise. Handle comparisons involving NaN and infinity appropriately (e.g., NaN is not close to anything, Inf is close only to Inf)."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array and returns an integer representing its number of dimensions (axes)."
    },
    {
        "instruction": "Implement a function that receives a multi-dimensional numerical array and returns an integer indicating the total number of elements it contains."
    },
    {
        "instruction": "Create a function that takes a multi-dimensional numerical array as input and returns a tuple of integers representing the size of each dimension (its shape)."
    },
    {
        "instruction": "Write a function that determines if a given multi-dimensional numerical array is a square matrix. It should return `True` if the array has exactly two dimensions and the length of both dimensions is the same, otherwise return `False`."
    },
    {
        "instruction": "Write a function that takes a shape tuple for a 1D array (e.g., `(N,)`) and a numerical data type specification (e.g., 'float32', 'complex64') and returns a 1D array of that shape and type filled with random numerical values."
    },
    {
        "instruction": "Implement a function that performs 1D convolution using the 'valid' mode. It should accept two 1D numerical arrays (e.g., `a` of size `N` and `b` of size `M`) and return a 1D array containing the valid part of the convolution, with size `max(N, M) - min(N, M) + 1`. Ensure the output has a floating-point or complex data type."
    },
    {
        "instruction": "Create a function that performs either 1D convolution or 1D correlation on two input 1D numerical arrays. The function should accept a string parameter ('convolve' or 'correlate') to specify the operation and another string parameter ('full', 'same', or 'valid') to specify the output mode. Return the resulting 1D numerical array, ensuring its data type is floating-point or complex."
    },
    {
        "instruction": "Implement a function that performs 1D correlation using the 'same' mode. It should accept two 1D numerical arrays (e.g., `a` of size `N` and `b` of size `M`) and return a 1D array of size `N` containing the central part of the correlation. Ensure the output has a floating-point or complex data type."
    },
    {
        "instruction": "Create a function to calculate the 'full' 1D cross-correlation of two 1D numerical arrays. Given input arrays `a` of length M and `b` of length N, the output array should have length M + N - 1."
    },
    {
        "instruction": "Write a function that takes a numerical array (1D or multi-dimensional) and a target numerical data type identifier (e.g., 'float32', 'complex128'). It should return a new array containing the same data explicitly cast to the specified target type."
    },
    {
        "instruction": "Develop a versatile function that performs 1D signal processing on two input 1D numerical arrays. The function must accept string parameters to specify: (1) the operation ('convolve' or 'correlate') and (2) the boundary handling mode ('full', 'same', or 'valid'), returning the appropriate 1D result array."
    },
    {
        "instruction": "Implement a function to compute the 'valid' 1D convolution of two 1D numerical arrays. Given input arrays `a` of length M and `b` of length N (where M >= N), the output array should have length M - N + 1."
    },
    {
        "instruction": "Implement a function that calculates the inner product of two numerical inputs `a` and `b`. If both are 1D arrays of the same size, compute their dot product. If one is a scalar and the other an array, perform element-wise scalar multiplication. If both are scalars, multiply them. Return the appropriate scalar or array result."
    },
    {
        "instruction": "Write a function to compute the inner product of two numerical arrays, supporting 'float16', 'float32', and 'float64' types. If either input is 'float16', perform intermediate calculations using at least 'float32' precision before potentially casting the final result back to the appropriate promoted type. Handle scalar and 1D vector inputs, ensuring vectors have compatible sizes."
    },
    {
        "instruction": "Create a function that takes two numerical data type identifiers (e.g., 'float16', 'float32', 'float64') and returns the identifier of the resulting data type after promotion (e.g., 'float16' + 'float32' -> 'float32', 'float32' + 'float64' -> 'float64')."
    },
    {
        "instruction": "Write a function that computes the dot product (inner product) of two 1D numerical arrays (vectors) of the same size. Return a scalar result."
    },
    {
        "instruction": "Write a function that takes an integer `n` and returns a 1D numerical array of size `n` initialized with zeros."
    },
    {
        "instruction": "Write a function that accepts a numerical array and a boolean array. First, verify if both arrays have the same length. If they don't, raise a ValueError. If they do, return a new array containing elements from the numerical array corresponding to `True` entries in the boolean array."
    },
    {
        "instruction": "Implement a function that takes two 1D arrays of the same length: a numerical array `data` and a boolean array `mask`. Return a new 1D array containing only the elements from `data` where the corresponding element in `mask` is `True`. The output array's length will depend on the number of `True` values in the mask."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array `matrix` (shape M x N) and a 1D boolean array `row_mask` of length M. Return a new 2D array containing only the rows from `matrix` where the corresponding element in `row_mask` is `True`. The number of rows in the output will depend on the number of `True` values in `row_mask`."
    },
    {
        "instruction": "Develop a function that takes a 1D integer array `arr` and an integer `value`. Return the total number of times `value` appears in `arr`."
    },
    {
        "instruction": "Create a function that accepts the shape `(M, N)` of a 2D array and a 1D integer array `indices` (shape K, containing values between 0 and M-1). Return a 2D numerical array `G` of shape `(M, N)` where each element `G[r, c]` represents the count of occurrences of the row index `r` within the `indices` array."
    },
    {
        "instruction": "Write a function simulating a specific directional derivative calculation. It accepts two 2D numerical arrays of identical shape (M, N): `gradient_matrix` and `direction_matrix`. Assuming the operation generating `gradient_matrix` has a zero rate of change with respect to the input that `direction_matrix` corresponds to, return a 2D numerical array of shape (M, N) filled with zeros."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `data` (shape M, N) and a 1D integer array `indices` (shape K, containing valid row indices for `data`). Return the scalar sum of all elements in the rows of `data` selected by `indices`. Note that rows can be selected multiple times if their index appears multiple times in `indices`."
    },
    {
        "instruction": "Write a function that takes a 4D numerical array `Source`, an index tuple `idx` (e.g., `(slice(None), 0, [1, 3], slice(None))`), and an `Update` array. The shape of the `Update` array matches the shape of the *last N dimensions* of the slice `Source[idx]`. Perform an indexed assignment where the `Update` array is broadcast across the initial dimensions of the slice `Source[idx]` and assigned. Return the *new* modified `Source` array."
    },
    {
        "instruction": "Create a function that accepts a 3D numerical array `Data`, a 1D boolean array `Mask` whose length equals the size of the first dimension of `Data`, and a 2D numerical array `Updates`. The shape of `Updates` should match the shape of the slice `Data[Mask, :, :]`. Return a *new* 3D array where the slices along the first dimension corresponding to `True` in `Mask` are replaced by the slices from `Updates`."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `Matrix`, a 1D integer array `RowIndices`, and a 1D numerical array `Values`. `RowIndices` specifies rows in `Matrix`, and `Values` provides new values for the element at column 0 in those specific rows. Return a *new* 2D array reflecting these updates. Assume `RowIndices` and `Values` have the same length."
    },
    {
        "instruction": "Develop a function that accepts a multi-dimensional numerical array, an index represented as a tuple (which can contain integers, slices, ellipses, and integer arrays), and an update array. The shape of the update array must exactly match the shape produced by indexing the input array with the provided index tuple. Return a *new* array with the elements at the specified index locations replaced by the values from the update array."
    },
    {
        "instruction": "Write a function that attempts to update a value in a 1D numerical array. It should accept the array, an index, and a new value. If the provided index is an integer and within the array bounds, update the element at that index (or return a modified copy) and return `True`. If the index is not an integer or is out of bounds, return `False` without modifying the array."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array and a tuple representing indices (e.g., `(row, column)`). The function should return `True` if *both* elements in the index tuple are integers, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and an integer index. It should return the element at the specified index. Assume the index is always valid and within bounds."
    },
    {
        "instruction": "Implement a function that safely retrieves an element from a 1D numerical array. It takes the array and an index as input. If the index is an integer and within the array bounds, return the element. If the index is not an integer *or* is out of bounds, return `None`."
    },
    {
        "instruction": "Design a custom class that wraps a list of numbers. Implement the `__getitem__` method for this class. This method should allow indexing using integers and slice objects only. If an attempt is made to index using a string, it must raise a TypeError with a descriptive error message."
    },
    {
        "instruction": "Implement a function that simulates accessing an element from a 1D numerical sequence using an index. The function should accept the sequence and the index. If the index is not an integer, raise a TypeError. If it is a valid integer index, return a placeholder value (e.g., 0)."
    },
    {
        "instruction": "Write a function that accepts a single argument. If the argument is a string, raise a TypeError with the message 'String indices are not supported'. Otherwise, return True."
    },
    {
        "instruction": "Develop a function that simulates slicing a 2D numerical data structure (like a list of lists). It takes the structure and two index/slice objects (one for each dimension). If either index/slice object is a string, raise a TypeError indicating invalid index type. Otherwise, return a placeholder (e.g., None)."
    },
    {
        "instruction": "Write a function that accepts a numerical array and returns its number of dimensions (e.g., 0 for a scalar, 1 for a vector, 2 for a matrix)."
    },
    {
        "instruction": "Write a function `validate_access(array, indices)` that takes a numerical array and a list/tuple of indices. If the number of indices is greater than the array dimensions, return the string \"Invalid Indexing: Too many dimensions\". If the number of indices is appropriate but the specific index values are out of bounds for the array shape, return \"Invalid Indexing: Index out of bounds\". If the access is valid, return \"Valid Indexing\"."
    },
    {
        "instruction": "Implement a function that takes a single numerical value and attempts to access it using one index (e.g., `value[0]`). The function should catch the expected error and return `True` if the specific error occurs, `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a numerical array and a list/tuple of indices. Return `True` if the number of indices provided is strictly greater than the number of dimensions of the array, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array. It should modify the array by adding 5 to every second element (starting from index 0). Return the modified array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and three integers representing slice parameters (start, stop, step). Return a *new* 1D array containing the elements extracted from the input array using this slice."
    },
    {
        "instruction": "Implement a function that takes an integer size `n`, an integer step `s`, and a numerical value `v`. It should generate a 1D array of length `n` filled with zeros, then update the elements at indices `0, s, 2*s, ...` (within the array bounds) to the value `v`. Return the resulting array."
    },
    {
        "instruction": "Develop a function that receives a 1D numerical array, three integers (start, stop, step), and a numerical value `val`. Modify the input array (or return a modified copy) by assigning `val` to all elements specified by the slice `start:stop:step`."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array `arr`. It should return a *new* array of the same size where each element at index `i` (for `i > 0`) is `1 + arr[i-1]`. The element at index 0 should remain unchanged from the input `arr`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `arr` and returns a *new* array of the same size. The first element of the new array should be the same as the input array's first element. Every subsequent element `out[i]` (for `i > 0`) should be calculated as `1 + out[i-1]`. This creates a cumulative sequence based only on the first element and the constant 1."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a new 1D array containing all elements *except* the last one."
    },
    {
        "instruction": "Develop a function that modifies a given 1D numerical array *in-place*. For indices `i` from 1 up to the end of the array, set the element `arr[i]` to the value of `arr[i-1]` plus 1. The first element `arr[0]` remains unchanged. The function should modify the input array directly."
    },
    {
        "instruction": "Develop a function that accepts a 1D numerical array of a specific data type (e.g., unsigned 8-bit integer), an index, and a numerical value. Return a new array where the element at the index is updated. The function must ensure that if the provided value exceeds the capacity of the array's data type, it is handled appropriately (e.g., by storing the value modulo 2^8 for uint8) within the returned array."
    },
    {
        "instruction": "Implement a function that takes a 1D array initialized with zeros and intended to hold unsigned 32-bit integers. The function also takes an index (e.g., 0) and an integer value representing the maximum possible unsigned 32-bit integer (2**32 - 1). Return a *new* array where the element at the specified index is updated with this maximum value, ensuring the value is correctly stored according to the unsigned 32-bit integer type."
    },
    {
        "instruction": "Create a function that accepts a size (integer) and a data type identifier (e.g., 'uint32', 'int8'). It should return a new 1D numerical array of the specified size and data type, filled entirely with zeros."
    },
    {
        "instruction": "Write a function that performs a basic scatter update on a 1D numerical array. It takes the initial array, a 1D array of indices, and a 1D array of update values (of the same length as the indices array). It should return a *new* array where the elements at the specified indices in the original array are replaced by the corresponding update values. Assume indices are unique and within bounds."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (M rows, N columns) and a single slice specification (e.g., `start:stop:step` for rows). Apply this slice to the first dimension (rows) of the array and return the resulting 2D subarray."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and two integers, `start` and `end`. Return the subarray containing elements from index `start` (inclusive) up to `end` (exclusive). Assume valid inputs."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array and a slice specification potentially including a non-unit or negative step (e.g., `start:stop:step`). Return the resulting 1D subarray according to the slice rules."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array and an indexer (which can be a single slice specification or a tuple of slice specifications). The function should first check if applying the indexer to the array is valid given the array's dimensions and the slice parameters. If valid, return the extracted subarray. If invalid (e.g., indices out of bounds), return `None`."
    },
    {
        "instruction": "Implement a function that receives a sequence of numbers. If the sequence does not contain exactly three elements, return an error indicator (e.g., None or a specific string). Otherwise, return the sum of the three elements."
    },
    {
        "instruction": "Develop a function that takes a sequence guaranteed to contain exactly three numerical values. Unpack these values and return the result of subtracting the second value from the sum of the first and third values."
    },
    {
        "instruction": "Write a function that accepts a sequence (like a list or tuple) containing exactly three numerical values and returns their sum."
    },
    {
        "instruction": "Create a function that takes a fixed-size sequence of three elements. Unpack the elements and return the second element."
    },
    {
        "instruction": "Write a function that takes a numerical value (e.g., 0, 1.5) and a string representing a target numerical data type (e.g., 'int16', 'float32', 'complex64'). Return the value represented as the specified target type."
    },
    {
        "instruction": "Implement a function `can_update_strict(array_type_str, value_type_str)` taking two strings representing numerical types (e.g., 'int32', 'float32', 'complex64'). Return `True` if a value of `value_type_str` can safely update an element in an array of `array_type_str` under *strict* rules (requiring identical types or only safe widening like int16->int32), and `False` otherwise (e.g., disallowing float->int, int->float, complex->real)."
    },
    {
        "instruction": "Develop a function that generates a 1D numerical array containing integers from 0 to N-1. The function should accept N and a string specifying the desired numerical data type (e.g., 'int32', 'float64') for the output array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array, an index, and a scalar value. Update the element at the given index with the scalar value. The function must return a new array where the numerical data type is identical to the input array's type, regardless of the scalar's original type (assume conversion is possible without error for this task)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array, an index, and a float value. Return a *new* array where the element at the index is replaced by the value, preserving the input array's exact data type."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array, an index, and a float value. Return a *new* array where the element at the index is multiplied by the value. Ensure the returned array has the same data type as the input array."
    },
    {
        "instruction": "Create a function accepting a 1D numerical array, an index, and a float value. Return a *new* array where the float value is added to the element at the specified index. The output array's data type must match the input's."
    },
    {
        "instruction": "Write a function that processes a sequence of updates on a 1D numerical array known to have a 'flexible' data type property. Each update specifies an index, operation ('set', 'add', 'mul'), and a float value. Return the *final* array after applying all updates, ensuring the 'flexible' type property and the base data type are preserved throughout."
    },
    {
        "instruction": "Write a function that accepts a 1D array of non-negative integers and returns the largest integer found within it."
    },
    {
        "instruction": "Create a function that takes a non-negative integer `size` and returns a new 1D numerical array of that `size` filled entirely with zeros."
    },
    {
        "instruction": "Develop a function that updates a target 1D numerical array based on scattered additions. It takes the `target` array, a 1D numerical array `values`, and a 1D integer array `indices` (same length as `values`). For each element in `values`, add it to the element in `target` at the index specified by the corresponding element in `indices`. The function should modify the `target` array in-place or return the modified array."
    },
    {
        "instruction": "Write a function to compute segmented sums with explicit segment count. Inputs are a 1D numerical `data` array, a 1D integer `segment_ids` array (same length), and an integer `num_segments`. Return a 1D array of length `num_segments` containing the sum for each segment ID from 0 to `num_segments-1`. Ensure sums for segments not present in `segment_ids` are zero. Validate that all segment IDs are less than `num_segments`."
    },
    {
        "instruction": "Create a function that accepts a numerical array (can be multi-dimensional) and returns a new array of the same shape where each element is the square of the corresponding element in the input array."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (e.g., list of lists of floats), a row index, and a column index. Return the square of the element located at the specified row and column. Assume the provided indices are always within the array bounds."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array, an integer index, and a numerical 'fill value'. It should return the element at the given index if it's within the array's bounds, otherwise, it must return the provided 'fill value'."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array `data`, a list of integer indices `indices`, and a numerical `fill_value`. For each index in `indices`, retrieve the corresponding element from `data` if the index is valid, otherwise use the `fill_value`. Return a new 1D array containing the square of each retrieved or filled value."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) and a single integer index `i`. Return the `i`-th row of the matrix as a 1D array. Support negative indexing for `i`."
    },
    {
        "instruction": "Write a function that performs dynamic indexing on a multi-dimensional numerical array. It accepts the array and an indexer, where the indexer is either a single integer or a tuple of integers. Return the element or subarray selected by the indexer. The number of indices provided must be less than or equal to the array's dimensions. Handle both positive and negative indices."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and a tuple of integer indices (e.g., `(i, j, k)`). Return the single scalar element located at the position specified by the indices. Assume the tuple length matches the array's dimensions."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a single integer index. Return the element at that index. Ensure it correctly handles negative indices (e.g., -1 refers to the last element)."
    },
    {
        "instruction": "Write a function that takes a 3D numerical array `data` (D x H x W) and an indexer tuple containing a mix of an integer and a 1D integer list, e.g., `(fixed_d, h_indices)`. `fixed_d` is a single integer specifying the depth, and `h_indices` is a 1D list of integers specifying height indices. The function should return a 2D array containing elements `data[fixed_d, h, :]` for each `h` in `h_indices`. The output shape should be (length of `h_indices`, W). Handle negative indices in both `fixed_d` and `h_indices`."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `data` (M x N) and two 1D lists of integers, `row_indices` and `col_indices`, of the *same length* K. It should return a 1D array of length K containing the elements `data[row_indices[i], col_indices[i]]` for i from 0 to K-1. Handle negative indices."
    },
    {
        "instruction": "Create a function that accepts a 3D numerical array `data` (Depth x Height x Width) and a 2D list of integer pairs `coords` (K rows, 2 columns). Each pair `[d, h]` in `coords` specifies a depth and height index. The function should return a 2D array (K rows, Width columns) where the i-th row contains the slice `data[coords[i][0], coords[i][1], :]`. Handle negative indices."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array `data` (M x N) and two 1D integer index lists: `row_indices` (length R) and `col_indices` (length C). Assume standard broadcasting rules apply (like adding dimensions of size 1). Return a 2D array `output` of shape (R x C) where `output[i, j] = data[row_indices[i], col_indices[j]]`. Handle negative indices."
    },
    {
        "instruction": "Develop a function that performs an indexed addition. It accepts a base numerical array, indices, and an addend array. It should return a *new* array where the elements of the addend array (potentially broadcast) are added to the corresponding elements of the base array at the specified indices. Other elements remain unchanged."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and a set of indices (e.g., integer coordinates, slices) and returns a new array containing only the elements specified by the indices."
    },
    {
        "instruction": "Create a function that checks if an 'update' array shape can be broadcast to match a 'target' array shape according to standard broadcasting rules. It should return `True` if compatible, `False` otherwise. Input are two tuples representing shapes."
    },
    {
        "instruction": "Implement a function that takes a main numerical array, a set of indices, and an update array. It should return a *copy* of the main array where the elements at the specified indices are replaced (overwritten) by the values from the update array. Assume the update array shape is compatible or broadcastable to the shape defined by the indices."
    },
    {
        "instruction": "Create a function that selects elements from a multi-dimensional numerical array based on an advanced indexer. The function takes the array and a tuple containing one or more integer arrays (the indexer) as input. It should return a new 1D array containing the elements specified by the indexer."
    },
    {
        "instruction": "Implement a function to update elements of a numerical array at specified indices. It takes an array `X`, an indexer tuple (like in Task 2), and an update array `Y`. Assume `Y` has the same shape as implied by the indexer. Return a *new* array where elements of `X` at the given indices are replaced by corresponding elements from `Y`."
    },
    {
        "instruction": "Write a function that checks if two shapes (represented as tuples of positive integers) are broadcast-compatible according to standard numerical computing rules. The function should take two shape tuples as input and return `True` if they are compatible, `False` otherwise."
    },
    {
        "instruction": "Write a function that performs an indexed summation update, correctly handling potentially *repeated* indices. It takes an initial array `X`, an indexer tuple (which may contain duplicate indices pointing to the same element), and an update array `Y` (broadcastable to the shape implied by the indexer). For indices that appear multiple times, the corresponding update values from `Y` should be *summed* at that location in the output array. Return the *new* updated array."
    },
    {
        "instruction": "Design a function simulating one step of an iterative optimization process. It should accept the current point (a 1D numerical array), an objective function (vector -> scalar), and parameters like step size or tolerance. Calculate and return a new candidate point (1D numerical array) intended to be closer to the function's minimum, based on a simplified update rule (e.g., gradient descent step if gradient is provided or approximated)."
    },
    {
        "instruction": "Write a function that accepts another function (an objective function mapping a 1D array to a scalar) and an initial 1D numerical array (guess) as input. It should simulate finding a minimum and return a 1D numerical array representing the supposed location of the minimum (e.g., return the initial guess or a slightly modified version)."
    },
    {
        "instruction": "Create a function that checks if two 1D numerical arrays (vectors) are element-wise close. It should take two vectors and two scalar tolerances (absolute and relative) as input and return `True` if all corresponding elements are within the specified tolerances, `False` otherwise."
    },
    {
        "instruction": "Implement the Rosenbrock function for two variables. It should accept a 1D numerical array (vector) of length 2 and return a single scalar value representing the function's output according to the standard formula."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array containing the same values but represented using 64-bit floating-point precision."
    },
    {
        "instruction": "Define the interface for a function that finds the minimum of a given mathematical function. It should accept two arguments: `objective_func` (a callable function that takes a 1D numerical array and returns a scalar) and `initial_guess` (a 1D numerical array). It should return a 1D numerical array representing the point where `objective_func` is estimated to be minimized. (Note: You don't need to implement the minimization algorithm itself, just define the function signature and describe its purpose)."
    },
    {
        "instruction": "Write a function that creates a 1D numerical array of a specified size `N`, initialized with a given floating-point value `v`. Return the created array."
    },
    {
        "instruction": "Implement the Himmelblau function: `f(x, y) = (x^2 + y - 11)^2 + (x + y^2 - 7)^2`. Your function should accept a 1D numerical array of size 2 (representing `[x, y]`) and return a single scalar numerical value."
    },
    {
        "instruction": "Develop a function that compares two 1D numerical arrays, `vec1` and `vec2`, of the same size. It should also accept two non-negative tolerance values, `atol` (absolute tolerance) and `rtol` (relative tolerance). The function returns `True` if `absolute(vec1[i] - vec2[i]) <= atol + rtol * absolute(vec2[i])` holds for all elements `i`, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `M` (shape N x N) and a 1D numerical array `v` (shape N). It should compute the matrix-vector product `M @ v`, then calculate the arithmetic mean (average) of the squares of the elements in the resulting vector. Return this single scalar value."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array (vector) and returns a new 1D array of the same size, where each element is the square of the corresponding element in the input array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `x` (vector of size N) as input. Inside the function, assume a predefined N x N matrix `A` exists (e.g., a scaled identity matrix). The function should compute the matrix-vector product `y = A @ x`, then return the scalar result of calculating the mean of the element-wise squares of `y`."
    },
    {
        "instruction": "Create a function that takes a 1D array of real numbers (size 2N, where 2N is even) and returns a 1D array of complex numbers (size N). Assume the first N elements of the input are the real parts and the next N elements are the imaginary parts."
    },
    {
        "instruction": "Write a function that takes a 1D array of complex numbers (size N) and returns a 1D array of real numbers (size 2N) by concatenating the real parts followed by the imaginary parts of the input array."
    },
    {
        "instruction": "Develop a function that compares two 1D arrays of complex numbers element-wise. It should return `True` if the absolute difference between the complex numbers at each corresponding position is less than a given tolerance `tol` for all elements, and `False` otherwise."
    },
    {
        "instruction": "Implement a function adapter. It should take a function `g` (which accepts a 1D real array of size 2N and returns a single real number) as input. The adapter should return a *new* function `h` that accepts a 1D complex array `z` (size N), converts `z` into a 2N real array (real parts then imaginary parts), calls `g` with this real array, and returns the result."
    }
]