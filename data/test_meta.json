[
    {
        "instruction": "Write a function `execute_function` that accepts two arguments: a function `func` and a tuple `arguments`. The function should call `func` with the elements of `arguments` unpacked as its parameters and return the result."
    },
    {
        "instruction": "Write a function that takes a string representing a data type name (e.g., 'integer', 'float', 'string', 'boolean') and returns `True` if the name is present in a predefined list of allowed type names ['integer', 'float', 'boolean'], and `False` otherwise."
    },
    {
        "instruction": "Create a function `apply_and_capture` that takes two arguments: a function `func` (which accepts a single numerical value and returns a single numerical value) and a numerical value `x`. This function should execute `func(x)` and return a pair: the result of `func(x)`, and a *new* function that takes no arguments and simply returns the computed result of `func(x)`."
    },
    {
        "instruction": "Simulate a basic reference counting system. Create functions to represent `allocate_resource() -> resource_id`, `increment_reference(resource_id)`, and `decrement_reference(resource_id)`. Implement a function `check_for_leaks()` that returns `True` if any allocated resources have a reference count of zero (indicating they are no longer reachable but not freed), and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a tuple representing a potential shape (e.g., `(2, 3)`). Return `True` if all elements in the tuple are positive integers, `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a numerical scalar input `x`. This function should calculate and return the value of `2 * x**2 * cos(3 * x**2)`, where `cos` is the standard cosine function."
    },
    {
        "instruction": "Write a function that accepts a single numerical scalar value (0-dimensional array) and returns the value incremented by 1.0."
    },
    {
        "instruction": "Create a function that takes two numerical inputs, adds them together, and returns the sum."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array containing `R * C` elements and reshapes it into a 2D numerical array (matrix) with `R` rows and `C` columns. Return the reshaped matrix."
    },
    {
        "instruction": "Develop a function that represents a nested function structure. It should take descriptions of an outer function's inputs/outputs and a list of 'equations' within it. One equation type should represent a call to an inner function, itself having input/output descriptions. The function should verify and return the count of inputs and outputs at both the outer and inner levels based on the provided structure."
    },
    {
        "instruction": "Create a function `get_array_size` that takes a 1D numerical array as input and returns its length (number of elements) as an integer."
    },
    {
        "instruction": "Write a function `check_output_consistency(operation_spec, actual_input_spec, declared_output_spec)`. It takes an operation specification (defining how input type maps to output type, e.g., identity preserves type), the actual input variable's type specification, and the declared output variable's type specification. Return `True` only if the output type derived by applying the operation to the actual input matches the declared output type specification. Return `False` otherwise."
    },
    {
        "instruction": "Develop a function that analyzes a predefined computational workflow (conceptually similar to Task 4: takes one input, produces two intermediate results, returns the second). Given a *description* of the input data (e.g., 'scalar integer', 'array of 5 floats'), the function should *not* execute the workflow but determine and return the descriptions (e.g., type/shape) of *both* intermediate results, including the one that is ultimately discarded."
    },
    {
        "instruction": "Develop a function factory named `create_adder_factory`. This factory should take a numerical value `offset` as input. It must return a *new* function. This newly returned function should accept a single numerical input `value` and return the sum `value + offset`."
    },
    {
        "instruction": "Create a higher-order function that accepts a scalar function `f` which takes one argument. The higher-order function should return a *new* function that takes a single numerical array as input, applies `f` to each element, and returns a new array of the same shape containing the results."
    },
    {
        "instruction": "Implement a function that takes a binary scalar function `f` (2 inputs, 1 output) and two 1D numerical arrays, `A` and `B`. It should return a 2D array `C` where `C[i, j] = f(A[i], B[j])` for all valid indices `i` and `j`."
    },
    {
        "instruction": "Develop a function that performs a reduction operation (like sum or product) on a numerical array. It should accept the array, the binary operation function, and an `identity` value. If the input array is empty, the function should return this `identity` value."
    },
    {
        "instruction": "Implement a function that takes two numerical scalar inputs and returns their product. This function should be suitable for use in cumulative operations and must strictly accept two inputs and return one output."
    },
    {
        "instruction": "Write a function that validates inputs for a segmented array operation. Inputs: an array shape (tuple), an axis index (integer), and a 1D array of segment start indices (integers). Output: Boolean True if the axis is valid for the shape and all indices are non-negative and strictly increasing, False otherwise."
    },
    {
        "instruction": "Create a function `to_short_integer(value)` that takes a numerical value and converts it to a 16-bit integer representation, returning the result."
    },
    {
        "instruction": "Implement a function that takes four arguments: a predicate `pred`, two values `val_true` and `val_false`, and an operand `x`. First, check if `pred` is exactly `None`. If it is, raise a `TypeError` with the message \"Predicate is missing\". Otherwise, if `pred` evaluates to true, return `val_true + x`. If `pred` evaluates to false, return `val_false + x`. Assume `val_true`, `val_false`, and `x` are numbers."
    },
    {
        "instruction": "Write a function `conditional_apply` that receives an index `idx`, a list of functions `func_list`, and an argument `arg`. If `idx` is a valid index for `func_list`, apply `func_list[idx]` to `arg`. If `func_list` contains exactly one function, apply that function to `arg` irrespective of `idx`. If `idx` is invalid and `func_list` does not contain exactly one function, return the original `arg` unmodified."
    },
    {
        "instruction": "Implement a function that takes a single number (representing an angle in radians) and returns its sine value. You may use standard math library functions if needed, but focus on the core calculation."
    },
    {
        "instruction": "Create a function that accepts an integer index and a list of items. It should return the item at the specified index. If the index is less than 0, use index 0. If the index is greater than or equal to the list length, use the last valid index."
    },
    {
        "instruction": "Design a function that takes a list of functions and a single numerical input. It applies each function in the list sequentially to the *original* input. It then evaluates a condition: if the input is less than 2.0, it returns the result of the first function; otherwise, it returns the result of the second function. Assume the list will always contain at least two functions."
    },
    {
        "instruction": "Develop a higher-order function named `conditional_execute`. It accepts a boolean condition, two callable functions (let's call them `on_true` and `on_false`), and a single argument. If the condition is true, the function should call `on_true` with the argument and return its result. Otherwise, it should call `on_false` with the argument and return its result."
    },
    {
        "instruction": "Develop a function that accepts a scalar numerical value `x`. It should compute the sine of `x` and then return a 1D numerical array representing `[3.0, 4.0]` scaled element-wise by `sin(x)`."
    },
    {
        "instruction": "Implement a function that takes an initial floating-point value `x` and applies a transformation 10 times sequentially. In each step, determine if the step number (0 through 9) is even or odd. If even, the value `x` remains unchanged for the next step. If odd, `x` is updated to `abs(x) - 1.0`. Return the final value of `x` after 10 steps."
    },
    {
        "instruction": "Write a function `general_indexed_loop` that takes a start index `start_idx`, an end index `end_idx` (exclusive), an initial value `init_val`, and an update rule function `update_func`. The `update_func` takes two arguments: the current index `i` and the current value `v`, returning the updated value. The main function should iterate from `start_idx` to `end_idx - 1`, applying the `update_func` at each step, and return the final value."
    },
    {
        "instruction": "Create a function that simulates applying an update function repeatedly for a fixed number of steps. It takes an initial value, a function `update_func` (which accepts the current value and returns the next value), and an integer `num_steps`. Apply the `update_func` exactly `num_steps` times, starting with the initial value, and return the final value."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and two simple mathematical functions (e.g., one that doubles a number, one that squares it). The function should also accept a string parameter, either \"apply_first\" or \"apply_second\". Apply the corresponding function element-wise to the input array and return the resulting array."
    },
    {
        "instruction": "Write a function that takes a 1D array of floating-point numbers and returns a new array of the same size where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and a context identifier (e.g., 'context1' or 'context2'). If the identifier is 'context1', return the element-wise sine of the array. If the identifier is 'context2', return a different transformation (e.g., element-wise cosine). Ensure the function selects and applies only the relevant transformation based on the identifier."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array where each element is the sine of the corresponding input element. Maintain the input array's shape and data type."
    },
    {
        "instruction": "Write a function that takes two arguments, an integer `n` and a value `x`. The function should simply return the value `x` without using `n`. This task focuses on function definition and argument handling."
    },
    {
        "instruction": "Create a function `validate_bool_flag(config_flag, value)` that raises a `ValueError` if `config_flag` is not a boolean (True or False). If it is a boolean, return `value`."
    },
    {
        "instruction": "Create a function to compute the total squared error between two numerical matrices of identical dimensions. It should return a single scalar value representing the sum of squares of the element-wise differences."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array, two integer indices (row, column), and a scalar value. Return a *new* 2D array identical to the input, except with the scalar value placed at the specified row and column index."
    },
    {
        "instruction": "Write a function that takes a single number `x` and a small positive threshold `t`. If `x` is less than `t`, the function should return `t`. Otherwise, it should return the square root of `x`. Assume inputs `x` are non-negative."
    },
    {
        "instruction": "Write a function that calculates a specific loss value from a 1D numerical array `x_final`. The loss is computed as the sum of the sine of `1.0 - element` for each element in `x_final`. Return the final scalar loss."
    },
    {
        "instruction": "Develop a function that accepts a 1D numerical array `initial_elements`. For each element `x` in this array, perform the following: Initialize a state `s = (0.0, 1.0, 2.0, x)`. Apply the transformation `s = (s[1], s[2], s[3], 0.0)` exactly twice. After processing all elements in `initial_elements`, return the results as a tuple of four 1D arrays `(out0, out1, out2, out3)`, where `out0` contains the first element of all final states, `out1` contains the second, and so on."
    },
    {
        "instruction": "Develop a function that accepts a square 2D numerical array `A` (shape N, N). Inside the function, initialize a 1D zero vector `x` of size N. Then, update `x` by applying the matrix `A` to it (matrix-vector multiplication) exactly 10 times. Finally, return the sum of the elements in the resulting vector."
    },
    {
        "instruction": "Write a function `run_operation_with_cleanup` that takes one argument: another function `operation`. The `run_operation_with_cleanup` function should execute the `operation` function, capture its return value, perform a conceptual cleanup step (e.g., print a message 'Cleanup finished'), and then return the value originally returned by `operation`."
    },
    {
        "instruction": "Develop a function that processes a 1D numerical array. For each element at index `i` with value `v`, initialize a state with `v`. While the state is less than `i * 2`, increment the state by 1. Return a new 1D array holding the final state for each corresponding input element."
    },
    {
        "instruction": "Write a function that accepts a single number `x`. If `x` is less than 3, the function should return the tuple `(x, x)`. If `x` is 3 or greater, it should calculate `y = 2 * x` and return the tuple `(y, 2 * y)`."
    },
    {
        "instruction": "Develop a function that takes a boolean condition, two callable functions (`operation_A`, `operation_B`), and a single numerical value `x`. If the condition is true, the function should compute and return `operation_A(x, x)`. If the condition is false, it should compute and return `operation_B(x, x)`."
    },
    {
        "instruction": "Develop a function `select_and_execute` that takes a boolean `condition`, two functions `func_true` and `func_false`, and a list of exactly three numerical values `operands`. If `condition` is true, invoke `func_true` passing the three values from `operands` as separate arguments. If `condition` is false, invoke `func_false` similarly. Return the result from the invoked function."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x` and returns a tuple containing `x` and its negation `-x`."
    },
    {
        "instruction": "Develop a function that takes three arguments: an integer index `idx`, a list of functions `func_list`, and a numerical value `val`. Each function in `func_list` accepts exactly two identical numerical arguments. Your function should select the function at the specified index `idx` from `func_list`, call it using `val` as both input arguments, and return the computed result. Assume the index is always valid."
    },
    {
        "instruction": "Write a function `check_truthy` that accepts a single numerical input (integer or float). It should return `True` if the input is non-zero and `False` if it is zero."
    },
    {
        "instruction": "Write a function that takes two numbers, `a` and `b`. It should return a boolean value indicating whether `a` is strictly less than `b`."
    },
    {
        "instruction": "Develop a function that accepts a single number. It should return the string \"positive\" if the number is greater than 0, and the string \"non-positive\" otherwise."
    },
    {
        "instruction": "Write a function that takes a single number as input. If the number is strictly less than 3, return the integer 1. Otherwise, return the input number itself."
    },
    {
        "instruction": "Write a function that applies a specific transformation element-wise to a 1D numerical array. For each input element `x`, the output element should be `x + 1` if `x` is zero, and `x - 1` otherwise. Return the new array."
    },
    {
        "instruction": "Implement a generic sequential accumulation function (scan). It takes a binary operation function (like addition), an initial value, a 1D input array, and a boolean flag to process in reverse order. It should return a new 1D array where each element is the result of applying the operation cumulatively up to (or from, if reversed) the corresponding input element."
    },
    {
        "instruction": "Write a function that computes the cumulative sum of a 1D numerical array. Given `[x0, x1, x2, ...]`, return `[x0, x0+x1, x0+x1+x2, ...]`. Return an empty array if the input is empty."
    },
    {
        "instruction": "Write a function that computes the reverse cumulative product of a 1D array of numbers. The i-th element of the output array should be the product of all elements from index i to the end of the input array. The output array must have the same size as the input."
    },
    {
        "instruction": "Write a function `is_callable(arg)` that returns `True` if the input `arg` can be called (like a function or method), and `False` otherwise."
    },
    {
        "instruction": "Define a class `SimplePair` that holds two values, `val1` and `val2`. Implement a method `get_data_tuple` within the class that returns a tuple containing these two values. Write a separate function that takes an instance of `SimplePair`, calls `get_data_tuple`, and returns the sum of the two values obtained in the tuple."
    },
    {
        "instruction": "Write a function `validate_conditional_args(predicate, example_true_output, example_false_output)`. This function must perform two checks: (1) Raise `TypeError('Predicate must be a scalar boolean or number')` if `predicate` is not a scalar boolean or number. (2) Raise `TypeError('Branch outputs must have identical structure and types/shapes')` if `example_true_output` and `example_false_output` do not have identical structures AND identical types/shapes at corresponding leaf elements. If both checks pass, the function should do nothing or return True."
    },
    {
        "instruction": "Write a function implementing a conditional choice. It takes three scalar numbers: `condition_val`, `true_val`, `false_val`. If `condition_val` is strictly less than 3, return `true_val`. Otherwise, return the negation of `false_val`."
    },
    {
        "instruction": "Create a function that accepts a single scalar number `x`. The function should compute `y = 2 * x` and return a tuple containing `y` and `2 * y`."
    },
    {
        "instruction": "Write a function that takes a single numerical input `x`. If `x` is less than 3, the function should return the constant value 2.0. Otherwise, it should return the value `2.0 * x`."
    },
    {
        "instruction": "Write a function that accepts a single numerical input `x`. The function should return `3.0 * x` if `x` is strictly less than 2, and the sine of `x` otherwise."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array `x` of size 2. Based on whether `x[0]` is less than 2.0, it selects one of two transformations: either element-wise multiplication by `[1.0, 2.0]` or element-wise sine. The function should return a 1D array representing the element-wise derivative of the *selected* transformation evaluated at `x`. For the multiplication, the derivative is `[1.0, 2.0]`. For the sine, it's `[cos(x[0]), cos(x[1])]`."
    },
    {
        "instruction": "Create a function `check_float_equality` that accepts two floating-point numbers, `val1` and `val2`, and an absolute tolerance `atol`. The function should return `True` if the absolute difference between `val1` and `val2` is less than or equal to `atol`, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts two scalar numerical inputs, `x` and `y`. If `x` is less than 3.0, the function should return `2.0 * sin(y)`. Otherwise, it should return `2.0 * cos(x)`."
    },
    {
        "instruction": "Develop a function that computes the derivative of a piecewise function evaluated at a point `x`. The piecewise function is defined as `f(y) = 3.0 * y` for `y < 2.0` and `f(y) = sin(y)` for `y >= 2.0`. Your function should return `3.0` if `x < 2.0` and `cos(x)` if `x >= 2.0`."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array (vector) `x` and two callable functions, `func_a` and `func_b`. If the first element of `x` (`x[0]`) is less than 2.0, the function should call `func_a` with `x` and return its result. Otherwise, it should call `func_b` with `x` and return its result."
    },
    {
        "instruction": "Write a function that accepts a single number as input and returns its square."
    },
    {
        "instruction": "Implement a function that takes a boolean condition and a pair of numbers. If the condition is true, return a new pair with the original first number and zero as the second number. If the condition is false, return the original pair unchanged."
    },
    {
        "instruction": "Implement a function that accepts a boolean flag and two numbers, `x` and `y`. If the flag is true, perform a fixed 2-step iteration starting with `x` where the value doesn't change in each step, and return the result (`x`). If the flag is false, return `y`."
    },
    {
        "instruction": "Define a structure representing a computation and its transformation rule. It should consist of: a) A base function that takes a 1D numerical array of size 3 and returns it unchanged. b) A rule function that takes two 1D numerical arrays of size 3 (`original_data`, `change_data`) and returns two 1D arrays: `original_data` element-wise multiplied by `[0, 1, 2]`, and `change_data` element-wise multiplied by `[0, 1, 2]`."
    },
    {
        "instruction": "Implement a function `process_range` that takes an integer `n`, and two functions `func_a` and `func_b`. It should iterate through numbers `i` from 0 to `n-1`. For each `i`, if `i` is non-zero, it calls `func_a(i)`; otherwise, it calls `func_b(i)`. The function should return a list containing the results of these calls in order."
    },
    {
        "instruction": "Implement a function that takes a 1D array of numbers and a function `g`. It should return a new 1D array where each element is the result of applying `g` to the corresponding element in the input array."
    },
    {
        "instruction": "Design a function `map_array_preserve_scalar` that takes a processing function `proc`, a 1D numerical array `arr`, and a scalar `val`. The `proc` function must accept two scalar arguments and return a tuple of two scalar values. `map_array_preserve_scalar` should apply `proc` to each `arr[i]` paired with `val` (i.e., `proc(arr[i], val)`). It must return two results: (1) a *new* 1D array formed by collecting the *first* element from each tuple returned by `proc`, and (2) the original scalar `val`."
    },
    {
        "instruction": "Write a function that takes a boolean, two single-argument functions, and an input which is either a single number or a list of numbers. Apply the function selected by the boolean (first function if true, second if false) to the input. If the input is a list, the function should be applied element-wise, returning a new list of results."
    },
    {
        "instruction": "Develop a function that accepts three positive integers N, T, K and returns a new 3D numerical array initialized entirely with zeros, having the shape (N, T, K)."
    },
    {
        "instruction": "Create a function that generates a 1D array of a specified size containing floating-point random numbers. These numbers should be drawn from an F-distribution defined by given positive numerator and denominator degrees of freedom parameters."
    },
    {
        "instruction": "Develop a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array of shape (`rows`, `cols`) filled entirely with zeros."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array where rows represent observations and columns represent variables. Return a 1D array containing the variance calculated independently for each column."
    },
    {
        "instruction": "Write a function that simulates generating samples based on matrix properties and a method choice. Inputs: mean (1D array), covariance (2D array), number of samples (integer), method ('type1', 'type2'). If the covariance matrix is singular (e.g., determinant near zero) AND method is 'type1', return an array of shape (num_samples, N) filled with NaNs (where N is the dimension from the mean/covariance). Otherwise, return an array of the same shape filled with zeros (representing a successful but simplified generation)."
    },
    {
        "instruction": "Write a function that generates a numerical array according to a specified output shape. It also accepts lower and upper bound arguments which can be either scalars or arrays. If the bounds are provided as arrays, they must be broadcastable to the target output shape following standard broadcasting rules (e.g., a bound array of shape (N,) should apply element-wise to the last dimension of an output shape (M, N)). The function should return the generated array, ensuring all elements fall within their respective broadcasted bounds. Handle both float and integer generation based on the type/nature of the bounds provided."
    },
    {
        "instruction": "Develop a function that mimics a specific differentiation behavior for constant functions. It takes two arguments: an input numerical array and a boolean flag `allow_integer_input`. If `allow_integer_input` is `False` and the input array contains integers, raise a `TypeError`. Otherwise (if `allow_integer_input` is `True` or the input array contains floats/complex numbers), return a new array of the same shape as the input, filled with floating-point zeros."
    },
    {
        "instruction": "Write a function that takes a representation of a pseudorandom number generator state (e.g., a small array or object) and returns exactly two new, distinct state representations derived deterministically from the input state."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array of sorted samples and a reference cumulative distribution function (CDF). Calculate and return the maximum absolute difference between the empirical CDF of the samples and the reference CDF evaluated at each sample point."
    },
    {
        "instruction": "Write a function `check_data_type(data_array, expected_type)` that verifies if all elements in the input `data_array` match the `expected_type` (e.g., 'complex64', 'float32'). Return `True` if they match, `False` otherwise."
    },
    {
        "instruction": "Implement a function to compute the inverse of a given non-singular lower triangular 2D numerical array (shape D x D). The function should return the resulting inverse matrix, which will also be lower triangular (shape D x D)."
    },
    {
        "instruction": "Write a function that accepts an input array `data` and a parameter `split_spec`. `split_spec` can be `None`, a positive integer `N`, or a tuple of positive integers `dims`. The function should return a new array containing copies of `data` arranged according to `split_spec`:\n    - If `split_spec` is `None`, output shape is `(2, *data.shape)`.\n    - If `split_spec` is an integer `N`, output shape is `(N, *data.shape)`.\n    - If `split_spec` is a tuple `dims`, output shape is `(*dims, *data.shape)`.\nHandle the different types of `split_spec` appropriately."
    },
    {
        "instruction": "Develop a function that calculates an empirical probability. It takes two integer inputs: a count of observed successes and a total number of trials. Return the empirical probability (successes / trials) as a float. Handle potential division by zero if trials is 0 (e.g., return 0.0)."
    },
    {
        "instruction": "Write a function that expects a single configuration token (e.g., an integer or string). If it receives a list or sequence of tokens instead of just one, it must raise a `ValueError` with a message indicating a single token was expected but a collection was received. Otherwise, it should return `True`."
    },
    {
        "instruction": "Implement a function that takes a base string and a non-negative integer `num_parts`. Return a list of strings where each element is the base string appended with an index from 0 to `num_parts - 1`. The list must contain exactly `num_parts` elements."
    },
    {
        "instruction": "Develop a function that takes two 2D numerical arrays, `matrix_a` (shape `M x K`) and `matrix_b` (shape `K x N`). It should apply a predefined binary operation `op(x, y)` where `x` is a row from `matrix_a` (shape `K`) and `y` is a column from `matrix_b` (shape `K`). The operation is performed for every combination of rows from `matrix_a` and columns from `matrix_b`. Return a 2D array of shape `M x N` containing the results `result[i, j] = op(matrix_a[i, :], matrix_b[:, j])`."
    },
    {
        "instruction": "Implement a function that takes a list of pseudo-random generator states. For each state in the input list, it should generate two new independent states using the logic from Task 1. Return a list of pairs, where each pair corresponds to the two states generated from an input state (e.g., a list of 2-element lists or tuples)."
    },
    {
        "instruction": "Create a function that accepts an integer `N` and a shape tuple `S`. Return a new shape tuple formed by prepending `N` to the original shape `S`. For example, if `N=10` and `S=(5, 2)`, the function should return `(10, 5, 2)`."
    },
    {
        "instruction": "Develop a function `generate_initial_states(base_seed, count)` that takes a numerical 'base_seed' and a positive integer 'count'. It should return a 1D numerical array of length 'count', where each element is deterministically derived from the 'base_seed' (e.g., `base_seed + i` for the i-th element, where i is the index)."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array and returns its shape as a tuple of integers."
    },
    {
        "instruction": "Write a function `verify_batch_processing(initial_token, list_size)`: First, generate a list of `list_size` tokens by splitting the `initial_token`. Then, process this list to generate pairs of new tokens from each token in two ways: (a) using an iterative approach (like Task 2) and (b) simulating a batch/vectorized approach (apply the split-into-2 operation conceptually to the whole list at once). Finally, compare the list of pairs generated by both methods using their underlying data (like Task 4) and return `True` if the results are identical, `False` otherwise."
    },
    {
        "instruction": "Create a function `vectorized_execution` that takes a function `func` (which accepts a single argument) and a list of arguments `args_list`. `vectorized_execution` should execute `func` for each argument in `args_list` and collect the results. It must return a flat 1D numerical array containing these results, where the size of the array is equal to the number of arguments originally provided in `args_list`."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same length and returns `True` if they are element-wise identical, and `False` otherwise."
    },
    {
        "instruction": "Create a function that applies a given number-generating function `func` (which takes a single seed/key and returns a 1D array of numbers) to a list of `M` distinct seeds/keys. The function should return a list containing `M` separate 1D arrays, one for each seed/key."
    },
    {
        "instruction": "Write a function that simulates splitting a pseudo-random number generator (PRNG) state. It should take a representation of a PRNG state and an integer `N` > 1, and return a list containing `N` new, distinct PRNG state representations derived deterministically from the input state."
    },
    {
        "instruction": "Write a function that creates and returns a new 1D numerical array of a specified size, initialized entirely with zeros."
    },
    {
        "instruction": "Create a function that takes two numerical 2D arrays, A (shape M, N) and B (shape M, 1). Return a new 2D array (shape M, N) where each element `(i, j)` is the sum of `A[i, j]` and `B[i, 0]`."
    },
    {
        "instruction": "Write a function `apply_specific_updates_inplace` that takes a 1D numerical array `arr` (assume it has length at least 2). Modify `arr` *in-place* by first adding `1.0` to every element, then adding `1` to the element at index 0, and finally adding `5` to the element at index 1. Return nothing."
    },
    {
        "instruction": "Write a function that accepts two arguments: a mutable 1D numerical array `input_arr` (size 3) and a numerical scalar `value`. The function must also modify a separate, accessible mutable 1D array `external_arr` (size 3). The function should perform the following operations in order: 1. Add 1.0 to all elements of `external_arr`. 2. Add 1 to the element `external_arr[0]`. 3. Add 5 to the element `external_arr[1]`. 4. Add 7 to the element `input_arr[2]`. 5. Return the input `value` plus 9."
    },
    {
        "instruction": "Create a function that accepts a mutable 1D numerical array, an index `i`, and a numerical value `v`. It should modify the array by adding `v` to the element at index `i`. Assume the modification happens in place and the function does not need to return the array."
    },
    {
        "instruction": "Write a function that creates and returns a 1D numerical array of length 8, filled entirely with zeros."
    },
    {
        "instruction": "Write a function that takes an object containing a 1D numerical array and associated metadata. It should return a *new* object representing a mutable version of the array, ensuring this new object carries the *identical* metadata as the input object."
    },
    {
        "instruction": "Develop a function `add_custom_logic_marker` that takes a function `original_func` as input. It should return a new function that behaves identically to `original_func` when called, but also carries information indicating that custom forward and backward processing steps are associated with it (you don't need to implement these steps, just mark the function)."
    },
    {
        "instruction": "Write a function that accepts two mutable container objects (like the one from Task 3). Call another function (e.g., the one from Task 2) passing these two containers as arguments, ensuring appropriate error handling if the containers are aliases."
    },
    {
        "instruction": "Write a function `execute_conditionally(predicate, func_true, func_false)` that takes a boolean `predicate` and two functions, `func_true` and `func_false`. Both functions take no arguments. Execute `func_true()` if `predicate` is true, otherwise execute `func_false()`. Return the result produced by the executed function."
    },
    {
        "instruction": "Implement a function that processes a sequence of 1D numerical arrays (`inputs`) using a stateful history mechanism. Initialize a fixed-size 1D history array (`history`) with zeros. For each array in `inputs`: calculate its maximum absolute value, update the `history` (shift right, insert max abs value at start), find the maximum value in the *updated* `history`, and record this maximum history value. Return the list containing the recorded maximum history values, one for each input array processed."
    },
    {
        "instruction": "Create a function that takes a boolean condition and two functions (each taking no arguments). Execute and return the result of the first function if the condition is true, otherwise execute and return the result of the second function."
    },
    {
        "instruction": "Implement a function `execute_branch` that takes a boolean flag, two callable functions (`true_case`, `false_case`), and a list of arguments `func_args`. If the flag is `True`, call `true_case` with `func_args` unpacked. If the flag is `False`, call `false_case` with `func_args` unpacked. Return the result of the executed function."
    },
    {
        "instruction": "Design a function `create_safe_updater(initial_state_container)` where `initial_state_container` is a mutable container (e.g., a list with one element). This function should return a *new function*, let's call it `updater`. The `updater` function accepts one argument `input_container`. Inside `updater`, before doing anything else, it *must* check if `input_container` is the *exact same object* as `initial_state_container`. If they are the same object, `updater` must raise a `ValueError` indicating prohibited aliasing. If they are different objects, `updater` should perform an update operation (e.g., add the value in `input_container` to the value in `initial_state_container`) and return the new state from `initial_state_container`."
    },
    {
        "instruction": "Write a function that simulates processing a sequence element by element. It takes a sequence (e.g., a list or array of numbers like `[0, 1, 2, 3, 4]`). For each element `x` in the sequence, it computes `x + 2`. The function should return a new list or array containing only the computed results for each element in the input sequence (e.g., `[2, 3, 4, 5, 6]`)."
    },
    {
        "instruction": "Implement a function `process_list_with_counter` that takes an initial integer `counter` and a list `items`. Iterate through the `items`. In each iteration, increment the `counter` by 2 and store this *new* counter value. Return a tuple containing the final value of the `counter` after all iterations and a list of the stored counter values (one from each iteration)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array 'A' and a sequence of scalar values 'V' (same length as 'A'). The function should simulate an iterative process. In step 'i' (from 0 to length-1), it should add the value V[i] to *every* element of the current state of array 'A'. The function must return a list or 2D array containing the state of array 'A' *after* each step of the iteration."
    },
    {
        "instruction": "Implement a function `process_sequence_safely(step_function, initial_state, inputs)`. This function iterates through the `inputs` sequence. For each item, it calls `new_state, output = step_function(current_state, item)`. It must verify that the returned `new_state` is *not* a mutable container (list, dict, set). If a mutable state is detected at any step, raise a `ValueError` immediately. Otherwise, update the state for the next iteration and collect the `output`. Return the final state and a sequence of collected outputs."
    },
    {
        "instruction": "Implement a function that takes a list containing potentially mutable objects (like lists or dictionaries). It should identify if any two distinct elements in the list are aliases (point to the same object). If aliasing is found, return the index of the first element involved in the first detected alias pair. If no aliasing is found, return -1."
    },
    {
        "instruction": "Implement a function `execute_or_raise_on_alias(mutable_obj, step_function, arg_obj)`. Assume `step_function` potentially closes over `mutable_obj`. First, check if `arg_obj` refers to the *exact same object* as `mutable_obj`. If they are the same, raise a `ValueError` with the message 'Aliasing detected: mutable object passed as argument is also closed over'. If they are not the same object, call `step_function(arg_obj)` and return its result."
    },
    {
        "instruction": "Write a function `get_output_shape_representation(size_input)` that simulates determining an array's shape. If `size_input` is a symbolic representation (like 'n'), return a symbolic representation indicating the shape is `(n,)`. If `size_input` is a concrete integer (like 5), return the concrete shape tuple `(5,)`."
    },
    {
        "instruction": "Develop a function that accepts a positive integer `n` and a floating-point value `v`. It should return a new 1D numerical array of size `n` where every element is initialized to the value `v`."
    },
    {
        "instruction": "Create a function wrapper (decorator or higher-order function) that manages a side effect. The wrapper should take a function `func` as input. It returns a new function that executes `func` on its arguments. Crucially, the wrapper also increments a shared counter, but *only* during the *first* call to the returned function. Subsequent calls execute `func` but do not increment the counter. The returned function should return whatever `func` returns."
    },
    {
        "instruction": "Develop a function that accepts two positive integers, `rows` and `cols`. It should return a 2D numerical array (matrix) with the specified number of rows and columns, filled entirely with the floating-point value 1.0."
    },
    {
        "instruction": "Implement a function that takes two 2D numerical arrays (matrices) having the same number of rows. Return a new 2D array formed by placing the columns of the second array next to the columns of the first."
    },
    {
        "instruction": "Develop a function that takes any multi-dimensional numerical array as input and returns a new 1D array containing all the elements of the input array in their original order (flattening)."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array as input. It should calculate the element-wise sine of this array twice, independently, and then return a new 2D array representing the element-wise sum of these two sine results."
    },
    {
        "instruction": "Create a function that takes an integer `N` and a numerical data type `dtype`. It should return a 1D numerical array of type `dtype` containing the sequence of numbers from 0 to `N-1`."
    },
    {
        "instruction": "Implement a function that takes a list of lists, where each inner list represents a row of a matrix containing numerical values. Return a new list of lists representing the transposed matrix. Handle cases where the input might not represent a valid rectangular matrix (e.g., return an empty list or raise an error)."
    },
    {
        "instruction": "Develop a function that determines if a given 2D numerical array represents a square matrix (number of rows equals number of columns). Return a boolean value."
    },
    {
        "instruction": "Create a function that takes two 2D numerical arrays (matrices) known to have compatible shapes for multiplication (A @ B) and returns their product. Input: Matrix A (M, N), Matrix B (N, P). Output: Matrix C (M, P)."
    },
    {
        "instruction": "Write a function that creates and returns a 2D numerical array (matrix) of size 5x5, initialized with all elements set to 1.0, using a floating-point data type."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new 1D array containing the sequence of integers from 0 up to `length-1`, where `length` is the number of elements in the input array. The output array must have the same data type as the input array."
    },
    {
        "instruction": "Create a function that takes a single numerical value and returns a 2D array of shape (R, C) filled entirely with that value, given R and C as inputs."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical array. The function should determine the input array's size and data type, create a corresponding 1D array filled with zeros, and then return the result of adding the original input array to the zero array element-wise."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Write a function that accepts a positive integer `n` and returns a 1D numerical array containing the sequence of integers from 0 up to (but not including) `2 * n`."
    },
    {
        "instruction": "Create a function that calculates the sum of all elements in a given 1D numerical array. It should accept the array as input and return a single numerical value representing the total sum."
    },
    {
        "instruction": "Design a simple class named `BoundedInteger`. Its constructor should accept an integer `value` and a positive integer `upper_bound`. Store these internally. If `value > upper_bound` during initialization, raise a `ValueError`. Implement a method within the class that returns the string representation \"value{\u2264upper_bound}\"."
    },
    {
        "instruction": "Write a function that takes a positive integer `n` and returns a list containing integers from 0 up to (but not including) `n`."
    },
    {
        "instruction": "Design a function `process_and_log(data, log_list)` that takes an input `data` (which can be an integer or a string) and a list `log_list`. If the *type* of `data` (integer or string) has not been seen in previous calls *recorded in `log_list`*, append the type name (e.g., 'integer' or 'string') to `log_list`. The function should always return `True`."
    },
    {
        "instruction": "Design a stateful calculator class. It should have a method `process(data, category)`. `data` is a 1D numerical array, and `category` is an identifier (e.g., an integer or string). The method should return the sum of `data`. Internally, the class must track the `category` from the *previous* call. It should also maintain an internal execution counter, which is incremented *only* if the `category` of the current call is different from the `category` of the immediately preceding call. The counter should start at 0 and increment on the *first* call as well."
    },
    {
        "instruction": "Implement a function that takes a non-negative integer `limit`. It should first generate a sequence of integers from 0 to `limit - 1`, and then return a new sequence of the same length where each element is the result of adding that element to itself."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array (matrix) and returns a new 2D array containing only the first element of each row."
    },
    {
        "instruction": "Implement a function that takes a list of strings representing a sequence of operations (e.g., [\"sin\", \"sin\", \"cos\", \"add\"]) and returns a dictionary mapping each unique operation name (string) to its frequency count (integer)."
    },
    {
        "instruction": "Develop a function that receives a dictionary where keys are strings (potentially representing operation sources) and values are integer counts. It also takes a prefix string. The function should calculate and return the sum of values associated with keys that start with the given prefix."
    },
    {
        "instruction": "Write a function that takes two numerical scalar inputs `a` and `b`. Inside this function, define and call a helper function that calculates the sum of `a` and `b`. Then, compute the sine of the helper function's result. Finally, return the sum of this sine value and the cosine of the original input `b`."
    },
    {
        "instruction": "Develop a function that accepts a numerical input `a`. Inside the function, calculate `b = a * a`, `c = sin(b)`, and `d = cos(a)`. Return the sum `c + d`."
    },
    {
        "instruction": "Given a dictionary where keys are operation names (strings) and values are their counts (integers), write a function to format and print this information as a simple text summary, like 'operation_name: count', with each entry on a new line."
    },
    {
        "instruction": "Implement a function that takes a string containing data formatted as JSON. Parse this string into a native key-value map data structure (like a dictionary). Return the resulting map. Handle invalid JSON input gracefully (e.g., return an empty map or raise an error)."
    },
    {
        "instruction": "Develop a function that calculates the expected output shape of a generalized tensor dot product *without* performing the actual computation. Input parameters include the shapes of the two input arrays and the dimension specifications (contracting dimensions, batch dimensions). Return a list or tuple representing the output shape."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (M rows, N columns) as input. First, compute the L2 norm for each row. Then, process the rows in non-overlapping pairs (i.e., rows 0 & 1, rows 2 & 3, etc.). For each pair, select the row that has the larger L2 norm. Return a new 2D array containing only these selected rows. Assume M is an even number."
    },
    {
        "instruction": "Implement a function to perform 2D convolution with strides. Inputs are a 4D input array (e.g., Batch, Height, Width, Channels), a 4D kernel array, and 2D stride values (stride_h, stride_w). Assume 'valid' padding (no padding applied). Return the 4D output array."
    },
    {
        "instruction": "Write a function that takes a numerical array and a type identifier string (e.g., 'int32', 'float32') and returns `True` if all elements of the array conform to that data type, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a numerical array (e.g., list of lists or equivalent) of floating-point numbers and two positive integers, `exponent_bits` and `mantissa_bits`. It should return a new array of the same shape where each element has been converted to a lower-precision format according to the specified bit counts."
    },
    {
        "instruction": "Write a function that takes a single 32-bit integer and returns the 32-bit floating-point number represented by the exact same bit pattern."
    },
    {
        "instruction": "Write a function that takes three numerical arrays: `min_array`, `operand_array`, `max_array`. These arrays can have different but broadcastable shapes according to standard numerical library conventions. Return a new array whose shape is determined by broadcasting the input shapes, containing elements from `operand_array` clamped element-wise between the corresponding broadcasted values of `min_array` and `max_array`."
    },
    {
        "instruction": "Implement a function for matrix-matrix multiplication. It should take two 2D numerical arrays (matrices), one of shape (M, K) and another of shape (K, N), and return a new 2D array of shape (M, N)."
    },
    {
        "instruction": "Develop a function that checks if two multi-dimensional arrays are compatible for a contraction operation along specified dimensions. Input: shape tuple for array 1, shape tuple for array 2, list of contracting dimension indices for array 1, list of contracting dimension indices for array 2. Output: Boolean (True if the number and size of corresponding contracting dimensions match, False otherwise)."
    },
    {
        "instruction": "Manually implement array broadcasting for adding leading dimensions. Write a function that takes a numerical array `arr` with shape `S` and a tuple `B` specifying leading dimensions. *Without using built-in broadcasting functions*, create and return a new array of shape `B + S` by explicitly replicating the elements of `arr` across the new dimensions `B`."
    },
    {
        "instruction": "Implement a function `broadcast_array(input_array, output_shape, dimension_mapping)`. `input_array` is a numerical array, `output_shape` is a tuple representing the desired output dimensions, and `dimension_mapping` is a tuple indicating which output dimension corresponds to each input dimension (e.g., if input has shape (A, B) and mapping is (2, 0), input dim 0 maps to output dim 2, input dim 1 maps to output dim 0). Return a new array with the `output_shape`, where data from `input_array` is replicated across the new dimensions."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and returns a new array with *all* dimensions of size 1 removed from its shape."
    },
    {
        "instruction": "Develop a function that rearranges the dimensions of a multi-dimensional numerical array according to a given permutation and then reshapes it. Input: the array, a tuple representing the permutation of axis indices (e.g., `(1, 0, 2)` for a 3D array), and a target output shape. Output: the transformed array. Ensure the permutation is valid and the total number of elements is conserved."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array, a padding value, and two non-negative integers (pad_before, pad_after). Return a new 1D array with `pad_before` copies of the padding value added to the beginning and `pad_after` copies added to the end."
    },
    {
        "instruction": "Implement a function that takes a scalar numerical `condition` and two numerical arrays `values_if_true` and `values_if_false` (both of the same shape, e.g., 1D or 2D). If `condition` is negative, return the `values_if_true` array; otherwise, return the `values_if_false` array."
    },
    {
        "instruction": "Develop a function to extract a sub-volume from a 3D numerical array. Given the array, a tuple of starting indices (dim1, dim2, dim3), and a tuple of ending indices (exclusive), return the resulting 3D sub-array. Assume a step of 1 in all dimensions."
    },
    {
        "instruction": "Given the shape (a tuple/list of integers) of an N-dimensional array, a split `axis` (integer), and a list of section `sizes` (list of positive integers) along that axis, write a function that returns a list of shapes (tuples/lists of integers) for the resulting sub-arrays after splitting. Assume inputs are valid."
    },
    {
        "instruction": "Write a function that takes the shape of a multi-dimensional array (as a tuple of integers) and a permutation tuple. It should return the shape of the array *after* it has been transposed according to the permutation, without needing the actual array data."
    },
    {
        "instruction": "Develop a function that reduces a numerical array by applying a given binary operation (e.g., addition, multiplication) along specified dimensions, starting with a provided initial value. Inputs are the array, initial value, the binary operation (as a function), and a tuple of dimensions. Output is the reduced array."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and an axis index. It should compute the cumulative sum of elements along the specified axis, returning a new array of the same shape as the input."
    },
    {
        "instruction": "Develop a function that generates a multi-dimensional numerical array of a specified shape (e.g., given as a tuple like (3, 4, 5)) filled with arbitrary numerical values. The function should take the desired shape tuple as input and return the generated array."
    },
    {
        "instruction": "Create a function that applies a reduction operation (e.g., minimum) over sliding windows of a 2D numerical array. Inputs are the array, window dimensions (height, width), and strides (vertical, horizontal). Only consider windows fully contained within the input ('VALID' padding). Return the 2D array of results."
    },
    {
        "instruction": "Create a function that calculates the cumulative product of elements in a 1D numerical array. It must accept a boolean `reverse` flag. If `reverse` is false, input `[a, b, c]` yields `[a, a*b, a*b*c]`. If `reverse` is true, it yields `[a*b*c, b*c, c]`. Input: 1D array, boolean. Output: 1D array of the same size and numerical type."
    },
    {
        "instruction": "Write a function `calculate_padding(input_size, window_size, stride, padding_type)` that calculates the padding needed (before, after) for a single dimension based on input size, window size, stride, and padding type ('VALID' or 'SAME'). Return a tuple `(pad_before, pad_after)`."
    },
    {
        "instruction": "Write a function that calculates the padding required for each dimension of a multi-dimensional array when applying a windowed operation (like pooling or convolution). Inputs: the array's shape (tuple of ints), the window dimensions (tuple of ints), the strides (tuple of ints), and the padding type ('VALID' or 'SAME'). Output: A list of pairs, where each pair `(pad_before, pad_after)` specifies the padding for the corresponding dimension."
    },
    {
        "instruction": "Develop a function that performs a multi-dimensional Discrete Fourier Transform (DFT) on a given multi-dimensional complex array. The function should accept the array and a tuple of axis indices along which the DFT should be computed. Return the resulting complex array of the same shape."
    },
    {
        "instruction": "Develop a function to extract rectangular patches (slices) from a 2D numerical array `image`. Inputs are the `image`, a 2D integer array `top_left_corners` (where each row is a `[row, col]` coordinate), and a tuple `patch_size` (height, width). Return a 3D array where the first dimension corresponds to the patches, and the subsequent dimensions are `height` and `width`. Assume corners and patch sizes result in valid slices within the image."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `data`, a 1D integer array `indices`, and a 1D numerical array `updates` of the same length as `indices`. Return a *new* array like `data`, but with `updates[i]` added to the element at `data[indices[i]]` for all `i`. Handle potential duplicate indices by accumulating additions."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `matrix`, a 2D integer array `indices` (where each row `[r, c]` specifies a target element), and a 1D array `updates`. Return a *copy* of `matrix` where `matrix[r, c]` is replaced by the corresponding value in `updates` for each `[r, c]` pair. If multiple updates target the same element, the last update should prevail."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and an integer `k`. It should return a new 1D array containing the `k` largest values from the input array, sorted in descending order. Assume `k` is positive and not greater than the array length."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array representing a batch of vectors (e.g., rows are vectors). The function should process each vector independently (as if applying an identity operation) and return the batch unchanged."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and an axis index (e.g., 0 for columns, 1 for rows). It should return a new 2D array sorted independently along the specified axis."
    },
    {
        "instruction": "Create a function that determines the broadcasted shape resulting from two input array shapes (represented as tuples of positive integers). Return the resulting broadcasted shape as a tuple, or indicate if broadcasting is not possible between the shapes."
    },
    {
        "instruction": "Create a function that calculates the final length of a 1D numerical array after padding. It accepts the original array's length (a non-negative integer) and the padding widths for the beginning and end (two non-negative integers, `pad_before` and `pad_after`). It should return the total length of the padded array."
    },
    {
        "instruction": "Develop a function that receives any Python object and returns `True` if the object is specifically a 1D numerical array type suitable for mathematical operations, and `False` otherwise."
    },
    {
        "instruction": "Write a function `is_numerical_array(data)` that returns `True` if the input `data` is a structure specifically designed for numerical computations (like a multi-dimensional array object) and `False` if it's a standard Python list, regardless of the list's contents."
    },
    {
        "instruction": "Create a function that takes a numerical base `x` and a non-negative integer exponent `n`. Return `x` multiplied by itself `n` times using an iterative approach (a loop). Assume n=0 returns 1."
    },
    {
        "instruction": "Write a function that computes the element-wise derivative of the hyperbolic tangent function for a given 1D numerical input array. Specifically, for each element `x_i` in the input array, calculate `1 - tanh(x_i)^2` and return the results as a new 1D array of the same shape. Ensure the calculation handles potential precision issues with large inputs where `tanh(x_i)` is close to 1."
    },
    {
        "instruction": "Create a function that takes a multi-dimensional numerical array (containing numbers like integers or floats) as input and returns its representation as a flat sequence of bytes."
    },
    {
        "instruction": "Implement a function that accepts an object. If the object is a standard multi-dimensional numerical array with concrete values, convert it to a nested Python list and return it. If the object represents an array structure that cannot be directly iterated to produce simple Python values (e.g., a symbolic representation), raise a `TypeError` with a descriptive message."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array, a target 2D shape `(M, N)`, and an integer `axis` (0 or 1). If `axis` is 0, the array's length must equal `M`, and it should be broadcast across columns. If `axis` is 1, the array's length must equal `N`, and it should be broadcast across rows. Return the resulting 2D array. Handle potential dimension mismatches."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and a single non-negative integer index. Return the row of the matrix corresponding to that index as a 1D array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `data` and a 1D integer array `indices`. Return a new 1D array containing elements of `data` at the positions specified by `indices`. Example: data=[10, 20, 30], indices=[0, 2] -> [10, 30]."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix) and returns a new matrix of the same dimensions. In the returned matrix, the element at index 0 of each row should be replaced by the corresponding row index (e.g., row 0 gets 0.0, row 1 gets 1.0, etc.)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix), a non-negative integer column index, and a scalar value. Return a *new* 2D array of the same dimensions where the column specified by the index is replaced by the result of dividing that original column's elements by the scalar. Assume valid inputs."
    },
    {
        "instruction": "Design a function that acts as a flexible array creator. It should accept parameters specifying the desired initialization method (e.g., 'zeros', 'ones', 'fill'), the array shape tuple, the data type identifier, and optionally a fill value (required only if method is 'fill'). The function should return the newly created numerical array according to the specified method and parameters."
    },
    {
        "instruction": "Design a function that creates a numerical array (e.g., filled with zeros) given a shape and data type. The function must also accept a 'resource_tag' (e.g., a string or integer identifier). The created array should be conceptually associated with this tag. Return the created array."
    },
    {
        "instruction": "Implement a function that receives a numerical array and a scalar fill value. It should return a new array matching the input array's shape and data type, where every element is set to the provided fill value."
    },
    {
        "instruction": "Write a function that takes a numerical array and a *location hint* (e.g., a string or integer identifier representing a processing unit). It should create a new array containing zeros, matching the input array's shape and data type, ensuring the new array is associated with the specified location hint. Return the new array."
    },
    {
        "instruction": "Create a function `scalar_to_container(value)` that takes a single number and wraps it in a basic container (like a single-element list or a simple object holding the value) preserving its original data type."
    },
    {
        "instruction": "Create a function that accepts an existing 1D numerical array and returns a new 1D numerical array which is a guaranteed, independent copy of the input array's data."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array. If the array is empty, it must raise a standard error (like ValueError) with a message indicating an operation cannot be performed on an empty sequence. Otherwise, the function can simply return None."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array and returns a new array with the order of its axes reversed. Example: Input shape (2, 3, 4) -> Output shape (4, 3, 2)."
    },
    {
        "instruction": "Write a function that accepts a numerical array of any dimension, an integer `axis` (which can be negative or None), and a 1D array of integer indices (which can be positive or negative). If `axis` is None, the function should operate on the flattened version of the input array. Return a new array (with potentially different shape and dimension) where the elements (if axis=None) or slices (if axis is specified) indicated by the indices along the relevant dimension are deleted."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and a 1D array of unique integer indices. Treat the input array as if it were flattened into a single dimension, and return a new 1D array with elements at the specified indices removed."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and a 1D boolean array (mask). The function should conceptually flatten the input array into a 1D array, remove elements corresponding to `True` values in the mask, and return the resulting 1D array. The mask length must match the total number of elements in the input array."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays of potentially different lengths: `data` and `counts`. `counts` contains non-negative integers. Return a new 1D array formed by repeating the i-th element of `data`, `counts[i]` times, for each element in `data`. Ensure your function handles cases where `counts` might be shorter than `data` (assume repeats=1 for missing counts) or empty."
    },
    {
        "instruction": "Write a function that computes the first-order difference between adjacent elements of a 1D numerical array. If the input array has N elements, the output should have N-1 elements."
    },
    {
        "instruction": "Develop a function that takes an object having 'shape' (a tuple of integers) and 'dtype' (a numerical data type) attributes. This function should return a new, uninitialized numerical array with the specified shape and data type. The initial contents of the array elements are arbitrary."
    },
    {
        "instruction": "Write a function `split_1d_array(array, indices)` that takes a 1D numerical array and a list of *integer* indices. Return a list of sub-arrays created by splitting the input array at the given indices."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays (vectors) of potentially different lengths and concatenates them horizontally into a single, longer 1D array."
    },
    {
        "instruction": "Develop a function that validates the data type of a function's input argument. It should take two arguments: the value provided by the user and the expected data type (e.g., integer, string, list). It should raise a `TypeError` if the value's type does not match the expected type, otherwise it should do nothing."
    },
    {
        "instruction": "Develop a function that receives a list of 2D numerical arrays (matrices) with the same number of columns and concatenates them vertically (along the first dimension) into a single taller matrix."
    },
    {
        "instruction": "Develop a function to check for the presence of a specific array within a collection (e.g., a list) of numerical arrays. Inputs: a list of numerical arrays, a target numerical array. Output: `True` if any array in the list is element-wise identical to the target array, `False` otherwise."
    },
    {
        "instruction": "Create a function that takes one argument and returns `True` if the argument is a list or a tuple, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes two floating-point numbers and returns True if the first is considered \"less than or equal to\" the second according to standard comparison rules, but treating all NaN values as equal to each other and greater than positive infinity."
    },
    {
        "instruction": "Create a function that takes a numerical array `A` and a desired output data type `T`. It should produce a new numerical array filled with ones, having the same dimensions (shape) as `A`, but specifically using the data type `T`."
    },
    {
        "instruction": "Create a function that constructs a 6-dimensional numerical array of shape (1, 2, 1, 1, 5, 1) filled with random floating-point numbers."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and an integer `k`. It should split the array into `k` equal contiguous sub-arrays. Assume the length of the array is divisible by `k`. Return a list of the sub-arrays."
    },
    {
        "instruction": "Create a function that takes a single argument, expected to be a tuple of positive integers (e.g., `(rows, cols)`). The function should return a new 2D numerical array initialized with ones, having the dimensions specified by the input tuple."
    },
    {
        "instruction": "Develop a function that accepts a 3D numerical array and an axis index. It should return a new array containing the inclusive cumulative sum of elements along the specified axis. The output shape must match the input shape."
    },
    {
        "instruction": "Implement a function that takes a list containing only Python integers and determines the standard integer data type for an array created from it."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `x` and a non-negative integer `deg`, and returns a 2D array where each row `i` corresponds to `[x[i]**deg, x[i]**(deg-1), ..., x[i]**1, x[i]**0]`. The output shape should be `(len(x), deg + 1)`."
    },
    {
        "instruction": "Create a function that generates a 1D array of a specified size `N`. The values in the array should be floating-point numbers spaced logarithmically based on an exponential scale between `exp(range_start)` and `exp(range_end)`. The function should accept `N`, `range_start`, and `range_end` as arguments."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) and an integer `N`. Split the matrix into `N` smaller matrices by dividing it horizontally (along the first dimension, rows). Return these as a list of matrices. Assume the number of rows is divisible by `N`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array with the elements in reverse order. For example, input `[1, 2, 3]` should produce `[3, 2, 1]`."
    },
    {
        "instruction": "Implement a function that receives a multi-dimensional numerical array (could be 1D, 2D, 3D, or higher) and returns a new array of the same shape and data type, where the elements along the first dimension (axis 0) are in reversed order."
    },
    {
        "instruction": "Write a function that rotates a 2D numerical array by 180 degrees. This involves reversing the order of elements along both the first (rows) and second (columns) dimensions. Return the rotated array."
    },
    {
        "instruction": "Implement a function that rotates an N-dimensional numerical array 90 degrees counter-clockwise specifically in the plane defined by its axes 0 and 1. Assume the array has at least 2 dimensions. Input: N-D array. Output: Rotated N-D array."
    },
    {
        "instruction": "Create a function that takes a 2D boolean array `condition` (shape M x N) and two scalar values `x` and `y`. Return a new 2D array (shape M x N) where each element is `x` if the corresponding element in `condition` is true, and `y` otherwise."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays, say `x` of length M and `y` of length N. It should return two 2D arrays. The first output array should have shape (N, M) where each row is a copy of `x`. The second output array should have shape (N, M) where each column is a copy of `y`."
    },
    {
        "instruction": "Create a function `generate_sequence_exclude_endpoint(start, stop, num_points)` that returns a 1D numerical array of `num_points` evenly spaced values between `start` and `stop` (exclusive of `stop`). Also, return the calculated step size between consecutive numbers."
    },
    {
        "instruction": "Write a function that computes `base ** exponent` for potentially multi-dimensional numerical arrays `base` and `exponent`. Handle broadcasting rules where applicable. Return the resulting numerical array."
    },
    {
        "instruction": "Create a function that accepts two numerical arrays, `start_arr` and `stop_arr` (broadcastable to a common shape), and an integer `n` (>=0). Return an array where geometric sequences of length `n` (from corresponding `start`/`stop` elements) form the last dimension. Output shape should be `broadcasted_shape + (n,)`."
    },
    {
        "instruction": "Write a function that takes an input numerical array and a target shape tuple. Return a new tuple representing the shape the input array would have *after* being broadcast to the target shape. Assume the shapes are broadcast-compatible."
    },
    {
        "instruction": "Write a function that computes the numerical gradient of a 1D numerical array using central differences for interior points and one-sided differences for boundaries. Assume unit spacing between points. Input: 1D array. Output: 1D array of the same shape."
    },
    {
        "instruction": "Write a function that performs advanced indexing on a multi-dimensional numerical array. It takes the array and an indexer tuple which can contain integers, slice objects, and 1D lists/arrays of integer indices. Return the resulting array according to the rules of advanced indexing."
    },
    {
        "instruction": "Develop a function that accepts a 3D numerical array and parameters defining a multi-step slicing process: first, select a sub-range along the first dimension; second, select a specific index from the result; third, select a 2D sub-block using ranges for the remaining two dimensions. Return the final selected 2D sub-block."
    },
    {
        "instruction": "Implement a function that modifies a given numerical array. It accepts the array, an indexer, and a value array. The function should update the elements of the original array at the locations specified by the indexer using the corresponding elements from the value array. Assume the value array's shape is compatible with the indexed slice."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array and a single indexer (which could be an integer, a slice object, or a tuple of integers/slices). Return the subarray resulting from applying this indexer to the input array."
    },
    {
        "instruction": "Write a function that copies data between two specified locations within potentially different multi-dimensional numerical arrays using corresponding strided patterns. Inputs: source array, source start indices (tuple), source strides (tuple), destination array, destination start indices (tuple), destination strides (tuple). The function should read from the source using its strides and write to the destination using its strides, assuming the number of elements read and written matches."
    },
    {
        "instruction": "Enhance the `extract_row_slice` function (from Task 3). Add input validation: check if `start` (from `start_index_array`) is non-negative and if `start + num_rows` does not exceed the number of rows in the input `matrix`. If validation fails, return an empty 2D array with the correct number of columns (shape 0 x N)."
    },
    {
        "instruction": "Implement a function that takes two numerical arrays as input. It should return `True` only if both arrays have the exact same shape, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) which may contain complex numbers, and returns its conjugate transpose (Hermitian transpose). An input shape (M, N) should result in an output shape (N, M)."
    },
    {
        "instruction": "Write a function that takes two numerical vectors, `v1` and `v2`, and two tolerance values, `atol` (absolute) and `rtol` (relative), and returns `True` if the vectors are element-wise close within the given tolerances (using `absolute(v1 - v2) <= atol + rtol * absolute(v2)`), and `False` otherwise."
    },
    {
        "instruction": "Design a function `apply_solver_and_extract` that accepts two arguments: `matvec_op` (a function that performs matrix-vector multiplication for a specific matrix `A`) and `rhs_vectors` (a list containing multiple 1D right-hand-side vectors, e.g., `[b1, b2]`). Assume an external function `solve_linear_system(op, vectors)` exists, which takes the operator and the list of vectors, solves `A @ x_i = b_i` for each `b_i`, and returns the corresponding solutions `[x1, x2]` in the same list format. Your `apply_solver_and_extract` function should call `solve_linear_system` with the provided arguments and return only the *first* solution vector (e.g., `x1`) from the resulting list."
    },
    {
        "instruction": "Implement a function to perform matrix-vector multiplication. It should accept a 2D numerical array (matrix) of shape `(M, N)` and a 1D array (vector) of shape `(N,)` and return the resulting 1D array (vector) of shape `(M,)`. Handle various numerical types."
    },
    {
        "instruction": "Implement a function that performs matrix-vector multiplication. It should accept a 2D numerical array `A` (shape `N x N`) and a 1D numerical array `x` (shape `N`) and return the resulting 1D array `b` (shape `N`), where `b = Ax`. Ensure it works correctly for both real and complex number inputs."
    },
    {
        "instruction": "Implement a function to perform matrix-vector multiplication. It should accept a 2D numerical array `A` (shape M x N) and a 1D numerical array `x` (shape N) and return the resulting 1D array `b` (shape M), where `b = Ax`."
    },
    {
        "instruction": "Implement a function that takes a function `M_func` (representing a transformation) and a 1D numerical array `v` (vector). The function should apply `M_func` to `v` and return the resulting 1D array. `M_func` is guaranteed to accept a vector of the same shape as `v` and return a vector of the same shape."
    },
    {
        "instruction": "Design a function that takes a 1D numerical data array, an optional 1D mask array, an optional initial scalar value, and a binary reduction operation (e.g., a function like `add`, `multiply`, `maximum`). If provided, the mask must be boolean and have the same shape as the data array, otherwise raise a TypeError. The function should apply the reduction operation iteratively to the data elements where the mask is True (or all elements if no mask), starting with the initial value (or a suitable default if none is provided). Return the final reduced scalar result."
    },
    {
        "instruction": "Write a function that checks if a given 1D array contains only boolean values (True/False). It should return `True` if all elements are boolean, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that acts as a simple argument validator. It takes a dictionary representing function arguments and a specific argument name (string) that is considered 'deprecated'. The function should return `True` if the deprecated argument key exists in the dictionary, and `False` otherwise."
    },
    {
        "instruction": "Develop a function `create_filled_array(shape_tuple, fill_value)` that takes a tuple representing dimensions (e.g., `(2, 3, 4)`) and a numerical `fill_value`. It should return a new multi-dimensional numerical array of that shape, filled entirely with the `fill_value`."
    },
    {
        "instruction": "Implement a function to calculate the cumulative sum of a multi-dimensional numerical array along a specified axis. Input: N-D array, axis index (integer). Output: N-D array of the same shape with cumulative sums along the given axis."
    },
    {
        "instruction": "Write a function that computes the cumulative product along a specified axis of a numerical N-D array, with an option to include an initial value (1) at the beginning along that axis. Input: N-D array, axis index, boolean flag `include_initial`. Output: N-D array whose size along the specified axis might be one larger if `include_initial` is true."
    },
    {
        "instruction": "Write a function that simulates dimension retention after an aggregation. It takes a 2D numerical array, an axis index (0 or 1), and a boolean `keep_dimensions`. Perform a simple aggregation (like sum, ignoring NaNs) along the specified axis. If `keep_dimensions` is true, return an array with the same number of dimensions as the input but with size 1 along the aggregated axis. If false, return an array with the aggregated dimension removed."
    },
    {
        "instruction": "Write a function that calculates the arithmetic mean of a 1D numerical array. Input: 1D array. Output: Scalar mean."
    },
    {
        "instruction": "Create a function that calculates a reduction (e.g., maximum value) over all elements of a numerical array if the axis parameter is None, or along a specific integer axis otherwise. It should take the array and an optional axis index. Return the reduced array or scalar."
    },
    {
        "instruction": "Create a function that calculates the variance of elements within a numerical array along a specified axis. The function takes the array and axis index. It should compute the mean, the squared differences from the mean, and their average. Consider how to handle calculations where the number of elements along the axis might be zero or one."
    },
    {
        "instruction": "Write a function that calculates the sum of elements along a specified dimension (axis) of a multi-dimensional numerical array. The function should take the array and the axis index as input and return a new array with the specified dimension removed. Handle positive and negative axis indices."
    },
    {
        "instruction": "Write a function that performs a specified reduction operation ('sum', 'product', 'max', 'min') on a numerical array. It should accept the array, an optional dimension index for reduction (if None, reduce all), an optional initial value for the operation, and a boolean flag to keep the reduced dimensions. Ensure correct handling of the initial value, especially for empty slices resulting from the dimension specification. Inputs: array, operation name (string), dimension index, initial value, keep_dims flag. Output: reduced array."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array, an axis index, a boolean `keep_dims` flag, and an operation name ('sum', 'product', 'min', 'max'). It should perform the specified reduction operation along the given axis, respecting the `keep_dims` flag. The function must correctly handle inputs containing zero-sized dimensions, provided the reduction axis size is >= 1."
    },
    {
        "instruction": "Write a function that computes the sum of all elements in a numerical array. It takes a multi-dimensional numerical array and returns a single scalar value representing the total sum."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and a 1D boolean array (mask) of the same size. Find the maximum value among the elements of the numerical array where the corresponding mask element is true. If the mask is all false, return a predefined minimum value (e.g., negative infinity for floats)."
    },
    {
        "instruction": "Write a function using a recursive approach to compute the `n`-th Bernoulli number, Bn, given `n` (a non-negative integer). The function should utilize the values of B0 to B(n-1) in its calculation. Return the result as a float."
    },
    {
        "instruction": "Develop a function that takes a 1D array of negative floating-point numbers (guaranteed not to be negative integers, NaN, or infinity). For each input `x`, determine an output sign: return 1.0 if the ceiling of `-x` (the smallest integer greater than or equal to `-x`) is an even integer, and -1.0 if the ceiling of `-x` is an odd integer. Return the resulting 1D array of signs."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array where each element is the square of the corresponding input element. The output array should have the same shape and data type as the input."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays, `x` and `y`, of the same length. Return a new array where the i-th element is positive infinity if `x[i]` is positive AND `y[i]` is less than or equal to zero. Otherwise, the element should be 0."
    },
    {
        "instruction": "Develop a function to numerically estimate the gradient of a given mathematical function `f` with respect to a subset of its arguments. The function should accept `f`, a list of all input arguments `args`, and a list of indices `diff_indices` indicating which arguments to differentiate with respect to. Return a list containing the estimated gradient for each argument specified by `diff_indices`."
    },
    {
        "instruction": "Write a function that compares two 1D numerical arrays of the same shape. It should return `True` if all corresponding elements are numerically close to each other (e.g., absolute difference is below a small threshold like 1e-5), and `False` otherwise."
    },
    {
        "instruction": "Implement a function that determines if a square 2D numerical array (matrix) is positive semi-definite. Assume the input matrix is Hermitian. The function should compute the eigenvalues of the matrix and return `True` if all eigenvalues are non-negative (allowing for a small numerical tolerance), and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a list representing a state key (e.g., 4 unsigned integers). Return a new list representing the next state, where each element is updated based on a simple deterministic rule (e.g., add 1 to each element)."
    },
    {
        "instruction": "Create a function that generates a 2D numerical array of specified dimensions (rows, columns) where every element is initialized to a given constant value."
    },
    {
        "instruction": "Write a function that takes no arguments. It should access a numerical variable defined outside its scope (a closure) and return the value of that variable."
    },
    {
        "instruction": "Create a function that accepts two arguments: an object and a class definition. It should return `True` if the object is an instance of the provided class, and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a tuple containing a single positive integer, representing a dimension (e.g., `(N,)`), and returns the integer value `N` itself."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array and an axis index (0 or 1). It should return a new 2D array where the elements along the specified axis are reversed."
    },
    {
        "instruction": "Develop a function that calculates the final size of a single dimension after applying padding. Input consists of the original dimension size (a non-negative integer) and a padding tuple `(low, high, interior)`. Raise a `ValueError` with a specific message if the calculated size (Original + Low + High + Interior * max(0, Original - 1)) is less than zero."
    },
    {
        "instruction": "Develop a function that reshapes a multi-dimensional numerical array by collapsing a specified range of adjacent dimensions. It should accept the array, a starting dimension index `start`, and an ending dimension index `end` (exclusive). Dimensions from `start` to `end-1` should be merged into one. Ensure it works for various ranks and valid index ranges."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array with at least two dimensions. It should return a new array where the last two dimensions are combined into a single dimension. For example, an input shape (A, B, C, D) should result in an output shape (A, B, C*D)."
    },
    {
        "instruction": "Write a function to check window dimension bounds. It takes the shape of a 'base' array and the shape of an 'updates' array. It also takes a list identifying which dimensions of the 'updates' array form the 'window' (`update_window_dims`) and a mapping list from these window dimensions to dimensions in the 'base' array (`window_to_base_map`). Return `True` if the size of each 'updates' window dimension is less than or equal to the size of the corresponding 'base' array dimension specified by the map, `False` otherwise."
    },
    {
        "instruction": "Write a function that creates and returns a new multi-dimensional numerical array of a specified shape (e.g., `(3, 4)`), filled entirely with zeros. The function should also accept an argument to specify the numerical data type (e.g., float32, int64) for the array elements."
    },
    {
        "instruction": "Write a function `check_list_length` that accepts a list and an integer `expected_length`. It should raise a `ValueError` with an informative message if the list's length is not equal to `expected_length`. Otherwise, it should return `True`."
    },
    {
        "instruction": "Write a function `is_scalar(value)` that returns `True` if the input `value` represents a single numerical value (0-dimensional) and `False` otherwise (e.g., for lists, arrays with dimensions)."
    },
    {
        "instruction": "Write a function `convert_and_infer_copy(input_array, target_type_string)` that converts `input_array` to the `target_type_string`. It should return a tuple: `(converted_array, copied)`, where `copied` is a boolean inferred to be `True` if the target type differs from the input array's original type, and `False` otherwise."
    },
    {
        "instruction": "Create a function that applies a simple transformation function element-wise across two input 1D arrays of the same size. The transformation function takes two arguments (one element from each array) and returns a single value. The main function should return a new 1D array containing the results of applying the transformation to corresponding element pairs."
    },
    {
        "instruction": "Write a function `create_and_update_array(length, start_index, end_index, value)`. It should create a 1D array of the given `length` (e.g., initialized with zeros), replace the elements from `start_index` (inclusive) up to `end_index` (exclusive) with the provided `value`, and return the modified array."
    },
    {
        "instruction": "Create a function that compares two 1D numerical arrays of the same size element by element. It should return `True` if all corresponding elements are numerically close (within a predefined small tolerance, e.g., 1e-5), and `False` otherwise."
    },
    {
        "instruction": "Create a function `configure_task` that accepts two arguments: `compute_fn` (a function taking one 1D numerical array and returning a 1D numerical array) and `config_data` (a 2D numerical array). `configure_task` should return a *new* function. This new function accepts a single 1D numerical array `x`, executes `compute_fn(x)`, and returns the result. The `config_data` must be associated with the returned function (e.g., stored within it) but is not directly used by `compute_fn` to produce its result."
    },
    {
        "instruction": "Write a function to validate inputs for a grouped matrix multiplication. It should take the dimensions M, K, N, NumGroups, and the `GroupSizes` array. Check if the length of `GroupSizes` equals `NumGroups`, if the sum of `GroupSizes` equals M, and if all elements in `GroupSizes` are positive integers. Return true if all conditions are met, false otherwise."
    },
    {
        "instruction": "Implement a function to compute the matrix product of two 2D numerical arrays. The function should take two arrays, `A` (shape M x K) and `B` (shape K x N), both of the same data type, and return their product (shape M x N), ensuring the output array has the exact same data type as the input arrays."
    },
    {
        "instruction": "Develop a function similar to Task 3, but perform a product reduction instead of a sum. It takes a 1D numerical array, an initial scalar value, and boolean flags for a type property ('is_weak') for both inputs. It returns the scalar product and a boolean indicating if the result has the property (True only if both input flags were True)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array containing floating-point numbers and returns a new array where each element is rounded to the nearest integer."
    },
    {
        "instruction": "Create a function that bundles data. It should accept two arguments: a 1D numerical array `arr1` of size 2 and a 2D numerical array `arr2` of shape (R, C). Return a tuple containing precisely these two arrays in the order `(arr1, arr2)`."
    },
    {
        "instruction": "Write a function that takes a 1D array of positive integers representing segment lengths. Return a 1D array containing the indices where splits should occur based on the cumulative sums of the lengths (excluding the last length)."
    },
    {
        "instruction": "Create a function that takes a positive integer `n` and a numerical value `v`. It should return a 1D numerical array of length `n` where every element is equal to `v`."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) `M` and returns a new matrix formed by prepending the first row of `M` to `M` itself. Input shape (N, K) should result in output shape (N+1, K)."
    },
    {
        "instruction": "Develop a function that takes a tuple representing dimensions (e.g., `(rows, cols)`) and returns a 2D data structure (like a list of lists) of those dimensions, initialized with a default placeholder value (e.g., 0 or None)."
    },
    {
        "instruction": "Develop a function that compares the input and output specifications of two abstract computational processes. Assume each process specification provides information about the expected number and characteristics (e.g., shape, data type) of input variables and output variables. The function should return `True` if both processes have identical input specifications AND identical output specifications, and `False` otherwise."
    },
    {
        "instruction": "Create a function that receives a sequence of data items. It iteratively applies a processing function to each item. The processing function returns two values at each step, but only the second value should be collected. Return a new sequence containing only the collected second values."
    },
    {
        "instruction": "Develop a function that receives the shape of a multi-dimensional array (e.g., a tuple like (5, 10, 3)) and an integer representing an axis index. Return `True` if the provided axis index is valid (i.e., exists) for the given shape, and `False` if it's out of bounds."
    },
    {
        "instruction": "Develop a function that applies a user-provided reduction operation (e.g., add, max) over sliding windows of a multi-dimensional numerical array. The function must support specifying window dimensions, strides, padding, input element spacing (base dilation), and window element spacing (window dilation). It also takes an initial value for the reduction. Return the resulting array."
    },
    {
        "instruction": "Develop a function to calculate the output shape when reinterpreting data from a type with more bits (`nbits_in`) to one with fewer bits (`nbits_out`). Input: `input_shape` (a tuple of positive integers), `nbits_in` (integer, `nbits_in > nbits_out`), `nbits_out` (integer). Return the output shape (input shape with an appended dimension of size `nbits_in // nbits_out`). Raise an error if `nbits_in` is not divisible by `nbits_out`."
    },
    {
        "instruction": "Create a function that takes the shapes (as tuples) of two matrices, A and B. If they are compatible for matrix multiplication (A * B), return the shape tuple of the resulting matrix. If they are not compatible, return `None`."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array and removes *all* dimensions that have a size of exactly 1. Return the resulting array with fewer dimensions."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array, a window size (integer), and a stride (integer). It should compute the sum of elements within a sliding window across the array using the specified size and stride, assuming no padding ('VALID' padding). Return the 1D array of window sums."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and returns a new array representing the cumulative minimum, calculated from right-to-left (reverse order). For input `[5, 1, 4, 2]`, the output should be `[1, 1, 2, 2]`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a tuple representing a new valid 2D shape (e.g., (M, N)). Return the array reshaped according to the new shape. Assume the total number of elements is compatible."
    },
    {
        "instruction": "Create a function that accepts two arguments and attempts to add them using the `+` operator. If a `TypeError` occurs during the addition, the function should catch it and return the string 'Error: Incompatible types'. Otherwise, it should return the result of the addition."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array and an axis identifier (e.g., 0 for column-wise, 1 for row-wise). It should return a 1D array containing the indices of the maximum values along the specified axis. Ensure the returned indices are standard integers."
    },
    {
        "instruction": "Implement a function that finds the index of the maximum value along a specified axis of a multi-dimensional numerical array. The function must raise a `ValueError` with a descriptive message if the array dimension indicated by the axis parameter is empty (size 0). Otherwise, return the array of indices."
    },
    {
        "instruction": "Implement a function that finds the index of the first occurrence of the maximum value within a 1D numerical array. It should return a single integer index."
    },
    {
        "instruction": "Implement a function that creates a 2x2 numerical array filled with the value 1.0. The function should accept a boolean flag; if true, the array elements should use a less precise floating-point type representation, otherwise use a standard precision representation. Return the created array."
    },
    {
        "instruction": "Develop a function that receives an input spatial shape tuple (e.g., `(H, W)`), a filter shape tuple (e.g., `(fH, fW)`), a strides tuple (e.g., `(sH, sW)`), and a padding list of tuples (e.g., `[(pH_b, pH_a), (pW_b, pW_a)]`). Calculate the output shape of the spatial dimensions after applying the padding and considering the strides and filter shape (as in a convolution). Return the calculated output spatial shape `(out_H, out_W)`."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication on two input 2D arrays of 16-bit floating-point numbers. The function should return a new 2D array, also containing 16-bit floating-point numbers, representing the product. Ensure the output array's data type is strictly 16-bit float."
    },
    {
        "instruction": "Create a function that generates a 2D numerical array (matrix) of a given shape (rows, columns) filled with random single-precision floating-point numbers."
    },
    {
        "instruction": "Develop a function that takes a single numerical value and returns its cube (the value raised to the power of 3)."
    },
    {
        "instruction": "Write a function `verify_computation` that takes an input value, a function `func` to test, and an expected output value. The function should call `func` with the input value and return `True` if the result strictly equals the expected output, and `False` otherwise. Demonstrate its use with a squaring function for input `2.0` expecting `4.0`."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and returns a new 1D array where each element is the square of the corresponding input element."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array and an integer `k`. The function should return two 1D arrays: the first containing the `k` largest values (sorted descending), and the second containing their corresponding original indices."
    },
    {
        "instruction": "Create a function that takes a list of numbers and returns a new list containing the square of each number in the input list."
    },
    {
        "instruction": "Create a function that takes another function `func` as input. Assume `func` takes no arguments. Your function should call `func` and return `True` if the result is numerically equal to `1.0`, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that takes a single argument of any basic data type (e.g., number, string) and returns it without modification."
    },
    {
        "instruction": "Develop a function that accepts a primary 1D numerical array and a secondary 1D numerical array of the same shape, provided as a keyword argument named `modifier`. The function should perform an element-wise calculation (e.g., division or multiplication) between the primary array and the `modifier` array and return the resulting 1D array."
    },
    {
        "instruction": "Write a function that takes a 3D numerical array with shape (1, N, 1) and returns a new 1D array of shape (N,) containing the same elements."
    },
    {
        "instruction": "Create a function that takes two 2D numerical arrays. Return `True` if the number of columns in the first array matches the number of rows in the second array (shape compatibility for multiplication), and `False` otherwise."
    },
    {
        "instruction": "Develop a function that creates a 2D numerical array (matrix) with specified dimensions (rows, columns) and data type (e.g., 'float32'). Fill the array with random numerical values."
    },
    {
        "instruction": "Develop a function that accepts the shapes of two numerical arrays (e.g., as tuples) and determines if they are compatible for a standard generalized dot product operation (vector-vector, matrix-vector, vector-matrix, matrix-matrix). Return `True` if compatible, `False` otherwise."
    },
    {
        "instruction": "Create a function to validate a set of potential eigenvectors and eigenvalues for a given square matrix. Inputs are the matrix (H), a 1D array of eigenvalues (e), and a 2D array where columns are the corresponding eigenvectors (V). Return true if the matrix-eigenvector product (H @ V) is approximately equal to the eigenvalues times eigenvectors (element-wise multiplication of e broadcasted appropriately onto V), within a specified numerical tolerance."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays of the same length containing integers. It should return a new 1D array where each element is the result of the floor division (integer division rounding towards negative infinity) of the element from the first array by the corresponding element from the second array. Consider how to handle potential division by zero."
    },
    {
        "instruction": "Implement a function executor that conditionally applies a setting. It accepts a function `func`, a list of arguments `args`, and a boolean `apply_setting`. If `apply_setting` is true, conceptually enable a 'special mode' (e.g., print 'Special mode on'), run `func(*args)`, conceptually disable the mode (e.g., print 'Special mode off'), and return the result. If `apply_setting` is false, just run `func(*args)` and return the result."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of potentially different types (e.g., integer and floating-point) and returns a new 1D array containing their element-wise sum. The output array's data type should follow standard promotion rules (e.g., integer + float results in float)."
    },
    {
        "instruction": "Create a function that accepts a 2D array and a 1D array of integer indices. It should return a new 2D array formed by selecting the rows from the input 2D array corresponding to the provided indices."
    },
    {
        "instruction": "Develop a function that generates a 2D numerical list-of-lists (matrix) of size Rows x Cols. Initialize the element at `[r][c]` with a floating-point value based on its row and column index, for example `float(r * Cols + c)`."
    },
    {
        "instruction": "Implement a function that finds the minimum value within a 1D numerical array. Input: 1D array of numbers. Output: The smallest number present in the array. Assume the input array is non-empty."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar value. It should return a *new* array of the same shape where all elements selected by the slice `[::2, 3:]` (every second row, starting from the fourth column) are replaced by the input scalar value. Non-selected elements should keep their original values."
    },
    {
        "instruction": "Write a function that accepts a 1D array of boolean values and returns `True` if at least one value in the array is `True`, and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a text input stream. It should read lines one by one until it encounters the end of the stream (EOF). The function should return the total count of lines read."
    },
    {
        "instruction": "Implement a function that simulates a basic command prompt interaction. It takes a prompt string (e.g., \"(cmd) \"), an input stream, and an output stream. It should first print the prompt string to the output stream, then read a single command line from the input stream, and finally return the command string read."
    },
    {
        "instruction": "Develop a function that takes a dictionary representing a variable scope (e.g., `{'x': 2.0, 'y': 'hello'}`) and a variable name string (e.g., \"x\"). It should return a formatted string displaying the variable's name and its value (e.g., \"x: 2.0\"). If the variable name is not found, return an appropriate message."
    },
    {
        "instruction": "Write a function that takes a single floating-point number as input and returns its sine."
    },
    {
        "instruction": "Write a function that accepts a float `x`. Inside, it calculates `y = x + 1.0`. It must then construct and return a single multi-line string representing a specific interaction log: `\"\\n    Entering Scope:\\n    (scope) (x, y)\\n    (scope) \"`, where `x` and `y` are replaced by their numerical values, formatted as floats with at least one decimal place (e.g., `\"(2.0, 3.0)\"`)."
    },
    {
        "instruction": "Develop a function that takes two strings: `text_to_search` and `regex_pattern`. Return `True` if the `regex_pattern` is found anywhere within the `text_to_search`, `False` otherwise. You can assume basic regex syntax support."
    },
    {
        "instruction": "Create a function that simulates a text-based input stream pre-filled with a list of command strings (e.g., ['command1', 'command2']) and an output stream. The function should allow reading commands sequentially from the input and writing arbitrary text messages to the output. Return the final content written to the output stream."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number and returns its sine value."
    },
    {
        "instruction": "Write a function that accepts a numerical input `val` and a separate callback function `record`. The main function should perform a calculation (e.g., `intermediate = val + 1.0`), then call `record(intermediate)` to pass the intermediate result to the callback, and finally return the `intermediate` value."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array as input and returns a new 1D array where each element is the exponential of the corresponding input element."
    },
    {
        "instruction": "Write a function that takes two strings: `text` and `pattern`. It should return `True` if the `text` contains a match anywhere within it for the regular expression `pattern`, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that simulates processing commands from a text stream. It takes an initial numerical array and a list of command strings (e.g., ['print data', 'continue']). If it encounters 'print data', it should return a string representation of the current array. If it encounters 'continue', it should signal to proceed (e.g., return None or a specific status). Handle unrecognized commands by returning an error string."
    },
    {
        "instruction": "Write a function that simulates a basic command-line interpreter managing two scopes (local, global). It takes a list of commands (e.g., 'DECLARE local var1=10', 'PRINT var1', 'DECLARE global var1=20', 'PRINT var1', 'DELETE local var1', 'PRINT var1'). It should process these commands, maintaining the state of local/global variables, performing lookups (local first), handling deletions, and returning a list of the outputs generated by PRINT commands."
    },
    {
        "instruction": "Stack Navigation Logic. Implement a function that simulates moving up a call stack view. It takes the current frame index (integer, 0 is top) and the total number of frames displayed (integer, `limit`). If the command is 'up' and the index is greater than 0, return the decremented index. If the command is 'up' and the index is 0, return 0 and signal that the top is reached (e.g., return a tuple `(0, 'top')`)."
    },
    {
        "instruction": "Write a function that accepts two function objects and a value, and creates a dictionary where the keys are the function objects and the value is the provided value. Return the dictionary."
    },
    {
        "instruction": "Implement a function that simulates processing commands from a text input stream. For a specific command like 'access data X', check if 'X' exists in a simple predefined dictionary. If not, write a specific error message (e.g., 'Error: Name X is not defined') to a provided text output stream. For a command like 'proceed', simply stop processing."
    },
    {
        "instruction": "Write a function `apply_conditional_custom_rule(condition, x)` that simulates applying a conditional operation with a custom transformation rule. If `condition` is true, it should return a pair of values: `(x * x, 3.0 * x * 1.0)`. If `condition` is false, it should return `(x, 1.0)`. The input `x` is numerical. This simulates evaluating a function and its custom derivative (with a tangent of 1.0) based on a condition."
    },
    {
        "instruction": "Write a function that takes a boolean condition, two functions (func_true, func_false), and an input value. If the condition is true, it applies func_true to the input; otherwise, it applies func_false. Return the result."
    },
    {
        "instruction": "Write a function that simulates an iterative process controlled by a counter. It takes a single floating-point number as an initial state. The process runs in steps. It maintains a counter, initialized to 0.0, and the state value. The process stops when the counter is no longer less than 10.0. In each step, the counter is incremented by 1.0, and the state value is updated by squaring its current value. The function should return the final state value reached when the process stops."
    },
    {
        "instruction": "Implement a function that takes two numerical inputs, a primary value `x` and a rate-of-change value `x_dot`, and computes a result based on a specific custom rule: `3.0 * x * x_dot`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array where each element is the square of the corresponding input element. Input: 1D array. Output: 1D array."
    },
    {
        "instruction": "Implement a function that takes a boolean condition, two single-argument functions (`func_if_true`, `func_if_false`), and a value `x`. If the condition is true, return the result of applying `func_if_true` to `x`. Otherwise, return the result of applying `func_if_false` to `x`."
    },
    {
        "instruction": "Develop a function that accepts a boolean predicate `p` and a number `x`. If `p` is true, the function should return `(x*x, x+1)`. If `p` is false, it should return `(x-1, x/2)`. Ensure the function always returns a tuple of two numbers."
    },
    {
        "instruction": "Write a function that accepts a boolean flag, two single-argument numerical functions (`func_true`, `func_false`), and a numerical operand `val`. If the flag is true, it should call `func_true` with `val` and return the result. Otherwise, it should call `func_false` with `val` and return its result."
    },
    {
        "instruction": "Write a function that takes a boolean condition, two functions (func_true, func_false), and a numerical input value. If the condition is true, it should call func_true with the value and return the result. Otherwise, it should call func_false with the value and return its result. Assume both functions take one numerical argument and return one numerical value."
    },
    {
        "instruction": "Implement a function that takes an initial scalar value and a 1D numerical array. It should compute a running sum where each element of the input array is added to the sum accumulated so far. Return the final sum."
    },
    {
        "instruction": "Implement a function that takes a current scalar numerical value (`accumulator`) and two scalar numerical inputs (`element1`, `element2`). It should return the updated accumulator calculated as `accumulator + element1 * element2`."
    },
    {
        "instruction": "Write a function `update_state` that takes a current state (a numerical scalar) and an input value (a numerical scalar). It should return the new state calculated as `current_state * input_value`."
    },
    {
        "instruction": "Write a function that mimics a general `while` loop structure. It should accept an initial state (e.g., a tuple containing an integer and a 1D numerical array), a condition function, and a body function. The condition function takes the current state and returns `True` or `False`. The body function takes the current state and returns the next state. The loop executes the body function as long as the condition function returns `True`. Return the final state after the loop terminates."
    },
    {
        "instruction": "Implement a function to find the roots of a quadratic polynomial. It should take a 1D numerical array of exactly 3 coefficients (representing c, b, a for ax^2 + bx + c) and return a 1D array containing the two roots as complex numbers."
    },
    {
        "instruction": "Develop a function to find the roots of a polynomial defined by a 1D array of coefficients. The function must consider the total length of the coefficient array (including any leading zeros) to determine the expected number of roots (length - 1). It should return a 1D array of complex roots. If fewer roots are found than expected, the output array must be padded with complex NaN values to match the expected count (`len(coefficients) - 1`)."
    },
    {
        "instruction": "Create a function that accepts an N-dimensional numerical array and returns a single scalar value representing the mean of the squares of all elements in the array."
    },
    {
        "instruction": "Write a function that takes a numerical multi-dimensional array and a tuple representing a target shape. It should return a new array containing the same data but rearranged into the target shape. The total number of elements must remain unchanged."
    },
    {
        "instruction": "Create a function that calculates the mean squared value of all elements in a given multi-dimensional numerical array. It should return a single scalar floating-point number."
    },
    {
        "instruction": "Develop a function that chains two operations: first, apply a 2D convolution (as described in Task 3, using stride 1x1 and 'SAME' padding) to a 4D input array using a given 4D kernel; second, apply 2D sum pooling (as described in Task 2, using a 2x2 window, 1x1 stride, and 'SAME' padding) to the convolution result. Return the final 4D array."
    },
    {
        "instruction": "Create a function that accepts a 3D numerical array `data` (shape D1 x D2 x D3) and a 1D integer array `indices` (shape K). Return a new 3D array (shape D1 x K x D3) by selecting slices along the *second* dimension (axis 1) of `data` using the values in `indices`."
    },
    {
        "instruction": "Design a function that takes a 3D numerical array (shape D1 x D2 x D3). For each index `i` from 0 to D1-1, consider the 2D slice `input[i, :, :]`. Apply an operation to this slice that selects only the columns at indices `[0, 2]`. Collect these resulting smaller 2D arrays and stack them to form a new 3D array of shape (D1, D2, 2). Return this resulting 3D array."
    },
    {
        "instruction": "Write a function that simulates a named-axis reduction. It takes a multi-dimensional numerical array, a list representing the names of all its axes (e.g., ['batch', 'height', 'width']), a list of axis names to reduce over (e.g., ['height', 'width']), and a reduction function (e.g., sum, max). The function should apply the reduction across the specified named axes, returning an array with the same dimensions as the input, but with size 1 along the reduced axes."
    },
    {
        "instruction": "Implement a function that takes two non-negative integer axis indices, `primary_axis` and `secondary_axis`. Calculate and return an 'adjusted' secondary axis index. The adjusted index is `secondary_axis + 1` if `primary_axis <= secondary_axis`, otherwise it remains `secondary_axis`."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array and a target shape tuple. Return a new array containing the same data but rearranged into the target shape. Assume the total number of elements is preserved."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array and conceptually applies a gradient calculation to each element. Assume each element `x_i` contributes to a final value `V = -sum(x_1, x_2, ..., x_n)`. The function should return a single scalar value representing the gradient of `V` with respect to any single element `x_i` (assuming the gradient is the same for all elements). Input: 1D array. Output: A single scalar numerical value."
    },
    {
        "instruction": "Write a function that takes an integer `N` and returns a 1D numerical array of length `N` where all elements are equal to 1.0."
    },
    {
        "instruction": "Write a function that takes a single numerical value (e.g., an integer) and returns a 1-dimensional array containing just that value."
    },
    {
        "instruction": "Create a function that calculates the total squared error between two numerical arrays (predictions and targets) of the same shape. It should compute the element-wise difference, square each difference, and return the sum of all squared differences as a single scalar value."
    },
    {
        "instruction": "Write a function that takes the shapes (as tuples of integers) of two numerical arrays, `A` and `B`, intended for a generalized dot product along the last axis. Assume the last dimensions are compatible. Return the expected shape of the resulting array, considering how leading dimensions are typically handled (e.g., matching dimensions are preserved). For instance, input shapes `(4, 2, 3)` and `(3,)` should result in output shape `(4, 2).`"
    },
    {
        "instruction": "Write a function that takes a 1D numerical array, an integer index, and a numerical value. It should return a *new* 1D array where the value at the specified index in the original array has been increased by the given numerical value. Ensure the original array remains unchanged."
    },
    {
        "instruction": "Develop a function that applies a given binary operation (e.g., vector dot product) element-wise across specified axes of two input tensors. The function should take the two tensors, the binary operation function, and the axes along which to map the operation. For example, applying a vector dot product to tensors X of shape (Batch, N) and Y of shape (Batch, N) along axis 0 should produce a 1D array of shape (Batch,)."
    },
    {
        "instruction": "Develop a function that calculates the gradient (vector of first partial derivatives) of the scalar function described in Task 3, with respect to its 1D array input. The output should be a 1D array of the same size as the input, representing the rate of change of the scalar output relative to each input element. Handle points where the derivative might change behavior (e.g., at zero)."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array `matrix` (M rows, N columns) and a 1D integer array `row_indices`. Return a new 2D array composed of the rows from `matrix` indicated by `row_indices`."
    },
    {
        "instruction": "Develop a function that applies a given operation function (`op`) to slices of an input array along a specified batch axis. The function should take the input array, the batch axis index, and the operation function `op`. It should iterate through each slice along the batch axis, apply `op` to the slice, and collect the results into a new array stacked along the batch dimension."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and a list of integer indices. Return a new array containing only the elements/slices corresponding to those indices along the *first* dimension of the input array."
    },
    {
        "instruction": "Implement a function that performs a gather operation where the indices themselves have a batch dimension. The function should efficiently process all index sets in the batch against the same data array. Inputs: a multi-dimensional numerical data array, an index array with an explicit batch dimension, dimension mapping rules (indicating the batch dimension in indices), and slice sizes. Output: an array containing the gathered slices for each element in the index batch, stacked along a new batch dimension."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and an axis index. It should return a list containing each slice of the array along the specified axis."
    },
    {
        "instruction": "Implement a function that performs a generalized slicing and gathering operation. Inputs are a source numerical array `source`, an integer index array `indices`, the axis of `source` to gather from (`source_axis`), the size of each slice to extract (`slice_size`), and rules defining how index dimensions map to output dimensions. Return a new array containing the extracted slices arranged according to the mapping rules."
    },
    {
        "instruction": "Design a callable object (e.g., a class instance) that wraps a simple element-wise numerical operation (like `y = x + x`). When the object is called with a 1D numerical array, it applies the operation and returns the result array. Crucially, it must also manage a side effect (e.g., printing 'First call!' or setting a flag) so that the side effect occurs *only* the very first time the object is called, and never on subsequent calls, even with different input arrays."
    },
    {
        "instruction": "Write a function that creates and returns a 2D numerical array of size M x N, populating it with consecutive integers starting from 0, row by row."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array and returns a new 2D array containing the element-wise square of the input array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (list of numbers) and returns a new 1D array where each element is the cumulative product of the elements up to that position in the input array. Example: `[1, 2, 3, 4]` -> `[1, 2, 6, 24]`."
    },
    {
        "instruction": "Select Element from 1D Array with Clamping: Write a function `select_clamped_1d(data, index)` that takes a 1D numerical array `data` and an integer `index`. It should return the element at the `index` after clamping the `index` to the valid range `[0, len(data) - 1]`."
    },
    {
        "instruction": "Develop a function similar to Task 3, but handle negative indices. A negative index `-k` should correspond to the index `N-k`, where `N` is the size of the dimension specified by the axis. The function takes a 2D numerical array `A`, an axis index, an integer index `i` (possibly negative but valid after wrapping), and a 1D numerical array `V`. Return the updated 2D array. Assume `V` has the correct length."
    },
    {
        "instruction": "Implement a function that splits a 1D numerical array into multiple sub-arrays. It takes the 1D array and a 1D array of positive integers (`sizes`) specifying the length of each sub-array. Assume the sum of `sizes` equals the length of the input array. Return a list of the resulting 1D sub-arrays."
    },
    {
        "instruction": "Create a function that accepts a shape tuple (e.g., (5, 3)) and returns a numerical array of that shape filled with random floating-point values."
    },
    {
        "instruction": "Implement a function that numerically approximates the first derivative of a given single-variable input function `f` at a point `x`. Use the central difference formula `(f(x + h) - f(x - h)) / (2 * h)` for a small step `h`. The function should accept `f`, `x`, and `h`."
    },
    {
        "instruction": "Write a function that calculates the partial derivative of f(x, y) = sin(x) * cos(y) with respect to x. The function should accept two numerical inputs, x and y, and return the computed derivative value."
    },
    {
        "instruction": "Develop a function `adjust_tolerance` that accepts a numeric type identifier (e.g., 'float32', 'float64', 'complex64') and a base tolerance. Return an adjusted tolerance value, potentially increasing the base tolerance slightly for lower-precision types like 'float32'."
    },
    {
        "instruction": "Develop a function that accepts another function `op` (representing a mathematical operation like `cos` or `sinh`) and a numerical input value. The function should execute `op` with the input value and return the result. Handle potential exceptions during the execution of `op` gracefully (e.g., return a specific indicator or re-raise)."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array `A` of data type `T1` and a target type `T2`. Convert `A` to type `T2`, creating array `B`. Calculate the element-wise difference between `A` and `B`. If the types are complex, consider only the real parts for the difference calculation. Return the maximum absolute value found in the difference array."
    },
    {
        "instruction": "Write a function that takes a single numerical value `x`, a minimum value `min_val`, and a maximum value `max_val`. It should return `x` clamped between `min_val` and `max_val` (inclusive)."
    },
    {
        "instruction": "Implement a function that accepts a list of numerical arrays and an integer representing the axis. It should join the arrays sequence along the specified axis. Assume all input arrays have the same shape except for the dimension specified by the axis."
    },
    {
        "instruction": "Write a function `prepend_broadcast(array, prepended_shape)` that takes a numerical `array` and a `prepended_shape` tuple. Return a new array where the original `array` is replicated across new leading dimensions defined by `prepended_shape`. The output shape should be `prepended_shape + array.shape`."
    },
    {
        "instruction": "Write a function that takes a numerical array (e.g., shape (M, N)) and a target shape (e.g., (N,)). Sum the input array along the dimensions that are present in the input shape but not in the target shape. Return the resulting lower-dimensional array."
    },
    {
        "instruction": "Write a function that manually performs a permuted reshape without using built-in reshape/transpose functions. Given an input N-dimensional array, a permutation P of its axes (0 to N-1), and a target shape T, calculate the new index for each element based on P and T, and construct and return the output array. Assume valid inputs where total elements match."
    },
    {
        "instruction": "Develop a function that applies padding to a multi-dimensional numerical array. It takes the array, a padding configuration (list of tuples `(pad_low, pad_high, pad_interior)`, one per dimension, with non-negative integers), and a scalar padding value. It should add padding at the start/end and insert padding between elements for each dimension. Return the resulting array."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix) and returns a new matrix where the order of elements within each row (i.e., along the columns) is reversed. Example: Input `[[1, 2, 3], [4, 5, 6]]`, Output `[[3, 2, 1], [6, 5, 4]]`."
    },
    {
        "instruction": "Implement a function `relu_like(input_array)` that takes a numerical array and returns a new array of the same shape where every negative element is replaced by zero, and all non-negative elements remain unchanged."
    },
    {
        "instruction": "Implement a function that performs multi-dimensional array slicing. It should accept an N-dimensional numerical array, a tuple of start indices, a tuple of limit indices (exclusive), and an optional tuple of strides (defaulting to 1 for each dimension if not provided or None). Return the resulting N-dimensional sub-array. Ensure it handles varying dimensions and stride values correctly."
    },
    {
        "instruction": "Create a function that generates a \"selection mask\" array based on slicing parameters. Inputs: the shape of an original multi-dimensional array (tuple), the slice start indices (tuple), and the slice sizes (tuple). Output: a new multi-dimensional array of the *original shape*, containing 1.0 where elements belong to the specified slice and 0.0 elsewhere."
    },
    {
        "instruction": "Implement a function that accepts a 2D numerical array (matrix), a tuple of two starting indices `(row_start, col_start)`, and a 2D update matrix. Return a *new* 2D array representing the original matrix with the slice defined by the start indices and the update matrix's shape replaced by the update matrix. Assume the update fits within the original matrix boundaries."
    },
    {
        "instruction": "Develop a function that checks if a given permutation tuple is valid for transposing an array with a specific shape. A valid permutation must contain each integer from 0 to N-1 exactly once, where N is the number of dimensions indicated by the shape. Return True if valid, False otherwise."
    },
    {
        "instruction": "Write a function that computes the sum of elements in a multi-dimensional numerical array along specified axes. It takes the array and a tuple of axis indices as input and returns the resulting array with reduced dimensions."
    },
    {
        "instruction": "Implement a function that calculates the sum reduction of a multi-dimensional numerical array along a single specified dimension. The function should accept the array and the dimension index as input. For example, reducing a (3, 4, 5) array along dimension 1 should result in a (3, 5) array."
    },
    {
        "instruction": "Write a function that applies a sliding window sum reduction to a 2D numerical array, incorporating window dilation. Inputs are the 2D array, window dimensions, strides, and window dilation factors (vertical, horizontal). Return the resulting 2D array. Dilation means elements within a window are spaced apart."
    },
    {
        "instruction": "Create a function that performs a cumulative sum along a specified dimension of a multi-dimensional numerical array. Input: an N-dimensional array and an integer axis index. Output: an N-dimensional array of the same shape with cumulative sums calculated along the given axis."
    },
    {
        "instruction": "Write a function that returns the indices that would sort a 1D numerical array in ascending order. Input: 1D array. Output: 1D array of integer indices."
    },
    {
        "instruction": "Write a function that takes a numerical array (potentially multi-dimensional) and an integer `k`. Find the `k` largest values along the *last* axis of the array. Return two arrays: one containing the `k` largest values for each slice along the last axis (sorted descendingly), and another containing their corresponding indices *within that slice*. The output shape should reflect the input shape but with the last dimension replaced by `k`."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array `data`, a tuple/list of 1D integer index arrays `indices`, and a tuple/list of integer axes `axes` (where the number of index arrays matches the number of axes). Return a new array constructed by gathering elements from `data` using the `indices` along the specified `axes` simultaneously."
    },
    {
        "instruction": "Index Clipping Function: Write a function that takes an integer index, a minimum bound (inclusive, usually 0), and a maximum bound (exclusive). It should return the index clamped to the range `[min_bound, max_bound - 1]`."
    },
    {
        "instruction": "Write a function that generates an array of random integers. It should take the desired array shape and the upper bound (exclusive) for the random integers as input. All generated integers should be non-negative."
    },
    {
        "instruction": "Develop a function that performs element-wise updates on a multi-dimensional numerical array. It takes the original array, a list/array of coordinate tuples (e.g., `[[0, 0], [1, 2], [0, 1]]` for a 2D array), and a list/array of corresponding update values. Return a *new* array where the elements at the specified coordinates are replaced by the update values. Ensure the coordinate tuples match the rank of the original array. Handle duplicate coordinates by applying the last specified update."
    },
    {
        "instruction": "Develop a function that takes a square 2D numerical array (matrix) of size `n x n`. It should return a *new* matrix where the main diagonal elements are replaced by the sequence 0, 1, 2, ..., n-1. All other elements should remain unchanged."
    },
    {
        "instruction": "Implement a function that updates elements in a 1D numerical array based on provided indices and update values using a 'max' operation. It accepts the initial array, a 1D array of indices, and a 1D array of update values (same size as indices). For each index `i` and corresponding update value `v`, the element `array[indices[i]]` should be updated to `max(array[indices[i]], v)`. Return the modified array."
    },
    {
        "instruction": "Develop a function that performs a scatter-minimum update on rows of a 2D array. It takes a 2D numerical array `operand` (shape M, N), a 1D integer array `scatter_indices` (shape K), and a 2D numerical array `updates` (shape K, N). Return a *new* array based on `operand` where the row `operand[scatter_indices[i]]` is updated by taking the element-wise minimum with the row `updates[i]`. Handle duplicate row indices correctly by applying the minimum rule across all relevant updates for that row."
    },
    {
        "instruction": "Implement a function that computes the element-wise remainder of division for two input numerical arrays, `a` and `b`. The function must support standard broadcasting rules, allowing, for example, `a` of shape (M, N) and `b` of shape (1, N) to produce an output of shape (M, N). Assume `b` contains no zeros."
    },
    {
        "instruction": "Implement a function that performs a generalized dot product between two multi-dimensional numerical arrays, `a` and `b`. It should take the two arrays and configuration specifying which dimensions to contract and which are batch dimensions. Return the resulting numerical array."
    },
    {
        "instruction": "Create a function that performs a generalized matrix multiplication on two 3D numerical arrays, `A` of shape `(Batch, M, K)` and `B` of shape `(Batch, N, K)`. The function should contract along the last dimension (`K`) for both arrays and treat the first dimension (`Batch`) as a batch dimension. The output should be a 3D array of shape `(Batch, M, N)`."
    },
    {
        "instruction": "Write a function `generate_random_tensor(shape)` that returns a numerical array of the specified `shape` filled with random floats uniformly distributed between -1.0 and 1.0."
    },
    {
        "instruction": "Implement a function that performs batched matrix multiplication according to the pattern `BMK, BNK -> BMN`. It takes two 3D numerical arrays, A of shape (B, M, K) and B of shape (B, N, K), and returns a 3D array C of shape (B, M, N) where `C[i, m, n] = sum(A[i, m, k] * B[i, n, k] for k in range(K))`."
    },
    {
        "instruction": "Implement a function that performs batch matrix multiplication. It should accept two 3D numerical arrays, A with shape (Batch, M, K) and B with shape (Batch, K, N), and return a 3D array C with shape (Batch, M, N), where C[i] is the matrix product of A[i] and B[i]."
    },
    {
        "instruction": "Develop a function that takes a large text block (string) and a regular expression pattern string. It should return `True` if the pattern is found anywhere within the text, treating the text as a single block (meaning '.' should match newlines), and `False` otherwise."
    },
    {
        "instruction": "Create a function that computes the sum of elements in a provided list of numbers."
    },
    {
        "instruction": "Develop a function to check if a scalar `val` and a 1D array `vec` form an approximate eigenvalue-eigenvector pair for a square 2D array `matrix`. Compute `matrix @ vec` and `val * vec`. Return `True` if the normalized difference between these resulting vectors (e.g., using L2 norm) is below a small tolerance, `False` otherwise. Handle complex numbers appropriately."
    },
    {
        "instruction": "Write a function that calculates the maximum absolute row sum for a 2D numerical array (matrix). This involves summing the absolute values of elements in each row and finding the maximum among these sums."
    },
    {
        "instruction": "Implement a function that computes the Manhattan (L1) norm for a non-empty 1D numerical array (vector). The input is guaranteed to have at least one element."
    },
    {
        "instruction": "Write a function that accepts three 2D numerical arrays (A, Q, R), potentially containing complex numbers. Calculate the matrix product P = Q * R. Return a single scalar value representing the Frobenius norm of the difference matrix (A - P)."
    },
    {
        "instruction": "Develop a function to determine if a given square 2D numerical array (matrix) is upper triangular. An upper triangular matrix has all elements below the main diagonal equal to zero. Return `True` if it is, `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes a square matrix (potentially complex) as input and verifies if it is the identity matrix. Return `True` if it is, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a 3D numerical array with shape (B, M, N) as input. It should return a new 3D numerical array filled entirely with zeros, having the shape (B, M, M)."
    },
    {
        "instruction": "Create a function that reconstructs a matrix from its singular value decomposition components. It accepts three numerical arrays: U (left singular vectors, shape M x K), S (singular values, 1D array of size K), and Vh (conjugate transpose of right singular vectors, shape K x N). Return the reconstructed matrix of shape M x N. Ensure correct handling of the 1D singular value array S during reconstruction (e.g., by forming a diagonal matrix)."
    },
    {
        "instruction": "Implement a function to verify the right eigenvector equation for a single eigenvalue/eigenvector pair. Inputs: a square matrix `A` (N,N), a scalar eigenvalue `w`, and a 1D array eigenvector `v` (N,). Output: Boolean indicating if the norm of the difference vector `(A @ v) - (w * v)` is below a small tolerance."
    },
    {
        "instruction": "Write a function that applies a given matrix operation function (`op`) independently to each matrix within a batch of matrices. The input is a 3D array representing the batch (shape `B, N, N`) and the function `op` which takes a single `N x N` matrix and returns some result. The function should return a list or array containing the results of applying `op` to each matrix in the batch. Inputs: `batch_matrices` (3D array), `op` (function). Output: List or array of results."
    },
    {
        "instruction": "Implement a function that verifies the relationship `Ax = wx` for a square matrix A, a vector x, and a scalar w. It should compute the matrix-vector product `Ax` and the scaled vector `wx`, then return `True` if the norm of the difference `Ax - wx` is below a given tolerance relative to the norm of A, `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a positive integer `k` and returns a `k x k` identity matrix (a 2D numerical array with 1.0 on the main diagonal and 0.0 elsewhere)."
    },
    {
        "instruction": "Develop a function that scales the columns of a matrix by the elements of a vector. It takes a 1D numerical array W (size N) and a 2D numerical array V (size N x N). It returns a new N x N matrix where the j-th column of the output is the j-th column of V multiplied by the j-th element of W."
    },
    {
        "instruction": "Write a function that takes a square 2D numerical array (matrix) and returns a symmetric matrix by adding the input matrix to its transpose. Input and output are square matrices of the same size and data type."
    },
    {
        "instruction": "Implement a function that takes a square 2D numerical array (matrix) `A`, a 2D numerical array `V` (where columns represent vectors), and a 1D numerical array `W` (representing scalar values). Verify if multiplying `A` by `V` yields a result close to multiplying each column of `V` by the corresponding scalar in `W`. Return `True` if the overall difference (measured by a suitable norm) is below a tolerance proportional to the overall magnitude (norm) of `A`, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a positive integer `n` and returns an `n x n` identity matrix containing floating-point numbers."
    },
    {
        "instruction": "Write a function that generates a 3D numerical array representing a batch of `B` square matrices, each of size `N x N`. The function should accept `B`, `N`, and a specification for the data type (e.g., real or complex floating-point) and return the initialized 3D array (e.g., filled with zeros or random values)."
    },
    {
        "instruction": "Create a function that takes one parameter. If this parameter is specifically the string 'inf', raise a `ValueError`. Otherwise, the function should complete without error (e.g., return `None`)."
    },
    {
        "instruction": "Write a function that generates a 3D numerical array representing a batch of `B` matrices, each of size `M x N`. The function should take `B`, `M`, and `N` as input and return the 3D array filled with random floating-point numbers."
    },
    {
        "instruction": "Design a function that takes two square N x N numerical matrices, `A` and `E`, and a boolean flag. If the flag is true, it returns *two* N x N matrices (representing a primary matrix result derived from `A` and a secondary matrix result derived from `A` and `E`). If the flag is false, it returns only the secondary matrix result."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array (matrix) and a positive target scalar value `t_norm`. Scale the input matrix so that its L1 norm equals `t_norm`. Return the scaled matrix. Handle potential division by zero if the input matrix L1 norm is zero (e.g., return the original matrix)."
    },
    {
        "instruction": "Develop a function that extracts either the lower or upper triangle of a square 2D numerical array. The function should take the matrix and a boolean flag indicating whether to extract the lower triangle. Return a new matrix where elements not in the specified triangle (including the diagonal) are set to zero."
    },
    {
        "instruction": "Develop a function to compute the condition number of a square 2D numerical array (matrix) with respect to the infinity norm. This is calculated as the product of the infinity norm of the matrix and the infinity norm of its inverse matrix. Handle potential non-invertibility."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `A` (shape M x N), potentially containing complex numbers, and returns a square matrix `H` (shape M x M) by computing the product of `A` and its conjugate transpose (`A @ A.conj().T`). This resulting matrix `H` will be Hermitian positive-semidefinite."
    },
    {
        "instruction": "Implement a function that reshapes a tensor `T`. Given `T` with shape `S1 + S2` (where `S1` and `S2` are shape tuples), reshape it into a 2D matrix where the first dimension aggregates axes from `S1` and the second aggregates axes from `S2`. Return the reshaped matrix."
    },
    {
        "instruction": "Write a function `are_close(val1, val2, rel_tol, abs_tol)` that checks if two numerical values (`val1`, `val2`) are close, considering both relative tolerance (`rel_tol`) and absolute tolerance (`abs_tol`). Return `True` if the absolute difference is within the combined tolerance, `False` otherwise. Handle potential complex number inputs by checking the magnitude of the difference."
    },
    {
        "instruction": "Develop a function that takes a square `N x N` numerical matrix and a 1D array (purportedly containing its eigenvalues). Verify if the sum of the elements in the 1D array is approximately equal to the trace (sum of diagonal elements) of the matrix, within a specified tolerance. Return `True` if they match, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix), potentially containing complex numbers, and returns its conjugate transpose (Hermitian transpose). An input shape (M, N) should result in an output shape (N, M)."
    },
    {
        "instruction": "Implement a function to compute the rank of a 2D numerical array (matrix) containing real floating-point numbers. The rank represents the maximum number of linearly independent rows or columns. The function should accept a tolerance value to determine effective non-zero elements during rank calculation."
    },
    {
        "instruction": "Write a function that checks if a given square 2D numerical array is lower triangular (all elements above the main diagonal are zero)."
    },
    {
        "instruction": "Write a function that takes an integer N and a data type specification (e.g., float, complex) and returns a square 2D numerical array (matrix) of shape (N, N) representing the identity matrix (1s on the main diagonal, 0s elsewhere) of the specified data type."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) and a 1D integer array representing a column permutation. Return a new matrix where the columns of the input matrix are rearranged according to the permutation array."
    },
    {
        "instruction": "Implement a function that takes a square 2D numerical array (matrix A, potentially complex) and returns two 2D arrays of the same shape and type: an upper Hessenberg matrix H and a unitary matrix Q, such that A is unitarily similar to H via Q (i.e., `A` is approximately equal to `Q @ H @ Q.conj().T`)."
    },
    {
        "instruction": "Develop a function that takes a square 2D numerical array (assumed to be symmetric or Hermitian) and a boolean flag `process_lower_triangle`. Based on the flag, it should process the relevant triangle (lower or upper) to compute and return two 1D arrays: the diagonal elements and the first off-diagonal elements (sub-diagonal if `process_lower_triangle` is true, super-diagonal otherwise) of its equivalent tridiagonal matrix representation."
    },
    {
        "instruction": "Create a higher-order function named `apply_elementwise_with_fixed_args`. It should accept three arguments: an operation function `op`, a tuple `fixed_args` containing arguments that should not be iterated over, and a 1D numerical array `element_arg`. The `op` function expects arguments in the order `(*fixed_args, element)`. Your function should iterate through `element_arg`, calling `op` for each element while passing `fixed_args` and the current element. Return a new 1D numerical array with the results."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array `data` and a string `config`. Apply a simple transformation to each element of `data` based on the `config` string (e.g., if `config` is 'identity', return the element unchanged). Ensure the transformation treats each element as a scalar. Return a new 1D array of the same size with the transformed elements."
    },
    {
        "instruction": "Create a higher-order function `check_return_type`. It should take a function `func` and a type `expected_type` as input. It should return a *new* function that, when called, executes `func` and raises a `TypeError` if the return value of `func` is not an instance of `expected_type`. Otherwise, it returns the value."
    },
    {
        "instruction": "Create a function that accepts a variable number of arguments. The function should return `True` if exactly two arguments were passed, and `False` otherwise."
    },
    {
        "instruction": "Write a function that checks if two matrices, given as 2D numerical arrays of shapes (N, M) and (M, K), are compatible for standard matrix multiplication. Return `True` if compatible, `False` otherwise."
    },
    {
        "instruction": "Create a function that generates and returns a 2D numerical array (matrix) filled entirely with zeros, given the desired number of rows and columns as input."
    },
    {
        "instruction": "Write a function that accepts a single numerical value `x` and returns a tuple containing two elements, both identical to `x`."
    },
    {
        "instruction": "Write a higher-order function called `create_optional_operator`. This function accepts another function `binary_op` which takes two numbers and returns a number (e.g., addition, multiplication). `create_optional_operator` should return a *new* function. This new function takes two arguments: `arr1` (a numerical array) and `arg2` (either a \"missing\" value like `None` or a numerical array compatible with `arr1`). The returned function should apply `binary_op` element-wise if `arg2` is an array, and return `arr1` unchanged if `arg2` is missing."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays of identical length as input and returns a new 1D array where each element is the sum of the elements at the corresponding positions in the input arrays."
    },
    {
        "instruction": "Implement a function that takes two scalar numerical inputs (0-dimensional) and returns their sum, also as a scalar."
    },
    {
        "instruction": "Develop a function that takes a 1D numerical array `bases` and a numerical scalar `exponent`. Return a new 1D array where each element is the corresponding element from `bases` raised to the power of `exponent`."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication on two compatible 2D numerical arrays. Input: `A` (shape N x M), `B` (shape M x K). Output: A new 2D array `C` (shape N x K) representing the product of A and B."
    },
    {
        "instruction": "Write a function that performs standard matrix-vector multiplication. It should accept a 2D numerical array (matrix) with shape (N, M) and a 1D numerical array (vector) with shape (M,) and return a 1D array (vector) of shape (N,)."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array A of shape (N, M) and a 1D numerical array B of shape (M,). It should return a 1D array C of shape (N,) where each element C[i] is the dot product of the i-th row of A (A[i, :]) and B."
    },
    {
        "instruction": "Implement a function that calculates the mean along the last axis of an N-dimensional numerical array. Input: N-D array, shape (d1, d2, ..., dn). Output: (N-1)-D array, shape (d1, d2, ..., d(n-1)). Handle the case where the input is 1D (shape (n,)), returning a single scalar value (shape ())."
    },
    {
        "instruction": "Write a function that takes a tuple representing the shape of an input array (e.g., `()`, `(3,)`, `(4, 5)`) and returns the shape of the output array after applying an operation that appends a new dimension of size 2 to the end (e.g., `()` -> `(2,)`, `(3,)` -> `(3, 2)`, `(4, 5)` -> `(4, 5, 2)`)."
    },
    {
        "instruction": "Write a function that accepts exactly two arguments. If called with a different number of arguments, it should raise a specific error indicating 'wrong number of positional arguments'. Otherwise, it can simply return True."
    },
    {
        "instruction": "Write a function that accepts a single argument (e.g., a number or string). The function should print this argument to standard output, prefixed with \"Data: \" and followed by a newline character."
    },
    {
        "instruction": "Implement a function that takes an object and a format string. The format string contains placeholders like `{obj_repr}` and `{obj_type}`. The function should return a formatted string substituting the object's standard string representation and its type name into the respective placeholders."
    },
    {
        "instruction": "Create a function that accepts a string template containing exactly one named placeholder (e.g., 'Result: {value}') and a corresponding value. The function should print the formatted string to standard output with the placeholder replaced by the provided value, ensuring a newline is added at the end."
    },
    {
        "instruction": "Design a function that accepts an arbitrary number of keyword arguments (label=value pairs). The function should generate and return a single multi-line string where each line corresponds to one keyword argument, formatted as \"label: value\\n\". The order of lines in the output string should reflect the order of the keyword arguments provided."
    },
    {
        "instruction": "Develop a function that takes two arguments: a function `func` (that prints to stdout) and a string `expected_output`. The function should execute `func`, capture its standard output, and return `True` if the captured output is identical to `expected_output`, otherwise return `False`."
    },
    {
        "instruction": "Develop a function that simulates capturing standard output. It should accept another function (which is guaranteed to perform printing) and any necessary arguments for it. The capturing function should execute the provided function with its arguments, capture all text it prints to standard output, and return this captured text as a single string, including any newline characters."
    },
    {
        "instruction": "Implement a function that receives two numerical arguments. Inside the function, print the first argument to standard output using the format 'input_val: <value>\\n'. Then, return the sum of the two arguments."
    },
    {
        "instruction": "Write a function `verify_output(func_to_test, input_val, expected_output_string)`. This function should execute `func_to_test(input_val)`, capture its standard output, and return `True` if the captured output exactly matches `expected_output_string` (including any trailing newline), and `False` otherwise."
    },
    {
        "instruction": "Implement a function that receives two numerical values. It should first print the first value to standard output using the format \"Input value: {value}\", and then return the sum of the two values."
    },
    {
        "instruction": "Implement a function that takes two numerical inputs, `a` and `b`. It should print `a` twice (each on a new line, formatted as \"input_a: [value_of_a]\") and then return the sum `a + b`."
    },
    {
        "instruction": "Create a function that takes a label (string) and a value (can be number or string). The function should return a formatted string \"[label]: [value]\\n\" without printing it."
    },
    {
        "instruction": "Write a function that takes a string template (e.g., \"Data: {}\") and a dictionary, and returns a formatted string by inserting the dictionary's standard string representation into the template."
    },
    {
        "instruction": "Create a utility function that executes a provided function (which is expected to print to standard output) and captures all output printed during its execution. Return the captured output as a single string."
    },
    {
        "instruction": "Write a function that simulates capturing formatted output. It should take a 1D numerical array and formatting parameters (e.g., precision). The function should generate the formatted string representation internally and return this string, mimicking the result of printing with specific options."
    },
    {
        "instruction": "Develop a function that takes a 1D array as input. It should iterate through the array and produce a single output string. This string should contain a line for each element from the input array, formatted as 'Value encountered: <element>', with each line separated by a newline character."
    },
    {
        "instruction": "Implement a higher-order function that simulates applying an operation across aligned elements/slices of two arrays based on specified axes. It takes a processing function `op`, a 1D array `input1` (size N), and a 2D array `input2` (shape MxN). It should apply `op` to N pairs `(input1[i], column_i_of_input2)`, where `column_i_of_input2` is the i-th column of `input2` (as a 1D array of size M). The function should return a list containing the result of each call to `op`."
    },
    {
        "instruction": "Write a function that accepts a single numerical value, prints it to the console prefixed with \"Log: \", and then returns the original value."
    },
    {
        "instruction": "Simulate calling the forward and backward passes associated with an operation. Assume you have three functions available: `op(x)` (prints and returns x), `op_fwd(x)` (prints x, returns `(x, x)`), and `op_bwd(residual, sensitivity)` (prints both inputs, returns sensitivity). Write a script that first calls `op_fwd` with an initial value (e.g., 2.0) to get the result and residual. Then, using the residual obtained and a given sensitivity (e.g., 3.0), call `op_bwd`."
    },
    {
        "instruction": "Design a generic function that applies a transformation step-by-step over a sequence, maintaining an evolving state. The function should accept: 1) an 'update' function, 2) an initial 'state', and 3) an input 'sequence'. The 'update' function takes the current state and one item from the sequence, returning a tuple: (new_state, result_item). Your generic function must iterate through the sequence, call the 'update' function at each step, collect the 'result_item's into a list, and finally return the last 'new_state' and the list of collected results."
    },
    {
        "instruction": "Implement a function that receives an initial integer `value` and a positive integer `steps`. The function should loop `steps` times. In each iteration `k` (from 0 to `steps-1`), it must first print the current index using the format \"Index: {k}\", then print the current value using the format \"Data: {value}\", and finally update the value by adding 1 to it. Return the final value after the loop finishes."
    },
    {
        "instruction": "Implement a function that accepts an initial integer `start_value`. It should simulate a loop that continues as long as the current value is less than 10. In each iteration, it should first record the current value (e.g., add it to a list), and then increment the value by 1. The function should return the list of recorded values *before* they were incremented (e.g., if starting at 5, it should return `[5, 6, 7, 8, 9]`)."
    },
    {
        "instruction": "Write a function that takes a single number as input and returns that number incremented by 1."
    },
    {
        "instruction": "Implement a function that receives a single numerical input `x`. Based on whether `x` is less than 5, it should internally select one of two predefined paths but must always return the original input value `x` unmodified."
    },
    {
        "instruction": "Create a function that accepts a string label and a numerical value. It should print a formatted string to standard output exactly in the format 'label: value\\n' (including the newline) and then return the original value."
    },
    {
        "instruction": "Data Partitioning. Create a function `partition_list` that takes a list `items` and an integer `num_partitions`. It should divide the `items` list into `num_partitions` sublists of roughly equal size. Return a list containing these sublists. Handle edge cases like empty input list or `num_partitions` being zero or greater than the list length."
    },
    {
        "instruction": "Develop a function that accepts a 1D numerical array and a format string (e.g., 'Data: {}'). It should return a list of strings, where each string is generated by formatting the template with a corresponding element from the input array, maintaining the original order."
    },
    {
        "instruction": "Implement a utility function `capture_output` that accepts another function `target_func` and its arguments `*args`. `capture_output` should execute `target_func(*args)`, capture all standard output generated during its execution, and return this captured output as a single string. The `target_func`'s return value should be ignored."
    },
    {
        "instruction": "Develop a function that takes an initial 1D numerical array. It should iterate 5 times. In each iteration, it should first *print* the current state of the array (e.g., its elements) to the console, and then update the array by adding 1 to each element. The function doesn't need to return the array."
    },
    {
        "instruction": "Create a function that accepts a number and a threshold value. It should return `True` if the number is strictly less than the threshold, and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a format string with one positional placeholder (e.g., 'Value: {}') and a single argument (e.g., 123). Return the resulting formatted string."
    },
    {
        "instruction": "Develop a function `checked_format` that takes a format string, positional arguments, and keyword arguments. This function must validate that *all* provided positional and keyword arguments are consumed by the format string's placeholders. If any argument (positional or keyword) is unused, raise a specific error clearly indicating whether the unused argument was positional or keyword. If all arguments are used, return the formatted string."
    },
    {
        "instruction": "Create a function `attempt_call` that accepts another function `target_func` and its arguments. It should call `target_func` with the arguments. If any exception occurs during the call, `attempt_call` should return `False`, otherwise it should return `True`."
    },
    {
        "instruction": "Design a function `execute_step_with_hook(data_input, processing_step, pre_step_hook)`. This function must first execute `pre_step_hook(data_input)` to allow inspection or validation of the input. If the hook executes successfully, the function should then compute and return the result of `processing_step(data_input)`. Ensure the hook is always called before the processing step begins."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a callback function. This function should first compute the element-wise square of the input array. Then, it must invoke the callback function, providing it with some information derived from the *intermediate squared array* (e.g., the squared array or its sum). Finally, the function should calculate and return the sum of all elements in the squared array."
    },
    {
        "instruction": "Write a function that accepts a numerical array and an object describing its partitioning layout (e.g., dimension, number of partitions). The function must first use a provided validation mechanism (e.g., a callback or internal check) to confirm the layout specifies partitioning along the first dimension (index 0) into exactly 2 partitions. If validation succeeds, compute and return the element-wise square of the input array. If validation fails, signal an error (e.g., return None or raise an exception)."
    },
    {
        "instruction": "Implement a function that takes a numerical array and a callback function. The function should determine some property of the array (e.g., its dimensions or total size) and invoke the callback function, passing the determined property as an argument. The original array should be returned unmodified."
    },
    {
        "instruction": "Design a function `process_item` that accepts one argument. If the argument is a string, raise a `TypeError` including the message \"String type is not supported\". Otherwise, return the argument unchanged."
    },
    {
        "instruction": "Create a function that simulates an iterative process. It accepts an initial state (e.g., a tuple containing a counter and a data array) and a maximum count. In each step, increment the counter and apply a simple transformation to the data array (e.g., add 1 to all its elements). Additionally, accept a callback function that is invoked each step, receiving the current counter and maximum count. The loop terminates when the counter reaches the maximum count. Return the final state (counter, data array)."
    },
    {
        "instruction": "Create a function that takes a numerical scalar input `x`. Inside the function, calculate the sine of `x`. Return two values: the calculated sine value, and a *new* function (e.g., a lambda or closure) that takes one numerical argument `t` and prints the value of `t` to the console."
    },
    {
        "instruction": "Write a function `validate_scalar_dimension` that accepts one argument. It should return `True` if the argument is an integer scalar, and `False` otherwise. Specifically, it must return `False` if the input is a numerical array containing more than one element."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and returns a new 2D array of the exact same dimensions, filled entirely with zeros."
    },
    {
        "instruction": "Develop a function that takes an initial tuple `(data, counter)` and an integer limit. The function should repeatedly apply an update rule to `data` and increment `counter` by 1 as long as `counter` is less than the limit. Return the final `(data, counter)` tuple. (The specific update rule for `data` is not required for this task, focus on the loop structure and state update)."
    },
    {
        "instruction": "Develop a function that receives a 1D numerical array `x`. It should return a new 1D numerical array of the same size as `x`, where every element of the output array is equal to the number of elements in the input array `x`."
    },
    {
        "instruction": "Create a function that accepts a single 4-dimensional numerical array `X` (shape B1, B2, D1, D2). It should compute the matrix product of `X` with its own transpose (where the transpose swaps the last two dimensions). The result should be a 4-dimensional array of shape (B1, B2, D1, D1)."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and returns a new 2D array of the exact same dimensions, filled entirely with zeros."
    },
    {
        "instruction": "Develop a function that accepts a 1D numerical array. Perform the following sequence: 1. Pad the array with zeros to the nearest even length (if not already even). 2. Reshape the padded array into a 2-row matrix. 3. Add the constant value 2 to every element of this matrix. 4. Reshape the matrix back into a 1D array. 5. Truncate this 1D array back to the original length of the input array. 6. Return the element-wise sum of the original input array and the truncated array from step 5."
    },
    {
        "instruction": "Create a function that accepts three positive integers representing dimensions (D1, D2, D3). It should return a new 3D numerical array of shape (D1, D2, D3) filled entirely with floating-point zeros."
    },
    {
        "instruction": "Create a function that extracts a specific range of columns from a 2D numerical array. It should accept the array (shape M x N), a starting column index `start`, and an end column index `end` (exclusive), returning a new array of shape M x (end - start)."
    },
    {
        "instruction": "Create a function that accepts two 2D numerical arrays, `input1` and `input2`, assumed to have the same number of columns. The function should return a tuple where the first element is `input1` and the second element is the result of vertically concatenating `input1` and `input2`."
    },
    {
        "instruction": "Develop a function that takes an integer `size` and a floating-point `value` as input. It should return a new 1D numerical array of the specified `size`, where every element is initialized to the given `value`."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array. Verify two conditions based on its length `L`: Condition A: `L >= 2`, Condition B: `L <= 4`. If Condition A fails, raise a `ValueError` indicating 'Length must be at least 2'. If Condition B fails, raise a `ValueError` indicating 'Length must be at most 4'. If both conditions pass, attempt to return the slice containing elements at indices 1 and 2. If this slice is invalid for the actual length (e.g., length is 2), raise an `IndexError`."
    },
    {
        "instruction": "Create a function that accepts any 2D numerical array and returns a tuple containing its two dimensions (e.g., number of rows, number of columns)."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array as input. It should return `True` if the number of rows equals the number of columns, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts two positive integers representing the dimensions of a 2D structure. Return `True` if both dimensions satisfy a specific equality constraint (e.g., both must be equal to 4), and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and a slice object. It should return a new 1D array containing a copy of the elements specified by the slice from the input array."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array and returns its shape as a sequence (e.g., list or tuple) of integers."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays, `arr1` of shape (N,) and `arr2` of shape (1,). Return a new 1D array of shape (N,) where each element is the sum of the corresponding element in `arr1` and the single element in `arr2`."
    },
    {
        "instruction": "Write a function that accepts an arbitrarily nested structure (composed of lists, tuples, dictionaries) containing 1D numerical arrays of identical size as leaves. The function should return a single 1D array representing the element-wise sum of all leaf arrays found within the structure."
    },
    {
        "instruction": "Implement a function that takes a 3D numerical array X of fixed shape (e.g., (2, 3, 4)). It should compute the element-wise gradient of the operation Y = X * 2.0 with respect to X. Return the gradient array, ensuring it has the same shape as X."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array. It should return a *new* array that has the *exact same shape* as the input array but is filled entirely with the floating-point value 1.0."
    },
    {
        "instruction": "Implement a function that compares two 1D numerical arrays element-wise. It should return `True` if the arrays have the same length and all corresponding elements are approximately equal (within a small predefined tolerance), and `False` otherwise."
    },
    {
        "instruction": "Write a function that reshapes a given numerical array into a new array with exactly two dimensions (rows, columns) as specified, preserving the element order. The function should take the input array and the desired number of rows and columns. Ensure the total number of elements is conserved."
    },
    {
        "instruction": "Write a higher-order function `check_identity_preservation` that takes another function `func` and a 1D numerical input array `data`. The `check_identity_preservation` function should apply `func` to `data` and verify if the output is numerically identical to the original `data`. Return `True` if they are identical, `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array. It should return a new array where each element of the input array has the length (number of elements) of the input array added to it."
    },
    {
        "instruction": "Implement a function that checks if two multi-dimensional numerical arrays are element-wise 'close enough'. It should take two arrays and a tolerance value as input, returning `True` if the absolute difference between corresponding elements is always less than the tolerance, and `False` otherwise."
    },
    {
        "instruction": "Implement a function that accepts three numerical arrays. It should first verify that all three arrays have the exact same dimensions. If they do, return their element-wise sum. If not, raise a specific error indicating a shape mismatch."
    },
    {
        "instruction": "Implement a function `is_item_in_list(target_item, item_list)` where `target_item` is an integer or string identifier and `item_list` is a list of such items. Return `True` if `target_item` is strictly identical (same value and type) to at least one element in `item_list`. Return `False` if no identical item is found or if the list is empty."
    },
    {
        "instruction": "Write a function that creates a 2D numerical array (e.g., 3x3) filled with 32-bit floating-point numbers, initialized with arbitrary values. The function should take the dimensions as input."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and an integer `k`. Return the integer result of multiplying the size (number of elements) of the array by `k`."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array. Let N be its size. Return the value of 2 raised to the power of N."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array and returns a new array of the same shape where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Develop a function that validates a multi-dimensional concrete shape (e.g., (4, 8, 2)) against a symbolic specification involving multiple variables (e.g., 'w, w * h, h'). Solve for all variables (e.g., 'w', 'h'), ensuring each resolves to a consistent positive integer across all its occurrences. Return a dictionary of the solved variable values (e.g., {'w': 4, 'h': 2}) upon success, or indicate failure/inconsistency."
    },
    {
        "instruction": "Create a function that accepts a nested data structure (lists, tuples, dictionaries) containing numerical arrays, all guaranteed to have the same shape. Return a single numerical array representing the element-wise sum of all arrays found within the structure. Assume at least one array is present."
    },
    {
        "instruction": "Develop a function that determines if two arbitrarily nested data structures (composed of lists and dictionaries) have the exact same structure, ignoring the values or types of the leaf elements. It should return `True` if the nesting pattern, types of containers (list/dict), and dictionary keys match, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and returns a new 2D array of the same shape and data type, where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Create a function that takes a string representing a simple symbolic expression involving dimension variables (e.g., '2*d1 + 3*d2') and a dictionary mapping these variables (e.g., {'d1': 10, 'd2': 20}) to integer values. Return the integer result of evaluating the expression. Assume only non-negative integer coefficients, '+', and '*' operators."
    },
    {
        "instruction": "Write a function that takes a dictionary mapping symbolic dimension names (strings) to concrete integer sizes (e.g., `{'n': 10, 'm': 5}`) and a constraint string involving one of these names and a lower bound (e.g., `'n >= 8'`). Return `True` if the constraint holds for the given size, `False` otherwise. Handle simple `>=` constraints."
    },
    {
        "instruction": "Write a function that slices a 2D numerical array (matrix) along a specified dimension. Inputs are the matrix, the dimension index (e.g., 0 or 1), a start index, and a slice size. Return the resulting sub-matrix. Include validation to confirm the slice (start index + size) fits within the bounds of the specified dimension."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays, `list_x` and `list_y`. Assume their lengths `len_x` and `len_y` satisfy `min(len_x, len_y) == len_y - 2` and `len_y >= 2`. Return the element-wise sum of two slices: the first slice contains the first `len_y` elements of `list_x`, and the second slice contains elements of `list_y` starting from index 2."
    },
    {
        "instruction": "Create a function that accepts two numerical arrays: a 1D array `A` of length `N` and a 3D array `B` of shape `(1, M, N)`. Reshape `A` to `(1, 1, N)` and add it element-wise to `B` using broadcasting rules. Return the resulting 3D array of shape `(1, M, N)`."
    },
    {
        "instruction": "Create a function that takes four 1D numerical arrays: `vec1`, `vec2`, `vec3`, `vec4`. The function should ignore `vec1` and `vec3`, and return a new 1D array formed by concatenating `vec2` and `vec4` end-to-end."
    },
    {
        "instruction": "Develop a function that updates a portion of a 2D numerical array. It takes a target 2D array, a source 2D array, and starting indices (row, col). It should return a new array where the region in the target array starting at the indices is replaced by the source array."
    },
    {
        "instruction": "Write a function that takes a higher-dimensional numerical array representing a batch of 3D arrays (e.g., 4D array: Batch x Dim1 x Dim2 x Dim3). Reshape each 3D array within the batch into a 2D array with a fixed first dimension size of 2. Return a new array containing the batch of reshaped 2D arrays (e.g., 3D array: Batch x 2 x NewDim)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a tuple containing a fixed integer value (e.g., 10) and the original input array. Input: 1D array, Output: tuple (integer, 1D array)."
    },
    {
        "instruction": "Create a function that accepts two arguments: an integer `A` and a numerical scalar `B`. It also takes a boolean flag `swap_operands`. If `swap_operands` is true, calculate `B - A`; otherwise, calculate `A - B`. Return the numerical result."
    },
    {
        "instruction": "Implement a function that receives a multi-dimensional numerical array, determines its dimensions (shape), and returns the sum of these dimension sizes as an integer."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (e.g., containing floats). Calculate a value by summing: the array's size, an integer constant (e.g., 4), a float constant (e.g., 5.0), and the first element of the array. Return the final scalar value, ensuring correct type promotion throughout the calculation (int + int -> int, int + float -> float, float + array_element_type -> appropriate float type)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns `True` if the sum of its elements is greater than or equal to zero, and `False` otherwise."
    },
    {
        "instruction": "Write a function `check_dimension_consistency(shape1, shape2, axis1, axis2)` where `shape1` and `shape2` are tuples representing array dimensions, and `axis1`/`axis2` are either an integer axis index or `None`. Return `True` if the dimensions specified by `axis1` and `axis2` are consistent (i.e., if both are integers, the dimension sizes `shape1[axis1]` and `shape2[axis2]` must be equal), `False` otherwise. If only one axis is specified, consistency is trivially `True`."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array. It should first create a new array by adding 5 to each element of the input. Then, it should compute the element-wise cosine of this new array. Return the resulting array, which must have the same dimensions as the original input."
    },
    {
        "instruction": "Write a function that takes a numerical array and returns a new array where each element is the sine of the corresponding input element. The input and output arrays must have the same shape."
    },
    {
        "instruction": "Create a function that accepts three arguments: `start`, `stop`, and `step`, intended for sequence generation. Validate that all three arguments are of integer type. If any argument is not an integer, raise a `TypeError` with the message 'All arguments must be integers'. If all are integers, return True."
    },
    {
        "instruction": "Write a function that computes the element-wise sine for every number in an input numerical array, returning a new array of the same shape."
    },
    {
        "instruction": "Develop a function that validates a list of shape specifications. Each specification in the list is a tuple. The function should return `True` if *all* tuples in the list contain only positive integers or a special marker (e.g., -1), and `False` if *any* tuple contains invalid elements (like 0, other negative numbers, strings, etc.)."
    },
    {
        "instruction": "Write a function that takes an N-dimensional numerical array, an integer `axis`, an integer `start_index`, and an integer `slice_size`. Return a new N-dimensional array representing the slice along the specified `axis`. The function must check if the dimension size along the given `axis` is greater than or equal to `start_index + slice_size`."
    },
    {
        "instruction": "Create a function that accepts a concrete shape tuple (e.g., `(6, 10)`) and a polymorphic shape string containing potentially one variable, multiplication, and ellipsis (e.g., `'3 * b, ...'`). Determine if the concrete shape is compatible by solving for the variable. Return the solved positive integer value for the variable if compatible, otherwise raise a ValueError."
    },
    {
        "instruction": "Develop a function to solve for multiple dimension variables based on an actual shape and a symbolic specification. Input: a list of integers (shape) and a list of symbolic strings (spec, e.g., `['a+b', 'a-b']`). Find non-negative integer values for all variables (a, b) that satisfy the system. Return the variable values (e.g., as a dictionary) or indicate if no unique non-negative integer solution exists."
    },
    {
        "instruction": "Implement a function that takes a dictionary where keys are strings and values are 1D numerical arrays of identical shape. The function should return the element-wise sum of all arrays in the dictionary's values."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array `X` (shape M, N). It should first compute an intermediate 2D array `Y` by applying element-wise sine to `X` and then adding the sequence `[0.0, 1.0, ..., N-1.0]` (broadcasted appropriately). Finally, it should return the element-wise sum of the original array `X` and the intermediate array `Y`. The output must have the same shape (M, N) as the input."
    },
    {
        "instruction": "Create a function that extracts a fixed-size rectangular slice from a 2D numerical array. Inputs are the array, a tuple `(start_row, start_col)` for the top-left corner, and a tuple `(end_row, end_col)` for the bottom-right corner (exclusive). Return the extracted sub-array."
    },
    {
        "instruction": "Write a function that takes two arguments: a 1D numerical array (whose length can vary) and a function `unary_op` that operates on scalar numerical values. The function should compute an integer scalar equal to twice the length of the input array. It must then apply the `unary_op` to this scalar. The function should return a tuple containing two elements: the scalar result from `unary_op`, and the original 1D numerical array. Ensure the first element of the returned tuple is always a scalar, regardless of the input array's length."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and returns the size of its first dimension (number of rows)."
    },
    {
        "instruction": "Create a function that accepts a numerical array and an integer scalar. Return a new array of the same shape where the scalar has been added to every element of the input array."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array (matrix) with M rows and N columns. Calculate a result by adding the number of rows (M), the number of columns (N), a given floating-point constant, and the element at the first row, first column (index [0, 0]). The function should return a single floating-point value reflecting standard numerical type promotion."
    },
    {
        "instruction": "Develop a function that takes a list of 1D numerical arrays and another function `f`. It should apply `f` to each array in the list independently and return a new list containing the results."
    },
    {
        "instruction": "Write a function `check_prerequisites` that takes a list of required capabilities (strings, e.g., [\"network_access\", \"large_disk\"]) and a list of available system capabilities (strings). Return `True` if all required capabilities are present in the available list, `False` otherwise."
    },
    {
        "instruction": "Design a function that takes a multi-dimensional array of unsigned integer seeds. Using a provided deterministic `generate_state_from_seed` function, produce a corresponding 'random state handle' object for each seed. Return a new array containing these handles, maintaining the exact shape of the input seed array."
    },
    {
        "instruction": "Develop a function that takes an array and checks if all its elements are of a specific, predefined 'key' data type (you might need to simulate this type, e.g., using a simple class or tuple). Return `True` if all elements match the type, `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts an array and checks if all its elements are of a conceptual 'key' type (you can represent this 'key' type simply, e.g., as a specific tuple structure or small integer array). Return `True` if all elements conform, `False` otherwise."
    },
    {
        "instruction": "Implement a function that takes a 2D array of unsigned integers (shape M, N) and applies a deterministic transformation to each element based on its value and its row/column index (i, j). Return a new 2D array of the same shape (M, N) containing the transformed values. The transformation should be a simple arithmetic operation (e.g., `(value * 17 + i * 7 + j * 3) % 1000`)."
    },
    {
        "instruction": "Write a function that accepts initial configuration data (e.g., a 2D array of shape (M, N)). It should simulate generating structured data by first creating an intermediate 3D array (e.g., shape (K, M, N)) based on the input, and then rearranging this 3D array's dimensions (e.g., to shape (K, N, M) or (N, K, M)) before returning the final rearranged array."
    },
    {
        "instruction": "Write a function that creates a 3D numerical array of a specified shape (e.g., (D1, D2, D3)) and fills it with default integer values (e.g., zeros)."
    },
    {
        "instruction": "Create a function that verifies the content of the first data partition of a simulated partitioned array object. The function takes the object and the expected complete data (as a single numerical array) as input. Assume the object allows access to its first partition's data. The function should return `True` if the data in the first partition matches the provided expected complete data (allowing for small numerical differences), and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts two 2D numerical arrays of identical dimensions and returns a new 2D array containing their element-wise sum."
    },
    {
        "instruction": "Write a function that accepts a positive integer `S` and returns a 1D numerical array containing sequential floating-point numbers starting from 0.0 up to (but not including) `S`. For example, if `S` is 4, it should return `[0.0, 1.0, 2.0, 3.0]`."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays of the same shape and returns a new 2D array representing their element-wise sum."
    },
    {
        "instruction": "Create a function that accepts a numerical array and an integer `k`. It should split the array into `k` equal sub-arrays along its first dimension and return these sub-arrays (e.g., in a list). The size of the first dimension must be divisible by `k`."
    },
    {
        "instruction": "Develop a function that splits a 2D numerical array (matrix) into a specified number of equal-sized sub-arrays along its first dimension (rows). Assume the number of rows is divisible by the number of splits. Return a list containing the sub-arrays."
    },
    {
        "instruction": "Develop a function that creates a 2D numerical array of given dimensions (rows, columns) where every element is initialized to a specified constant numerical value."
    },
    {
        "instruction": "Implement a function `check_buffer_status` that takes two input arrays (`arr_a`, `arr_b`) and a string `donated_input_name` ('arr_a' or 'arr_b'). Simulate an operation (like addition) using these arrays. Return a dictionary indicating the status ('valid' or 'invalidated') for both `arr_a` and `arr_b` after the operation, where the buffer corresponding to `donated_input_name` should be marked 'invalidated' and the other 'valid'."
    },
    {
        "instruction": "Write a function that takes two numerical 2D arrays of the same shape and returns their element-wise sum. Ensure the output array has the same shape as the inputs."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays of the same shape and returns a new 2D array representing their element-wise sum."
    },
    {
        "instruction": "Implement a function `apply_to_all_leaves` that accepts a nested dictionary (tree structure) potentially containing numerical arrays at its leaves, and a callback function. It should traverse the tree and apply the callback function to each leaf array, returning a new tree of the same structure containing the results of the callback applications."
    },
    {
        "instruction": "Design a function that takes a 2D numerical array as input. It should perform an element-wise squaring operation on the input. The function must return a tuple containing two items: the resulting 2D array and a boolean status flag. This flag should indicate `True` if the operation *might* have invalidated the original input array data (meaning the caller should not reuse the original input array), and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array (matrix) `A` of shape M x N and returns the result of multiplying `A` by its transpose (`A @ A.T`). The output should have shape M x M."
    },
    {
        "instruction": "Implement a function configuration mechanism. Define a function `process_data(data)` that doubles each element in a numerical array `data`. Create a way to *configure* this function execution such that it's explicitly marked that the input `data` buffer is preferred for reuse to store the output, potentially overwriting the input."
    },
    {
        "instruction": "Develop a function that compares two 2D numerical arrays, `array1` and `array2`, for element-wise equality. It should return `True` if both arrays have the same shape and all corresponding elements are equal, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array. It should first add 1 to every element and then multiply every element by 2. Return the resulting 2D array, ensuring it has the same dimensions as the input."
    },
    {
        "instruction": "Create a function that accepts a total number of elements `N` and a desired 2D shape (e.g., `(rows, cols)` where `rows * cols == N`). Return a 2D numerical array of the specified shape containing integers from 0 to `N-1`."
    },
    {
        "instruction": "Write a function that creates a 2D numerical array of shape (M, N) filled with integers starting from 0 and increasing sequentially row by row."
    },
    {
        "instruction": "Implement a function that performs a deep copy of a nested data structure. The structure can contain lists, dictionaries, and numerical arrays. Ensure that modifying the returned copy (including elements within arrays) does not alter the original structure."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and returns a new 2D array of the same shape where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and returns the sum of all its elements as a single scalar value."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and returns a single scalar value representing the sum of all its elements."
    },
    {
        "instruction": "Write a function that takes a number `n` (integer or float) and a string `tag`. If `tag` equals `\"option_A\"`, return `n + 3`. Otherwise, return `n + 4`."
    },
    {
        "instruction": "Implement a function that takes a 2D array of non-negative integers (seeds). Return a new 2D array of the same shape, where each element is a simple data structure (like a tuple or a small dictionary) containing the original integer seed value. For example, input `5` could become `(5,)` or `{\"seed\": 5}`."
    },
    {
        "instruction": "Create a function that takes two numerical inputs and returns their sum."
    },
    {
        "instruction": "Write a function that takes a list of assignment strings (e.g., ['c:f32[1] = add a a']) and a result tuple string (e.g., '(c,)') and formats them into a multi-line string using a specific indented structure: 'let\\n  assignment1\\n  assignment2\\nin result_tuple'. Ensure two spaces for indentation before assignments."
    },
    {
        "instruction": "Write a function that produces a structured, multi-line string representation of a simple computation. Input includes an input variable name and type (e.g., 'data:float[1]'), an operation name (e.g., 'multiply'), a constant value and type (e.g., '1.0:float'), and an output variable name (e.g., 'result'). The output string should clearly delineate inputs, the operation performed using the input and constant, and the final output variable, using indentation for structure."
    },
    {
        "instruction": "Create a function that generates a string representing a single computational step. It should accept two input variable names (strings, e.g., 'a', 'b') and one output variable name (string, e.g., 'c'). It should return a formatted string like 'let c = multiply a b'."
    },
    {
        "instruction": "Write a function that takes a single floating-point number as input and returns a 1-element, 1-dimensional numerical array containing that number."
    },
    {
        "instruction": "Design a function that generates a string representation for a nested code structure. Input could be a dictionary describing the structure (e.g., {'outer_func': ['inner_func', 'inner_func']}). The function must produce a formatted string showing the nesting. If a name appears multiple times at the same nesting level (like 'inner_func'), append a unique suffix (e.g., '_1', '_2') to distinguish them in the output string."
    },
    {
        "instruction": "Develop a function that takes a floating-point numerator and a floating-point denominator (which could be +0.0 or -0.0). Return the resulting floating-point value, correctly handling the sign of infinity based on the signs of both the numerator and the zero denominator (e.g., positive/positive_zero -> +inf, negative/positive_zero -> -inf, positive/negative_zero -> -inf, negative/negative_zero -> +inf). Handle non-zero denominators by performing standard division."
    },
    {
        "instruction": "Create a function simulating a partitioned computation step. It accepts two 2D numerical arrays (A: M x K, B: K x N), an integer partition index `i`, and the total number of partitions `P` along the shared dimension K. The function should: 1. Select the `i`-th slice of A's columns (size K/P) and the `i`-th slice of B's rows (size K/P). 2. Compute the matrix product of these slices. Return the resulting partial product matrix (shape M x N). Assume K is perfectly divisible by P."
    },
    {
        "instruction": "Create a function that accepts two numerical data structures (e.g., 2D arrays) of the same shape and type, and returns a new data structure representing their element-wise sum."
    },
    {
        "instruction": "Implement a function that takes a function `f` as input. It should return a new function that accepts a single argument `x`, calls `f(x)`, and returns the result. The returned function should essentially behave identically to `f` for a single argument."
    },
    {
        "instruction": "Create a function that accepts the dimensions (number of rows M, number of columns N) of a 2D numerical array and returns the dimensions (rows, columns) of the matrix resulting from multiplying the original matrix by its transpose."
    },
    {
        "instruction": "Implement a function to verify if a smaller 2D numerical array matches a specific slice within a larger 2D numerical array. Inputs: the large array, the small array, and the slice definition (e.g., start/end row/col indices). Return `True` if the data matches, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `data` (shape M x N) and two integers `num_row_splits` and `num_col_splits` (assume M is divisible by `num_row_splits` and N by `num_col_splits`). The function should partition the input array into `num_row_splits * num_col_splits` non-overlapping sub-arrays of equal size. Return a list containing these sub-arrays in row-major block order."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array `data` and a representation of a multi-dimensional slice or index (e.g., a tuple of slice objects or integer indices). It should return the sub-array extracted from `data` using the provided slice/index."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar number. Return a new 2D array of the same dimensions where each element is the corresponding element of the input array multiplied by the scalar."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and a scalar number. Return a new 2D array where each element of the input array is multiplied by the scalar. Ensure the output array has the same shape as the input."
    },
    {
        "instruction": "Develop a function that takes a tuple representing the dimensions of an array (like `(8, 2)`) and returns a formatted string `\"[8, 2]\"`."
    },
    {
        "instruction": "Write a function that accepts dimensions (e.g., rows, columns) and corresponding axis names (e.g., ['dim1', 'dim2']) and returns a simple data structure (like a dictionary or object) representing this named grid configuration."
    },
    {
        "instruction": "Write a function `create_sequential_array(rows, cols)` that returns a 2D numerical array of shape `(rows, cols)` filled with sequential integers starting from 0."
    },
    {
        "instruction": "Write a function `process_located_data(func, located_data)` that takes a function `func` (which operates on numerical arrays) and `located_data` (the output from Task 3). It should apply `func` to the array within `located_data` and return a new structure containing the result, still associated with the original `location_id`."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array and a scalar value `s`. It should first apply the element-wise transformation `sin(value * 4 + 2)` to the input array. Then, calculate the sum of each row in the transformed array. Finally, multiply this 1D array of sums by the scalar `s`. Return the resulting 1D array."
    },
    {
        "instruction": "Implement a function that takes two multi-dimensional numerical arrays as input and returns `True` if they have the same shape and all corresponding elements are equal, and `False` otherwise."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array and returns the array unmodified. Verify the output is element-wise identical to the input."
    },
    {
        "instruction": "Design a structure to represent a 2D logical grid, storing its dimensions (e.g., rows, columns) and dimension names (e.g., 'axis_0', 'axis_1'). Implement a way to retrieve the total number of elements in the grid."
    },
    {
        "instruction": "Write a higher-order function that takes another function `op` and a list of input arrays. This function should first check if the distribution properties associated with each input array match the distribution requirements expected by `op`. If any input array has an incompatible distribution, raise a configuration error. If all inputs are compatible, apply `op` to the inputs and return the result(s)."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and a scalar number, and returns a new 1D array where the scalar has been added to each element of the input array."
    },
    {
        "instruction": "Write a function that creates a 2D numerical array of a given shape (e.g., 8x2) containing sequential integers starting from 0. Input is a tuple representing shape, output is the 2D array."
    },
    {
        "instruction": "Develop a function that takes a list of numbers (e.g., integers or floats) and returns a 1D numerical array containing those numbers in the same order."
    },
    {
        "instruction": "Develop a function that receives a single numerical input via a keyword argument (e.g., `number=5`) and returns that number."
    },
    {
        "instruction": "Develop a function that takes two arguments: a required string and an optional boolean argument defaulting to `True`. The function should return a tuple containing both the string and the boolean value used (either provided or default)."
    },
    {
        "instruction": "Write a function that simulates querying available processing units. It should return a list of unique string identifiers (e.g., 'UNIT_0', 'UNIT_1', 'UNIT_DEFAULT'). If only one unit is conceptually available, return a list with just one identifier."
    },
    {
        "instruction": "Define a function `process_inputs(val_a, val_b, val_c)` that simply returns its three arguments as a tuple `(val_a, val_b, val_c)`. Demonstrate calling this function successfully using: (a) only positional arguments, (b) only keyword arguments, and (c) a mix of positional and keyword arguments, ensuring the output tuple always reflects the intended inputs."
    },
    {
        "instruction": "Implement a function that computes the outer product of a 1D numerical array (vector) with itself. Input: a 1D array `v` of length N. Output: a 2D array (matrix) of shape N x N, where the element at index `(i, j)` is `v[i] * v[j]`."
    },
    {
        "instruction": "Write a function that calculates the dot product of a 1D numerical array (vector) with its transpose (effectively, the sum of squares of its elements). Input: one 1D array. Output: a single scalar number."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array (matrix X) as input. It should first compute an intermediate matrix Y by multiplying X with its transpose (Y = X @ X.T). Then, it should compute the final result Z by multiplying Y with its transpose (Z = Y @ Y.T). Return the final matrix Z."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array and a scalar value. It should first compute the sum of the array's elements along axis 1 (resulting in a 1D array), and then multiply each element of this 1D array by the given scalar value. Return the final 1D array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array (vector) of size N and returns a 2D array (matrix) of shape (1, N) containing the same elements."
    },
    {
        "instruction": "Implement a function `outer_op` that takes a 1D numerical array `x`. Inside `outer_op`, compute an intermediate 1D array `y` by performing an element-wise calculation involving `x` (e.g., `y = x + 5.0`). Define and return an *inner function* `inner_calc`. This `inner_calc` should accept a 1D array `z` (same size as `y`) and return the result of an element-wise operation between the captured `y` and `z` (e.g., `y * z`)."
    },
    {
        "instruction": "Write a function `setup_operation` that defines a constant 1D numerical array internally (e.g., `[0.0, 1.0, 2.0]`). It should then define and return a *new* function. This returned function should accept one argument, a 1D numerical array `v` (assume same size as the internal constant), and return the element-wise sum of `v` and the internally defined constant array."
    },
    {
        "instruction": "Develop a function that generates a 1D numerical array containing a sequence of floating-point numbers starting from 0.0 up to (but not including) a specified integer end value, with a step of 1.0."
    },
    {
        "instruction": "Write a function that takes a positive integer `N` and returns a list containing the sequence of integers starting from 0 up to, but not including, `N`."
    },
    {
        "instruction": "Create a context manager class `ExecutionScope`. When entering the scope (`__enter__`), it sets a global or instance flag indicating 'force execution'. When exiting (`__exit__`), it resets the flag. This flag can be checked by other functions to modify their behavior (e.g., bypass caching)."
    },
    {
        "instruction": "Write a function that takes a list of strings and checks if any string contains both the phrase 'input type signature' and a pattern indicating different placement hints (e.g., 'seen {...}, but now given {...(Auto: ...)}'). Return True if such a string is found, False otherwise."
    },
    {
        "instruction": "Create a function that takes an array's shape (e.g., (8, 4, 2, 2)) and a mapping rule (e.g., a list mapping dimension index to a 'partition group' identifier or None, like ['group1', None, None, None]). Assume a fixed partition factor for each group identifier (e.g., 'group1' means split by 2). Return a list indicating how many ways each dimension is split based on the rule (e.g., [2, 1, 1, 1])."
    },
    {
        "instruction": "Develop a function that takes a numerical array, an operation (passed as a function), and a specific 'output distribution marker'. Apply the operation to the array and return the result, ensuring the result is associated with the provided 'output distribution marker', irrespective of any marker associated with the input."
    },
    {
        "instruction": "Write a higher-order function that takes an element-wise operation function and partitioning specifications. This higher-order function should return a *new* function. The new function accepts *either* a raw numerical array *or* a pre-partitioned array object (from Task 3). If given a raw array, it should first associate the partitioning specifications with it. It then applies the original element-wise operation to the data (respecting the partitioning) and returns the result as a partitioned array object, ensuring the partitioning is correctly represented in the output."
    },
    {
        "instruction": "Develop a function that generates a 2D numerical array of shape (R, C) initialized with integers from 0 to R*C-1. The function should also accept a string identifier for a 'partition scheme'. Return the array and the provided partition scheme identifier as a pair."
    },
    {
        "instruction": "Write a function named `do_nothing` that accepts no parameters and has no explicit return statement. Call this function to ensure it executes without error."
    },
    {
        "instruction": "Design a function that orchestrates a two-step computation. It takes an initial 1D numerical array, two distinct resource identifiers (ID1, ID2), and an operation function. It should simulate: 1) associating the array with ID1, 2) applying the operation, 3) associating the resulting array with ID2, 4) applying the *same* operation again to the data associated with ID2. Return the final array."
    },
    {
        "instruction": "Design a function simulating a two-stage processing pipeline. Input: a 1D numerical array and definitions for two distinct processing groups ('group_A', 'group_B'). Steps: 1. Assign the array to 'group_A' with a 'distributed' strategy. 2. Double each element of the array. 3. Assign the resulting array to 'group_B' with a 'replicated' strategy. 4. Double each element again. Return the final 1D array."
    },
    {
        "instruction": "Implement a function that accepts a 2D numerical array of shape (M, N) and computes the matrix product of the array with its own transpose. The function should return the resulting 2D array of shape (M, M)."
    },
    {
        "instruction": "Implement a function that accepts a variable number of numerical arrays as input arguments (*args). The function should return a tuple where each element is the result of doubling every element in the corresponding input array."
    },
    {
        "instruction": "Design a system with a global configuration setting (e.g., 'Mode A' or 'Mode B'). Implement a function `generate_random(seed)` that produces a pseudo-random integer between 0 and 9 based on the `seed` and the *current* global setting. Also, provide a mechanism (like a context manager or setup/teardown functions) to temporarily change the global setting and ensure it reverts afterward. Demonstrate that calling `generate_random` with the same seed yields different results depending on the active global setting."
    },
    {
        "instruction": "Develop a function that receives a 2D numerical array `data_matrix` (shape `M x N`), a 1D numerical array `adjustment_vector` (shape `M`), and a *procedure* (a function taking no arguments and returning nothing). The function must first execute the procedure, then compute and return a new `M x N` array where the `adjustment_vector` has been added element-wise to each corresponding column of the `data_matrix` via broadcasting."
    },
    {
        "instruction": "Write a function that takes a single integer `n` and returns a new 1D numerical array of length `n` filled entirely with ones."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array as input and returns a new array containing the same values but ensuring the data type is 32-bit floating point."
    },
    {
        "instruction": "Implement a function that takes no arguments. Inside the function, create a specific 1D numerical array (e.g., `[0, 1, 2, 3, 4, 5, 6, 7]`) and associate a predefined 'layout hint' string (e.g., \"layout_A\") with it. Return the array conceptually marked with this hint."
    },
    {
        "instruction": "Implement a sequence of operations: 1. Define two distinct logical resource groups (e.g., `G1=[0,1]`, `G2=[2,3]`). 2. Create a 1D numerical array `A`. 3. Associate `A` with `G1`. 4. Apply a function `F` (which takes an array and an abstract layout template compatible with `G1` and `G2`) to `A`, getting result `B`. 5. Associate `B` with `G2`. 6. Apply the *same* function `F` (with the same abstract template) to `B`. Return the final result."
    },
    {
        "instruction": "Write a function that simulates applying a data layout preference. It accepts a 2D numerical array, a layout mapping (similar to Task 4's output), and a simple element-wise operation (like doubling). The function should perform the element-wise operation on the array and return both the resulting array and a confirmation (e.g., the input layout mapping itself) indicating the intended data layout for the output."
    },
    {
        "instruction": "Write a function `create_sequential_array(rows, cols)` that returns a 2D numerical array of shape (`rows`, `cols`) filled with integers starting from 0 and increasing sequentially row by row."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `X`. Consider the operation `Y = (X * 2) * (X * 2)`. Your function should compute and return a 2D array representing the element-wise rate of change (gradient) of the sum of all elements in `Y` with respect to the corresponding elements in the original input `X`. The output array must have the same dimensions as `X`."
    },
    {
        "instruction": "Develop a function that takes two 2D numerical arrays and their 'layout hints'. If the hints are compatible according to predefined rules for element-wise operations, the function should return a derived 'layout hint' for the output (e.g., inheriting the hint from the first input). If the input hints are incompatible, return `None`."
    },
    {
        "instruction": "Create a function that performs matrix multiplication. It should accept two 2D numerical arrays, A (shape M x K) and B (shape K x N), and return their product C (shape M x N)."
    },
    {
        "instruction": "Implement a function to perform matrix multiplication. It should accept two 2D numerical arrays, A of shape (M, K) and B of shape (K, N), and return their product, a 2D array of shape (M, N)."
    },
    {
        "instruction": "Create a function `multiply_matrices(matrix_a, matrix_b)` that performs matrix multiplication. It should accept two 2D numerical arrays. Before multiplying, validate that the inner dimensions are compatible (columns of `matrix_a` == rows of `matrix_b`). If incompatible, raise a ValueError with a descriptive message. Otherwise, return the resulting matrix."
    },
    {
        "instruction": "Simulate a sum reduction across two logical partitions. Write a function that takes two 2D numerical arrays (representing data split row-wise, e.g., top half and bottom half) and an axis index. Calculate the sum along the specified axis for each input array independently, then combine these intermediate results to produce the final array that represents the sum across the original combined data."
    },
    {
        "instruction": "Implement a function that receives a 2D numerical array. It should first compute the maximum value for each row (i.e., find the maximum along axis 1), resulting in a 1D array. Then, it must calculate and return the arithmetic mean of the elements in this 1D array."
    },
    {
        "instruction": "Develop a function that takes a list/tuple of dimension labels (e.g., `['batch', 'feature']`) corresponding to a 2D array, and an integer `axis` for expansion. Return the new list/tuple of labels after inserting a `None` label at the specified `axis`. Example: input `['x', 'y']` and `axis=0` returns `[None, 'x', 'y']`."
    },
    {
        "instruction": "Write a function that takes a list of numbers and a positive integer exponent `p`. Return a new list where each number from the input list is raised to the power `p`."
    },
    {
        "instruction": "Create a function that takes two instances of the structure defined in Task 3. It should return `True` if their 'processing group' identifiers are identical, and `False` otherwise. Input: two data structures (array + group_id). Output: boolean."
    },
    {
        "instruction": "Define a data structure that holds both a 2D numerical array and a 'distribution_tag' (e.g., a string). Create a function that accepts an instance of this structure, calculates the element-wise cosine of the contained array, verifies internally that the 'distribution_tag' hasn't changed, and returns a *new* instance of the structure containing the result array and the original 'distribution_tag'."
    },
    {
        "instruction": "Write a function that performs an element-wise data type conversion on a multi-dimensional numerical array. It takes an array of integers and a target floating-point type specification (e.g., 'float32'). It must return a *new* array of the same shape where each element is the input element cast to the specified floating-point type, preserving the original array's structure and element order."
    },
    {
        "instruction": "Develop a function that calculates the resulting shape of a multi-dimensional array after its axes are permuted. Input should be the original shape (as a tuple of integers) and the axis permutation (as a tuple of indices). Output should be the new shape (as a tuple of integers)."
    },
    {
        "instruction": "Create a function that takes a numerical array (any dimension) and a scalar value. Return a new array of the same shape where each element is the result of multiplying the corresponding input element by the scalar."
    },
    {
        "instruction": "Develop a function that computes the sum of all elements within a given numerical array (which can be multi-dimensional) and returns the single scalar result."
    },
    {
        "instruction": "Create a function that accepts two tuples representing shapes of multi-dimensional arrays. The function should return True if an array with the first shape can be legally reshaped into the second shape (i.e., they have the same total number of elements), and False otherwise."
    },
    {
        "instruction": "Implement a function that reshapes a multi-dimensional numerical array by 'merging' a sequence of adjacent dimensions into a single dimension. The function should accept the array, the starting index of the dimensions to merge, and the number of adjacent dimensions to merge. Example: Input shape (A, B, C, D), merge 2 dimensions starting at index 1 (B, C), output shape (A, B*C, D)."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays of the same shape and returns a new 2D boolean array. Each element in the output array should be true if the corresponding elements in the input arrays are equal, and false otherwise."
    },
    {
        "instruction": "Implement a function to perform matrix multiplication. It should accept two 2D numerical arrays, `A` (shape M x K) and `B` (shape K x N), and return their product, a 2D array of shape M x N."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array and its initial data layout description (e.g., 'partitioned_dim_0'). The function performs an element-wise multiplication by 2. It must return the resulting array and ensure its final data layout description exactly matches the initial one provided as input, regardless of any hypothetical intermediate layout changes."
    },
    {
        "instruction": "Write a function `execute_safely(action_function, data)` that calls `action_function(data)`. If `action_function` raises a `ValueError` during its execution, `execute_safely` should catch it and return `True`. If `action_function` completes without raising a `ValueError`, or raises any other type of error, `execute_safely` should return `False`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and two integers, M and N. It should return a new 2D numerical array with shape (M, N) formed by reshaping the input 1D array, assuming the total number of elements matches (length of 1D array equals M * N)."
    },
    {
        "instruction": "Write a function that takes two 2D numerical arrays of the same shape and returns a new 2D array where each element is the product of the corresponding elements from the input arrays."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication. It should take a 2D numerical array (matrix A) of shape (M, K) and a second 2D array (matrix B) of shape (K, N) and return the resulting 2D array (matrix C) of shape (M, N)."
    },
    {
        "instruction": "Write a function that extracts a rectangular sub-region from a 2D numerical array. It accepts the array, a tuple representing the starting (row, column) indices (inclusive), and a tuple representing the ending (row, column) indices (exclusive). Return the resulting 2D sub-array."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array containing N*M elements and reshapes it into a 2D array with dimensions N rows and M columns."
    },
    {
        "instruction": "Develop a function `generate_sequence(n)` that creates and returns a 1D numerical array containing the floating-point sequence 0.0, 1.0, 2.0, ..., (n-1).0. Handle the case where n is 0, returning an empty array."
    },
    {
        "instruction": "Write a function `can_concatenate_horizontally` that accepts two 2D numerical arrays. It should return `True` if the arrays have the same number of rows (allowing them to be joined side-by-side), and `False` otherwise."
    },
    {
        "instruction": "Develop a function that simulates a sequential scan operation. It accepts an initial `carry` state (e.g., a 2D array), an input sequence (a 3D array where the first dimension represents steps), and a `step_function`. The `step_function` takes the current `carry` and one slice (a 2D array) from the input sequence, returning an `updated_carry` and an `intermediate_output`. The main function should iterate through the sequence, applying the `step_function` at each step, and return the final `carry` and a new 3D array formed by stacking all `intermediate_output`s."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array (M rows, N columns). It should compute two results: (1) a 1D array of length N containing the indices of the maximum value in each column, and (2) a 1D array of length M containing the indices of the minimum value in each row. Return both 1D arrays."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array. Return a new 2D array of the same shape where each element is the sine of the corresponding element in the input array."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication. It should take two 2D numerical arrays, A (shape M x K) and B (shape K x N), and return their product C (shape M x N). Ensure it handles numerical types correctly."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array and performs a sequence of transformations: element-wise scaling by 2, element-wise sine, and matrix multiplication of the result with its transpose. The function should include internal checks (e.g., return boolean flags or use assertions) to verify that the array dimensions are correct after the scaling step and after the matrix multiplication step. Return the final computed matrix."
    },
    {
        "instruction": "Design a function that accepts a 2D numerical array and a string indicating its initial abstract data layout (e.g., 'LayoutXY'). Apply an element-wise operation (e.g., multiply by 2). Then, simulate a change to a new layout (e.g., 'LayoutY'). Apply another element-wise operation (e.g., sine). Finally, simulate a change to a third layout (e.g., 'LayoutNone'). Return the resulting 2D array and the final layout string ('LayoutNone')."
    },
    {
        "instruction": "Write a function that takes a bundled data structure (containing a 2D numerical array and its current layout specification, as created in Task 4) and a *new* target layout specification. The function should return an updated bundle where the array remains the same, but the associated layout specification is replaced with the new target layout."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array (matrix) and a scalar value. It should return a new matrix of the same dimensions where each element is the corresponding element of the input matrix multiplied by the scalar value."
    },
    {
        "instruction": "Write a function that divides a 2D numerical array (matrix) vertically into two equal sub-matrices. Assume the input matrix has an even number of rows. Input: Matrix `A` of shape (M, N), where M is even. Output: A list/tuple containing two matrices, each of shape (M/2, N)."
    },
    {
        "instruction": "Develop a function that accepts a 2D numerical array conceptually associated with a 'distribution context A'. The function should simulate executing within a different 'distribution context B'. Inside context B, it should modify the array's conceptual distribution property (e.g., remove specific dimension distribution). The function must return the array, ensuring its numerical values are identical to the input, but its associated conceptual context reflects context B."
    },
    {
        "instruction": "Create a function that accepts a positive integer `S` and returns a 1D numerical array (vector) of size `S` where all elements are equal to the floating-point value 1.0."
    },
    {
        "instruction": "Create a function that takes a 2D numerical array of shape (M, N) and returns its transpose, which will be a new 2D array with shape (N, M)."
    },
    {
        "instruction": "Create a function that takes a 3D numerical array and applies an element-wise multiplication by 2. The function should return the resulting array. Additionally, verify internally (e.g., using an assertion or check) that if the input array's first dimension was conceptually 'partitioned', the output array's first dimension also retains this 'partitioned' characteristic."
    },
    {
        "instruction": "Develop a function that takes a 2D numerical array as input. It should first apply an element-wise sine operation to the array, and then compute the matrix product of this transformed array with its transpose. Return the final square matrix."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and a tuple representing a target multi-dimensional shape. Return a new array with the elements rearranged into the specified shape. Validate that the total number of elements in the input array matches the product of the dimensions in the target shape, raising an error if they don't match."
    },
    {
        "instruction": "Develop a function that receives a multi-dimensional numerical array and returns its shape as a tuple of integers."
    },
    {
        "instruction": "Write a function that takes a 2D boolean array `cond` and two 2D numerical arrays `x` and `y` of the exact same shape. Return a new 2D array of the same shape where elements are taken from `x` if the corresponding element in `cond` is true, and from `y` otherwise."
    },
    {
        "instruction": "Write a function that calculates the total number of elements in a multi-dimensional array given its shape (a tuple of dimension sizes). For example, input (8, 32, 1, 16) should return 4096."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and applies the mathematical sine function element-wise to it. Return the resulting 2D array, preserving the original shape."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and returns a new 2D array of the same shape, where each element is the sine of the corresponding element in the input array."
    },
    {
        "instruction": "Implement a function that performs an indexed lookup. It accepts a 2D numerical data array (shape M x P) and a 2D integer index array (shape N x K). It should return a 3D numerical array (shape N x K x P) where `output[i, j, :]` corresponds to `data[indices[i, j], :]`. Assume valid indices."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array of shape (`rows`, `cols`) filled with consecutive floating-point numbers starting from 0.0."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array of 16 elements and reshapes it into a 2D array with dimensions 8x2."
    },
    {
        "instruction": "Develop a function that first applies an element-wise sine operation to a 2D numerical array (Input 1), then performs matrix multiplication between the result and a second 2D numerical array (Input 2), and finally adds a scalar value of 1 to every element of the multiplication result. Return the final 2D array."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array and a representation of a logical 2D grid (e.g., specified by its dimensions like `(rows, cols)`). Return an object or structure that logically associates the input array data with the specified grid configuration."
    },
    {
        "instruction": "Implement a function that calculates the sum of all elements in a given 2D numerical array (matrix). Return the total sum as a single scalar value."
    },
    {
        "instruction": "Write a function that computes the sensitivity of a calculation's total sum with respect to its input array. The calculation involves: taking an input 2D array, applying a transformation to each row independently (multiply row by 2, then square element-wise), and summing all elements of the transformed 2D array. The function should return a 2D array of the same shape as the input, where each element indicates how much the total sum changes for a small change in the corresponding input element."
    },
    {
        "instruction": "Develop a function that applies a specified binary operation (e.g., matrix multiplication) element-wise across slices of two 3D input arrays, `Arr1` and `Arr2`, based on specified axes. The function should take `Arr1` (shape D0, D1, D2), `Arr2` (shape E0, E1, E2), `axis1` (axis of `Arr1` to map over), `axis2` (axis of `Arr2` to map over), and the binary operation. Assume the sizes of the mapped axes (`Arr1.shape[axis1]` and `Arr2.shape[axis2]`) are equal (let's call it `B`). The function should iterate `B` times, applying the operation to the corresponding slices taken along `axis1` and `axis2`, and collect the results into an output array."
    },
    {
        "instruction": "Write a function that takes a single numerical value (scalar) and an integer `size`. It should return a new 1D numerical array of the specified `size` filled entirely with zeros."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and a scalar value. It should return a new 1D array of the same size, where each element is the result of multiplying the corresponding element from the input array by the scalar."
    },
    {
        "instruction": "Write a function that takes a positive integer `N` and returns a 1D numerical array containing the sequence of integers from 0 up to (but not including) `N`."
    },
    {
        "instruction": "Write a function that creates a 2D numerical array (matrix) of shape M x N, filling it with consecutive integers starting from 0, row by row."
    },
    {
        "instruction": "Implement a function that computes the cumulative sum of a 2D numerical array along its first dimension (rows). It should accept a 2D array and return a new 2D array of the same shape containing the cumulative sums row-wise. Example: Input `[[1, 2], [3, 4]]`, Output `[[1, 2], [4, 6]]`."
    },
    {
        "instruction": "Develop a function `update_layout` that takes an object potentially containing array data and an *old* layout specification, plus a *new* layout specification. It should return a new object containing the original array data associated *only* with the *new* layout specification, ensuring data integrity."
    },
    {
        "instruction": "Implement a function `reinterpret_array_bits(input_array, output_dtype_name)` that takes a numerical array and a string representing the desired output data type. Reinterpret the raw memory bits of the input array elements as the new data type. The total number of bits must remain constant, which might change the array's shape (calculated based on input/output bit widths). Return the new array with the specified output data type and adjusted shape. Assume input and output types have bit widths that allow for this conversion (e.g., 32-bit int to 32-bit float, or 32-bit int to 16-bit int resulting in twice as many elements of the original last dimension)."
    },
    {
        "instruction": "Implement a function `outer_processor(data_array)` that defines an inner function `inner_identity(item)` which simply returns `item`. The `outer_processor` should then call `inner_identity` with `data_array` and return the result."
    },
    {
        "instruction": "Implement a function that accepts a 1D numerical array and returns a new 1D array of the same size where each element is the corresponding input element plus one."
    },
    {
        "instruction": "Write a function that takes an integer `N` and returns a 1D numerical array of length `N` containing the sequence `0, 1, ..., N-1`."
    },
    {
        "instruction": "Write a function factory `create_array_processor` that accepts two processing functions (func_a, func_b) and a size threshold (integer). `create_array_processor` should return a *new* function. This returned function takes two 1D numerical arrays (`data`, `condition`). It applies `func_a` to `data` if `condition`'s element count exceeds the threshold, otherwise it applies `func_b` to `data`. Both `func_a` and `func_b` are assumed to take one 1D array and return one 1D array."
    },
    {
        "instruction": "Write a function that accepts three arguments (e.g., a list, a number, another number) and returns a tuple containing only the first and third arguments."
    },
    {
        "instruction": "Develop a function that takes four positive integers: `M`, `K`, `N`. It should first create two matrices: `A` of shape `(M, K)` filled sequentially with integers from 0 upwards, and `B` of shape `(K, N)` filled sequentially with integers starting from `M*K`. Then, it should compute and return the matrix product of `A` and `B`."
    },
    {
        "instruction": "Write a function that simulates aggregating results across partitions. It takes a list of numerical arrays, all having the exact same shape. The function should compute and return a single array of the same shape, where each element is the sum of the corresponding elements from all arrays in the input list."
    },
    {
        "instruction": "Write a function that takes a size (integer) and a device identifier (e.g., 'device0', 'device1'). It should return a 1D numerical array of the specified size, filled with zeros, conceptually located on the specified device."
    },
    {
        "instruction": "Write a function that simulates applying a data layout constraint. It takes a multi-dimensional numerical array (e.g., initialized with zeros), a logical grid configuration (from Task 2), and a partitioning specification (from Task 3). It should return an object or structure indicating that the array is now associated with the specified layout constraint (e.g., return the array along with a representation of its intended layout)."
    },
    {
        "instruction": "Implement a function that takes a desired array shape (tuple), a numerical data type string, and an axis mapping rule (as defined in Task 3). It should create a zero-filled array of the specified shape and type, and return both the array and the axis mapping rule it's intended to follow."
    },
    {
        "instruction": "Create a function that checks if a required set of resource identifiers (e.g., representing processing units needed for a data layout) is compatible with a single designated execution resource identifier. Return `True` if the set contains only the single designated identifier or is empty, `False` otherwise."
    },
    {
        "instruction": "Create a function that takes one argument of any type, ignores it completely, and returns the integer value `0`."
    },
    {
        "instruction": "Write a function that pads a 2D numerical array. It accepts the array, four non-negative integers for padding widths (`pad_top`, `pad_bottom`, `pad_left`, `pad_right`), a string indicating the mode ('wrap' or 'constant'), and an optional constant value (used only if mode is 'constant'). Implement the padding logic for both specified modes and return the padded array."
    },
    {
        "instruction": "Write a function that takes an integer `n` and a shape specification (e.g., `(1,)`) as input. It should return a list containing `n` separate numerical arrays, each matching the given shape and filled with zeros."
    },
    {
        "instruction": "Create a utility function `verify_error(action_callable, expected_error_type, expected_message_substring)` that executes `action_callable()`. It should catch any exception. Return `True` only if an exception of exactly `expected_error_type` is raised *and* its string representation contains the `expected_message_substring`. Return `False` in all other cases (no error, wrong error type, wrong message)."
    },
    {
        "instruction": "Implement a function `verify_data_placement` that takes an input 2D numerical array and a target distribution specification (e.g., \"split_columns_over_2_shards\"). The function should simulate placing the data according to the spec and return a boolean indicating if the data values are preserved and the resulting conceptual placement matches the specification."
    },
    {
        "instruction": "Write a function that takes an integer `n` and returns an `n x n` 2D numerical array initialized entirely with zeros."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array where each element is the square of the corresponding input element."
    },
    {
        "instruction": "Write a function that takes two positive integers, `len1` and `len2`. Inside the function, perform the following: a) Create a 1D array `arr1` with integers from 0 to `len1-1`. b) Create a 1D array `arr2` with integers from 0 to `len2-1`. c) Create a 1D array `arr3` by concatenating `arr1` and `arr2`. d) Return a tuple containing the maximum value found in `arr1`, the maximum value in `arr2`, and the maximum value in `arr3`."
    },
    {
        "instruction": "Design a function `execute_with_layout_check` that accepts a 1D numerical array, an 'input layout spec', and an 'output layout spec'. The function should perform an identity operation (return the array unchanged) but *only* if the 'input layout spec' and 'output layout spec' are identical. If they differ, it should raise an error or return a failure indicator."
    },
    {
        "instruction": "Write a function that accepts two 1D numerical arrays. It should return `True` if both arrays have the exact same elements in the same order, and `False` otherwise."
    },
    {
        "instruction": "Design a higher-order function `configure_execution` that takes a function `f` (operating on numerical arrays) and a processing unit identifier (string). It should return a *new* function `g`. When `g` is called with an array `x`, it should execute `f(x)` and conceptually ensure the result is associated *only* with the provided unit identifier. The function `g` should return the result of `f(x)`."
    },
    {
        "instruction": "Write a function that takes a 2D distributed numerical array `M` (shape X, Y) and computes the matrix product of `M` with its transpose (`M.T`). The function should allow specifying a desired distribution layout for the resulting square matrix (shape X, X)."
    },
    {
        "instruction": "Design a function that analyzes a sequence of abstract computational steps. Input is a list where each item represents a step and contains metadata, including the 'output_partitioning_spec' (a string) for the data after that step. The function should return the total count of these output partitioning specifications present in the sequence."
    },
    {
        "instruction": "Write a function that takes two 3D numerical arrays, `A` of shape `(X, Y, N)` and `B` of shape `(X, Y, M)`, and returns a new 3D array of shape `(X, Y, N+M)` by concatenating them along the last dimension."
    },
    {
        "instruction": "Develop a function `scan_sum_rows` that simulates processing a 2D array row-by-row with an accumulator. It takes a 2D numerical array and an initial scalar accumulator value (e.g., 0). For each row, it calculates the sum of that row and adds it to the accumulator. It returns the final accumulated scalar value after processing all rows."
    },
    {
        "instruction": "Develop a function that compares two data specification pairs for equality. Each pair consists of a specification string and a set of integer indices. The function takes two such pairs (e.g., `(spec1, set1)` and `(spec2, set2)`) and returns `True` if `spec1` equals `spec2` AND `set1` equals `set2`, otherwise returns `False`."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication. It should accept two 2D numerical arrays, A (shape M x N) and B (shape N x P), and return their product, a 2D array of shape M x P."
    },
    {
        "instruction": "Develop a function `distribute_data(data_list, device_ids)` that takes a list of data items and a list of device IDs. Assume `len(data_list)` equals `len(device_ids)`. Assign each data item `data_list[i]` to `device_ids[i]`. Return a structure (e.g., a dictionary) mapping each device ID to its assigned data item, preserving the original data types."
    },
    {
        "instruction": "Design a function that calculates sensitivity information for a scalar-valued function operating on two input multi-dimensional arrays. Given a function `f(X, Y)` that returns a scalar, and input arrays X and Y, compute two output arrays, `sens_X` and `sens_Y`. `sens_X` must have the exact same shape as X, and `sens_Y` must have the exact same shape as Y, representing how `f`'s output changes with respect to each element of X and Y."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size and returns a new 1D array representing their element-wise sum."
    },
    {
        "instruction": "Implement a memoization cache for a function that depends on both its arguments and an immutable 'configuration context' object. Create a cache mechanism that stores results keyed by a combination of the function's arguments and the context object. If the function is called with the same arguments and an equal context object already seen, return the cached result; otherwise, compute the result, store it associated with the arguments and context, and then return it."
    },
    {
        "instruction": "Implement a mechanism (e.g., a class or a higher-order function) that wraps a given computational function. This mechanism should store the results of function calls. If the wrapped function is called again with the *exact same* input arguments, the stored result should be returned directly, avoiding re-computation. Assume input arguments are suitable for equality comparison."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns the sum of all its elements as a single scalar value."
    },
    {
        "instruction": "Develop a function that takes a single 2D numerical array as input. Perform the following sequence: first, multiply every element by 2; second, compute the element-wise sine of the result; third, compute the matrix product of this new matrix and its transpose. Return the final 2D array."
    },
    {
        "instruction": "Write a function that creates a 2D numerical array of shape (M, N) filled with sequential floating-point numbers starting from 0.0."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size and returns a new 1D array representing their element-wise sum."
    },
    {
        "instruction": "Implement a function that modifies a specific part of a nested data structure. The function takes the structure, a sequence of keys/indices representing the path to an element (e.g., `[0, 'a']` to access the element via `structure[0]['a']`), and a modification function. It should apply the modification function to the element found at the specified path and return the modified structure. Assume paths are valid."
    },
    {
        "instruction": "Write a function that accepts two 2D numerical arrays of identical shapes. It should return a new 2D array, also of the same shape, where each element is the sum of the corresponding elements from the two input arrays."
    },
    {
        "instruction": "Write a function that accepts any number of positional arguments and returns the very first argument passed to it. If no arguments are provided, it should return `None`."
    },
    {
        "instruction": "Create a function wrapper that takes a target function and a list of its parameter names (strings) designated as 'reusable'. The wrapper should return a new function. When the new function is called, it should first identify the positional indices corresponding to the 'reusable' names in the target function's signature. It should then execute the target function with the provided arguments and return a tuple containing two elements: the target function's original result, and a tuple of the identified indices."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication on two input 2D numerical arrays (matrices). It should take two matrices, A and B, and return their product A @ B. Assume the shapes are compatible for multiplication."
    },
    {
        "instruction": "Develop a function `apply_binary_op(operation, args)` that expects `args` to be a sequence (list/tuple) of exactly two numerical arrays. If the structure is correct, it calls `operation(args[0], args[1])` and returns the result. If `args` does not have this specific structure (e.g., wrong number of elements, elements are not numerical arrays, or elements are nested within further lists), raise a `TypeError` with a message indicating the structure mismatch."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array and a string representing a data type (e.g., 'float32', 'int32'). Return a new 2D array containing the original data cast to the specified type."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication. It should accept two 2D numerical arrays, `A` (shape M x K) and `B` (shape K x N), and return their product, a 2D array of shape M x N. Handle incompatible shapes gracefully (e.g., raise an error or return an indicator)."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and two positive integers, `rows` and `cols`. Return a new 2D numerical array (matrix) by reshaping the input array into the specified `rows` and `cols`. Assume the input array has exactly `rows * cols` elements."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array (matrix) of shape (`rows`, `cols`) filled with sequential floating-point numbers starting from 0.0 (i.e., 0.0, 1.0, 2.0, ...)."
    },
    {
        "instruction": "Create a function that accepts two 2D numerical arrays (matrices) of the exact same shape. It should return a new matrix where each element is the sum of the corresponding elements from the two input matrices."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication. It should take two 2D numerical arrays (matrices), `A` (shape `M x N`) and `B` (shape `N x P`), and return their product, a new matrix of shape `M x P`. Assume the input shapes are always compatible."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array (matrix) of shape (`rows`, `cols`) filled with sequential integers starting from 0 (i.e., 0, 1, 2, ...)."
    },
    {
        "instruction": "Write a function that takes an integer `n` and returns a 1D numerical array containing the sequence of integers from 0 up to (but not including) `n`."
    },
    {
        "instruction": "Write a function that accepts an integer `n` and returns a 1D numerical array containing integers from 0 to `n-1`."
    },
    {
        "instruction": "Create a function that accepts two 2D numerical arrays (matrices) `A` and `B`. If matrix multiplication `A @ B` is valid according to their shapes, return the shape (dimensions) of the resulting matrix. Otherwise, indicate impossibility (e.g., return None)."
    },
    {
        "instruction": "Write a function that takes an integer `n` and returns a 1D numerical array containing integers from 0 to `n-1`."
    },
    {
        "instruction": "Create a function that accepts two multi-dimensional numerical arrays and returns `True` if they have identical shapes and all corresponding elements are numerically equal, `False` otherwise."
    },
    {
        "instruction": "Create a function that defines how a 2D array should be partitioned across a 2D logical grid. The function should accept grid dimension names (e.g., `('axis_x', 'axis_y')`) and return two distinct partitioning specifications, for example, `('axis_x', 'axis_y')` and `('axis_y', 'axis_x')`, representing different data distribution strategies."
    },
    {
        "instruction": "Write a function `create_sequential_array(shape)` that accepts a tuple representing dimensions (e.g., `(4, 2)`) and returns a 2D numerical array of this shape, filled with sequential integers starting from 0."
    },
    {
        "instruction": "Implement a function `identity_two_inputs(input1, input2)` that accepts two numerical arrays (`input1`, `input2`) and returns them as a tuple `(input1, input2)` without modification."
    },
    {
        "instruction": "Create a function that accepts an input name (string) and a resource group structure (containing a set of resource identifiers). Return a representation (e.g., a dictionary or tuple) associating the input name with its assigned resource group."
    },
    {
        "instruction": "Write a function `get_array_metadata(shape, dtype_name)` that takes a shape tuple (e.g., `(8, 4)`) and a string representing a data type (e.g., 'float32'). It should return a simple structure or object containing the provided shape and data type information."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array as input and returns a representation of its shape (e.g., a tuple of integers) and its data type (e.g., a string like 'float32')."
    },
    {
        "instruction": "Implement a function `specify_input_requirements(required_shape, required_placement_rule)` that returns a structure (e.g., dictionary) defining the necessary shape (tuple) and placement rule (string) for an input to a specific computational operation."
    },
    {
        "instruction": "Design a function `create_strict_processor(structure_template)` that takes a template dictionary structure. It should return a *new* function. This new function accepts a data dictionary. Inside the new function, it first checks if the input data dictionary's structure *exactly* matches the `structure_template`. If it matches, the function should return the data dictionary itself. If it doesn't match, it must raise a `TypeError`."
    },
    {
        "instruction": "Write a function that accepts a configuration integer `config` and a 2D numerical array `matrix`. If `config` equals 1, return the `matrix` unmodified. If `config` equals any other integer value, return a new matrix of the same shape where each element is the corresponding element of the input `matrix` incremented by one."
    },
    {
        "instruction": "Develop a function that receives a single 2D numerical array (matrix `X` of shape M x N). It should compute and return the product of the matrix with its own transpose. The resulting matrix will have shape M x M."
    },
    {
        "instruction": "Write a function that generates a sequence of floating-point numbers starting from 0.0 up to (but not including) a given integer N, with a step of 1.0. Return the sequence as a 1D numerical array or list."
    },
    {
        "instruction": "Implement a structure or class that bundles a numerical array with a string identifier representing its 'distribution type' (e.g., 'Named', 'Positional'). Write a function that takes an array and a string type, returning an instance of this structure."
    },
    {
        "instruction": "Write a function `apply_operation` that takes two arguments: `operation` (a function that performs an element-wise calculation on a 1D array) and `data` (a 1D numerical array). The function should execute `operation(data)` and return the resulting 1D array. Ensure the output array has the same length as the input array."
    },
    {
        "instruction": "Develop a function that analyzes a string representing simplified instructions (one per line). It should identify and return a list of 0-indexed line numbers where a specific instruction pattern (e.g., an 'operation' string followed immediately by an 'argument' string on the same line) occurs. Inputs: Multi-line string, target operation string, target argument string. Output: List of integer line numbers."
    },
    {
        "instruction": "Develop a function that compares two numerical arrays (which can be 1D or 2D). It should return `True` only if they have the exact same dimensions and all corresponding element values are equal, returning `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array of shape (M, N) and returns its transpose, which will have shape (N, M)."
    },
    {
        "instruction": "Create a function that takes a single positive integer `N` and returns a 1D numerical array containing the sequence of integers from 0 up to (but not including) `N`."
    },
    {
        "instruction": "Implement a function that determines the output metadata for a hypothetical 'concatenate' operation along the first axis. Inputs: metadata dictionaries for two 1D arrays (e.g., {'shape': (5,), 'dtype': 'int32'} and {'shape': (3,), 'dtype': 'int32'}). Output: a single metadata dictionary for the resulting concatenated array (e.g., {'shape': (8,), 'dtype': 'int32'}). Assume data types must match for concatenation."
    },
    {
        "instruction": "Create a function that takes a positive integer `N` and generates a 1D numerical array containing the sequence of integers from 0 up to (but not including) `N`."
    },
    {
        "instruction": "Develop a function that accepts two data bundles (as created in Task 2). It should return `True` if their location tags are identical, and `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and a scalar number `k`. It should return a new array of the same length where each element of the input array is multiplied by `k`."
    },
    {
        "instruction": "Implement a pre-check function for processing operations involving potentially abstract arrays. It takes a list of array definitions (some potentially abstract) and an optional target processing environment identifier (string). If any array definition is abstract, the environment identifier *must* be provided. The function should return `True` if this condition is met, otherwise raise a specific error (e.g., `ConfigurationError`)."
    },
    {
        "instruction": "Create a function that checks if a given 1D array has a specific length (e.g., 8) and contains only 32-bit integers. Return `True` if both conditions are met, `False` otherwise."
    },
    {
        "instruction": "Implement a function that simulates applying an element-wise operation (e.g., multiplication by 2) on a conceptually partitioned 2D array. Input: The original 2D array and a partitioning scheme description (like the output of Task 3). Output: A new 2D array containing the results of applying the operation element-wise to the original array."
    },
    {
        "instruction": "Create a function that accepts a multi-dimensional numerical array and a partitioning specification (represented as a sequence where each element corresponds to an array dimension and indicates either a partitioning dimension name (string) or 'unpartitioned' (None/null)). The function should return a data structure (e.g., dictionary) containing the array's shape and the provided partitioning specification."
    },
    {
        "instruction": "Design a data structure (like a dictionary or simple class) to represent a 2D logical grid, storing its dimensions' names (e.g., 'axis_A', 'axis_B') and their corresponding sizes (e.g., 4, 2)."
    },
    {
        "instruction": "Develop a function that takes a data structure definition (shape and type) and a resource grid definition. It should return a configuration object indicating that this data structure should be automatically partitioned across the specified resource grid during computation."
    },
    {
        "instruction": "Write a function `count_outputs` that takes one argument, which resulted from some computation. It should return the integer 1 if the result represents a single logical output (like a single array or value), even if that output has internal structure. Assume complex nested structures (lists/tuples of arrays) would represent multiple logical outputs and should not return 1."
    },
    {
        "instruction": "Write a function that accepts three scalar numerical inputs x, y, and z. It should return the result of the arithmetic operation 100*x + 10*y + z."
    },
    {
        "instruction": "Write a function `assign_context(value, context_id)` that associates a given value with a specific computational context identifier. Then, create another function `operate_on_associated(associated_value, other_value)` which performs addition, and demonstrate that the operation primarily uses the context associated with `associated_value`."
    },
    {
        "instruction": "Write a function that accepts a list of numerical values and returns their sum."
    },
    {
        "instruction": "Create a function `flexible_caller` that takes a target function `op` (which accepts arguments named 'x' and 'y'), two values `val1` and `val2`, and a string `call_method` which is either 'by_position' or 'by_name'. If `call_method` is 'by_position', call `op` positionally like `op(val1, val2)`. If `call_method` is 'by_name', call `op` using keyword arguments like `op(x=val1, y=val2)`. Return the result from `op`."
    },
    {
        "instruction": "Write a function that accepts a 2D numerical array and returns a new 2D array of the same shape where each element is doubled."
    },
    {
        "instruction": "Write a function that takes a numerical array and returns a new array of the same shape where each element is doubled."
    },
    {
        "instruction": "Write a function `scale_array(matrix, scalar)` that accepts a 2D numerical array `matrix` and a number `scalar`. It should return a *new* 2D array of the same dimensions where each element is the corresponding element of `matrix` multiplied by `scalar`."
    },
    {
        "instruction": "Develop a function wrapper `safe_caller(func, arg1, arg2)` that takes a two-argument function `func` and two arguments `arg1`, `arg2`. This wrapper assumes `arg1` might be modified by `func`. Before calling `func`, it must check if `arg1` and `arg2` refer to the exact same object. If they do, it should raise a specific error (e.g., ValueError). Otherwise, it should call `func(arg1, arg2)` and return the result."
    },
    {
        "instruction": "Implement a class `OperationTracker`. It should be initialized with a function `op` that takes two arguments. The class must provide:\n    *   A method `execute(arg1, arg2)`: This runs `op(arg1, arg2)`. It also increments an internal usage counter *only the first time* `execute` is called on this specific instance. It returns the result of `op`.\n    *   A method `get_usage_count()`: Returns the current value of the internal counter.\n    *   A method `reset()`: Resets the internal counter to 0 and allows the counter to be incremented again on the *next* call to `execute`."
    },
    {
        "instruction": "Create a context manager class `ListAppendMonitor`. Initialize it with a reference to a list. When entering the context, it records the list's current length. When exiting, it calculates and returns how many items were appended to the list *during* the execution of the `with` block."
    },
    {
        "instruction": "Implement a function that accepts two same-length 1D sequences: `data` (numerical) and `mask` (boolean). It should return a new sequence containing only the elements from `data` where the corresponding `mask` value is `False`."
    },
    {
        "instruction": "Implement a function that accepts two 1D numerical arrays of the same length and returns `True` if all corresponding elements are equal, and `False` otherwise."
    },
    {
        "instruction": "Create a function `process_and_execute` that takes another function `input_func` as an argument. It should return a new function `processed_func`. This `processed_func` must maintain access to any data captured by `input_func`, even if the variable holding `input_func` is later deleted. Calling `processed_func` should execute the logic of `input_func`."
    },
    {
        "instruction": "Define a Python class `EmptySlots` that explicitly uses `__slots__ = []` to indicate it should not have an instance dictionary. Write a function that takes an instance of this class and returns `True` if it was successfully created, `False` otherwise."
    },
    {
        "instruction": "Create a Python class named `UnhashableValue` such that attempting to get the hash of an instance (e.g., using `hash(instance)`) raises a `TypeError`."
    },
    {
        "instruction": "Design a function `dispatch_computation(primary_context, secondary_context, value)` that simulates dispatching parts of a computation. It takes two context identifiers and a numerical `value`. It should first check if `primary_context` and `secondary_context` represent incompatible contexts (e.g., are not equal). If incompatible, raise a `ValueError` stating \"Incompatible contexts for computation\". If compatible, it should simulate performing a simple computation assigned to the `secondary_context` (e.g., `value + 1`) and return the result."
    },
    {
        "instruction": "Develop a function that accepts exactly two keyword arguments, `key1` and `key2`. The function should ignore `key2` and return the value associated with `key1`."
    },
    {
        "instruction": "Implement a function `caller` that accepts another function `target_func` as an argument. `caller` should call `target_func` without any arguments (assuming `target_func` has default values for all its parameters) and return the result."
    },
    {
        "instruction": "Implement a function that accepts an initial 1D numerical array and applies a given transformation function (which takes and returns a 1D numerical array) to it repeatedly for a specified number of iterations (e.g., 1000). Return the final array after all iterations."
    },
    {
        "instruction": "Develop a function that attempts to apply a given single-input numerical function `f` to each element of an input array. If calling `f` with any element raises a `TypeError`, the function should catch this specific error and return the boolean value `False`. If the function `f` can be applied to all elements without a `TypeError`, return `True`."
    },
    {
        "instruction": "Define a simple enumeration representing distinct status codes (e.g., OK, ERROR, PENDING). Write a function that accepts a status code member and returns a predefined descriptive string for that code."
    },
    {
        "instruction": "Implement a function that accepts one argument and returns a string representing the name of its data type (e.g., 'int', 'bool', 'float')."
    },
    {
        "instruction": "Write a function that takes no arguments and returns a pre-defined scalar numerical constant (e.g., the result of applying the sine function to the number 1)."
    },
    {
        "instruction": "Develop a function that generates a 1D numerical array containing a sequence of floating-point numbers starting from 0.0 up to (but not including) a specified integer end value, with a step of 1.0."
    },
    {
        "instruction": "Develop a function that takes a single floating-point number as input and returns `True` if the number is `NaN` (Not a Number), and `False` otherwise."
    },
    {
        "instruction": "Implement a simple function `identity(x)` that takes any single argument `x` and returns it without modification."
    },
    {
        "instruction": "Design a function that takes a numerical container and a boolean flag `allow_extraction`. If `allow_extraction` is `True` and the container is 0-dimensional with one element, return the scalar value. Otherwise (if `allow_extraction` is `False` or the container is not valid for extraction), return a predefined status code (e.g., -1) without attempting extraction."
    },
    {
        "instruction": "Design a higher-order function that takes a function `f` and an integer `arg_index`. When called with arguments intended for `f`, it should return a tuple: (1) the result of calling `f` with those arguments, and (2) the gradient (derivative) of `f` with respect to the positional argument specified by `arg_index`, evaluated at the given arguments. Handle potential index errors if `arg_index` is out of bounds."
    },
    {
        "instruction": "Write a function that accepts two 1D numerical arrays. If they have the same length, return a new array representing their element-wise sum. If their lengths differ, raise a ValueError indicating the incompatible lengths."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array as input. This function should simulate modifying the array *in-place* by doubling the value of each element. The function should return nothing, but the input array object itself should reflect the changes after the function call."
    },
    {
        "instruction": "Implement a simplified simulation of buffer donation failure. Create functions `allocate(data)` -> `handle`, `process_and_consume(handle, operation)`, and `reallocate(handle, new_config)`. `process_and_consume` marks the handle as invalid after applying the operation. `reallocate` should check if the handle is valid before proceeding. Write a sequence that calls `allocate`, then `process_and_consume`, and finally `reallocate` using the original handle. Verify that the `reallocate` call detects the handle's invalid status and returns an error indicator (e.g., False or raises a custom error)."
    },
    {
        "instruction": "Write a function `get_first_output` that accepts another function `multi_output_func` and an input value `inp`. Assume `multi_output_func(inp)` returns a tuple or list. Your function should call `multi_output_func(inp)` and return only the first element of the result."
    },
    {
        "instruction": "Create a function that takes an object representing a 2D point (with numerical attributes `x` and `y`). The function should return a *new object* of the *exact same type* as the input, where the `x` attribute is the square of the input's `x`, and the `y` attribute is the square of the input's `y`."
    },
    {
        "instruction": "Create a function that calculates the Euclidean distance from the origin (0,0) for a point represented by an object having numerical attributes 'x' and 'y'. The function should return sqrt(x**2 + y**2)."
    },
    {
        "instruction": "Create a function that takes a shape tuple (e.g., `(2, 3, 4)`) as input. It should calculate and return the total number of elements represented by that shape (the product of the dimensions). An empty shape `()` should result in a size of 1."
    },
    {
        "instruction": "Implement a function that takes a function `op` (operating on a single element) and a list of elements. It should return a new list containing the results of applying `op` to each element in the input list."
    },
    {
        "instruction": "Write a function that accepts two numerical arrays of identical shapes. It should return a new array where each element is the sum of the corresponding elements from the input arrays."
    },
    {
        "instruction": "Implement a mechanism (e.g., a context manager or a decorator) to temporarily change a global verbosity setting (represented by strings like 'DEBUG', 'INFO', 'WARN') for the duration of a function call. Ensure the original setting is restored afterwards, even if the called function raises an error. Assume functions `get_verbosity()` and `set_verbosity(level)` exist."
    },
    {
        "instruction": "Implement two functions. `func_inner(a, b)` should perform the calculation `(2*a + b, 3)` and return the resulting tuple. `func_outer(x)` should take one number `x` and return the result of calling `func_inner` with `2` as the first argument and `x` as the second argument."
    },
    {
        "instruction": "Create a function `apply_n_times` that takes an initial numerical value, an update function, and an integer `n`. The update function accepts one numerical value and returns an updated numerical value. `apply_n_times` should call the update function `n` times, feeding the output of one call as the input to the next, starting with the initial value. Return the final value after `n` applications."
    },
    {
        "instruction": "Write a function that takes no arguments and returns a 1D numerical array of size 2, filled entirely with zeros."
    },
    {
        "instruction": "Write a function that accepts two arguments: a calculation function `func` (which takes no arguments and returns a number) and a numerical value `expected`. Your function should execute `func`, retrieve its numerical result, and return `True` if this result is equal to `expected`, otherwise return `False`."
    },
    {
        "instruction": "Create a Python class `MutationDetector` that acts as a context manager. It should be initialized with a list. When entering the context, it records the list's length. When exiting, if the list's length has changed, it should raise a `ValueError` with the message \"List mutated!\". Otherwise, it should exit cleanly."
    },
    {
        "instruction": "Write a function that takes a single argument and appends it to a predefined global list. The function should then return the argument unchanged."
    },
    {
        "instruction": "Implement a function `vectorize_scalar_func` that takes two arguments: a function `g` that accepts a single scalar and returns a single scalar, and a 1D numerical array `arr`. The function should return a new 1D array of the same size where each element is the result of applying `g` to the corresponding element in `arr`."
    },
    {
        "instruction": "Write a higher-order function called `map_list`. It takes two arguments: a function `f` and a list `L`. It should apply the function `f` to each element of the list `L` and return a new list containing the results in the corresponding order."
    },
    {
        "instruction": "Develop a function that processes a 1D numerical array element by element. For each number in the input array, it should treat that number as an initial 'state' and apply a simple single-step state update (like returning the state unchanged, similar to Task 2). The function should return a new 1D array containing the final state resulting from applying the single-step update to each corresponding input element."
    },
    {
        "instruction": "Write a function `outer_func` that accepts an integer `x`. Inside `outer_func`, define a nested function `inner_func` that accepts an integer `y` and returns `x * y`. `outer_func` should call `inner_func` with `y=5` and return the result."
    },
    {
        "instruction": "Create a class that acts as a container for a 1D numerical array. Implement methods or properties to allow users to retrieve the `shape` (as a tuple) and the data type of the contained array."
    },
    {
        "instruction": "Basic Wrapper Initialization: Write a function `create_wrapper(input_array)` that accepts a 2D numerical array and returns an instance of a simple wrapper class (assume `WrapperClass(data)`) initialized with that array."
    },
    {
        "instruction": "Write a function that accepts a single numerical argument but always returns the predefined integer value 1."
    },
    {
        "instruction": "Create a function that accepts a single numerical value and a string representing a target numerical data type (e.g., 'float32', 'int16'). Return the input value converted to the specified data type."
    },
    {
        "instruction": "Write a function `create_adder(amount)` that takes a number `amount` and returns a *new* function. This new function should accept a single number `x` and return the sum `x + amount`."
    },
    {
        "instruction": "Implement a simple memoization mechanism for a function that takes one hashable argument. It should store the result for a given input and return the stored result on subsequent calls with the same input, avoiding re-computation."
    },
    {
        "instruction": "Write a function that accepts a single numerical value and returns it unchanged."
    },
    {
        "instruction": "Develop a function that takes a 3D numerical array and a scalar value. Apply the operation of adding the scalar to every element of the 3D array. The function should return the resulting 3D array, ensuring its dimensions are identical to the input array's dimensions."
    },
    {
        "instruction": "Create a function `apply_transformation` that accepts two arguments: a function `transform_func` (which itself takes one float and returns one float) and a float `value`. The `apply_transformation` function should call `transform_func` with `value` and return the result."
    },
    {
        "instruction": "Write a higher-order function named `create_scaling_function`. This function should accept a single numerical value `scale_factor`. It must *return a new function*. This returned function should itself accept a single numerical input `v` and return the result `scale_factor * v`."
    },
    {
        "instruction": "Write a function `apply_linear_transpose`. It should accept two arguments: a function `f` representing a linear transformation `f(x) = a*x` (where `a` is some constant scalar factor embedded within `f`), and a numerical scalar value `y`. The function should compute the result of applying the linear transpose of `f` to `y`, and return this result wrapped in a single-element tuple. (Hint: If `f(x) = a*x`, its transpose applied to `y` yields `a*y`)."
    },
    {
        "instruction": "Implement a simple memoization wrapper for a function operating on numerical arrays. The wrapper should store results based on the shape of the input array. Include a counter to track how many times the original function (not the cache) is actually executed."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is multiplied by 2."
    },
    {
        "instruction": "Develop a function that takes a scalar number `x` and a dictionary `d` containing a single 1D numerical array under the key 'hi'. Perform an element-wise multiplication of `x` with the array `d['hi']` and return the resulting 1D numerical array."
    },
    {
        "instruction": "Implement a function that generates a single floating-point random number from a normal distribution, ensuring the value falls strictly between a given lower and upper bound. The function should accept a seed for reproducibility."
    },
    {
        "instruction": "Write a function that accepts a list of items and returns a *new* list containing the same items but in a randomly shuffled order. Ensure the original list is not modified."
    },
    {
        "instruction": "Write a function that accepts a single numerical input `n`. Return the string \"positive\" if `n` is greater than 0, and the string \"non-positive\" otherwise."
    },
    {
        "instruction": "Write a function that takes a single floating-point number as input and returns its sine. Ensure the function handles standard float inputs."
    },
    {
        "instruction": "Write a function that calculates the numerical derivative of the composite function `sin(sin(x))` at a given input floating-point number `x`. You may use a numerical differentiation technique like the central difference method. Return the resulting derivative as a float."
    },
    {
        "instruction": "Create a function that takes a single numerical scalar input `x`. Inside this function, call a helper function that also takes `x` and returns *two* values: the result of applying the sine function twice to `x`, and a separate constant numerical value (e.g., 3.0). The main function should discard the constant value and return only the nested sine result."
    },
    {
        "instruction": "Create a function that takes a single floating-point number `x`. Inside this function, determine if `x` is positive. If it is, compute `sin(x)` and the constant `3.0`. If not, compute `cos(x)` and the constant `4.0`. Return the computed trigonometric value and the corresponding constant as a pair."
    },
    {
        "instruction": "Create a function that accepts a floating-point number. Based on whether the number is positive or not, it should return a pair (tuple) containing: 1) the result of a mathematical operation (e.g., sine if positive, cosine if not), and 2) a fixed numerical constant (e.g., 3.0 if positive, 4.0 if not). Then, write a wrapper function that calls the first function but only returns the mathematical result (the first element of the pair)."
    },
    {
        "instruction": "Define a function `process_data` that takes a numerical input `x`. This function must call a helper function `get_values(x)` which returns two derived values (e.g., `x+1` and `x*2`). The `process_data` function should then discard the second value returned by `get_values` and only return the first value."
    },
    {
        "instruction": "Write a function that accepts a single number. If the number is greater than zero, return the pair (calculated_value_A, 3.0). Otherwise, return the pair (calculated_value_B, 4.0). calculated_value_A and calculated_value_B should be the results of applying two distinct, simple mathematical operations (e.g., trigonometric functions) to the input number."
    },
    {
        "instruction": "Implement a function demonstrating the chain rule for differentiation. It accepts four functions: `f`, `g`, `f_prime` (derivative of `f`), and `g_prime` (derivative of `g`). All functions take one numerical input and return one numerical output. The main function also takes a numerical value `x` and must return the derivative of the composite function `f(g(x))` evaluated at `x`, calculated using the formula `f_prime(g(x)) * g_prime(x)`."
    },
    {
        "instruction": "Implement a function `outer_func` that takes one floating-point number `z`. Inside `outer_func`, call another function `inner_func` with a fixed constant (e.g., 2.0) and `z` as arguments. `outer_func` should return the result of `inner_func`. Assume `inner_func` takes two floats and returns a float."
    },
    {
        "instruction": "Write a function that accepts a single number as input and returns double its value."
    },
    {
        "instruction": "Implement a higher-order function called `create_wrapper`. This function should accept another function `func` as input. `create_wrapper` must return a *new* function. This new function, when invoked with any set of arguments, should call the original `func` with those exact arguments and return the result."
    },
    {
        "instruction": "Implement a higher-order function `wrap_execution` that accepts a function `target_func`. It returns a *new* function that, when called with arguments `*args`, executes `target_func(*args)`, prints a message 'Executing function', and returns the result. The `target_func` performs a simple numerical operation."
    },
    {
        "instruction": "Write a function that takes an initial 1D numerical array `x0`, a transformation function `transform_func`, and an integer `k`. The `transform_func` takes a 1D array as input and returns a 1D array of the same size. Your function should apply `transform_func` to the array `k` times iteratively, starting with `x0`. Return the final 1D array after `k` applications."
    },
    {
        "instruction": "Define a pair of functions. The first function should compute `sin(x)`. The second function should compute the product of the derivative of the first function (`cos(x)`) and an arbitrary input value `g`. Both functions take `x` (and `g` for the second) as input."
    },
    {
        "instruction": "Define two functions. The first, `forward_square(x)`, should compute `y = x * x` and return both `y` and the original `x` (needed for gradient calculation). The second, `backward_square(saved_x, grad_y)`, should take the saved `x` from the forward pass and an incoming gradient `grad_y` (gradient w.r.t. `y`), and return the gradient w.r.t. `x`."
    },
    {
        "instruction": "Create a function `g` that takes a scalar `x`. Inside `g`, it should call a predefined function `f(x)` (assume `f(x)` returns `(x, x)`), extract the first element of the result, calculate the derivative of this element with respect to `x` (using a hypothetical `compute_derivative`), and return this derivative value."
    },
    {
        "instruction": "Develop a function that computes the total sum of all elements within a given numerical array, regardless of its shape (e.g., 1D, 2D, or higher). The function should return a single scalar number."
    },
    {
        "instruction": "Create a function that accepts an initial 1D numerical array `x`. It applies a transformation function (where the output element `y[i]` is the input element `x[i]` multiplied by its index `i`) exactly once. The function should return the sum of all elements in the resulting array."
    },
    {
        "instruction": "Implement a function that performs matrix-vector multiplication with high precision. It should accept a 2D numerical array (matrix, shape M x N) and a 1D numerical array (vector, shape N) and return a 1D numerical array (vector, shape M)."
    },
    {
        "instruction": "Develop a function that simulates evaluating a sequence of operations and selectively storing intermediate results. It takes an initial numerical value, a list of function objects `[f1, f2, ..., fn]` (each accepting and returning a numerical scalar), and a list of booleans `[s1, s2, ..., sn]` of the same length. Apply the functions sequentially: `y1 = f1(x)`, `y2 = f2(y1)`, ..., `yn = fn(y_{n-1})`. If `si` is true, consider the result `yi` \"stored\". After computing `yn`, count how many results `yi` (for i from 1 to n) were *not* stored (where `si` was false). Return this count, representing the number of values that would need re-computation."
    },
    {
        "instruction": "Implement a function `compute_value_and_derivative(x)` that takes a scalar numerical input `x`. It should return a tuple containing two values: the result of a predefined mathematical operation (e.g., sine of x) and the result of its derivative (e.g., cosine of x), both evaluated at `x`."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array. If the sum of its elements is greater than zero, it returns the original array. Otherwise, it returns a new array of the same shape containing only zeros. Input: 1D array. Output: 1D array of the same size."
    },
    {
        "instruction": "Create a function that accepts a single number. If the number is positive, return the number unchanged. If the number is zero or negative, return its sine value."
    },
    {
        "instruction": "Implement a function that takes a number `x`. It should return `x` if `x` is positive, and the sine of `x` if `x` is zero or negative."
    },
    {
        "instruction": "Create a function that accepts a numerical array and a string specifying a target data type (e.g., 'float32', 'int64'). Return a new array containing the same values as the input but represented using the target data type."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `x` and returns a new array where each element `x[i]` is multiplied by the index `i`. Assume the input array is non-empty."
    },
    {
        "instruction": "Write a function that computes the sine of a given scalar floating-point input number."
    },
    {
        "instruction": "Write a function that takes a single floating-point number `x` as input and returns the result of the mathematical operation `cos(2 * x) / 2.0`."
    },
    {
        "instruction": "Implement a function `apply_conditional_scaling` that takes two floating-point numbers, `value` and `factor`. If `value` is positive, return `2.0 * factor`. If `value` is zero or negative, return `3.0 * factor`."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and applies a given scalar mathematical function (e.g., sine) to every element. It must return a new 2D array of the same shape containing the results."
    },
    {
        "instruction": "Implement a function that takes a single floating-point number `x` and returns a pair (or tuple) containing two floating-point numbers: the sine of `x` and twice the cosine of `x`."
    },
    {
        "instruction": "Write a function that accepts a dictionary containing a single key 'a' with a numerical value. The function should return a new dictionary containing a single key 'b' whose value is the sine of the input dictionary's 'a' value."
    },
    {
        "instruction": "Write a function that takes two required numerical inputs (`x`, `y`) and one optional numerical keyword input (`c` with a default value of 1.0). The function should return the result of `c * (x + y)`."
    },
    {
        "instruction": "Write a function that takes an initial numerical value `c` and applies a given transformation function `t(c)` exactly once. The function should return the result of applying `t(c)`."
    },
    {
        "instruction": "Write a function that takes a single numerical scalar input `x` and returns the value `3 * x`."
    },
    {
        "instruction": "Write a function that accepts another function `op` (which takes one numerical argument and returns one numerical value) and a numerical value `val`. The function should return the result of calling `op(val)`."
    },
    {
        "instruction": "Design a function `compute_custom_derivative_pair` that accepts three numerical scalars: `param1`, `param2`, and `sensitivity_in`. Assume `param1` is constant for differentiation purposes. The function should compute and return a pair: (1) the product `param1 * param2`, and (2) the scaled sensitivity `5.0 * sensitivity_in`."
    },
    {
        "instruction": "Implement a function that takes a base function `op` (which accepts two scalar arguments) and two 1D numerical arrays `arr1` and `arr2` of the same length. Return a new 1D array where the i-th element is the result of `op(arr1[i], arr2[i])`."
    },
    {
        "instruction": "Create a function `apply_rule(func, rule, *args)` that takes a primary function `func`, a rule function `rule`, and arguments `*args`. The `rule` function should accept `args` and return two values: `result1` and `result2`. `apply_rule` should first call `func(*args)` to get an `expected_structure_output`. Then, it should call `rule(*args)` to get `result1` and `result2`. It must verify that `result1` has the *exact same data structure* (nesting and container types like list/tuple) as `expected_structure_output`. If the structures match, return `(result1, result2)`. If they do not match, raise a `TypeError` with a message indicating the structural mismatch."
    },
    {
        "instruction": "Develop a function that takes a numerical scalar `x`. Inside the function, compute `y = x * x`. Then, create a 1-element numerical array `dy` containing the value `1.0`. Return the pair `(y, dy)`."
    },
    {
        "instruction": "Implement a function that takes an arbitrary value. If the value is not a tuple or list of length two, raise a `TypeError` with the message \"Rule failed: Expected a pair (length 2 sequence), but received [actual value]\". If it is a valid pair, return the value unchanged."
    },
    {
        "instruction": "Write a function that takes a single numerical value as input. It should return a tuple containing two elements, where both elements are the original input value. For example, input `5.0` should return `(5.0, 5.0)`."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new 1D array of the same size and data type, filled entirely with zeros."
    },
    {
        "instruction": "Write a function that calculates the directional derivative of a matrix-vector product. Inputs: Matrix `A` (M x N), Vector `b` (N,), Matrix direction `dA` (M x N), Vector direction `db` (N,). Output: The resulting directional derivative vector `dz` (M,) computed using the product rule: `dz = A @ db + dA @ b`. Ensure the function performs the necessary matrix-vector and matrix-vector multiplications."
    },
    {
        "instruction": "Create a function that represents the derivative rule for the negation function `f(x) = -x`. It should accept a numerical value `dx` (representing a directional change) and return the resulting output change `-dx`."
    },
    {
        "instruction": "Write a function `create_constant_func` that accepts a number `c`. It should return a *new* function that takes a single argument but always ignores it and returns the original number `c`."
    },
    {
        "instruction": "Create a function `compute_f_and_df` that takes two scalar numerical inputs: `x` (primal) and `dx` (tangent). It should compute `y = x * x` and the directional derivative `dy = 2 * x * dx`. The function must return both `y` and `dy` as a pair."
    },
    {
        "instruction": "Write a function `create_zero_like(value)` that accepts a numerical scalar or an array. It should return a new scalar or array of the same shape and data type as the input, but filled entirely with zeros."
    },
    {
        "instruction": "Create a function `apply_twice` that takes two arguments: another function `f` (which accepts one numerical input and returns one numerical output) and a numerical value `x`. The `apply_twice` function should return the result of applying `f` twice to `x`, i.e., `f(f(x))`."
    },
    {
        "instruction": "Create a function `apply_chain_rule` that accepts four functions: `f`, `g`, `f_prime` (the derivative of `f`), and `g_prime` (the derivative of `g`). All functions take a single scalar float argument and return a scalar float. The function should also take a scalar float `x` and return the derivative of the composition `h(x) = f(g(x))` evaluated at `x`, calculated using the chain rule: `f_prime(g(x)) * g_prime(x)`."
    },
    {
        "instruction": "Define a scalar function `f(x)`. Separately, specify a custom rule for its derivative calculation: for any scalar input tangent `g`, the corresponding output tangent (derivative component) should always be `2 * g`, irrespective of the value of `x` or the output of `f(x)`. Implement a helper function that, given `g`, returns this custom derivative value."
    },
    {
        "instruction": "Write a function that takes a 3D numerical array `batch_data` (shape B, M, N). Assume a hypothetical function `process_slice(slice)` exists that takes an (M, N) slice and returns an (M, N) array. Your function should apply `process_slice` to each 2D slice `batch_data[i, :, :]`, sum the resulting (M, N) arrays along the first (batch) dimension (axis 0), and finally compute the mean of the summed result along the second dimension (axis 1), keeping the dimension. Return the final (M, 1) array."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns the sum of all its elements as a single scalar value."
    },
    {
        "instruction": "Write a function that takes no arguments and returns the integer value `1`."
    },
    {
        "instruction": "Create a function that accepts a 2D numerical array and a unary function (a function taking one numerical argument). Apply the unary function element-wise to every entry in the 2D array and return a new 2D array containing the results, maintaining the original shape."
    },
    {
        "instruction": "Write a function `add_batch_dim` that takes a list of arguments (where each argument is either a scalar or a 1D numerical array). For each argument, it should reshape it by adding a leading dimension of size 1 (e.g., scalar `5.0` becomes `[5.0]`, array `[1, 2]` becomes `[[1, 2]]`). Return the list of reshaped arguments."
    },
    {
        "instruction": "Implement a higher-order function called `vectorize_binary_op`. It should accept a binary function `op` (which takes two scalar arguments and returns one scalar). `vectorize_binary_op` should return a *new* function that takes two 1D numerical arrays of the same length and applies `op` element-wise, returning a new 1D array of the results."
    },
    {
        "instruction": "Implement a function `linearize_at` that takes another function `func` (which accepts two scalar arguments) and two scalar values `arg1`, `arg2`. `linearize_at` should return two results: the value of `func(arg1, arg2)`, and a *new* function that accepts two derivative inputs (`d_arg1`, `d_arg2`) and computes the output derivative based on a predefined rule (e.g., always returning `d_arg2`)."
    },
    {
        "instruction": "Write a function `combine_conditional(val1, val2, zero_marker)` where `val1` and `val2` can be numbers or a special `zero_marker` object. Implement the logic: return `val2` if `val1` is `zero_marker`, return `val1` if `val2` is `zero_marker`, otherwise return `val1 + val2`."
    },
    {
        "instruction": "Write a function that receives a nested data structure, specifically a pair where the first element is another pair of numbers and the second element can be ignored, like `((value1, value2), ignored)`. The function should extract and return only `value1`."
    },
    {
        "instruction": "Develop a function that takes two scalar numerical inputs, x and y, and a list of two booleans, `use_outputs`. The function should compute `(sine(x), x + cosine(y))`. If `use_outputs[0]` is false, the sine calculation should ideally be skipped. If `use_outputs[1]` is false, the cosine calculation should ideally be skipped. Return a tuple where results corresponding to `false` in `use_outputs` are replaced with a placeholder (e.g., None or 0)."
    },
    {
        "instruction": "Write a wrapper function `check_missing_arg` that takes another function `func` as input. Assume `func` requires exactly two positional arguments (`x`, `y`). The wrapper should call `func` with only one argument (e.g., `func(10)`), catch the expected `TypeError` indicating a missing argument, and return `True` if the specific error is caught, `False` otherwise."
    },
    {
        "instruction": "Create a function that accepts a single floating-point number `x` and returns the value of `cos(x)`, representing the standard derivative of `sin(x)`."
    },
    {
        "instruction": "Create a function `evaluate_and_apply_custom_grad` that accepts three arguments: a function `f` (like `func` from Task 2), a custom gradient rule function `g` (like `custom_grad_rule` from Task 2), and a scalar input value `x`. This function should return a pair: the result of `f(x)` and the result of `g(x, 1.0)`."
    },
    {
        "instruction": "Implement a function that simulates the forward pass for a custom operation. It takes a scalar input 'x'. Based on whether 'x' is positive or not, it calculates an intermediate result (sine if positive, cosine otherwise). It must return *both* the intermediate result and the original input 'x' packaged together (e.g., in a tuple or list)."
    },
    {
        "instruction": "Implement a mechanism to define a scalar function (e.g., f(x) = sin(x)) along with its custom gradient calculation (e.g., specifying f'(x) = 2 * cos(x)), ensuring the function initially only accepts scalar numerical inputs."
    },
    {
        "instruction": "Create a function that takes a floating-point number `x`. Inside the function, calculate both `sin(x)` and `cos(x)`. Return these two values as a pair or tuple."
    },
    {
        "instruction": "Develop a function that receives two dictionaries: `cache = {'saved_val': s}` and `gradient_in = {'downstream_grad': g}`. Calculate `gradient_out = s * g * 2`. Return a dictionary `{'upstream_grad': gradient_out}`."
    },
    {
        "instruction": "Implement a function `compute_forward_derivative(func, x, tangent)` that calculates the directional derivative of a given numerical function `func` at point `x` along the direction specified by `tangent`. Assume `func` takes and returns numerical types (scalar or array), and `x` and `tangent` have compatible shapes."
    },
    {
        "instruction": "Create a function that takes two numerical inputs and returns the square of their sum."
    },
    {
        "instruction": "Write a function `evaluate_custom_second_derivative(value)` that calculates the *custom* second derivative of the conceptual function `f` described in Task 4. This involves finding the derivative of the custom first derivative rule (`2 * cos(value)`). The function should return the result of this second derivative (i.e., `-2 * sin(value)`) evaluated at the input `value`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array where each element is the cosine of the corresponding input element."
    },
    {
        "instruction": "Create a function `forward_op` that accepts a function `fn` and a numerical value `x`. It should return a tuple containing two elements: the result of `fn(x)` and the cosine of `x`."
    },
    {
        "instruction": "Implement a function `custom_forward_operation(input_value)` that takes a single numerical `input_value`. It should compute two results: the primary result (e.g., `input_value * constant`) and auxiliary data needed for a later step (e.g., the cosine of `input_value`). Return both results as a pair (primary_result, auxiliary_data). Assume `constant` is accessible."
    },
    {
        "instruction": "Define two functions: `compute_primary_and_intermediate(input_val)` and `process_intermediate(intermediate_val, gradient_val)`. The first function should take a numerical `input_val`, compute `input_val * 5.0` as the primary result, and `input_val + 2.0` as an intermediate result, returning both (primary, intermediate). The second function should take the `intermediate_val` and another numerical `gradient_val`, and return their product: `intermediate_val * gradient_val`."
    },
    {
        "instruction": "Design a function `apply_transform_pair(data, primary_transform, secondary_transform)`. `primary_transform` is a function taking `data` and returning an intermediate result. `secondary_transform` is a function taking both the original `data` and the intermediate result, returning the final value. Your function should execute `intermediate = primary_transform(data)` followed by `final_result = secondary_transform(data, intermediate)` and return `final_result`."
    },
    {
        "instruction": "Write a function that accepts two numerical scalar inputs and returns their product."
    },
    {
        "instruction": "Develop a function that simulates checking the output structure of another process. It takes an integer `expected_arg_count` and a tuple `actual_output_tuple`. If the number of elements in `actual_output_tuple` does not equal `expected_arg_count`, it should raise a `TypeError` with a message indicating the expected and actual counts."
    },
    {
        "instruction": "Create a function `validate_array_spec` that takes two numerical arrays, `arr_a` and `arr_b`. The function should return `True` if both arrays have identical shapes and data types (e.g., both are 1D arrays of 5 integers, or both are 2x3 arrays of 64-bit floats). Return `False` if either the shapes or the data types differ."
    },
    {
        "instruction": "Create a callable structure (like a class with a `__call__` method or a function closure) that stores an internal numerical value 'a'. When the structure is called with a numerical argument 'x', it should return the product of `max(0, a)` and `x`."
    },
    {
        "instruction": "Write a function that accepts a single numerical input and returns its square."
    },
    {
        "instruction": "Develop a function `compute_gradient_of_sum`. This function accepts a 1D numerical array `InputVec`. It applies a specific scalar function `foo` (which uses custom forward/backward rules like Task 3) element-wise to `InputVec`, sums the results, and then computes the gradient of this total sum with respect to `InputVec` using the custom backward rules. Return the final gradient array."
    },
    {
        "instruction": "Implement a function that takes two numerical inputs, `g` and `y`. It should return the product `g * 2.0 * cos(y)`. This simulates applying a scaling factor `g` based on an external parameter `y`."
    },
    {
        "instruction": "Create a function that accepts a single numerical input `x` and computes the analytical derivative of `2.0 * sin(x)`, returning `2.0 * cos(x)`."
    },
    {
        "instruction": "Write a function that accepts a single numerical value and returns it unchanged."
    },
    {
        "instruction": "Create a function that takes a single floating-point number `x` and returns the sine of the sine of `x` (i.e., sin(sin(x)))."
    },
    {
        "instruction": "Write a function that computes the third derivative of the composite function `k(x) = sin(sin(x))` evaluated at a given numerical input `x`."
    },
    {
        "instruction": "Create a function that accepts a single scalar numerical input `x` and returns the value of `x` multiplied by the sine of `x`."
    },
    {
        "instruction": "Implement a function `forward_pass` that takes two scalar numerical inputs, `x` and `y`. It should return a tuple containing two values: the result of `x * sin(y)` and the value `cos(y)`."
    },
    {
        "instruction": "Develop a function that accepts a single number `v`. It should compute `v * v * sin(v)` and return the result."
    },
    {
        "instruction": "Develop a function that accepts two arguments: an array (which can be ignored in the calculation) and a single floating-point number `val`. The function should compute `2.0 * cosine(val)` and return this single floating-point result."
    },
    {
        "instruction": "Implement a function `compute_derivatives` that takes two arguments: a function `fn` (which accepts a single numerical input and returns a single numerical output) and a number `x`. `compute_derivatives` should calculate and return a tuple containing: `fn(x)`, an approximation of the first derivative of `fn` at `x`, and an approximation of the second derivative of `fn` at `x`. Use numerical methods (like finite differences with a small step size) for the derivative approximations."
    },
    {
        "instruction": "Develop a higher-order function named `calculate_gradient`. It takes two arguments: `target_func` and `wrt_args`. `target_func` is a function that accepts two scalar inputs (`in1`, `in2`) and returns a pair `(result, backward_rule)`, where `result` is a scalar and `backward_rule` is a callable that accepts an upstream scalar `sensitivity` and returns sensitivities w.r.t `in1` and `in2`. `wrt_args` is a tuple of integers (e.g., `(0,)`, `(1,)`, or `(0, 1)`) indicating which input sensitivities are desired. `calculate_gradient` should return a *new* function. This new function accepts two scalars (`val1`, `val2`), calls `target_func(val1, val2)`, invokes the returned `backward_rule` with a sensitivity of `1.0`, and finally returns a tuple containing only the sensitivities corresponding to the indices specified in `wrt_args`."
    },
    {
        "instruction": "Implement a function that accepts a 1D numerical array `x` and returns a new 1D array where each element `i` is the cosine of `x[i]` multiplied by `3.0 + i`. Input: `[x0, x1, ..., xN-1]`, Output: `[cos(x0)*3.0, cos(x1)*4.0, ..., cos(xN-1)*(3.0+N-1)]`."
    },
    {
        "instruction": "Implement a function to compute the first derivative of a primary function `f` at a point `x`. You are given `f` and a custom derivative rule `df(g, x)` which defines how to calculate the derivative contribution based on an upstream value `g` and the original input `x`. Assume `g=1` for the initial derivative calculation. Example: Use `f(x) = x^2` and `df(g, x) = g * x`."
    },
    {
        "instruction": "Create a function that simulates tracking 'active' variables. It should accept three numerical inputs and a boolean list of length three (e.g., `[True, False, False]`). The function should return the result `(input1, input1)` and also verify internally that only the inputs marked `True` in the boolean list are considered 'active' (you can simulate this check, e.g., by printing a confirmation or raising an error if the check fails)."
    },
    {
        "instruction": "Write a function that calculates and returns the sum of all elements in a given numerical array. The input is a single numerical array, and the output should be a single scalar number representing the sum."
    },
    {
        "instruction": "Write a function `execute_partial` that accepts a dynamic scalar `d_s` and a dynamic 1D numerical array `d_a`. Inside, it calls a predefined function `compute(s_s, s_a, d_s, d_a)` using fixed static values `s_s=1.0` and `s_a=[2.0, 3.0]` along with the dynamic inputs. `compute` returns four values `(o_ss, o_sa, o_ds, o_da)`. Your `execute_partial` function should return a tuple containing only `(o_sa, o_ds, o_da)`."
    },
    {
        "instruction": "Write a function that accepts two numerical arrays, `arr1` and `arr2`, of the same shape and returns them as an ordered pair (e.g., a tuple)."
    },
    {
        "instruction": "Create a function `simulate_gradient_step` that takes four arguments: an original function `func`, a forward pass function `fwd`, a backward pass function `bwd`, and a list of input arguments `args` for `func`. Inside `simulate_gradient_step`, first call `fwd` with `args` to get the original result and the saved intermediate values (residuals). Then, assuming an initial gradient of 1.0 for the result, call `bwd` with the residuals and this initial gradient. The function should return the input gradients computed by `bwd`."
    },
    {
        "instruction": "Create a higher-order function named `apply_iteratively`. It accepts another function `update_func`, an initial numerical scalar value `x_init`, and a number of iterations `N`. `update_func` itself takes two scalar arguments. `apply_iteratively` should maintain a state `(current_x, constant_val)` initialized as `(x_init, 1.0)`. For `N` iterations, it updates the state using `(current_x, constant_val) = (update_func(current_x, constant_val), current_x)`. It should return the final `current_x` value."
    },
    {
        "instruction": "Create a function that takes a single numerical value `val` and constructs a specific nested tuple structure: `(val, (None, None))`. Ensure `None` is used literally."
    },
    {
        "instruction": "Write a function that accepts a nested tuple structure (e.g., `(item1, (item2, item3))`) and returns only the very first item (`item1`)."
    },
    {
        "instruction": "Implement a function simulating a backward calculation step. It takes three numerical inputs: `val1`, `val2`, and `gradient_signal`. It should return two values: `gradient_signal * val2` and `val1 * gradient_signal`."
    },
    {
        "instruction": "Write a function that accepts two numerical scalar inputs, `x` and `y`, and returns the result of `sin(x) * y`."
    },
    {
        "instruction": "Implement a function that takes two scalar numerical inputs, `x` and `y`. It should compute `z = sin(x) * y` and also return the intermediate values `cos(x)`, `sin(x)`, and `y` needed for a subsequent calculation. The function should return a tuple where the first element is `z` and the second element is another tuple containing the three intermediate values: `(z, (cos(x), sin(x), y))`. Ensure the function can handle an optional, unused keyword argument without error."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays, `a` and `b`. It should compute three results: (1) a 1D array `c` where `c[i] = sin(a[i]) * b[i]`, (2) a 1D array `d` where `d[i] = cos(a[i])`, and (3) the original array `b`. The function should return all three arrays (`c`, `d`, `b`)."
    },
    {
        "instruction": "Write a function that accepts two scalar numerical inputs, `x` and `y`. It should return a tuple containing two values: the sine of `x`, and the sum of `x` and the cosine of `y`."
    },
    {
        "instruction": "Create a function `check_required` that requires two positional numerical arguments, `val1` and `val2`. If the function is called with fewer than two arguments, it must raise a `TypeError` specifically mentioning that a required argument is missing."
    },
    {
        "instruction": "Develop a function named `apply_binary_op` that accepts three arguments: a function `op`, and two numerical arrays `arg1` and `arg2` (assume compatible shapes). The `apply_binary_op` function should call `op(arg1, arg2)` and return its result. Demonstrate its use where `op` performs element-wise division."
    },
    {
        "instruction": "Define a pair of related functions operating element-wise on numerical arrays of the same shape. The first function, `process(r, x)`, should return `x / r`. The second function, `adjoint_process(r, t)`, should simulate an adjoint operation by returning `t / (2.0 * r)`."
    },
    {
        "instruction": "Develop a function that receives two numerical arrays, `x` and `y`, with matching shapes. Compute an intermediate array `t` where `t[i] = x[i] / (2.0 * y[i])`. Return the element-wise sum `x + t`. Handle potential division by zero during the calculation of `t`."
    },
    {
        "instruction": "Write a function that accepts two scalar numerical inputs, `factor` and `value`, and returns their product."
    },
    {
        "instruction": "Write a function that takes a single numerical input and returns it unchanged. Create a second function that takes any numerical input but always returns 0.0."
    },
    {
        "instruction": "Implement a function that accepts two 1D numerical arrays, `vec1` and `vec2`, of equal length. The function should compute `vec1 + (vec1 / vec2)` element-wise and return the resulting 1D array. Ensure proper handling for cases where `vec2` contains zeros."
    },
    {
        "instruction": "Implement a function that takes two numerical arrays, `a` and `b`, of the same shape. The function should compute `a + (a / b)` element-wise and return the resulting array. Ensure robust handling for cases where elements in `b` might be zero."
    },
    {
        "instruction": "Implement a function that takes two 1D numerical arrays, `a` and `b`, of the same shape. The function should compute `c = a / b` element-wise and then return the element-wise sum `a + c`. Ensure compatibility of shapes."
    },
    {
        "instruction": "Define two distinct functions, `op_forward` and `op_backward`. Both functions should accept two 1D numerical arrays of the same size (`param`, `value`) and return a new 1D array resulting from a specific element-wise calculation (e.g., `op_forward` could compute `value / param`, `op_backward` could compute `value / (2.0 * param)`)."
    },
    {
        "instruction": "Implement a function that takes a list or tuple containing exactly two numerical values, `t1` and `t2`, and returns their sum `t1 + t2`."
    },
    {
        "instruction": "Design a system where functions can call other functions that also have associated transforms. Create an outer function `F` that calls an inner function `G`. `G` returns its input; its transform returns 0.0. `F` returns the result of `G`; its transform returns 7.0. Verify that `F` returns its input, the first transform of `F` returns 7.0, the second transform of `F` returns the input, and the third transform of `F` returns 7.0."
    },
    {
        "instruction": "Create a callable structure (e.g., a class instance or a closure) that holds references to two distinct numerical functions (like those from Task 1 and Task 2). Initially, when the structure is called with a float argument, it should execute the first function and return the result."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number `z` and returns the value `2.0 * z`."
    },
    {
        "instruction": "Develop a function `apply_alternating_transform` that takes an initial function `func`, an integer `n` (number of transformations), and an input value `val`. Assume `func` has a paired 'transform' function (like `f` and `g` from Task 3, where applying the transform twice returns the original). Apply the 'transform' operation `n` times to `func`. If `n` is even, the result is equivalent to calling the original `func` on `val`. If `n` is odd, the result is equivalent to calling the transformed function on `val`. Return the final computed value."
    },
    {
        "instruction": "Write a function `create_multiplier(factor)` that takes a numerical factor and returns a *new function*. This new function should accept a single numerical argument `x` and return `factor * x`."
    },
    {
        "instruction": "Write a function that takes two numerical inputs, `numerator` and `denominator`, and returns their quotient (`numerator / denominator`). Ensure it handles potential division by zero gracefully (e.g., return a specific numerical value like 'NaN' or infinity, or raise an error)."
    },
    {
        "instruction": "Define a function `evaluate_primary(x, y)` that calculates `x + x / y`. Define a second function `evaluate_derivative_wrt_y(x, y)` that calculates the mathematical partial derivative of the expression `x + x / y` specifically with respect to `y`. Both functions take scalar numbers `x` and `y` as input."
    },
    {
        "instruction": "Define two functions, `forward_op(a, b)` and `backward_op(a, t)`. `forward_op` should perform an element-wise calculation like `b / a`. `backward_op` should implement a related element-wise operation, for example, returning `2 * t / a`. Both functions take numerical arrays as input."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size, `a` and `b`, and returns a new 1D array where each element is the corresponding element of `a` divided by the corresponding element of `b`. Handle potential division by zero gracefully (e.g., return a default value like 0 or infinity)."
    },
    {
        "instruction": "Define a primary function that takes two 1D numerical arrays, `input1` and `input2`. This function should contain an inner, nested function that performs element-wise division (`input1 / input2`). The primary function should return the sum of `input1` and the result of this inner division. Additionally, define a *separate* transformation function that takes the arguments of the inner function (`input2`, `input1`) and returns double the result of the inner function applied to those arguments."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same size and returns a new 1D array representing their element-wise sum."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays of the same shape and returns a new 1D array representing their element-wise division (first array divided by the second)."
    },
    {
        "instruction": "Write a function `get_specific_output` that takes a number `x` and an index (either 0 or 1). If the index is 0, the function should compute and return the exponential of `x`. If the index is 1, it should compute and return the square root of `x`. Assume valid inputs for the index and handle potential domain errors for the square root."
    },
    {
        "instruction": "Design a function that takes an input value, a calculation function, and a list of boolean usage flags. The calculation function accepts the input value and returns a list of results. Your main function should call the calculation function, then process its results based on the usage flags: if the flag at index `i` is True, double the corresponding result; otherwise, replace it with None. Return the list of processed results/None values."
    },
    {
        "instruction": "Design a function `selective_transform` that takes two lists of numbers, `list1` and `list2`, and a string argument `mode` which can be 'first', 'second', or 'both'. If `mode` is 'first', return the element-wise `cos` of `list1` and a placeholder (e.g., None) for the second result. If `mode` is 'second', return a placeholder and the element-wise `cos` of `list2`. If `mode` is 'both', return the element-wise `sin` of `list1` and the element-wise `sin` of `list2`. Input: list[float], list[float], str. Output: tuple[Optional[list[float]], Optional[list[float]]]."
    },
    {
        "instruction": "Write a function that takes two scalar numerical inputs, `angle` and `factor`. Return the product of the cosine of `angle` and `factor`."
    },
    {
        "instruction": "Write a function that computes both the result and the gradient of `h(x) = f(x)**2`. This function should accept the input `x` and leverage pre-defined custom forward (`fwd`: x -> result, intermediate) and backward (`bwd`: intermediate, grad_out -> grad_in) functions corresponding to `f(x)`. It must return a pair: (the final result `h(x)`, the final gradient `h'(x)`)."
    },
    {
        "instruction": "Create a function that takes another function `func` (which accepts one numerical input and returns one numerical output) and a numerical value `val`. This function should compute `y = func(val)` and return a tuple containing two elements: `y` and `10 * y`."
    },
    {
        "instruction": "Implement a function `validate_structure(arr1, arr2)` that takes two multi-dimensional arrays. Return `True` only if both arrays have the exact same shape *and* contain elements of the same fundamental data type, otherwise return `False`."
    },
    {
        "instruction": "Write a function that accepts a single numerical input `x` and returns a tuple containing two derived results, for example, the sine and cosine of `x`."
    },
    {
        "instruction": "Create a function that takes a number `x` and two boolean flags, `need_output1` and `need_output2`. The function should return a pair (e.g., a list or tuple of length 2). The first element of the pair should be the square of `x` if `need_output1` is true, and a null value otherwise. The second element should be the cube of `x` if `need_output2` is true, and a null value otherwise."
    },
    {
        "instruction": "Create a function `check_kwargs` that takes a list of allowed keyword argument names (strings) and a dictionary representing keyword arguments provided by a caller. The function should raise a `TypeError` if the dictionary contains any key that is *not* in the allowed list. The error message should identify the unexpected keyword argument(s)."
    },
    {
        "instruction": "Implement a function that accepts a 1D numerical array. Inside the function, determine the size (number of elements) of the input array. Then, return a tuple containing two elements: (1) a new 1D array resulting from applying the cosine function element-wise to the input, and (2) a boolean value `True` (representing that the input was treated as a batch)."
    },
    {
        "instruction": "Design a function `apply_transform(data)` which uses an internal, fixed 1D numerical array `z`. If the input `data` is a scalar number `x`, the function must compute `z + sin(x)` (element-wise). If `data` is a 1D numerical array `xs`, it must compute `z + cos(xs)` (element-wise). The function should return the resulting 1D array, ensuring the correct trigonometric function is chosen based on whether the input is a scalar or an array."
    },
    {
        "instruction": "Develop a function that behaves differently based on the input type. If the input is a single number `x`, return the tuple `(sin(x), cos(x))`. If the input is a 1D numerical array `xs`, return a tuple of two 1D arrays `(cos(xs), sin(xs))`, where trigonometric functions are applied element-wise."
    },
    {
        "instruction": "Create a function that accepts a nested structure (potentially containing lists, tuples, and numerical arrays at the leaves) and a transformation function. It should return a new nested structure with the same organization, but where each leaf array has had the transformation function applied element-wise."
    },
    {
        "instruction": "Write a function that takes a nested structure containing 1D numerical arrays and potentially `None`. Verify that all arrays present in the structure have the same length. Return this common length if consistent, otherwise raise an error or return -1. Ignore `None` values during the check."
    },
    {
        "instruction": "Implement a function that takes a single numerical value `x` and returns its sine. Also, implement a mechanism such that when this function is applied element-wise to a 1D array `xs`, it returns a new 1D array containing the cosine of each element in `xs`."
    },
    {
        "instruction": "Create a function that accepts two 1D numerical arrays of the same length. It should return a new 1D array where each element is the sum of the elements at the corresponding positions in the input arrays."
    },
    {
        "instruction": "Develop a function `map_with_constant` that takes three arguments: a list `input_list`, a constant value `const_val`, and a function `binary_func` which accepts two arguments. The `map_with_constant` function should apply `binary_func` to each element of `input_list` paired with `const_val`, returning a new list of the results. Example: `map_with_constant([1, 2, 3], 10, lambda a, b: a * b)` should return `[10, 20, 30]`."
    },
    {
        "instruction": "Develop a decorator factory `create_validator(is_enabled: bool)`. This factory returns a decorator. When this returned decorator is applied to a function, it wraps the function. If `is_enabled` was `False` when the factory was called, calling the decorated function should immediately raise an `AttributeError`. If `is_enabled` was `True`, the decorated function should execute as normal."
    },
    {
        "instruction": "Implement a higher-order function `vectorized_call`. This function takes another function `f` (which operates on single numbers) as input. `vectorized_call` returns a *new* function. This new function accepts a 1D numerical array `arr` and should apply a *different*, predefined transformation (e.g., element-wise cosine, *not* `f`) to `arr`, returning the resulting array. The original function `f` is not directly used by the returned function in this specific task, simulating a scenario where vectorization overrides the base behavior."
    },
    {
        "instruction": "Implement a \"backward pass\" function. It accepts two arguments: a tuple of saved intermediate values `(val1, val2, val3)` (representing `cos(x)`, `sin(x)`, `y` from a previous step) and an incoming numerical value `g` (scalar or array). Return a tuple containing two computed values: `(val1 * g * val3, val2 * g)`. Handle element-wise operations for arrays."
    },
    {
        "instruction": "Create a function `process_data` that requires exactly two positional arguments, `data_points` (a list of numbers) and `method` (a string). If `method` is not provided when calling the function, raise a `TypeError` with the exact message \"Error: Missing required argument: 'method'\"."
    },
    {
        "instruction": "Develop a function that takes a boolean flag and a list of items. If the flag is true, return the first item in the list. If the flag is false, return the last item. Handle the case where the list might be empty (e.g., return None)."
    },
    {
        "instruction": "Write a function `create_selector` that takes a boolean `select_second`. It returns a new function that takes two arguments, `arg1` and `arg2`. This new function should return `arg2` if `select_second` was true when `create_selector` was called, otherwise it should return `None`."
    },
    {
        "instruction": "Write a function that accepts two 64-bit signed integers, `a` and `b`. Compute their sum. Before returning, check if the mathematical result exceeds the maximum or minimum value representable by a 64-bit signed integer. If it does, raise an `OverflowError`. Otherwise, return the resulting 64-bit signed integer sum."
    },
    {
        "instruction": "Given a function `func` that takes two 1D numerical arrays, `v1` of size N and `v2` of size M, and returns a scalar, write a function to compute the mixed second partial derivative matrix. Differentiate first with respect to `v1` and then with respect to `v2`. The output should be an N x M numerical matrix."
    },
    {
        "instruction": "Write a function `safe_scalar_converter(arr)` that takes a numerical array. It should return the element if `arr` is a 1-element array. It should return specific string codes: 'ERROR_EMPTY' if `arr` is empty, 'ERROR_MULTI_ELEMENT' if `arr` has more than one element, and 'ERROR_NON_NUMERIC' if the element is not suitable for typical scalar operations (this check is simplified - assume basic numeric types are ok)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `u` and a scalar numerical constant `c`, and returns a new 2D array representing the element-wise computation `c**2 * u`."
    },
    {
        "instruction": "Create a function that accepts another function `f` and an argument `x`. Execute `f(x)`. If `f(x)` returns a single scalar number, return that number. If `f(x)` returns anything else (like a collection or void), raise a `TypeError` with the exact message: \"Function did not return a scalar value.\""
    },
    {
        "instruction": "Write a function `is_scalar(value)` that returns `True` if the input `value` represents a single numerical value (integer, float, etc.) and `False` otherwise (e.g., if it's a list, array, or other collection)."
    },
    {
        "instruction": "Write a function `attempt_call` that accepts two arguments: a function `target_func` and an input value `val`. It should execute `target_func(val)`. If this execution raises any kind of `Exception`, `attempt_call` must catch the exception and return `None`. Otherwise, it should return the result of `target_func(val)`."
    },
    {
        "instruction": "Write a function that takes two 1D numerical arrays (vectors) as input. Return `True` if they have the same number of elements (compatible for a standard dot product), and `False` otherwise."
    },
    {
        "instruction": "Develop a function that accepts a 2D numerical array with dimensions M x N. Calculate the total number of elements K = M * N. The function should return a 3D numerical array of shape (K, M, N) representing the standard basis for the input array's shape. This output can be conceptualized as taking each column of a KxK identity matrix and reshaping it into an MxN matrix."
    },
    {
        "instruction": "Create a function that accepts an integer `n` and a complex number `c`. It should return a 1D numerical array (e.g., a list) of length `n` where every element is equal to the complex number `c`."
    },
    {
        "instruction": "Create a function that takes no arguments and returns a scalar floating-point value representing zero."
    },
    {
        "instruction": "Write a function that takes a single floating-point number, representing a 'tangent' direction. Assuming an underlying process with a constant rate of change equal to 1, return the product of this rate (1) and the input 'tangent'."
    },
    {
        "instruction": "Create a function that takes no arguments and returns a scalar floating-point value representing zero."
    },
    {
        "instruction": "Implement a function that accepts a floating-point number. Inside the function, convert this number to its integer representation (truncating any decimal part). Return the resulting integer."
    },
    {
        "instruction": "Create a function that accepts a shape tuple (e.g., `(N,)` for a 1D array) and an integer index `i`. It should return a new 1D numerical array of the specified shape, filled with zeros, but with the floating-point value `1.0` placed at index `i`. Assume `i` is a valid index for the shape."
    },
    {
        "instruction": "Implement a function that takes an input numerical array (e.g., shape `(4, 1)`) and reshapes it into a specified output shape (e.g., `(2, 2)`). The function should return the reshaped array."
    },
    {
        "instruction": "Implement a function that calculates the gradient components for the function `f(x, y) = x + y`. It should return the partial derivative with respect to `x` and the partial derivative with respect to `y` as numerical values."
    },
    {
        "instruction": "Create a function that accepts a tuple representing dimensions (e.g., `(2, 3)`) and returns a multi-dimensional numerical array of those dimensions filled entirely with zeros."
    },
    {
        "instruction": "Develop a function that receives a single value as input and returns `True` if the value is of an integer type, and `False` otherwise."
    },
    {
        "instruction": "Create a function that takes a boolean input. It should always return a single floating-point number equal to `0.0`, regardless of the boolean input value. Ensure the output is a scalar float."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array `data` and an integer index `idx`. The function should return two values: first, the element `data[idx]`, and second, a new array of the same size as `data` indicating which input element was selected (1.0 at `idx`, 0.0 elsewhere)."
    },
    {
        "instruction": "Implement a function that takes two integers, `size` and `index`. It should return a list of numbers of length `size`, containing `0.0` at all positions except for a `1.0` at the position specified by `index`. Assume `0 <= index < size`."
    },
    {
        "instruction": "Develop a function that takes an existing 2D numerical array (matrix) filled with zeros and reshapes it. The function accepts the input matrix and two target dimensions (`target_rows`, `target_cols`). It should return a new matrix of zeros with the target dimensions. Ensure the total number of elements remains constant."
    },
    {
        "instruction": "Write a function `is_restricted_zero(value)` that returns `True` if the input `value` represents a special 'restricted zero' type (which cannot be used in arithmetic) and `False` otherwise. Assume a way to distinguish this special type exists (e.g., it's a specific predefined constant or object)."
    },
    {
        "instruction": "Develop a function that takes an existing numerical array and a target data type string (e.g., 'float64', 'int32'). It should return a *new* array containing the original values converted to the specified target data type."
    },
    {
        "instruction": "Create a function that takes two 1D numerical arrays of the same length and returns a new 1D array where each element is the sum of the corresponding elements from the input arrays."
    },
    {
        "instruction": "Implement a function that receives a sequence (list/tuple) of processing rules and a target function. Verify if the number of rules in the sequence matches the number of positional arguments expected by the target function. If they mismatch, raise a `ValueError` detailing the discrepancy (e.g., \"Expected N arguments but got M rules.\"). Otherwise, return `True`."
    },
    {
        "instruction": "Create a function that takes two arguments: a value and a required type object (like `int` or `str`). If the provided value is not an instance of the required type, raise a `TypeError`. Otherwise, return `True`."
    },
    {
        "instruction": "Implement a function `process_with_axis` that takes `data` (e.g., a list) and an `axis_specifier`. Check if `axis_specifier` is an integer. If it's specifically a boolean value (`True` or `False`), raise a `TypeError` explaining that the axis specifier needs to be an integer index, not a boolean. If it is a non-boolean, non-integer type, raise a generic `TypeError`. If it is an integer, return `True`."
    },
    {
        "instruction": "Implement a function `validate_structure` that takes two arguments, `reference` and `value`. It should check if `value` has the same basic structure (scalar vs. 1D sequence) and shape (length if 1D sequence) as `reference`. Additionally, it must verify that `value` (if scalar) or all elements in `value` (if 1D sequence) are floating-point numbers. If the structure/shape mismatch, raise `ValueError(\"Inconsistent structure\")`. If the type requirement isn't met, raise `TypeError(\"Requires floating-point type\")`. If both checks pass, return `True`."
    },
    {
        "instruction": "Create a function `get_specific_device` that takes a list of available device identifiers (strings like 'cpu:0', 'cpu:1', 'gpu:0') and a desired type (e.g., 'cpu'). It should return the identifier of the *last* device matching that type in the list. Return `None` if no matching device is found."
    },
    {
        "instruction": "Write a function that takes two square 2D numerical arrays of the same dimensions and returns their matrix product."
    },
    {
        "instruction": "Create a function that takes an object and a target substring as input. It should return `True` if the string representation of the object contains the target substring, and `False` otherwise."
    },
    {
        "instruction": "Write a higher-order function `apply_and_report` that accepts another function `target_func`. `apply_and_report` should execute `target_func`. If `target_func` modifies a variable defined *outside* its own immediate scope, `apply_and_report` should return `True`, otherwise `False`. Assume a mechanism exists to detect such modifications."
    },
    {
        "instruction": "Develop a function that takes a simple data structure (e.g., a tuple containing a mix of numbers and 1D numerical arrays) and generates a concise string representation describing its structure and the data types of its elements. For example, `(1.0, [0.0, 0.0])` might be represented as `\"tuple(float, array<float>[2])\"`."
    },
    {
        "instruction": "Design a function that receives a description of a simple computational process involving basic arithmetic on a scalar and fixed array creation. Given a description of the input scalar's type, the function should trace the operations to determine and return a structured representation (similar to Task 4) of the shape and data type for *each* output of the process. Handle cases where the process returns multiple outputs."
    },
    {
        "instruction": "Write a function that accepts two arguments, potentially of different numerical types (e.g., integer, float), and returns them unchanged as a pair (tuple)."
    },
    {
        "instruction": "Write a function that takes a scalar float and a scalar integer as input. It should return a tuple containing two scalar values: the constant float `2.0` and a scalar zero value (e.g., `0.0` or `0`)."
    },
    {
        "instruction": "Implement a function that takes another function `f` and a list of data items. It should apply `f` individually to each item in the list, collecting and returning the results in a new list. Ensure `f` is called exactly once per item."
    },
    {
        "instruction": "Implement a function that simulates generating fixed-shape 'gradient' outputs. Regardless of any input arguments (like original input shapes), this function should always return two specific numerical arrays, both initialized to zeros and having a predefined shape, for example, a 1D array of size 3."
    },
    {
        "instruction": "Implement a function `apply_rules` that takes two numerical arrays, `input_a` and `input_b`. It should internally call a predefined 'forward rule' (which just returns `input_a`) and a predefined 'backward rule'. The 'backward rule' ignores its input and returns two fixed arrays: `arr_k` of shape (K,) and `arr_l` of shape (L,) filled with zeros (where K and L are predefined constants). `apply_rules` should execute both rules and return the `arr_l` obtained from the 'backward rule'."
    },
    {
        "instruction": "Implement a function that transforms a 1D numerical array `x` based on a specific projection algorithm. The steps are: 1. Sort `x` descendingly to get `u`. 2. Compute `cssv`, the cumulative sum of `u`. 3. Find the largest index `k` (1-based) such that `u[k-1] - (cssv[k-1] - 1.0) / k > 0`. 4. Calculate `threshold = (cssv[k-1] - 1.0) / k`. 5. Return a new array where each element is `max(0, x_i - threshold)`. Input: 1D numerical array. Output: 1D numerical array."
    },
    {
        "instruction": "Design a mechanism (e.g., a class or a function returning multiple functions) to bundle together a primary calculation function and its sensitivity analysis. The primary function, `calc(x, y)`, should compute `x + y * 0.1`. The sensitivity function, `sensitivity(x, y)`, should return a tuple representing the rates of change of `calc` with respect to `x` and `y`. Implement this mechanism and provide the specific `calc` and `sensitivity` functions for the expression `x + y * 0.1`."
    },
    {
        "instruction": "Design a pair of functions, `forward_pass` and `backward_pass`. `forward_pass` takes two numerical inputs, `a` and `b`. It computes `result = cos(a + b)` and returns both `result` and a tuple `(a, b)` for saving. `backward_pass` takes the saved tuple `(a, b)` and an incoming `gradient_signal` (a numerical value). It should return a tuple representing derived values for the original inputs `a` and `b`, calculated as `(17.0 * a, 42.0 * b)`."
    },
    {
        "instruction": "Write a function that takes three 1D numerical arrays of the same size (c, s, x) and computes the scalar value corresponding to the sum of `s[i] * (x[i] - c[i])**2` for all elements `i`."
    },
    {
        "instruction": "Write a function `approximate_sensitivity` that takes four scalar inputs: a primary value `x`, a secondary value `y`, a small change `dx`, and a small change `dy`. The function should first compute the baseline result `res1 = x + x / y`. Then, compute the perturbed result `res2 = (x + dx) + (x + dx) / (y + dy)`. Finally, return the difference `res2 - res1`, which approximates how the output changes based on small input changes. Handle potential division by zero."
    },
    {
        "instruction": "Write a function `define_identity_op(registry, op_name)` that takes an `OperationRegistry` instance (from Task 2) and an operation name (string). It should register two rules for `op_name`: an 'evaluate' rule and a 'derivative' rule. Both registered functions should simply return their input argument unchanged (implementing the identity function). Use the `register_rule` method of the provided registry."
    },
    {
        "instruction": "Develop a higher-order function `enforce_return_type` that takes an expected type (e.g., `tuple`, `list`) and a function `target_func`. It should return a *new* function. This new function, when called with arbitrary arguments, will execute `target_func` with those arguments, check if the result is an instance of the `expected_type`, raise a `TypeError` if the check fails, and return the result otherwise."
    },
    {
        "instruction": "Create a function that accepts a numerical input. Inside the function, convert the input to a 32-bit floating-point number, multiply it by the constant 1.0 (also represented as a 32-bit float), and return the final 32-bit float result."
    },
    {
        "instruction": "Create a function registry mechanism. Implement two functions: `register_function(name, func, requires_rule=False)` and `call_registered_function(name, arg)`. `register_function` stores the function `func` under `name` along with the `requires_rule` flag. `call_registered_function` retrieves the function by name. If the function exists but its `requires_rule` flag is `True` and no rule has been associated (you'll need a third function, `associate_rule(name, rule_func)`, not required for this task itself, just assume its existence for the check), `call_registered_function` should raise a `LookupError`. Otherwise, it calls the function with `arg` and returns the result."
    },
    {
        "instruction": "Implement a function that iteratively updates a list/array of numbers. It takes an initial list/array `c_init` and a number of iterations `N`. In each iteration, it applies the transformation described in Task 3 to the current list/array to get the next state. Return the final list/array after `N` iterations."
    },
    {
        "instruction": "Implement a function that takes another function `f` and an argument `x`. It should execute `f(x)`. If `f(x)` raises any error during execution, the function must catch the error and return `None`. Otherwise, it should return the result of `f(x)`."
    },
    {
        "instruction": "Implement a function `create_optimized_derivative_evaluator`. It accepts an `original_func` (e.g., `x -> x*x`) which internally tracks its execution count (e.g., increments a counter or appends to a list). `create_optimized_derivative_evaluator` should return a *new* function, `derivative_evaluator`. When `derivative_evaluator` is called multiple times with different inputs (e.g., `derivative_evaluator(1.0)`, then `derivative_evaluator(2.0)`), it must return the correct derivative values, but the execution count of the `original_func` should increment only once across all calls to `derivative_evaluator`."
    },
    {
        "instruction": "Implement a function that takes a numerical array (1D or 2D) and returns the size of its first dimension. For a 1D array, this is its length; for a 2D array, this is the number of rows."
    },
    {
        "instruction": "Write a function `apply_sum_if_valid` that takes two arguments, `x` and `y`. It should also receive a configuration flag, `y_must_be_positional`. If this flag is `True`, the function *must* be called with `y` as a positional argument (not keyword). If this rule is violated, raise a `TypeError`. Otherwise, return the sum of `x` and `y`. (Hint: You might need to inspect how the function was called). *This task is tricky without inspecting call stack/signature introspection, maybe rephrase.* Let's rephrase: Write a function `apply_sum_with_rule` that takes `*args` and `**kwargs`. It expects exactly two inputs conceptually named 'x' (index 0) and 'y' (index 1). It also takes a rule: `y_must_be_positional: bool`. If `y_must_be_positional` is True, check if `len(args)` is at least 2. If not, raise `ValueError`. If the rule is met (or `y_must_be_positional` is False), find 'x' (either `args[0]` or `kwargs['x']`) and 'y' (either `args[1]` if available, or `kwargs['y']`) and return their sum. Handle potential errors if arguments are missing."
    },
    {
        "instruction": "Create a function that takes two 2D numerical arrays, `A` and `B`, and returns a single scalar value equal to the product of the sum of elements of `A` and the sum of elements of `B`."
    },
    {
        "instruction": "Write a function that takes two numerical inputs, `a` and `b`, and returns their product `a * b`."
    },
    {
        "instruction": "Create a function that takes one argument `x` of any basic type and returns a tuple containing that argument repeated twice, like `(x, x)`."
    },
    {
        "instruction": "Create a function that accepts one argument of any type but always returns an empty tuple, effectively ignoring the input."
    },
    {
        "instruction": "Design a function `compute_and_analyze` that takes a numerical input `x`. It first computes `y = operation_b(operation_a(x))` where `operation_a` and `operation_b` are simple arithmetic functions you define (e.g., `a(z)=z+1`, `b(z)=z*z`). Then, it simulates a \"reverse\" computation path based on `y` and `x` that logically requires more conditional checks or iterative steps than the forward path. The function should return a tuple containing: (a) the forward result `y`, and (b) a boolean indicating whether the simulated reverse path representation included keywords like \"IF\" or \"WHILE\"."
    },
    {
        "instruction": "Implement a function `process_input` that takes one numerical argument. Inside `process_input`, call a separate helper function `calculate_values` (which you must also define). `calculate_values` should take the number, compute `sin(sin(number))`, and return this result along with a constant number (e.g., 3.0) as a tuple. The `process_input` function should then call `calculate_values`, receive the tuple, ignore the constant, and return only the `sin(sin(number))` value."
    },
    {
        "instruction": "Write a function `group_sum` that accepts a single numerical value `val` and an integer `group_size`. It should return the result of summing `val` with itself `group_size` times (equivalent to `val * group_size`)."
    },
    {
        "instruction": "Write a function `check_for_value_error` that takes another function `target_func` (which takes no arguments) as input. It should call `target_func()` within a try-except block. If a `ValueError` occurs during the call, return `True`, otherwise return `False`."
    },
    {
        "instruction": "Create a function `apply_operation(operation, data)` where `operation` is a function taking one numerical argument, and `data` is a numerical value. The function should return the result of `operation(data)`."
    },
    {
        "instruction": "Write a function `apply_custom_diff_rule_elementwise(scalar_a, vector_b, vector_b_direction)` that applies a custom multiplication-and-derivative rule element-wise. For each corresponding element `b_i` from `vector_b` and `b_dot_i` from `vector_b_direction`, it should compute `scalar_a * b_i` and `scalar_a * b_dot_i`. The function must return two 1D numerical arrays of the same size as the inputs: one containing all the products and one containing all the directional derivatives. `scalar_a` is a scalar, `vector_b` and `vector_b_direction` are 1D numerical arrays."
    },
    {
        "instruction": "Create two functions: `func_A` takes a number `x` and returns `x * 2`. `func_B` takes a number `y` and returns `y + 3`. Write a third function `combined_func` that takes a number `z`, applies `func_A` to it, and then applies `func_B` to the result, returning the final value."
    },
    {
        "instruction": "Write a function that simulates a collective sum. It takes a numerical scalar value and an integer representing the size of a group. Assume the function is called conceptually by all members of the group, each providing the same value. Return the total sum across the group."
    },
    {
        "instruction": "Write a function that accepts two numerical scalar inputs and returns their product."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new array where each element is the square of the corresponding input element."
    },
    {
        "instruction": "Write a higher-order function that takes another function `func`, a primary numerical input `x`, and a tangent numerical input `t`. Assume `func(x)` returns a tuple `(y, aux)` where `y` is the main result and `aux` is some auxiliary data. Your function should compute the directional derivative of the main result `y` with respect to `x` in the direction `t`. Return a tuple containing the main result `y` and its computed directional derivative `y_dot`. You might need to numerically approximate the derivative if symbolic differentiation is not available."
    },
    {
        "instruction": "Develop a function that generates a 2D array (matrix) of a specified size (rows, columns) filled with random integers between a given minimum and maximum value (inclusive)."
    },
    {
        "instruction": "Write a function that takes a 1D array of complex numbers `z`. Inside the function, calculate `v = 2 * z`, then compute the L2 norm `n = ||v||`, and finally return `cos(n)`. The input is a 1D complex array, and the output is a single real scalar."
    },
    {
        "instruction": "Design a function that takes a scalar number `x`. It should conditionally execute one of two provided single-argument sub-functions (`f1`, `f2`) based on whether `x > 0`. Return *both* the result of the chosen sub-function evaluated at `x` *and* the value of its first derivative evaluated at `x`. Assume the derivatives of `f1` and `f2` are known or can be computed."
    },
    {
        "instruction": "Create a function that accepts a boolean condition, two callable functions (func_true, func_false), and a single data argument. If the condition evaluates to true, the function should call func_true with the data argument and return its result. Otherwise, it should call func_false with the data argument and return its result."
    },
    {
        "instruction": "Implement a function that performs matrix multiplication between a 1D numerical array (vector, shape N) and a 2D numerical array (matrix, shape N x N), ensuring the calculation uses the highest possible numerical precision available in the environment. The function should return the resulting 1D array (shape N)."
    },
    {
        "instruction": "Write a function that simulates a sequential computation pipeline. It takes a list of functions `[step1, step2, ..., stepN]`, an initial value `v0`, and a policy function `should_store(step_index) -> bool` (where step_index is 0-based). The function should compute `v1 = step1(v0)`, `v2 = step2(v1)`, ..., `vN = stepN(vN-1)`. It must return the final value `vN` and also a dictionary mapping step indices `i` (where `should_store(i)` was true) to their corresponding computed intermediate values `v{i+1}`."
    },
    {
        "instruction": "Implement a function `apply_twice_conditionally`. It takes a scalar number `x` and a function `f`. It first applies `f` to `x` only if `x` is positive (otherwise `x` remains unchanged). Then, it applies `f` to the result of the first step, again, only if that intermediate result is positive (otherwise the intermediate result remains unchanged). Return the final result."
    },
    {
        "instruction": "Write a function `apply_conditionally(condition, func_true, func_false, value)`. It takes a boolean `condition`, two single-argument functions `func_true` and `func_false`, and a `value`. If `condition` is true, it returns the result of `func_true(value)`; otherwise, it returns the result of `func_false(value)`."
    },
    {
        "instruction": "Write a function that takes a single floating-point number as input and returns `True` if the number is non-negative (greater than or equal to zero), and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a single number as input. If the number is positive, return True; otherwise, return False."
    },
    {
        "instruction": "Create a function that accepts a single numerical input `x` and returns the result of applying the sine function to it."
    },
    {
        "instruction": "Create a function `apply_repeatedly` that takes an initial `state`, a function `update_func`, and the number of repetitions `N`. `update_func` should accept the current `state` and return the new `state`. `apply_repeatedly` must call `update_func` exactly `N` times, passing the output of one call as the input to the next. Return the final `state`."
    },
    {
        "instruction": "Implement a function `detect_list_modification`. It takes two arguments: a target function `func` and a list `monitored_list`. The `detect_list_modification` function should execute `func()`. It must return `True` if `func` appended any elements to `monitored_list` during its execution, and `False` otherwise. Assume `func` takes no arguments."
    },
    {
        "instruction": "Develop a function that generates a sequence of floating-point numbers. Given an integer N, it should return a 1D array containing numbers from 0.0 up to (but not including) N, with increments of 1.0 (e.g., N=3 -> [0.0, 1.0, 2.0])."
    },
    {
        "instruction": "Define a function named `process_item` that takes two arguments: `state` and `item`. This function should return a tuple where the first element is the original `state` unchanged, and the second element is always `None`."
    },
    {
        "instruction": "Write a function that takes a single numerical value 'x' and an integer 'n'. It should apply the sine function iteratively 'n' times, starting with 'x', and return the final numerical result."
    },
    {
        "instruction": "Implement a function simulating one step of an update process. It takes a 2D numerical array `R` and a scalar `D`. Inside the function, calculate an intermediate array `F = D * R`. Then, compute the updated array `R_new = R + 0.001 * F`. Return `R_new`."
    },
    {
        "instruction": "Write a function that computes the numerical derivative (sensitivity) of a composite function's output with respect to its initial input. The composite function is defined as follows: it takes an initial numerical value `x0`, applies a fixed transformation function `g` (e.g., `g(y) = y + 1`) exactly `N` times sequentially. Your function should calculate how the final result changes for a tiny change in `x0`, effectively finding the derivative of the N-step process evaluated at `x0`."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number and returns its sine value."
    },
    {
        "instruction": "Develop a function `apply_sequence_selectively(initial_value, functions, save_indices)`. It takes a numerical `initial_value`, a list of function objects `functions` (each taking one numerical argument and returning one), and a set/list of integer indices `save_indices`. Apply each function sequentially. Return a tuple containing the final numerical result and a dictionary mapping each index `i` in `save_indices` to the result *after* applying the function at that index `i`."
    },
    {
        "instruction": "Create a function that accepts a list of numbers `c`. It should return a new list where the first element is the same as the first element of `c`, and all subsequent elements are the sums of adjacent pairs in the input list `c`. For input `[a, b, c, d]`, the output should be `[a, a+b, b+c, c+d]`."
    },
    {
        "instruction": "Create a function that accepts a list of numbers `L`. It should return a new list where the first element is `L[0]`, and the element at index `i` (for `i > 0`) is the product of `L[i-1]` and `L[i]`. The output list will have the same length as the input list."
    },
    {
        "instruction": "Write a generic function that simulates a stateful iterative process over a sequence. It takes an initial state (e.g., a list) and applies an update function in a loop for N steps, where N is the length of the initial sequence. In each step, it also uses a separate function to derive an output value from the state *before* the update. It collects these output values. Return the list of collected output values. Demonstrate its use where the state is a list, the update is a right circular shift, and the output derivation is getting the last element. Input: `initial_state`, `update_function`, `output_function`. Output: `list_of_outputs`."
    },
    {
        "instruction": "Write a function `select_outputs` that takes a tuple of arbitrary values and a list of booleans of the same length. It should return a new tuple containing only the values from the input tuple where the corresponding boolean in the list is `True`. Maintain the relative order of the selected elements."
    },
    {
        "instruction": "Design a function that simulates Dead Code Elimination (DCE) on a simple, ordered list of computational steps. Each step defines output variables based on input variables (which must be defined by previous steps or be initial inputs). Given the list of steps and a set of required final output variables, return a new list containing only the steps necessary to compute those outputs, preserving their original order."
    },
    {
        "instruction": "Create a function that accepts a tuple containing two numbers. Return a new tuple where the first element is the input's first element, and the second element is the sum of the two input numbers."
    },
    {
        "instruction": "Write a function that implements the Rectified Linear Unit (ReLU). It takes a numerical array and returns a new array where each element is the maximum of the corresponding input element and zero."
    },
    {
        "instruction": "Write a function that repeatedly executes a given calculation function. It takes a function `calc_func` (which accepts no arguments and returns a numerical value) and an integer `count`. Call `calc_func` exactly `count` times and return a list containing all the returned values."
    },
    {
        "instruction": "Implement a function simulating a sequential process. It takes an initial state (a 2D numerical array), a number of steps `k`, and an update function. The update function accepts the current state array and returns a potentially modified state array. Apply the update function iteratively `k` times, starting with the initial state, and return the state array after the final step."
    },
    {
        "instruction": "Create a function simulating the gradient calculation for element-wise multiplication (`output = array * scalar`). It accepts the original `array`, the original `scalar`, and an incoming gradient `g` (same shape as `array`). It should return two values: the gradient for the `array` (element-wise `g * scalar`) and the gradient for the `scalar` (the sum of all elements in `array * g`)."
    },
    {
        "instruction": "Write a function `calculate_value` that takes three integer arguments `x`, `y`, `z` and returns the integer computed as `100*x + 10*y + z`."
    },
    {
        "instruction": "Implement a function `recursive_compose(funcs)` that takes a list of single-argument numerical functions `funcs`. If the list contains zero or one function, return a function that reflects that (identity for zero, the function itself for one). Otherwise, split the list into two halves (first half, second half). Recursively call `recursive_compose` on each half to get two composed functions, `comp1` and `comp2`. Return a *new* function that computes `comp1(comp2(x))` when called."
    },
    {
        "instruction": "Write a function that takes two positive integers, `rows` and `cols`, and returns a 2D numerical array of shape (`rows`, `cols`) where every element is initialized to 1.0."
    },
    {
        "instruction": "Write a function `infer_shape_identity` that takes two arguments: a function `func` and an input specification object `inp_spec`. `inp_spec` has a `shape` attribute (tuple). Assume `func` conceptually represents an operation that does not change the shape (like an identity operation). Return a new output specification object containing a `shape` attribute identical to `inp_spec.shape`."
    },
    {
        "instruction": "Design a function that takes a mutable container (like a list) holding a single generator key state. Inside the function, split the key (using logic similar to Task 2), generate a scalar value using one derived key (like Task 3), and update the key state within the container to the *other* derived key. The function should return the generated scalar value."
    },
    {
        "instruction": "Write a function that accepts a list of numbers (e.g., `[7, 14]`) and returns a 1D numerical array containing those numbers, ensuring the elements are stored as floating-point values."
    },
    {
        "instruction": "Create a higher-order function `vectorize_over_arg`. This function takes another function `f` and an argument index `idx` as input. It returns a *new* function, `vectorized_f`. When `vectorized_f` is called with arguments, it expects the argument at index `idx` to be a sequence (e.g., a list). `vectorized_f` should then call `f` multiple times, once for each item in the sequence passed at index `idx`, keeping all other arguments fixed for each call. Finally, `vectorized_f` should return a list containing the results of all these calls."
    },
    {
        "instruction": "Write a function that accepts two scalar numerical inputs and returns a tuple containing two fixed values: `(1.0, 0.0)`. This represents the sensitivity of a hypothetical first output with respect to both inputs."
    },
    {
        "instruction": "Implement a function that calculates the mathematical exponential (`e^x`) for a given scalar numerical input `x`."
    },
    {
        "instruction": "Create a function that accepts two inputs. It should return `True` if both inputs are strings, and `False` otherwise."
    },
    {
        "instruction": "Implement a simple counter class `CallTracker` with an `increment()` method which increases an internal count by one, and a `get_count()` method which returns the current count. The count should start at zero."
    },
    {
        "instruction": "Write a function that accepts a 1D numerical array and returns a new 1D array where each element is the corresponding input element multiplied by 2."
    },
    {
        "instruction": "Implement a simple tracking system. Provide a function `record_event(event_id)` where `event_id` is a unique identifier (e.g., string or number). The system must keep track of all the unique `event_id`s it has recorded. Provide another function `get_unique_event_count()` that returns the total number of distinct `event_id`s recorded so far."
    },
    {
        "instruction": "Write a function that computes the analytical derivative of `f(x) = x**3 * sin(x)` with respect to `x`. The function should take a single floating-point number `x` as input and return the calculated derivative value evaluated at `x`."
    },
    {
        "instruction": "Create a function `compute_derivative_of_processed_value`. This function takes a scalar float `x`. Inside, it first calls a helper function `process(y)` (which you also need to define) that takes a scalar `y` and returns two values: `result1` (e.g., `y**3`) and `result2` (e.g., `[y**3]`). `compute_derivative_of_processed_value` should then calculate and return the mathematical derivative of `result2[0]` (considered as a function of the original input `x`) evaluated at `x`."
    },
    {
        "instruction": "Write a function `verify_functions(func1, func2, input_val, tolerance)` that takes two functions (`func1`, `func2`), a numerical input value (`input_val`), and a small numerical tolerance. It should call both functions with the input value and return `True` if the absolute difference between their numerical outputs is less than or equal to the tolerance, and `False` otherwise."
    },
    {
        "instruction": "Develop a function that attempts to call a provided function `op` with a given value `val`. If calling `op(val)` raises a `TypeError`, the function should catch this specific error and return the boolean `True`. Otherwise (if no `TypeError` occurs), it should return `False`."
    },
    {
        "instruction": "Write a function that accepts a complex number as input and returns its real and imaginary parts as two separate floating-point numbers."
    },
    {
        "instruction": "Create a function that takes another function `f` and a value `val` as input. It should call `f(val)`. If the result of `f(val)` is a complex number, this function must raise a `TypeError`. Otherwise, it should return the result."
    },
    {
        "instruction": "Write a function that accepts a single numerical input. If the input is a complex number, the function should raise a `TypeError`. Otherwise, it should return the input unchanged."
    },
    {
        "instruction": "Implement a function that takes a numerical input `x`, calculates the cosine of `x`, and then returns the sine of that result."
    },
    {
        "instruction": "Implement a function that accepts a primary function `f` (operating on floats) and returns a *new* function `g`. This new function `g`, when called with `x`, should execute `f(x)`. Demonstrate creating `g` from `f` (e.g., where `f` computes the sine) and then calling `g` with at least two different input values."
    },
    {
        "instruction": "Create a function that calculates the trigonometric sine of a single numerical scalar input (assuming input is in radians) and returns the result."
    },
    {
        "instruction": "Develop a system with two functions: one to record ('log') string messages to an internal list, and another to check if the number of recorded messages exactly matches a given integer count. The checking function should return `True` or `False`."
    },
    {
        "instruction": "Implement a function that takes a list of numerical values and an integer `k`. It should return a new list where the exponential function (`e^x`) has been applied to the first `k` elements, and the sine function (`sin(x)`) has been applied to all subsequent elements."
    },
    {
        "instruction": "Write a function `evaluate_and_approx_derivative` that accepts two arguments: another function `func` (which takes one numerical argument and returns one numerical argument) and a numerical value `x`. This function should return a pair of values: first, the result of calling `func(x)`, and second, an approximation of the derivative of `func` at point `x` using the finite difference method (e.g., `(func(x + h) - func(x)) / h` for a small `h` like 1e-5)."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array (vector) and returns a 2D square array (matrix) where the input vector elements form the main diagonal and all other elements are zero."
    },
    {
        "instruction": "Create a function `transpose_matrix(matrix)` that accepts a 2D numerical array (matrix) with dimensions M rows and N columns. It should return the transpose of the matrix, which will have dimensions N rows and M columns."
    },
    {
        "instruction": "Write a function that takes two single-variable numerical functions, `f1` and `f2`, and a floating-point number `x`. It should numerically compute the second derivative of both `f1` and `f2` at `x` (using a suitable finite difference method). Return `True` if the absolute difference between the two computed second derivatives is less than a specified tolerance (e.g., 1e-5), and `False` otherwise."
    },
    {
        "instruction": "Implement a function that computes both the value `f(x)` and the product of its derivative `f'(x)` with a given numerical tangent `v` for the specific function `f(x) = sin(sin(x) * sin(x))`. The function should accept the input number `x` and the tangent number `v`, returning a pair of numbers: `(value, derivative_product)`."
    },
    {
        "instruction": "Write a function that takes a scalar numerical input `x` and two unary numerical functions, `f` and `g`. The function should compute `f(g(x))` and return the scalar result."
    },
    {
        "instruction": "Create a function that accepts a square 2D numerical array (matrix) and returns its square (the result of multiplying the matrix by itself)."
    },
    {
        "instruction": "Develop a function that accepts a square 2D numerical array. It should repeatedly apply the following two steps three times in order: first, multiply the current matrix by itself; second, apply the element-wise sine function to the result. Return the matrix after these six operations."
    },
    {
        "instruction": "Implement a function that performs batch matrix multiplication. It should accept two 3D numerical arrays, `A` of shape `(N, I, J)` and `B` of shape `(N, J, K)`, and return a 3D array `C` of shape `(N, I, K)` such that `C[n, :, :]` is the matrix product of `A[n, :, :]` and `B[n, :, :]` for each `n` from 0 to N-1."
    },
    {
        "instruction": "Implement a function that takes a square 2D numerical array. First, multiply the matrix by itself. Then, scale each element of the resulting matrix by 0.001 and compute the sine of each element. Return the final 2D array."
    },
    {
        "instruction": "Create a function that accepts two 2D numerical arrays of the same shape and returns a new 2D array representing their element-wise product."
    },
    {
        "instruction": "Develop a function that simulates tracking a named value within a calculation. It takes a calculation function `calc` and its inputs. Assume `calc` internally calls a special (hypothetical) function `tag_value(value, name)` exactly once. Your function should execute `calc` and return a tuple containing the shape of the tagged value and the name it was given (e.g., `((), \"result_name\")`)."
    },
    {
        "instruction": "Create a function that accepts a sequence containing exactly two numbers `x` and a single number `y` provided as a keyword argument. Return the product `x[0] * x[1] * y`."
    },
    {
        "instruction": "Create a function that accepts a tuple containing an integer counter and a numerical value `x`. It should return a new tuple where the counter is incremented by 1 and the sine of `x` is computed as the new value. Input: tuple (integer, number). Output: tuple (integer, number)."
    },
    {
        "instruction": "Develop a function that accepts an initial state represented as a tuple `(index, data_value)`. It also takes a condition function (checks the index) and an update function (modifies the tuple). Repeatedly apply the update function to the state as long as the condition function returns true. Return the final state."
    },
    {
        "instruction": "Implement a function that simulates conditional processing based on operation type. It takes a list of operation names (strings, e.g., ['apply_filter', 'transform_data', 'calculate_sum']) and a target operation name (string). It should return a list of booleans, where each boolean indicates if the corresponding operation name in the input list matches the target operation name."
    },
    {
        "instruction": "Develop a function that accepts a numerical input. It first applies a specific mathematical transformation (e.g., calculates the tangent) to the input, and then squares the outcome of that transformation. Return the final squared number."
    },
    {
        "instruction": "Design a simulator for an iterative analysis process. The simulator takes an initial list of required inputs (booleans) and a list representing subsequent analyses (each analysis specifies which results are needed, e.g., `[True, False]`). For each analysis step, it calls a provided \"rule function\" which takes the current required inputs and the analysis specification, logs the specification it received, and returns the *new* list of required inputs for the *next* step. The simulator returns the complete log of specifications received by the rule function across all steps."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `x` and returns a new array containing the cosine of each element in `x`."
    },
    {
        "instruction": "Write a function that accepts two arguments. It should return `True` if the first argument is an integer and the second argument is a list, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and returns a new 1D array where each element is the sine of the corresponding input element."
    },
    {
        "instruction": "Define a function that accepts a single number and returns a tuple. The first element of the tuple should be the sine of the input number, and the second element should be the boolean value `True`."
    },
    {
        "instruction": "Write a function that computes the sine of a single floating-point number."
    },
    {
        "instruction": "Implement a function that computes both the value and the directional derivative (scaled by a tangent) for the cosine function. Given a numerical input `x` and a corresponding tangent `t` (which can be scalars or arrays of the same shape), it should return two values: `cos(x)` and `-sin(x) * t`. Ensure calculations are performed element-wise if inputs are arrays."
    },
    {
        "instruction": "Develop a function that computes \"forward derivative\" information across batches. It takes four 1D numerical arrays `xs, ys, txs, tys` (all of length `N`). It should return two 1D arrays, `zs` and `tzs` (both length `N`), where `zs[i] = sin(xs[i]) + ys[i]` and `tzs[i] = cos(xs[i]) * txs[i] + tys[i]`."
    },
    {
        "instruction": "Write a function that takes a single scalar numerical input `x` and returns the cosine of `x`."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array and returns a new 1D array where each element is the cosine of the corresponding input element."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array and a scalar numerical value. Return a new 1D array where each element is the product of the corresponding element from the input array and the scalar value."
    },
    {
        "instruction": "Implement a function `apply_elementwise_fixed_arg(func, array_a, scalar_b)`. This function should take a function `func` (which accepts two scalar arguments and returns one scalar), a 1D numerical array `array_a`, and a scalar `scalar_b`. It should return a new 1D array where the i-th element is the result of `func(array_a[i], scalar_b)`."
    },
    {
        "instruction": "Develop a function that creates a 1D numerical array of floating-point numbers starting from 0.0 up to (but not including) a given integer `N`, with a step of 1.0. For example, if N=3, it should return `[0.0, 1.0, 2.0]`."
    },
    {
        "instruction": "Write a function `calculate_sine(x)` that accepts a single numerical input `x` and returns its sine."
    },
    {
        "instruction": "Write a function that orchestrates a forward and backward pass for gradient calculation. It accepts a 'forward_pass' function, a 'backward_pass' function (as defined in Task 4), initial inputs `x_val` and `y_val`, and a sensitivity value `ct_val`. It should first call `forward_pass(x_val, y_val)` to get the primary output and auxiliary data. Then, it must call `backward_pass` with the auxiliary data and `ct_val` to compute and return the final derived gradient components."
    },
    {
        "instruction": "Develop a function that computes a specific scalar value based on two input arrays. Input: A 2D numerical array `W` (shape M x N) and a 2D numerical array `V` (shape 1 x N). Calculate an intermediate array `S` by applying the element-wise sigmoid function to the result of element-wise multiplication of `W` and `V` (with `V` broadcasted). Output: The scalar sum of the squares of the element-wise differences between `S` and `V` (with `V` broadcasted)."
    },
    {
        "instruction": "Write a function that creates a simple data structure (e.g., a list containing a few numbers). Create a weak reference to this structure. Modify the original structure (e.g., add an element). Return the structure obtained by dereferencing the weak reference."
    },
    {
        "instruction": "Implement a function `apply_wrapper(func)` that takes a callable `func` and returns a new callable that invokes `func`. Create a class with a method `method_b`. In its `__init__`, store the result of `apply_wrapper(self.method_b)` in an instance attribute `self._wrapped_b`. Write a function to instantiate this class."
    },
    {
        "instruction": "Write a function `demonstrate_reference_survival`. Inside this function, create a list of numbers. Create a second variable that references the *same* list. Delete the first variable. Finally, return the list using the second variable."
    },
    {
        "instruction": "Write a function `execute_with_log(input_value, parameter)` that multiplies `input_value` by 10. It should also append the `parameter` to an external list `execution_log` *only* the first time it executes for a specific `parameter` value (use a set to track seen parameters). Return the multiplication result."
    },
    {
        "instruction": "Create a function that takes a dictionary mapping string keys to numerical array values. It should return a new dictionary with the same keys, where each corresponding value is a new array containing the doubled elements of the original array."
    },
    {
        "instruction": "Create a function that takes an arbitrary number of keyword arguments, where each argument is expected to be a dictionary. The function should return a new dictionary containing only the key-value pairs from the input dictionary passed via the keyword argument named 'config'. If no 'config' argument is provided, return an empty dictionary."
    },
    {
        "instruction": "Create a function that takes a dictionary as input. Inside the function, access and return the value associated with a specific key (e.g., 'a') from the input dictionary. Handle the case where the key might not exist gracefully (e.g., return None)."
    },
    {
        "instruction": "Write a function that takes a single floating-point number `x` as input. It should compute the square root of `x` squared, add 1.0 to the result, and return this final floating-point value."
    },
    {
        "instruction": "Write a function that accepts a single scalar floating-point number as input and returns its value multiplied by 2."
    },
    {
        "instruction": "Develop a function that takes one argument. It should return `True` if the argument is a single numerical value (integer or float) and `False` otherwise (e.g., if it's a list, string, tuple, etc.)."
    },
    {
        "instruction": "Implement a function that takes one numerical input and returns the result of adding zero to it."
    },
    {
        "instruction": "Implement a function that takes a numerical value `val` and a configuration object `config`. The function should conceptually associate `val` with the rules defined in `config` without altering `val`'s value, and then return `val`."
    },
    {
        "instruction": "Write a function `check_if_scalar(value)` that takes one argument and returns `True` if the argument is a single numerical value (integer or float) and `False` otherwise (e.g., if it's a list, tuple, string)."
    },
    {
        "instruction": "Design a function `checked_execution` that takes three arguments: a callable function `op`, a value `arg`, and a string `expected_arg_type`. Before executing `op(arg)`, check if the type of `arg` matches `expected_arg_type`. If it matches, return the result of `op(arg)`. If it doesn't match, raise a TypeError indicating the type mismatch (e.g., 'Argument type mismatch: expected <expected_arg_type>, got <actual_type>')."
    },
    {
        "instruction": "Create a function that accepts a variable number of positional arguments (*args). The function should return the first argument provided, or handle the case where no arguments are given (e.g., return a default value or raise an error)."
    },
    {
        "instruction": "Create a function that accepts a variable number of positional arguments and returns the total count of arguments received."
    },
    {
        "instruction": "Implement a function that takes a variable number of numerical arguments (*args). It must extract the first argument, add 4.0 to it, and return the floating-point result. Other arguments should be ignored."
    },
    {
        "instruction": "Write a function that accepts a single floating-point number as input and returns that number plus the constant value 4.0."
    },
    {
        "instruction": "Design a system (e.g., a class) that takes a simple mathematical function (e.g., one argument, simple arithmetic) as input. Implement a method that simulates preparing this function for execution using a sample input value. This method should return an object representing the prepared function."
    },
    {
        "instruction": "Extend the `analyze_operation` function from Task 3. Add a parameter `description_format` (a string). The function should return the textual description in the specified format (e.g., 'basic', 'detailed'). If the format is unsupported or analysis fails, return `None`."
    },
    {
        "instruction": "Create a function that takes two arguments: a main string and a substring. It should return True if the substring is found anywhere within the main string, and False otherwise."
    },
    {
        "instruction": "Write a function that accepts two numerical inputs, `x` and `y`, and returns their sum."
    },
    {
        "instruction": "Create a function that takes a single numerical input and returns the result of adding a predefined constant (e.g., 4) to it."
    },
    {
        "instruction": "Write a function that accepts a single argument of any basic data type (like number, string) and returns that argument unchanged."
    },
    {
        "instruction": "Develop a function that accepts another function `f` (assume `f` takes one argument) as input. The function should return a simple string description of `f`, for example, \"Represents a transformation function\". Do not execute `f`."
    },
    {
        "instruction": "Create a function `add_four` that takes a single numerical input and returns the result of adding the integer 4 to it."
    },
    {
        "instruction": "Create a function that takes one numerical input and returns the result of adding the integer 4 to it."
    },
    {
        "instruction": "Create a function `define_prepare_analyze` that takes two inputs: a function `op` (accepting one numerical argument) and a numerical value `val`. Inside this function, it should first 'prepare' the function `op` (conceptually similar to Task 3), then 'analyze' the prepared function (conceptually similar to Task 4), and finally return the result of applying the original `op` to `val`."
    },
    {
        "instruction": "Write a function that accepts a single numerical value and returns it unchanged."
    },
    {
        "instruction": "Write a function that accepts a dictionary of settings (string keys, various value types) and a specific setting name (string). The function should return the value associated with that setting name in the dictionary. If the setting name is not found, it should return a predefined default value (e.g., None)."
    },
    {
        "instruction": "Develop a function that takes another function (with no arguments) as input. It should execute the input function and return `True` if the execution raises *any* kind of runtime error, and `False` if it executes without raising a runtime error."
    },
    {
        "instruction": "Write a function that accepts a single numerical input `x` and returns the result of calculating the absolute value of `x` plus 1.0."
    },
    {
        "instruction": "Develop a function that takes a single positive integer 'N' as input and returns a 1D numerical array containing the sequence of integers starting from 0 up to (but not including) 'N'."
    },
    {
        "instruction": "Design a function that takes a tuple representing dimensions (e.g., `(2, 4)`) and a string representing a data type (e.g., `\"float32\"`) and returns a simple object or dictionary containing these two pieces of information."
    },
    {
        "instruction": "Implement a simple registry system using a dictionary. Create a function `register_rule(identifier, rule_function)` that stores the `rule_function` associated with a given `identifier` (e.g., a string name). Also create a function `get_rule(identifier)` that retrieves the associated `rule_function` from the registry."
    },
    {
        "instruction": "Define a function that multiplies two scalar inputs. Additionally, provide two associated functions: a 'forward' function returning the product, and a 'backward' function that accepts an incoming gradient (corresponding to the product's gradient) and returns the gradient contributions for the *first* input only, treating the second input's gradient contribution as zero."
    },
    {
        "instruction": "Write a function that numerically estimates the gradient of a given scalar function `func(p1, p2)` which takes two scalar inputs. Your gradient function should accept `func`, and the points `p1`, `p2` at which to estimate the gradient. It should return a pair of values representing the approximate partial derivatives (\u2202func/\u2202p1, \u2202func/\u2202p2) at that point using a small step (e.g., finite differences)."
    },
    {
        "instruction": "Implement a function that receives a 1D numerical list. It should first create an independent copy of the list. Then, it should modify the first element of the *original* list to 77. The function should return the *unmodified copy*."
    },
    {
        "instruction": "Write a function that accepts two arguments: a function `f` (which takes one integer and returns one integer) and an integer `x`. Your function should call `f` with `x`, and return a tuple containing the result repeated twice."
    },
    {
        "instruction": "Implement a function that receives a callable object potentially created by nesting wrappers multiple times (e.g., wrapper(wrapper(original_function))). It should retrieve and return the name of the innermost, original function."
    },
    {
        "instruction": "Implement a function that takes a numerical array `arr` and a boolean `flag`. If `flag` is true, return the original array `arr`. If `flag` is false, return a new array with the same shape and data type as `arr`, but filled with zeros."
    },
    {
        "instruction": "Write a function that accepts two strings, `text_to_search` and `substring_to_find`. Return `True` if `substring_to_find` exists within `text_to_search`, and `False` otherwise."
    },
    {
        "instruction": "Create a function `create_zero_array(shape, use_special_type)` that returns a numerical array of the given `shape` filled with zeros. If `use_special_type` is `True`, the array should have the specific \"zero-dimension\" data type (from Task 4); otherwise, it should use the default floating-point type."
    },
    {
        "instruction": "Write a function that creates a multi-dimensional numerical array filled with zeros. The function should accept a tuple representing the desired shape and a string indicating the data type (e.g., 'float32', 'int64'). It should return the newly created zero-filled array."
    },
    {
        "instruction": "Create a function that takes a single Python number (int, float, complex) or boolean value. It should return a string indicating the canonical data type: \"int64\", \"float64\", \"complex128\", or \"bool\"."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array `x` of size 3. It should first construct a 4x4 matrix `H` where the top-left 3x3 submatrix is diagonal with elements `x[0]`, `x[1]`, `x[2]`, `H[3,3]` is 1.0, and other elements are 0. Then, it should create a 4-element vector `v` by appending 1.0 to `x`. Finally, it should compute and return the matrix-vector product of `H` and `v`."
    },
    {
        "instruction": "Implement a function that takes a single Python complex number (e.g., 3+4j). It should return the standard 128-bit complex data type corresponding to this input when stored in a numerical array."
    },
    {
        "instruction": "Create a function that takes two numerical arrays and an integer `axis` index. Calculate the vector dot product along the specified axis. Assume the arrays have the same size along this axis and identical shapes otherwise. Handle both positive and negative values for the `axis` index relative to the number of dimensions."
    },
    {
        "instruction": "Implement a function that multiplies a batch of matrices represented by a 3D array (B x M x N) by a single vector represented by a 1D array (N). The function should return a 2D array (B x M), where each row corresponds to the matrix-vector product for each matrix in the batch."
    },
    {
        "instruction": "Develop a function that takes two numerical arrays, `A` and `B`, with potentially different leading dimensions (batch dimensions). `A` has shape `(*batch_A, K)` and `B` has shape `(*batch_B, K, N)`. The function must compute the product `conjugate(A) @ B` following broadcasting rules for the batch dimensions. The output array should have a shape resulting from broadcasting `*batch_A` and `*batch_B`, followed by `(N,)`."
    },
    {
        "instruction": "Write a function that takes a list of operations (represented as strings or function objects) and an integer `k`. Generate all possible sequences of length `k` where each element in the sequence is chosen from the input list, allowing repetitions. Return a list containing all generated sequences."
    },
    {
        "instruction": "Implement a function that generates a sequence of `num` evenly spaced numerical values starting from `start` and ending at `stop` (inclusive). It should return a 1D numerical array."
    },
    {
        "instruction": "Implement a function that takes a start value, an end value, and an integer count `N`. It should return a 1D numerical array containing exactly `N` evenly spaced numbers, starting with the start value and ending with the end value (inclusive)."
    },
    {
        "instruction": "Create a function that takes two arrays of the same shape: a data array (numerical) and a condition array (boolean). Return a new 1D array containing only the elements from the data array where the corresponding element in the condition array is true."
    },
    {
        "instruction": "Develop a function that takes a numerical array of any dimension and a 1D boolean mask whose length equals the total number of elements in the array. Return a new 1D array containing elements from the (conceptually flattened) input array where the corresponding mask element is False."
    },
    {
        "instruction": "Write a function that accepts a multi-dimensional numerical array and a target shape (tuple of integers). Return `True` if the target shape has fewer dimensions (length of the shape tuple) than the array's shape, and `False` otherwise."
    },
    {
        "instruction": "Write a function `map_to_order_indices(array_with_specials)` that takes a 1D array containing floating-point numbers (potentially including `-inf`, `+inf`, `NaN`, `-0.0`, `0.0`). It returns a new array of integers of the same size, where each integer represents the rank/order of the corresponding element based on a consistent sorting rule (e.g., `-inf` first, then finite numbers, then `+inf`, then `NaN`s, with `0.0` and `-0.0` treated as equal)."
    },
    {
        "instruction": "Implement a function that takes a numerical array `template_arr`. It should return a *new* array filled with the value `0`, matching the shape and data type of `template_arr`."
    },
    {
        "instruction": "Implement a function that receives a list containing numerical values. Some values might have explicit low-precision types (e.g., representing float16 or int16). Determine and return the appropriate data type name for an array created from this list, ensuring the explicit precision is respected when possible (e.g., a list of only int16-like values should result in 'int16')."
    },
    {
        "instruction": "Create a function that performs weighted least-squares polynomial fitting. Input: 1D numerical array x, 1D numerical array y, 1D numerical array w (weights, same size as x), integer degree. Output: 1D numerical array of polynomial coefficients considering the weights."
    },
    {
        "instruction": "Write a function to generate geometrically spaced numbers handling edge cases for `N`. Inputs: `start`, `stop` (broadcastable numerical arrays), `N` (integer >= 0), `endpoint` (boolean), `axis` (integer). If `N` is 0, return an empty array with the correct shape based on broadcasting and `axis`. If `N` is 1, return an array containing `start` (broadcasted) shaped appropriately. For `N > 1`, generate the sequence along `axis`, respecting `endpoint`."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and computes the difference between adjacent elements (e.g., `out[i] = arr[i+1] - arr[i]`). Handle the boundary conditions appropriately (e.g., for the last element). Return a new array of the same size."
    },
    {
        "instruction": "Implement a function that takes a 2D numerical array (matrix) and a positive integer `k`. It should return a new 2D array where each *row* of the input matrix is repeated `k` times."
    },
    {
        "instruction": "Create a function that takes a 1D numerical array as input. Inside the function, modify this array (e.g., subtract a constant value from all elements). The function should return the modified array. Then, write code to verify that the original 1D array passed to the function remains unchanged after the function call."
    },
    {
        "instruction": "Develop a function that takes a list of numbers, a corresponding boolean mask list (True=invalid), and a default value. Return a new list of the same size where numbers marked as invalid in the mask are replaced by the default value."
    },
    {
        "instruction": "Develop a function to convert multi-dimensional coordinates to a flat index, wrapping out-of-bounds values using modulo arithmetic. Input: a tuple of coordinate arrays, the space dimensions, and an ordering ('C' or 'F'). For each dimension, wrap the coordinate using `coord % dim_size`. Return the 1D array of flat indices."
    },
    {
        "instruction": "Develop a function that selects elements from a list of `choices` arrays using an `indices` array. Handle out-of-bounds indices by wrapping them around using the modulo operator (e.g., index `k` becomes `k % num_choices`). The output array shape must match the `indices` array shape."
    },
    {
        "instruction": "Write a function that takes a multi-dimensional numerical array guaranteed to contain exactly one element. The function should return that single scalar element without requiring any index arguments."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array and computes its cumulative sum. The output should be a 1D array of the same size containing the cumulative sums."
    },
    {
        "instruction": "Write a function that calculates the square root of a single floating-point number. It should return the principal root for non-negative inputs and a 'Not a Number' (NaN) value for negative inputs."
    },
    {
        "instruction": "Develop a function that takes a multi-dimensional numerical array and returns a tuple containing two elements: first, the number of dimensions (integer), and second, the shape (tuple of integers)."
    },
    {
        "instruction": "Write a function that takes a numerical array (potentially containing integers) and returns a new array where all elements are converted to an inexact numerical type (e.g., integers become floats, floats/complex numbers remain as float/complex). The output array should have the same shape as the input."
    },
    {
        "instruction": "Write a function that takes a shape tuple (e.g., `(N,)`) and a numerical data type identifier (e.g., 'float64'), and returns a new 1D array of that shape filled with random numbers of the specified type."
    },
    {
        "instruction": "Develop a function that computes the inner product of two multi-dimensional numerical arrays, `a` and `b`. The operation involves summing the product of elements along the *last* axis of both arrays. Ensure the last dimensions of `a` and `b` are equal. The output shape will be the combination of the input shapes excluding their last dimensions."
    },
    {
        "instruction": "Create a function that accepts a list of boolean values (True/False) and returns a 1D boolean array containing those values."
    },
    {
        "instruction": "Implement a function that takes a 1D numerical array `row_values` (shape M,) and a positive integer `num_cols`. Return a 2D numerical array (shape M, `num_cols`) where each row `r` is entirely filled with the value `row_values[r]`."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array, a tuple representing a single element's index (row, col), and a scalar value. Return a *new* 2D array identical to the input but with the value at the specified index updated."
    },
    {
        "instruction": "Write a function that takes a single value as input and returns `True` if the value is an integer, and `False` otherwise. Do not consider boolean values as integers for this task."
    },
    {
        "instruction": "Create a function that takes an index value. Return True if the index is an integer or a slice object, and False otherwise."
    },
    {
        "instruction": "Develop a function that accepts a 1-dimensional numerical array (vector) and attempts to access it using two indices (e.g., `vector[:, 0]`). The function should return `True` if this operation causes an indexing error, and `False` otherwise."
    },
    {
        "instruction": "Write a function that takes a positive integer `n` and returns a new 1D numerical array of length `n` containing only zeros."
    },
    {
        "instruction": "Write a function that takes an integer `n` and returns a 1D numerical array of length `n` initialized entirely with zeros."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array, an integer index, and a numerical value. It should return a *new* array where the element at the given index is replaced by the provided value."
    },
    {
        "instruction": "Implement a function that takes a multi-dimensional numerical array and a tuple of slice specifications (one potentially for each dimension). Return the subarray resulting from applying these slices simultaneously to the corresponding dimensions."
    },
    {
        "instruction": "Write a function that takes a sequence known to have exactly three items. Return the first item from the sequence."
    },
    {
        "instruction": "Create a function that accepts a 1D numerical array `arr` and a scalar value `val`. Modify the first element of `arr` to be `val`. Return the modified array, ensuring it retains the original numerical data type of `arr`. If assigning `val` might lead to loss of precision or information (e.g., float to int, complex to float) according to 'standard' casting rules, the function should also return a flag or indicator that a potential issue occurred."
    },
    {
        "instruction": "Develop a function `update_element(array, index, value, operation)` where `operation` is 'set', 'add', or 'multiply'. It returns a *new* 1D numerical array with the update applied at the `index`, maintaining the original `array`'s data type."
    },
    {
        "instruction": "Implement a function that performs a segmented sum. It should accept a 1D numerical array `data` and a 1D integer array `segment_ids` of the same length. Return a new 1D array where the value at index `i` is the sum of all elements in `data` for which the corresponding `segment_ids` element is `i`. The output array's size should accommodate the highest segment ID."
    },
    {
        "instruction": "Write a function that takes a 1D numerical array (e.g., list of floats) and an integer index. Return the element at that index. If the index is out of bounds, return a default value like 0.0."
    },
    {
        "instruction": "Develop a function that takes a multi-dimensional numerical array and a tuple of integer indices. Return the single scalar element at the specified position. This function must support negative indices within the index tuple (e.g., `(-1, 0)` for a 2D array gets the element in the last row, first column)."
    },
    {
        "instruction": "Write a function that takes a 2D numerical array `data` (M rows, N columns) and a 1D list of integers `row_indices`. It should return a new 2D array containing the rows specified by `row_indices`. Handle negative indices (e.g., -1 means the last row)."
    },
    {
        "instruction": "Write a function that applies a specified element-wise operation ('add', 'subtract', 'multiply', 'overwrite') at given indices of a numerical array. The function should take the base array, indices, an update array, and a string specifying the operation. It must handle broadcasting of the update array to the indexed portion of the base array and return the modified array as a *new* array."
    },
    {
        "instruction": "Develop a function that performs an indexed arithmetic update (e.g., addition) on a numerical array. It accepts the original array `X`, an indexer tuple, and an update array `Y`. The shape of `Y` must be broadcastable to the shape implied by the indexer. Return a *new* array where the elements of `X` at the specified indices have been updated by adding the corresponding (potentially broadcasted) values from `Y`. Assume indices are unique."
    },
    {
        "instruction": "Implement the Himmelblau function. This function accepts a 1D numerical array (vector) of length 2 and returns a single scalar value based on its standard mathematical definition."
    },
    {
        "instruction": "Create a function that checks if two 1D numerical arrays are element-wise close. It should take two 1D arrays of the same size and an absolute tolerance value. Return `True` if the absolute difference between corresponding elements is less than or equal to the tolerance for all elements, `False` otherwise."
    },
    {
        "instruction": "Write a function that takes an integer `n` and a scalar value `s`. It should return an `n x n` 2D numerical array (matrix) where all diagonal elements are equal to `s` and all off-diagonal elements are 0."
    },
    {
        "instruction": "Design a function `find_minimum` that accepts three arguments: `objective_func` (a function that takes a 1D complex array and returns a real scalar value to be minimized), `initial_guess` (a 1D complex array), and `tolerance` (a small positive real number). The function should iteratively refine the guess using some numerical method to find a 1D complex array `result` such that `objective_func(result)` is minimized, aiming for convergence based on the `tolerance`. Return the resulting 1D complex array."
    }
]