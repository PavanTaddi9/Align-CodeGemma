[
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testVmapOfPmap3(self):\n    device_count = jax.device_count()\n    if device_count < 2:\n        raise SkipTest('test requires at least two devices')\n\n    def map_version(qs, pts):\n        return jax.lax.map(lambda x: func(x, pts), qs)\n\n    def vmap_version(qs, pts):\n        return jax.vmap(func, in_axes=(0, None))(qs, pts)\n\n    def func(q, pts):\n        q_from_pmap = self.pmap(lambda x, y: y, in_axes=(0, None))(pts, q)\n        return (q, q_from_pmap)\n    pts = jnp.ones(device_count)\n    qs = jnp.asarray(((0, 0), (3, 3), (2, 2)))\n    with ignore_jit_of_pmap_warning():\n        _, expected = map_version(qs, pts)\n    _, ans = vmap_version(qs, pts)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def func(x):\n    x, = promote_dtypes_complex(x)\n    return jnp.fft.irfft(jnp.concatenate([jnp.zeros_like(x, shape=1), x[:2] + 1j * x[2:]]))"
  },
  {
    "test_code": "@unittest.skip('need eager multi-replica support')\ndef testPostProcessMap(self):\n    nrep = jax.device_count()\n\n    def pmvm(a, b):\n        a = a.reshape((nrep, -1, a.shape[1]))\n        func = self.pmap(lambda z: jnp.dot(z, b))\n        return func(a).reshape(b.shape)\n    n = nrep * 2\n    rng = self.rng()\n    a = rng.randn(n, n)\n    b = rng.randn(n)\n    iters = jnp.arange(5)\n\n    def body(carry, i):\n        return (pmvm(a, carry), i)\n    ans, _ = lax.scan(body, b, iters)\n    expected = np.linalg.matrix_power(a, 5).dot(b)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def func(x):\n    x, = promote_dtypes_complex(x)\n    return jnp.fft.irfft(jnp.concatenate([jnp.zeros_like(x, shape=1), x[:2] + 1j * x[2:]]))"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': '_dtype={}'.format(jtu.format_shape_dtype_string((), dtype)), 'dtype': dtype} for dtype in [np.float32, np.int32]))\ndef testPmapDtype(self, dtype):\n\n    @partial(self.pmap, axis_name='i')\n    def func(_):\n        return jax.lax.psum(dtype(0), axis_name='i')\n    unused_arg = jnp.arange(jax.device_count())\n    out_dtype = func(unused_arg).dtype\n    self.assertEqual(out_dtype, dtype)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def func(x):\n    x, = promote_dtypes_complex(x)\n    return jnp.fft.irfft(jnp.concatenate([jnp.zeros_like(x, shape=1), x[:2] + 1j * x[2:]]))"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "def testRule30(self):\n    device_count = jax.device_count()\n\n    def send_right(x, axis_name):\n        left_perm = [(i, (i + 1) % device_count) for i in range(device_count)]\n        return lax.ppermute(x, perm=left_perm, axis_name=axis_name)\n\n    def send_left(x, axis_name):\n        left_perm = [((i + 1) % device_count, i) for i in range(device_count)]\n        return lax.ppermute(x, perm=left_perm, axis_name=axis_name)\n\n    def update_board(board):\n        left = board[:-2]\n        right = board[2:]\n        center = board[1:-1]\n        return lax.bitwise_xor(left, lax.bitwise_or(center, right))\n\n    @partial(self.pmap, axis_name='i')\n    def step(board_slice):\n        left, right = (board_slice[:1], board_slice[-1:])\n        right, left = (send_left(left, 'i'), send_right(right, 'i'))\n        enlarged_board_slice = jnp.concatenate([left, board_slice, right])\n        return update_board(enlarged_board_slice)\n    board = np.zeros(40, dtype=bool)\n    board[board.shape[0] // 2] = True\n    reshaped_board = board.reshape((device_count, -1))\n    boards = []\n\n    def print_board(board):\n        boards.append(''.join(('*' if x else ' ' for x in board.ravel())))\n    print_board(reshaped_board)\n    for _ in range(9):\n        reshaped_board = step(reshaped_board)\n        print_board(reshaped_board)\n    ans = '\\n'.join(boards)\n    expected = '\\n'.join(('                    *                   ', '                   ***                  ', '                  **  *                 ', '                 ** ****                ', '                **  *   *               ', '               ** **** ***              ', '              **  *    *  *             ', '             ** ****  ******            ', '            **  *   ***     *           ', '           ** **** **  *   ***          '))\n    print(ans)\n    self.assertEqual(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "@ignore_jit_of_pmap_warning()\ndef testIssue1065(self):\n    device_count = jax.device_count()\n\n    def multi_step_pmap(state, count):\n\n        @partial(self.pmap, axis_name='x')\n        @jit\n        def exchange_and_multi_step(state):\n            return state\n\n        @jit\n        def time_evolution(state):\n            return lax.fori_loop(0, count, lambda i, s: exchange_and_multi_step(s), state)\n        return time_evolution(state)\n    multi_step_pmap(jnp.zeros((device_count,)), count=1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "def test_num_replicas_with_switch(self):\n\n    def identity(x):\n        return x\n\n    def cond_of_pmap(x):\n        y = lax.cond(True, jax.pmap(identity), jax.pmap(identity), x)\n        return y\n    with ignore_jit_of_pmap_warning():\n        cond_of_pmap(jnp.zeros((jax.device_count(), 2)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "def test_cache_hits_across_threads(self):\n    f = lambda x: x + 1\n    inputs = np.zeros([jax.device_count()], dtype=np.float32)\n    pmaped_f = self.pmap(f)\n    self.assertEqual(pmaped_f._cache_size, 0)\n    futures = []\n    with ThreadPoolExecutor(max_workers=2) as executor:\n        for _ in range(8):\n            futures.append(executor.submit(lambda: pmaped_f(inputs)))\n        outputs = [f.result() for f in futures]\n    if pmaped_f._cache_size != 1:\n        print(pmaped_f._debug_cache_keys())\n    self.assertEqual(pmaped_f._cache_size, 1)\n    np.testing.assert_array_equal(pmaped_f(inputs), outputs[0])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "def test_cache_uses_jax_key(self):\n    f = lambda x: x + 1\n    inputs = np.zeros([jax.device_count()], dtype=np.float32)\n    pmaped_f = self.pmap(f)\n    pmaped_f(inputs)\n    self.assertEqual(pmaped_f._cache_size, 1)\n    pmaped_f(inputs)\n    self.assertEqual(pmaped_f._cache_size, 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "def test_constants_fallback(self):\n    fn = pmap(lambda x, y: x + y, in_axes=(0, None))\n    for _ in range(2):\n        fn(np.zeros((jax.device_count(), 5), dtype=np.float32), 2.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "def testNestedPmapsBools(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return jnp.logical_not(y)\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2), jnp.bool_)\n    ans = foo(x)\n    expected = jnp.zeros((jax.device_count() // 2, 2), jnp.bool_)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "@parameterized.named_parameters(jtu.named_cases_from_sampler(lambda s: ({'testcase_name': f'{shapes}_{vmap_in_axes}_{vmap_out_axes}_{pmap_in_axes}_{pmap_out_axes}', 'shapes': shapes, 'vmap_in_axes': vmap_in_axes, 'vmap_out_axes': vmap_out_axes, 'pmap_in_axes': pmap_in_axes, 'pmap_out_axes': pmap_out_axes} for arg_shapes in s(compatible_shapes) for num_args in s(range(1, 4)) for shapes in s(list(it.combinations_with_replacement(arg_shapes, num_args))) for vmap_in_axes in s(all_bdims(*shapes, pmap=False)) for pmap_in_axes in s(all_bdims(*shapes, pmap=True)) for vmap_out_axes in s(out_bdims(shapes[0], False)) for pmap_out_axes in s(out_bdims(shapes[0], True)))))\ndef testVmapOfPmap(self, shapes, vmap_in_axes, pmap_in_axes, vmap_out_axes, pmap_out_axes):\n    vmapped_size = 3\n    pmapped_size = jax.device_count()\n    rng = jtu.rand_default(self.rng())\n\n    def fun(*args):\n        return sum(args)\n    final_shapes = map(partial(add_bdim, vmapped_size), vmap_in_axes, map(partial(add_bdim, pmapped_size), pmap_in_axes, shapes))\n\n    def args_slice(vi, pi):\n        return args_slicer(args_slicer(args, vmap_in_axes)(vi), pmap_in_axes)(pi)\n    args = [rng(shape, jnp.float32) for shape in final_shapes]\n    ans = vmap(pmap(fun, in_axes=pmap_in_axes, out_axes=pmap_out_axes), in_axes=vmap_in_axes, out_axes=vmap_out_axes)(*args)\n    expected = np.stack([np.stack([fun(*args_slice(vi, pi)) for pi in range(pmapped_size)], axis=pmap_out_axes) for vi in range(vmapped_size)], axis=vmap_out_axes)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, abstracted_axes=('n',))\ndef fun(x):\n    return jnp.sum(x)"
  },
  {
    "test_code": "def testAllToAllReplicaGroups(self):\n    device_count = jax.device_count()\n    if device_count % 2 != 0:\n        raise SkipTest('test requires an even number of devices')\n    shape = (device_count, device_count // 2)\n    x = np.arange(math.prod(shape)).reshape(shape)\n    axis_index_groups = np.arange(device_count, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((device_count // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n\n    @partial(self.pmap, axis_name='i')\n    def fn(x):\n        return lax.all_to_all(x, 'i', 0, 0, axis_index_groups=axis_index_groups)\n    expected = np.swapaxes(x.reshape((device_count // 2, 2, device_count // 2)), 0, 2).reshape(shape)\n    self.assertAllClose(fn(x), expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef fn(n, x):\n    return lax.broadcast_in_dim(x, (n,), ())"
  },
  {
    "test_code": "def testGradOfAllToAllReplicaGroups(self):\n    device_count = jax.device_count()\n    if device_count % 2 != 0:\n        raise SkipTest('test requires an even number of devices')\n    shape = (device_count, device_count // 2, 1)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n    axis_index_groups = np.arange(device_count, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((2, device_count // 2))\n    axis_index_groups = axis_index_groups.tolist()\n\n    @partial(self.pmap, axis_name='i')\n    def fn(x, w):\n        g = lambda x: jnp.sum(lax.all_to_all(x, 'i', 0, 1, axis_index_groups=axis_index_groups) * w)\n        return grad(g)(x)\n    expected = np.ones_like(x) * w[:, np.newaxis, np.newaxis]\n    expected = np.swapaxes(expected.reshape((2, device_count // 2, device_count // 2)), 1, 2).reshape(shape)\n    self.assertAllClose(fn(x, w), expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef fn(n, x):\n    return lax.broadcast_in_dim(x, (n,), ())"
  },
  {
    "test_code": "def test_typed_prng_key_sharded(self):\n    devices = jax.local_devices()\n\n    @partial(jax.pmap, in_axes=0, out_axes=0, axis_size=len(devices), axis_name='i', devices=devices)\n    def fn(key):\n        return jax.random.fold_in(key, 0)\n    sharded_key = jax.random.split(jax.random.key(0), len(devices))\n    replicated_key = jax.random.key(1)\n    sharded_key = jax.device_put_sharded(jnp.unstack(sharded_key), devices)\n    replicated_key = jax.device_put_replicated(replicated_key, devices)\n    fn(sharded_key)\n    fn(replicated_key)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef fn(n, x):\n    return lax.broadcast_in_dim(x, (n,), ())"
  },
  {
    "test_code": "def test_constants_fallback(self):\n    fn = pmap(lambda x, y: x + y, in_axes=(0, None))\n    for _ in range(2):\n        fn(np.zeros((jax.device_count(), 5), dtype=np.float32), 2.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef fn(n, x):\n    return lax.broadcast_in_dim(x, (n,), ())"
  },
  {
    "test_code": "def testJitOfPmapOutputSharding(self):\n    device_count = jax.device_count()\n    if device_count == 1 or config.disable_jit.value:\n        raise SkipTest('test requires at least two devices')\n\n    @jax.jit\n    @jax.pmap\n    def foo(x):\n        return x + x\n    x = np.ones((2, 2, 2), dtype=np.float32)\n    for _ in range(10):\n        with jtu.ignore_warning(message='.*Using jit-of-pmap can lead to inefficient data movement'):\n            x = foo(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x, y):\n    z = jax.vmap(jax.vmap(jnp.sin))(x) * y\n    return jax.vmap(jax.vmap(jnp.add))(x, z)"
  },
  {
    "test_code": "def testNestedPmaps(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2))\n    ans = foo(x)\n    expected = x * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x, y):\n    z = jax.vmap(jax.vmap(jnp.sin))(x) * y\n    return jax.vmap(jax.vmap(jnp.add))(x, z)"
  },
  {
    "test_code": "def testNestedPmapsBools(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return jnp.logical_not(y)\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2), jnp.bool_)\n    ans = foo(x)\n    expected = jnp.zeros((jax.device_count() // 2, 2), jnp.bool_)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x, y):\n    z = jax.vmap(jax.vmap(jnp.sin))(x) * y\n    return jax.vmap(jax.vmap(jnp.add))(x, z)"
  },
  {
    "test_code": "def testNestedPmapsError(self):\n\n    @partial(pmap, axis_name='i')\n    def foo(x):\n\n        @partial(pmap, axis_name='j', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    with self.assertRaisesRegex(ValueError, 'Nested pmap with explicit devices argument.'):\n        foo(jnp.ones((jax.device_count(), 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x, y):\n    z = jax.vmap(jax.vmap(jnp.sin))(x) * y\n    return jax.vmap(jax.vmap(jnp.add))(x, z)"
  },
  {
    "test_code": "def testJitInPmap(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @jit\n        def bar(y):\n            return y + 1\n        return lax.psum(bar(x), 'i')\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x, y):\n    z = jax.vmap(jax.vmap(jnp.sin))(x) * y\n    return jax.vmap(jax.vmap(jnp.add))(x, z)"
  },
  {
    "test_code": "@ignore_jit_of_pmap_warning()\ndef testPmapInJit(self):\n\n    @jit\n    def foo(x):\n\n        @partial(pmap, axis_name='i', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'i')\n        return bar(x)\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x, y):\n    z = jax.vmap(jax.vmap(jnp.sin))(x) * y\n    return jax.vmap(jax.vmap(jnp.add))(x, z)"
  },
  {
    "test_code": "def test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def foo(x):\n        return jnp.exp(x)\n\n    @foo.defjvp\n    def foo_jvp(xs, ts):\n        (x,), (t,) = (xs, ts)\n        return (foo(x), t * 4.0)\n    f = lambda x, t: jax.jvp(foo, (x,), (t,))\n    x = jnp.arange(jax.local_device_count() * 5, dtype=jnp.dtype('float32')).reshape((jax.local_device_count(), 5))\n    self.assertAllClose(self.pmap(f)(x, x), jax.vmap(f)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x, y):\n    z = jax.vmap(jax.vmap(jnp.sin))(x) * y\n    return jax.vmap(jax.vmap(jnp.add))(x, z)"
  },
  {
    "test_code": "def test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def foo(x):\n        return jnp.exp(x)\n\n    def foo_fwd(x):\n        return (foo(x), x)\n\n    def foo_bwd(_, g):\n        return (g * 5.0,)\n    foo.defvjp(foo_fwd, foo_bwd)\n    f = jax.grad(foo)\n    x = jnp.arange(jax.local_device_count(), dtype=jnp.dtype('float32'))\n    self.assertAllClose(self.pmap(f)(x), jax.vmap(f)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x, y):\n    z = jax.vmap(jax.vmap(jnp.sin))(x) * y\n    return jax.vmap(jax.vmap(jnp.add))(x, z)"
  },
  {
    "test_code": "def testVmapOfPmap3(self):\n    device_count = jax.device_count()\n    if device_count < 2:\n        raise SkipTest('test requires at least two devices')\n\n    def map_version(qs, pts):\n        return jax.lax.map(lambda x: func(x, pts), qs)\n\n    def vmap_version(qs, pts):\n        return jax.vmap(func, in_axes=(0, None))(qs, pts)\n\n    def func(q, pts):\n        q_from_pmap = self.pmap(lambda x, y: y, in_axes=(0, None))(pts, q)\n        return (q, q_from_pmap)\n    pts = jnp.ones(device_count)\n    qs = jnp.asarray(((0, 0), (3, 3), (2, 2)))\n    with ignore_jit_of_pmap_warning():\n        _, expected = map_version(qs, pts)\n    _, ans = vmap_version(qs, pts)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def func(size):\n    lhs_one_d = jnp.arange(size, dtype='int32') + 1\n    lhs_two_d = jax.lax.broadcast_in_dim(lhs_one_d, (size, 2), (0,))\n    rhs = jax.lax.broadcasted_iota('int32', (2, 4), 0) + 1\n    return jnp.dot(lhs_two_d, rhs)"
  },
  {
    "test_code": "@unittest.skip('need eager multi-replica support')\ndef testPostProcessMap(self):\n    nrep = jax.device_count()\n\n    def pmvm(a, b):\n        a = a.reshape((nrep, -1, a.shape[1]))\n        func = self.pmap(lambda z: jnp.dot(z, b))\n        return func(a).reshape(b.shape)\n    n = nrep * 2\n    rng = self.rng()\n    a = rng.randn(n, n)\n    b = rng.randn(n)\n    iters = jnp.arange(5)\n\n    def body(carry, i):\n        return (pmvm(a, carry), i)\n    ans, _ = lax.scan(body, b, iters)\n    expected = np.linalg.matrix_power(a, 5).dot(b)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def func(size):\n    lhs_one_d = jnp.arange(size, dtype='int32') + 1\n    lhs_two_d = jax.lax.broadcast_in_dim(lhs_one_d, (size, 2), (0,))\n    rhs = jax.lax.broadcasted_iota('int32', (2, 4), 0) + 1\n    return jnp.dot(lhs_two_d, rhs)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': '_dtype={}'.format(jtu.format_shape_dtype_string((), dtype)), 'dtype': dtype} for dtype in [np.float32, np.int32]))\ndef testPmapDtype(self, dtype):\n\n    @partial(self.pmap, axis_name='i')\n    def func(_):\n        return jax.lax.psum(dtype(0), axis_name='i')\n    unused_arg = jnp.arange(jax.device_count())\n    out_dtype = func(unused_arg).dtype\n    self.assertEqual(out_dtype, dtype)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def func(size):\n    lhs_one_d = jnp.arange(size, dtype='int32') + 1\n    lhs_two_d = jax.lax.broadcast_in_dim(lhs_one_d, (size, 2), (0,))\n    rhs = jax.lax.broadcasted_iota('int32', (2, 4), 0) + 1\n    return jnp.dot(lhs_two_d, rhs)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "def testVmapOfPmap3(self):\n    device_count = jax.device_count()\n    if device_count < 2:\n        raise SkipTest('test requires at least two devices')\n\n    def map_version(qs, pts):\n        return jax.lax.map(lambda x: func(x, pts), qs)\n\n    def vmap_version(qs, pts):\n        return jax.vmap(func, in_axes=(0, None))(qs, pts)\n\n    def func(q, pts):\n        q_from_pmap = self.pmap(lambda x, y: y, in_axes=(0, None))(pts, q)\n        return (q, q_from_pmap)\n    pts = jnp.ones(device_count)\n    qs = jnp.asarray(((0, 0), (3, 3), (2, 2)))\n    with ignore_jit_of_pmap_warning():\n        _, expected = map_version(qs, pts)\n    _, ans = vmap_version(qs, pts)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def func(x):\n    return jax.random.uniform(x, (2, 4), dtype=np.float32)"
  },
  {
    "test_code": "@unittest.skip('need eager multi-replica support')\ndef testPostProcessMap(self):\n    nrep = jax.device_count()\n\n    def pmvm(a, b):\n        a = a.reshape((nrep, -1, a.shape[1]))\n        func = self.pmap(lambda z: jnp.dot(z, b))\n        return func(a).reshape(b.shape)\n    n = nrep * 2\n    rng = self.rng()\n    a = rng.randn(n, n)\n    b = rng.randn(n)\n    iters = jnp.arange(5)\n\n    def body(carry, i):\n        return (pmvm(a, carry), i)\n    ans, _ = lax.scan(body, b, iters)\n    expected = np.linalg.matrix_power(a, 5).dot(b)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def func(x):\n    return jax.random.uniform(x, (2, 4), dtype=np.float32)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': '_dtype={}'.format(jtu.format_shape_dtype_string((), dtype)), 'dtype': dtype} for dtype in [np.float32, np.int32]))\ndef testPmapDtype(self, dtype):\n\n    @partial(self.pmap, axis_name='i')\n    def func(_):\n        return jax.lax.psum(dtype(0), axis_name='i')\n    unused_arg = jnp.arange(jax.device_count())\n    out_dtype = func(unused_arg).dtype\n    self.assertEqual(out_dtype, dtype)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def func(x):\n    return jax.random.uniform(x, (2, 4), dtype=np.float32)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_num_replicas_with_switch(self):\n\n    def identity(x):\n        return x\n\n    def cond_of_pmap(x):\n        y = lax.cond(True, jax.pmap(identity), jax.pmap(identity), x)\n        return y\n    with ignore_jit_of_pmap_warning():\n        cond_of_pmap(jnp.zeros((jax.device_count(), 2)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def cond(state):\n    it, _, fx, _ = state\n    return (jnp.max(jnp.abs(fx)) > tol) & (it < max_it)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(jtu.named_cases_from_sampler(lambda s: ({'testcase_name': f'{shapes}_{vmap_in_axes}_{vmap_out_axes}_{pmap_in_axes}_{pmap_out_axes}', 'shapes': shapes, 'vmap_in_axes': vmap_in_axes, 'vmap_out_axes': vmap_out_axes, 'pmap_in_axes': pmap_in_axes, 'pmap_out_axes': pmap_out_axes} for arg_shapes in s(compatible_shapes) for num_args in s(range(1, 4)) for shapes in s(list(it.combinations_with_replacement(arg_shapes, num_args))) for vmap_in_axes in s(all_bdims(*shapes, pmap=False)) for pmap_in_axes in s(all_bdims(*shapes, pmap=True)) for vmap_out_axes in s(out_bdims(shapes[0], False)) for pmap_out_axes in s(out_bdims(shapes[0], True)))))\ndef testVmapOfPmap(self, shapes, vmap_in_axes, pmap_in_axes, vmap_out_axes, pmap_out_axes):\n    vmapped_size = 3\n    pmapped_size = jax.device_count()\n    rng = jtu.rand_default(self.rng())\n\n    def fun(*args):\n        return sum(args)\n    final_shapes = map(partial(add_bdim, vmapped_size), vmap_in_axes, map(partial(add_bdim, pmapped_size), pmap_in_axes, shapes))\n\n    def args_slice(vi, pi):\n        return args_slicer(args_slicer(args, vmap_in_axes)(vi), pmap_in_axes)(pi)\n    args = [rng(shape, jnp.float32) for shape in final_shapes]\n    ans = vmap(pmap(fun, in_axes=pmap_in_axes, out_axes=pmap_out_axes), in_axes=vmap_in_axes, out_axes=vmap_out_axes)(*args)\n    expected = np.stack([np.stack([fun(*args_slice(vi, pi)) for pi in range(pmapped_size)], axis=pmap_out_axes) for vi in range(vmapped_size)], axis=vmap_out_axes)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef fun(x, y):\n    return cond(x < 3, None, lambda _: 2.0 * jnp.sin(y), x, lambda x: 2.0 * x)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "def testRule30(self):\n    device_count = jax.device_count()\n\n    def send_right(x, axis_name):\n        left_perm = [(i, (i + 1) % device_count) for i in range(device_count)]\n        return lax.ppermute(x, perm=left_perm, axis_name=axis_name)\n\n    def send_left(x, axis_name):\n        left_perm = [((i + 1) % device_count, i) for i in range(device_count)]\n        return lax.ppermute(x, perm=left_perm, axis_name=axis_name)\n\n    def update_board(board):\n        left = board[:-2]\n        right = board[2:]\n        center = board[1:-1]\n        return lax.bitwise_xor(left, lax.bitwise_or(center, right))\n\n    @partial(self.pmap, axis_name='i')\n    def step(board_slice):\n        left, right = (board_slice[:1], board_slice[-1:])\n        right, left = (send_left(left, 'i'), send_right(right, 'i'))\n        enlarged_board_slice = jnp.concatenate([left, board_slice, right])\n        return update_board(enlarged_board_slice)\n    board = np.zeros(40, dtype=bool)\n    board[board.shape[0] // 2] = True\n    reshaped_board = board.reshape((device_count, -1))\n    boards = []\n\n    def print_board(board):\n        boards.append(''.join(('*' if x else ' ' for x in board.ravel())))\n    print_board(reshaped_board)\n    for _ in range(9):\n        reshaped_board = step(reshaped_board)\n        print_board(reshaped_board)\n    ans = '\\n'.join(boards)\n    expected = '\\n'.join(('                    *                   ', '                   ***                  ', '                  **  *                 ', '                 ** ****                ', '                **  *   *               ', '               ** **** ***              ', '              **  *    *  *             ', '             ** ****  ******            ', '            **  *   ***     *           ', '           ** **** **  *   ***          '))\n    print(ans)\n    self.assertEqual(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def step(x, i):\n    return (jnp.matmul(A, x), None)"
  },
  {
    "test_code": "def testAllToAllReplicaGroups(self):\n    device_count = jax.device_count()\n    if device_count % 2 != 0:\n        raise SkipTest('test requires an even number of devices')\n    shape = (device_count, device_count // 2)\n    x = np.arange(math.prod(shape)).reshape(shape)\n    axis_index_groups = np.arange(device_count, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((device_count // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n\n    @partial(self.pmap, axis_name='i')\n    def fn(x):\n        return lax.all_to_all(x, 'i', 0, 0, axis_index_groups=axis_index_groups)\n    expected = np.swapaxes(x.reshape((device_count // 2, 2, device_count // 2)), 0, 2).reshape(shape)\n    self.assertAllClose(fn(x), expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\ndef fn(a, b):\n    m1, v1 = a\n    m2, v2 = b\n    return (m1 + m2, jsp.linalg.solve(m1, v2) + jsp.linalg.solve(m2, v1))"
  },
  {
    "test_code": "def testGradOfAllToAllReplicaGroups(self):\n    device_count = jax.device_count()\n    if device_count % 2 != 0:\n        raise SkipTest('test requires an even number of devices')\n    shape = (device_count, device_count // 2, 1)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n    axis_index_groups = np.arange(device_count, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((2, device_count // 2))\n    axis_index_groups = axis_index_groups.tolist()\n\n    @partial(self.pmap, axis_name='i')\n    def fn(x, w):\n        g = lambda x: jnp.sum(lax.all_to_all(x, 'i', 0, 1, axis_index_groups=axis_index_groups) * w)\n        return grad(g)(x)\n    expected = np.ones_like(x) * w[:, np.newaxis, np.newaxis]\n    expected = np.swapaxes(expected.reshape((2, device_count // 2, device_count // 2)), 1, 2).reshape(shape)\n    self.assertAllClose(fn(x, w), expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\ndef fn(a, b):\n    m1, v1 = a\n    m2, v2 = b\n    return (m1 + m2, jsp.linalg.solve(m1, v2) + jsp.linalg.solve(m2, v1))"
  },
  {
    "test_code": "def test_typed_prng_key_sharded(self):\n    devices = jax.local_devices()\n\n    @partial(jax.pmap, in_axes=0, out_axes=0, axis_size=len(devices), axis_name='i', devices=devices)\n    def fn(key):\n        return jax.random.fold_in(key, 0)\n    sharded_key = jax.random.split(jax.random.key(0), len(devices))\n    replicated_key = jax.random.key(1)\n    sharded_key = jax.device_put_sharded(jnp.unstack(sharded_key), devices)\n    replicated_key = jax.device_put_replicated(replicated_key, devices)\n    fn(sharded_key)\n    fn(replicated_key)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\ndef fn(a, b):\n    m1, v1 = a\n    m2, v2 = b\n    return (m1 + m2, jsp.linalg.solve(m1, v2) + jsp.linalg.solve(m2, v1))"
  },
  {
    "test_code": "def test_constants_fallback(self):\n    fn = pmap(lambda x, y: x + y, in_axes=(0, None))\n    for _ in range(2):\n        fn(np.zeros((jax.device_count(), 5), dtype=np.float32), 2.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\ndef fn(a, b):\n    m1, v1 = a\n    m2, v2 = b\n    return (m1 + m2, jsp.linalg.solve(m1, v2) + jsp.linalg.solve(m2, v1))"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def scan(y):\n\n    def body(carry, x):\n        return (carry, jnp.dot(x, x))\n    return jax.lax.scan(body, 1.0, y, unroll=False)"
  },
  {
    "test_code": "@unittest.skip('need eager multi-replica support')\ndef testPostProcessMap(self):\n    nrep = jax.device_count()\n\n    def pmvm(a, b):\n        a = a.reshape((nrep, -1, a.shape[1]))\n        func = self.pmap(lambda z: jnp.dot(z, b))\n        return func(a).reshape(b.shape)\n    n = nrep * 2\n    rng = self.rng()\n    a = rng.randn(n, n)\n    b = rng.randn(n)\n    iters = jnp.arange(5)\n\n    def body(carry, i):\n        return (pmvm(a, carry), i)\n    ans, _ = lax.scan(body, b, iters)\n    expected = np.linalg.matrix_power(a, 5).dot(b)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def scan(y):\n\n    def body(carry, x):\n        return (carry, jnp.dot(x, x))\n    return jax.lax.scan(body, 1.0, y, unroll=False)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "def testNestedPmapReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 4 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas // 2).reshape(2, replicas // 4).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f1 = self.pmap(self.pmap(f, 'i'), 'j')\n    f2 = self.pmap(lambda x: self.pmap(f, 'i')(x) + 1.0, 'j')\n    f3 = self.pmap(self.pmap(f, 'j'), 'i')\n    shape = (2, replicas // 2, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper_f1(a):\n        return np.broadcast_to(a.sum(1, keepdims=True), (shape[0], shape[1] // 2, shape[2]))\n    expected_psum_1 = sum_helper_f1(x[:, :replicas // 4])\n    expected_psum_2 = sum_helper_f1(x[:, replicas // 4:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 1)\n    expected = x - expected_psum\n    ans = f1(x)\n    self.assertAllClose(ans, expected)\n    expected = x - expected_psum + 1.0\n    ans = f2(x)\n    self.assertAllClose(ans, expected)\n    shape = (replicas // 2, 2, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper_f3(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (shape[0] // 2, shape[1], shape[2]))\n    expected_psum_1 = sum_helper_f3(x[:replicas // 4])\n    expected_psum_2 = sum_helper_f3(x[replicas // 4:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f3(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f2():\n    x = 2\n    g2()\n    return x"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "def testRule30(self):\n    device_count = jax.device_count()\n\n    def send_right(x, axis_name):\n        left_perm = [(i, (i + 1) % device_count) for i in range(device_count)]\n        return lax.ppermute(x, perm=left_perm, axis_name=axis_name)\n\n    def send_left(x, axis_name):\n        left_perm = [((i + 1) % device_count, i) for i in range(device_count)]\n        return lax.ppermute(x, perm=left_perm, axis_name=axis_name)\n\n    def update_board(board):\n        left = board[:-2]\n        right = board[2:]\n        center = board[1:-1]\n        return lax.bitwise_xor(left, lax.bitwise_or(center, right))\n\n    @partial(self.pmap, axis_name='i')\n    def step(board_slice):\n        left, right = (board_slice[:1], board_slice[-1:])\n        right, left = (send_left(left, 'i'), send_right(right, 'i'))\n        enlarged_board_slice = jnp.concatenate([left, board_slice, right])\n        return update_board(enlarged_board_slice)\n    board = np.zeros(40, dtype=bool)\n    board[board.shape[0] // 2] = True\n    reshaped_board = board.reshape((device_count, -1))\n    boards = []\n\n    def print_board(board):\n        boards.append(''.join(('*' if x else ' ' for x in board.ravel())))\n    print_board(reshaped_board)\n    for _ in range(9):\n        reshaped_board = step(reshaped_board)\n        print_board(reshaped_board)\n    ans = '\\n'.join(boards)\n    expected = '\\n'.join(('                    *                   ', '                   ***                  ', '                  **  *                 ', '                 ** ****                ', '                **  *   *               ', '               ** **** ***              ', '              **  *    *  *             ', '             ** ****  ******            ', '            **  *   ***     *           ', '           ** **** **  *   ***          '))\n    print(ans)\n    self.assertEqual(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def step(x, _):\n    return (jnp.matmul(A, x), None)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@parameterized.named_parameters(jtu.named_cases_from_sampler(lambda s: ({'testcase_name': f'{shapes}_{vmap_in_axes}_{vmap_out_axes}_{pmap_in_axes}_{pmap_out_axes}', 'shapes': shapes, 'vmap_in_axes': vmap_in_axes, 'vmap_out_axes': vmap_out_axes, 'pmap_in_axes': pmap_in_axes, 'pmap_out_axes': pmap_out_axes} for arg_shapes in s(compatible_shapes) for num_args in s(range(1, 4)) for shapes in s(list(it.combinations_with_replacement(arg_shapes, num_args))) for vmap_in_axes in s(all_bdims(*shapes, pmap=False)) for pmap_in_axes in s(all_bdims(*shapes, pmap=True)) for vmap_out_axes in s(out_bdims(shapes[0], False)) for pmap_out_axes in s(out_bdims(shapes[0], True)))))\ndef testVmapOfPmap(self, shapes, vmap_in_axes, pmap_in_axes, vmap_out_axes, pmap_out_axes):\n    vmapped_size = 3\n    pmapped_size = jax.device_count()\n    rng = jtu.rand_default(self.rng())\n\n    def fun(*args):\n        return sum(args)\n    final_shapes = map(partial(add_bdim, vmapped_size), vmap_in_axes, map(partial(add_bdim, pmapped_size), pmap_in_axes, shapes))\n\n    def args_slice(vi, pi):\n        return args_slicer(args_slicer(args, vmap_in_axes)(vi), pmap_in_axes)(pi)\n    args = [rng(shape, jnp.float32) for shape in final_shapes]\n    ans = vmap(pmap(fun, in_axes=pmap_in_axes, out_axes=pmap_out_axes), in_axes=vmap_in_axes, out_axes=vmap_out_axes)(*args)\n    expected = np.stack([np.stack([fun(*args_slice(vi, pi)) for pi in range(pmapped_size)], axis=pmap_out_axes) for vi in range(vmapped_size)], axis=vmap_out_axes)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def fun():\n    return jax.ffi.ffi_call('test', jax.ShapeDtypeStruct((), np.int64))()"
  },
  {
    "test_code": "def testVmapOfPmap3(self):\n    device_count = jax.device_count()\n    if device_count < 2:\n        raise SkipTest('test requires at least two devices')\n\n    def map_version(qs, pts):\n        return jax.lax.map(lambda x: func(x, pts), qs)\n\n    def vmap_version(qs, pts):\n        return jax.vmap(func, in_axes=(0, None))(qs, pts)\n\n    def func(q, pts):\n        q_from_pmap = self.pmap(lambda x, y: y, in_axes=(0, None))(pts, q)\n        return (q, q_from_pmap)\n    pts = jnp.ones(device_count)\n    qs = jnp.asarray(((0, 0), (3, 3), (2, 2)))\n    with ignore_jit_of_pmap_warning():\n        _, expected = map_version(qs, pts)\n    _, ans = vmap_version(qs, pts)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def func(xs):\n    return jnp.array(list(xs))"
  },
  {
    "test_code": "@unittest.skip('need eager multi-replica support')\ndef testPostProcessMap(self):\n    nrep = jax.device_count()\n\n    def pmvm(a, b):\n        a = a.reshape((nrep, -1, a.shape[1]))\n        func = self.pmap(lambda z: jnp.dot(z, b))\n        return func(a).reshape(b.shape)\n    n = nrep * 2\n    rng = self.rng()\n    a = rng.randn(n, n)\n    b = rng.randn(n)\n    iters = jnp.arange(5)\n\n    def body(carry, i):\n        return (pmvm(a, carry), i)\n    ans, _ = lax.scan(body, b, iters)\n    expected = np.linalg.matrix_power(a, 5).dot(b)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def func(xs):\n    return jnp.array(list(xs))"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': '_dtype={}'.format(jtu.format_shape_dtype_string((), dtype)), 'dtype': dtype} for dtype in [np.float32, np.int32]))\ndef testPmapDtype(self, dtype):\n\n    @partial(self.pmap, axis_name='i')\n    def func(_):\n        return jax.lax.psum(dtype(0), axis_name='i')\n    unused_arg = jnp.arange(jax.device_count())\n    out_dtype = func(unused_arg).dtype\n    self.assertEqual(out_dtype, dtype)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def func(xs):\n    return jnp.array(list(xs))"
  },
  {
    "test_code": "@parameterized.named_parameters(jtu.named_cases_from_sampler(lambda s: ({'testcase_name': f'{shapes}_{vmap_in_axes}_{vmap_out_axes}_{pmap_in_axes}_{pmap_out_axes}', 'shapes': shapes, 'vmap_in_axes': vmap_in_axes, 'vmap_out_axes': vmap_out_axes, 'pmap_in_axes': pmap_in_axes, 'pmap_out_axes': pmap_out_axes} for arg_shapes in s(compatible_shapes) for num_args in s(range(1, 4)) for shapes in s(list(it.combinations_with_replacement(arg_shapes, num_args))) for vmap_in_axes in s(all_bdims(*shapes, pmap=False)) for pmap_in_axes in s(all_bdims(*shapes, pmap=True)) for vmap_out_axes in s(out_bdims(shapes[0], False)) for pmap_out_axes in s(out_bdims(shapes[0], True)))))\ndef testVmapOfPmap(self, shapes, vmap_in_axes, pmap_in_axes, vmap_out_axes, pmap_out_axes):\n    vmapped_size = 3\n    pmapped_size = jax.device_count()\n    rng = jtu.rand_default(self.rng())\n\n    def fun(*args):\n        return sum(args)\n    final_shapes = map(partial(add_bdim, vmapped_size), vmap_in_axes, map(partial(add_bdim, pmapped_size), pmap_in_axes, shapes))\n\n    def args_slice(vi, pi):\n        return args_slicer(args_slicer(args, vmap_in_axes)(vi), pmap_in_axes)(pi)\n    args = [rng(shape, jnp.float32) for shape in final_shapes]\n    ans = vmap(pmap(fun, in_axes=pmap_in_axes, out_axes=pmap_out_axes), in_axes=vmap_in_axes, out_axes=vmap_out_axes)(*args)\n    expected = np.stack([np.stack([fun(*args_slice(vi, pi)) for pi in range(pmapped_size)], axis=pmap_out_axes) for vi in range(vmapped_size)], axis=vmap_out_axes)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def fun(x, t):\n    return jnp.sum(jnp.power(jnp.maximum(x, 0.0), 2)) + t"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testTrees(self):\n    ptranspose = lambda x, axis_name: lax.all_to_all(x, axis_name, 0, 0)\n\n    def protate(x, axis_name):\n        n = lax.psum(1, axis_name)\n        return lax.ppermute(x, axis_name, [(i, (i + 1) % n) for i in range(n)])\n    tree_f = lambda f: partial(jax.tree.map, f)\n    jax_f = lambda p: self.pmap(lambda x: p(x, 'i'), 'i')\n    np_f = lambda p: tree_f(lambda x: np.broadcast_to(p(x, 0), x.shape))\n    np_transpose = tree_f(np.transpose)\n    np_rotate = tree_f(lambda x: np.concatenate([x[-1:], x[:-1]]))\n    n = jax.device_count()\n    x = {'a': np.arange(1 * n * n, 2 * n * n).reshape([n, n]), 'b': np.arange(2 * n * n, 3 * n * n).reshape([n, n]), 'c': np.arange(4 * n * n, 5 * n * n).reshape([n, n])}\n    assert_allclose = partial(jax.tree.map, partial(self.assertAllClose, check_dtypes=False))\n    assert_allclose(jax_f(lax.pmax)(x), np_f(np.max)(x))\n    assert_allclose(jax_f(lax.pmin)(x), np_f(np.min)(x))\n    assert_allclose(jax_f(lax.psum)(x), np_f(np.sum)(x))\n    assert_allclose(jax_f(lax.pmean)(x), np_f(np.mean)(x))\n    assert_allclose(jax_f(ptranspose)(x), np_transpose(x))\n    assert_allclose(jax_f(protate)(x), np_rotate(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def ppermute(input):\n    return jax.lax.ppermute(input, axis_name='i', perm=[[0, 1], [1, 0]])"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def ppermute(input):\n    return jax.lax.ppermute(input, axis_name='i', perm=[[0, 1], [1, 0]])"
  },
  {
    "test_code": "@jtu.skip_on_devices('cpu')\ndef testCollectivePermuteGrad(self):\n    device_count = jax.device_count()\n    shift_right = [(i, i + 1) for i in range(device_count - 1)]\n    f = lambda x: lax.ppermute(x, perm=shift_right, axis_name='i')\n    y = np.pi + np.arange(device_count, dtype=np.float32)\n    g = lambda x: jnp.sum(y * self.pmap(f, 'i')(x))\n    x = np.arange(device_count, dtype=np.float32)\n    ans = grad(g)(x)\n    expected = np.concatenate([np.pi + np.arange(1, device_count), [0]])\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def ppermute(input):\n    return jax.lax.ppermute(input, axis_name='i', perm=[[0, 1], [1, 0]])"
  },
  {
    "test_code": "def testCollectivePermuteCyclicGrad(self):\n    device_count = jax.device_count()\n    shift_right = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=shift_right, axis_name='i')\n    y = np.pi + np.arange(device_count, dtype=np.float32)\n    g = lambda x: jnp.sum(y * self.pmap(f, 'i')(x))\n    x = np.arange(device_count, dtype=np.float32)\n    ans = grad(g)(x)\n    expected = np.roll(np.pi + np.arange(device_count), -1)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    jtu.check_grads(g, (x,), 2, ['fwd', 'rev'], 0.01, 0.01)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def ppermute(input):\n    return jax.lax.ppermute(input, axis_name='i', perm=[[0, 1], [1, 0]])"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def ppermute(input):\n    return jax.lax.ppermute(input, axis_name='i', perm=[[0, 1], [1, 0]])"
  },
  {
    "test_code": "def testRule30(self):\n    device_count = jax.device_count()\n\n    def send_right(x, axis_name):\n        left_perm = [(i, (i + 1) % device_count) for i in range(device_count)]\n        return lax.ppermute(x, perm=left_perm, axis_name=axis_name)\n\n    def send_left(x, axis_name):\n        left_perm = [((i + 1) % device_count, i) for i in range(device_count)]\n        return lax.ppermute(x, perm=left_perm, axis_name=axis_name)\n\n    def update_board(board):\n        left = board[:-2]\n        right = board[2:]\n        center = board[1:-1]\n        return lax.bitwise_xor(left, lax.bitwise_or(center, right))\n\n    @partial(self.pmap, axis_name='i')\n    def step(board_slice):\n        left, right = (board_slice[:1], board_slice[-1:])\n        right, left = (send_left(left, 'i'), send_right(right, 'i'))\n        enlarged_board_slice = jnp.concatenate([left, board_slice, right])\n        return update_board(enlarged_board_slice)\n    board = np.zeros(40, dtype=bool)\n    board[board.shape[0] // 2] = True\n    reshaped_board = board.reshape((device_count, -1))\n    boards = []\n\n    def print_board(board):\n        boards.append(''.join(('*' if x else ' ' for x in board.ravel())))\n    print_board(reshaped_board)\n    for _ in range(9):\n        reshaped_board = step(reshaped_board)\n        print_board(reshaped_board)\n    ans = '\\n'.join(boards)\n    expected = '\\n'.join(('                    *                   ', '                   ***                  ', '                  **  *                 ', '                 ** ****                ', '                **  *   *               ', '               ** **** ***              ', '              **  *    *  *             ', '             ** ****  ******            ', '            **  *   ***     *           ', '           ** **** **  *   ***          '))\n    print(ans)\n    self.assertEqual(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def ppermute(input):\n    return jax.lax.ppermute(input, axis_name='i', perm=[[0, 1], [1, 0]])"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def ppermute(input):\n    return jax.lax.ppermute(input, axis_name='i', perm=[[0, 1], [1, 0]])"
  },
  {
    "test_code": "def testPPermuteAgreesWithVmap(self):\n    if jax.device_count() < 3:\n        raise SkipTest('test requires at least three devices')\n\n    def f(x):\n        return lax.ppermute(x, 'i', [[1, 0], [2, 1], [0, 2]])\n    xs = jnp.arange(3) * 10\n    ys = jax.pmap(f, axis_name='i')(xs)\n    zs = jax.vmap(f, axis_name='i')(xs)\n    self.assertAllClose(ys, zs, check_dtypes=True)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def ppermute(input):\n    return jax.lax.ppermute(input, axis_name='i', perm=[[0, 1], [1, 0]])"
  },
  {
    "test_code": "@parameterized.named_parameters(jtu.named_cases_from_sampler(lambda s: ({'testcase_name': f'{shapes}_{vmap_in_axes}_{vmap_out_axes}_{pmap_in_axes}_{pmap_out_axes}', 'shapes': shapes, 'vmap_in_axes': vmap_in_axes, 'vmap_out_axes': vmap_out_axes, 'pmap_in_axes': pmap_in_axes, 'pmap_out_axes': pmap_out_axes} for arg_shapes in s(compatible_shapes) for num_args in s(range(1, 4)) for shapes in s(list(it.combinations_with_replacement(arg_shapes, num_args))) for vmap_in_axes in s(all_bdims(*shapes, pmap=False)) for pmap_in_axes in s(all_bdims(*shapes, pmap=True)) for vmap_out_axes in s(out_bdims(shapes[0], False)) for pmap_out_axes in s(out_bdims(shapes[0], True)))))\ndef testVmapOfPmap(self, shapes, vmap_in_axes, pmap_in_axes, vmap_out_axes, pmap_out_axes):\n    vmapped_size = 3\n    pmapped_size = jax.device_count()\n    rng = jtu.rand_default(self.rng())\n\n    def fun(*args):\n        return sum(args)\n    final_shapes = map(partial(add_bdim, vmapped_size), vmap_in_axes, map(partial(add_bdim, pmapped_size), pmap_in_axes, shapes))\n\n    def args_slice(vi, pi):\n        return args_slicer(args_slicer(args, vmap_in_axes)(vi), pmap_in_axes)(pi)\n    args = [rng(shape, jnp.float32) for shape in final_shapes]\n    ans = vmap(pmap(fun, in_axes=pmap_in_axes, out_axes=pmap_out_axes), in_axes=vmap_in_axes, out_axes=vmap_out_axes)(*args)\n    expected = np.stack([np.stack([fun(*args_slice(vi, pi)) for pi in range(pmapped_size)], axis=pmap_out_axes) for vi in range(vmapped_size)], axis=vmap_out_axes)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, backend=backend)\ndef fun(x, y):\n    return jnp.matmul(x, y)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testJitOfPmapOutputSharding(self):\n    device_count = jax.device_count()\n    if device_count == 1 or config.disable_jit.value:\n        raise SkipTest('test requires at least two devices')\n\n    @jax.jit\n    @jax.pmap\n    def foo(x):\n        return x + x\n    x = np.ones((2, 2, 2), dtype=np.float32)\n    for _ in range(10):\n        with jtu.ignore_warning(message='.*Using jit-of-pmap can lead to inefficient data movement'):\n            x = foo(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_vjp\ndef foo(x):\n    return x"
  },
  {
    "test_code": "def testNestedPmaps(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2))\n    ans = foo(x)\n    expected = x * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_vjp\ndef foo(x):\n    return x"
  },
  {
    "test_code": "def testNestedPmapsBools(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return jnp.logical_not(y)\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2), jnp.bool_)\n    ans = foo(x)\n    expected = jnp.zeros((jax.device_count() // 2, 2), jnp.bool_)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_vjp\ndef foo(x):\n    return x"
  },
  {
    "test_code": "def testNestedPmapsError(self):\n\n    @partial(pmap, axis_name='i')\n    def foo(x):\n\n        @partial(pmap, axis_name='j', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    with self.assertRaisesRegex(ValueError, 'Nested pmap with explicit devices argument.'):\n        foo(jnp.ones((jax.device_count(), 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_vjp\ndef foo(x):\n    return x"
  },
  {
    "test_code": "def testJitInPmap(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @jit\n        def bar(y):\n            return y + 1\n        return lax.psum(bar(x), 'i')\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_vjp\ndef foo(x):\n    return x"
  },
  {
    "test_code": "@ignore_jit_of_pmap_warning()\ndef testPmapInJit(self):\n\n    @jit\n    def foo(x):\n\n        @partial(pmap, axis_name='i', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'i')\n        return bar(x)\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_vjp\ndef foo(x):\n    return x"
  },
  {
    "test_code": "def test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def foo(x):\n        return jnp.exp(x)\n\n    @foo.defjvp\n    def foo_jvp(xs, ts):\n        (x,), (t,) = (xs, ts)\n        return (foo(x), t * 4.0)\n    f = lambda x, t: jax.jvp(foo, (x,), (t,))\n    x = jnp.arange(jax.local_device_count() * 5, dtype=jnp.dtype('float32')).reshape((jax.local_device_count(), 5))\n    self.assertAllClose(self.pmap(f)(x, x), jax.vmap(f)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_vjp\ndef foo(x):\n    return x"
  },
  {
    "test_code": "def test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def foo(x):\n        return jnp.exp(x)\n\n    def foo_fwd(x):\n        return (foo(x), x)\n\n    def foo_bwd(_, g):\n        return (g * 5.0,)\n    foo.defvjp(foo_fwd, foo_bwd)\n    f = jax.grad(foo)\n    x = jnp.arange(jax.local_device_count(), dtype=jnp.dtype('float32'))\n    self.assertAllClose(self.pmap(f)(x), jax.vmap(f)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_vjp\ndef foo(x):\n    return x"
  },
  {
    "test_code": "def testNestedPmaps(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2))\n    ans = foo(x)\n    expected = x * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def bar(x):\n    out = jnp.sin(foo(x))\n    jax_setattr(thing, 'x', 5.0)\n    return out"
  },
  {
    "test_code": "def testNestedPmapsBools(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return jnp.logical_not(y)\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2), jnp.bool_)\n    ans = foo(x)\n    expected = jnp.zeros((jax.device_count() // 2, 2), jnp.bool_)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def bar(x):\n    out = jnp.sin(foo(x))\n    jax_setattr(thing, 'x', 5.0)\n    return out"
  },
  {
    "test_code": "def testNestedPmapsError(self):\n\n    @partial(pmap, axis_name='i')\n    def foo(x):\n\n        @partial(pmap, axis_name='j', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    with self.assertRaisesRegex(ValueError, 'Nested pmap with explicit devices argument.'):\n        foo(jnp.ones((jax.device_count(), 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def bar(x):\n    out = jnp.sin(foo(x))\n    jax_setattr(thing, 'x', 5.0)\n    return out"
  },
  {
    "test_code": "def testJitInPmap(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @jit\n        def bar(y):\n            return y + 1\n        return lax.psum(bar(x), 'i')\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def bar(x):\n    out = jnp.sin(foo(x))\n    jax_setattr(thing, 'x', 5.0)\n    return out"
  },
  {
    "test_code": "@ignore_jit_of_pmap_warning()\ndef testPmapInJit(self):\n\n    @jit\n    def foo(x):\n\n        @partial(pmap, axis_name='i', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'i')\n        return bar(x)\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def bar(x):\n    out = jnp.sin(foo(x))\n    jax_setattr(thing, 'x', 5.0)\n    return out"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def split(self) -> jax.Array:\n    key = jax_getattr(self, 'key')\n    new_key, returned_key = jax.random.split(key)\n    jax_setattr(self, 'key', new_key)\n    return returned_key"
  },
  {
    "test_code": "def test_typed_prng_key_sharded(self):\n    devices = jax.local_devices()\n\n    @partial(jax.pmap, in_axes=0, out_axes=0, axis_size=len(devices), axis_name='i', devices=devices)\n    def fn(key):\n        return jax.random.fold_in(key, 0)\n    sharded_key = jax.random.split(jax.random.key(0), len(devices))\n    replicated_key = jax.random.key(1)\n    sharded_key = jax.device_put_sharded(jnp.unstack(sharded_key), devices)\n    replicated_key = jax.device_put_replicated(replicated_key, devices)\n    fn(sharded_key)\n    fn(replicated_key)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def split(self) -> jax.Array:\n    key = jax_getattr(self, 'key')\n    new_key, returned_key = jax.random.split(key)\n    jax_setattr(self, 'key', new_key)\n    return returned_key"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'{suffix}', 'remat': remat} for suffix, remat in [('', jax.remat), ('_new', new_checkpoint)]))\ndef testAxisIndexRemat(self, remat):\n    n = len(jax.devices())\n\n    def f(key):\n        key = random.fold_in(key, jax.lax.axis_index('i'))\n        return random.bernoulli(key, p=0.5)\n    keys = random.split(random.PRNGKey(0), n)\n    self.pmap(remat(f), axis_name='i')(keys)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def split(self) -> jax.Array:\n    key = jax_getattr(self, 'key')\n    new_key, returned_key = jax.random.split(key)\n    jax_setattr(self, 'key', new_key)\n    return returned_key"
  },
  {
    "test_code": "def test_pmap_of_prng_key(self):\n    keys = jax.random.split(jax.random.key(0), jax.device_count())\n    result1 = jax.pmap(jax.random.bits)(keys)\n    with jtu.ignore_warning(category=UserWarning, message='The jitted function bits includes a pmap'):\n        result2 = jax.jit(jax.pmap(jax.random.bits))(keys)\n    self.assertArraysEqual(result1, result2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def split(self) -> jax.Array:\n    key = jax_getattr(self, 'key')\n    new_key, returned_key = jax.random.split(key)\n    jax_setattr(self, 'key', new_key)\n    return returned_key"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "def test_num_replicas_with_switch(self):\n\n    def identity(x):\n        return x\n\n    def cond_of_pmap(x):\n        y = lax.cond(True, jax.pmap(identity), jax.pmap(identity), x)\n        return y\n    with ignore_jit_of_pmap_warning():\n        cond_of_pmap(jnp.zeros((jax.device_count(), 2)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.named_scope('bar_cond')\ndef cond(x):\n    return x < 5.0"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "def testAllToAllReplicaGroups(self):\n    device_count = jax.device_count()\n    if device_count % 2 != 0:\n        raise SkipTest('test requires an even number of devices')\n    shape = (device_count, device_count // 2)\n    x = np.arange(math.prod(shape)).reshape(shape)\n    axis_index_groups = np.arange(device_count, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((device_count // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n\n    @partial(self.pmap, axis_name='i')\n    def fn(x):\n        return lax.all_to_all(x, 'i', 0, 0, axis_index_groups=axis_index_groups)\n    expected = np.swapaxes(x.reshape((device_count // 2, 2, device_count // 2)), 0, 2).reshape(shape)\n    self.assertAllClose(fn(x), expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@custom_transpose_with_example_out(jnp.ones(2))\ndef fn(r, x):\n    tracer_spy.append(r)\n    tracer_spy.append(x['c'])\n    return dict(b=x['c'] / r)"
  },
  {
    "test_code": "def testGradOfAllToAllReplicaGroups(self):\n    device_count = jax.device_count()\n    if device_count % 2 != 0:\n        raise SkipTest('test requires an even number of devices')\n    shape = (device_count, device_count // 2, 1)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n    axis_index_groups = np.arange(device_count, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((2, device_count // 2))\n    axis_index_groups = axis_index_groups.tolist()\n\n    @partial(self.pmap, axis_name='i')\n    def fn(x, w):\n        g = lambda x: jnp.sum(lax.all_to_all(x, 'i', 0, 1, axis_index_groups=axis_index_groups) * w)\n        return grad(g)(x)\n    expected = np.ones_like(x) * w[:, np.newaxis, np.newaxis]\n    expected = np.swapaxes(expected.reshape((2, device_count // 2, device_count // 2)), 1, 2).reshape(shape)\n    self.assertAllClose(fn(x, w), expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@custom_transpose_with_example_out(jnp.ones(2))\ndef fn(r, x):\n    tracer_spy.append(r)\n    tracer_spy.append(x['c'])\n    return dict(b=x['c'] / r)"
  },
  {
    "test_code": "def test_typed_prng_key_sharded(self):\n    devices = jax.local_devices()\n\n    @partial(jax.pmap, in_axes=0, out_axes=0, axis_size=len(devices), axis_name='i', devices=devices)\n    def fn(key):\n        return jax.random.fold_in(key, 0)\n    sharded_key = jax.random.split(jax.random.key(0), len(devices))\n    replicated_key = jax.random.key(1)\n    sharded_key = jax.device_put_sharded(jnp.unstack(sharded_key), devices)\n    replicated_key = jax.device_put_replicated(replicated_key, devices)\n    fn(sharded_key)\n    fn(replicated_key)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@custom_transpose_with_example_out(jnp.ones(2))\ndef fn(r, x):\n    tracer_spy.append(r)\n    tracer_spy.append(x['c'])\n    return dict(b=x['c'] / r)"
  },
  {
    "test_code": "def test_constants_fallback(self):\n    fn = pmap(lambda x, y: x + y, in_axes=(0, None))\n    for _ in range(2):\n        fn(np.zeros((jax.device_count(), 5), dtype=np.float32), 2.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@custom_transpose_with_example_out(jnp.ones(2))\ndef fn(r, x):\n    tracer_spy.append(r)\n    tracer_spy.append(x['c'])\n    return dict(b=x['c'] / r)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testJitOfPmapOutputSharding(self):\n    device_count = jax.device_count()\n    if device_count == 1 or config.disable_jit.value:\n        raise SkipTest('test requires at least two devices')\n\n    @jax.jit\n    @jax.pmap\n    def foo(x):\n        return x + x\n    x = np.ones((2, 2, 2), dtype=np.float32)\n    for _ in range(10):\n        with jtu.ignore_warning(message='.*Using jit-of-pmap can lead to inefficient data movement'):\n            x = foo(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "def testNestedPmaps(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2))\n    ans = foo(x)\n    expected = x * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "def testNestedPmapsBools(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return jnp.logical_not(y)\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2), jnp.bool_)\n    ans = foo(x)\n    expected = jnp.zeros((jax.device_count() // 2, 2), jnp.bool_)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "def testNestedPmapsError(self):\n\n    @partial(pmap, axis_name='i')\n    def foo(x):\n\n        @partial(pmap, axis_name='j', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    with self.assertRaisesRegex(ValueError, 'Nested pmap with explicit devices argument.'):\n        foo(jnp.ones((jax.device_count(), 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "def testJitInPmap(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @jit\n        def bar(y):\n            return y + 1\n        return lax.psum(bar(x), 'i')\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "@ignore_jit_of_pmap_warning()\ndef testPmapInJit(self):\n\n    @jit\n    def foo(x):\n\n        @partial(pmap, axis_name='i', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'i')\n        return bar(x)\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "def test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def foo(x):\n        return jnp.exp(x)\n\n    @foo.defjvp\n    def foo_jvp(xs, ts):\n        (x,), (t,) = (xs, ts)\n        return (foo(x), t * 4.0)\n    f = lambda x, t: jax.jvp(foo, (x,), (t,))\n    x = jnp.arange(jax.local_device_count() * 5, dtype=jnp.dtype('float32')).reshape((jax.local_device_count(), 5))\n    self.assertAllClose(self.pmap(f)(x, x), jax.vmap(f)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "def test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def foo(x):\n        return jnp.exp(x)\n\n    def foo_fwd(x):\n        return (foo(x), x)\n\n    def foo_bwd(_, g):\n        return (g * 5.0,)\n    foo.defvjp(foo_fwd, foo_bwd)\n    f = jax.grad(foo)\n    x = jnp.arange(jax.local_device_count(), dtype=jnp.dtype('float32'))\n    self.assertAllClose(self.pmap(f)(x), jax.vmap(f)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testOneDevice(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    d0 = jax.devices()[0]\n    d1 = jax.devices()[1]\n    f = lambda x: jnp.dot(x, x.T)\n    f0 = pmap(f, devices=[d0])\n    f1 = pmap(f, devices=[d1])\n    x = self.rng().rand(1, 500, 500)\n    r0 = f0(x)\n    r1 = f1(x)\n    expected = np.expand_dims(np.dot(x.squeeze(), x.squeeze().T), 0)\n    self.assertAllClose(r0, expected, atol=1e-06, rtol=0.001)\n    self.assertAllClose(r1, expected, atol=1e-06, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def rand(key):\n    nums = jax.vmap(lambda key: random.uniform(key, (1000,), dtype))(key)\n    return nums.flatten()"
  },
  {
    "test_code": "def test_num_replicas_with_switch(self):\n\n    def identity(x):\n        return x\n\n    def cond_of_pmap(x):\n        y = lax.cond(True, jax.pmap(identity), jax.pmap(identity), x)\n        return y\n    with ignore_jit_of_pmap_warning():\n        cond_of_pmap(jnp.zeros((jax.device_count(), 2)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def cond(x):\n    return jnp.linalg.norm(matvec(x) - b) > tolerance"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPmapPostProcess(self):\n\n    def mk_case(map_fun):\n\n        def f(x, y):\n\n            @partial(map_fun, in_axes=1, out_axes=2)\n            def h(y):\n                return jnp.sin(x + y)\n            return h(y).sum()\n        return f\n    xshape = (5, 7)\n    x = np.arange(math.prod(xshape), dtype=np.float32).reshape(xshape)\n    yshape = (5, jax.device_count(), 7)\n    y = np.arange(math.prod(yshape), dtype=np.float32).reshape(yshape)\n    self.assertAllClose(jax.grad(mk_case(pmap))(x, y), jax.grad(mk_case(vmap))(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef h(x):\n    return x"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testJitOfPmapOutputSharding(self):\n    device_count = jax.device_count()\n    if device_count == 1 or config.disable_jit.value:\n        raise SkipTest('test requires at least two devices')\n\n    @jax.jit\n    @jax.pmap\n    def foo(x):\n        return x + x\n    x = np.ones((2, 2, 2), dtype=np.float32)\n    for _ in range(10):\n        with jtu.ignore_warning(message='.*Using jit-of-pmap can lead to inefficient data movement'):\n            x = foo(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "def testNestedPmaps(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2))\n    ans = foo(x)\n    expected = x * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "def testNestedPmapsBools(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return jnp.logical_not(y)\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2), jnp.bool_)\n    ans = foo(x)\n    expected = jnp.zeros((jax.device_count() // 2, 2), jnp.bool_)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "def testNestedPmapsError(self):\n\n    @partial(pmap, axis_name='i')\n    def foo(x):\n\n        @partial(pmap, axis_name='j', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    with self.assertRaisesRegex(ValueError, 'Nested pmap with explicit devices argument.'):\n        foo(jnp.ones((jax.device_count(), 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "def testJitInPmap(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @jit\n        def bar(y):\n            return y + 1\n        return lax.psum(bar(x), 'i')\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "@ignore_jit_of_pmap_warning()\ndef testPmapInJit(self):\n\n    @jit\n    def foo(x):\n\n        @partial(pmap, axis_name='i', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'i')\n        return bar(x)\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "def test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def foo(x):\n        return jnp.exp(x)\n\n    @foo.defjvp\n    def foo_jvp(xs, ts):\n        (x,), (t,) = (xs, ts)\n        return (foo(x), t * 4.0)\n    f = lambda x, t: jax.jvp(foo, (x,), (t,))\n    x = jnp.arange(jax.local_device_count() * 5, dtype=jnp.dtype('float32')).reshape((jax.local_device_count(), 5))\n    self.assertAllClose(self.pmap(f)(x, x), jax.vmap(f)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "def test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def foo(x):\n        return jnp.exp(x)\n\n    def foo_fwd(x):\n        return (foo(x), x)\n\n    def foo_bwd(_, g):\n        return (g * 5.0,)\n    foo.defvjp(foo_fwd, foo_bwd)\n    f = jax.grad(foo)\n    x = jnp.arange(jax.local_device_count(), dtype=jnp.dtype('float32'))\n    self.assertAllClose(self.pmap(f)(x), jax.vmap(f)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef foo(x):\n    return jnp.concatenate(x)"
  },
  {
    "test_code": "def testNestedPmapReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 4 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas // 2).reshape(2, replicas // 4).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f1 = self.pmap(self.pmap(f, 'i'), 'j')\n    f2 = self.pmap(lambda x: self.pmap(f, 'i')(x) + 1.0, 'j')\n    f3 = self.pmap(self.pmap(f, 'j'), 'i')\n    shape = (2, replicas // 2, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper_f1(a):\n        return np.broadcast_to(a.sum(1, keepdims=True), (shape[0], shape[1] // 2, shape[2]))\n    expected_psum_1 = sum_helper_f1(x[:, :replicas // 4])\n    expected_psum_2 = sum_helper_f1(x[:, replicas // 4:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 1)\n    expected = x - expected_psum\n    ans = f1(x)\n    self.assertAllClose(ans, expected)\n    expected = x - expected_psum + 1.0\n    ans = f2(x)\n    self.assertAllClose(ans, expected)\n    shape = (replicas // 2, 2, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper_f3(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (shape[0] // 2, shape[1], shape[2]))\n    expected_psum_1 = sum_helper_f3(x[:replicas // 4])\n    expected_psum_2 = sum_helper_f3(x[replicas // 4:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f3(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f2(o, x):\n    self.assertIsInstance(o, dict)\n    self.assertIs(o['a'], obj['a'])\n    return jnp.sin(x)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testNestedPmapReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 4 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas // 2).reshape(2, replicas // 4).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f1 = self.pmap(self.pmap(f, 'i'), 'j')\n    f2 = self.pmap(lambda x: self.pmap(f, 'i')(x) + 1.0, 'j')\n    f3 = self.pmap(self.pmap(f, 'j'), 'i')\n    shape = (2, replicas // 2, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper_f1(a):\n        return np.broadcast_to(a.sum(1, keepdims=True), (shape[0], shape[1] // 2, shape[2]))\n    expected_psum_1 = sum_helper_f1(x[:, :replicas // 4])\n    expected_psum_2 = sum_helper_f1(x[:, replicas // 4:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 1)\n    expected = x - expected_psum\n    ans = f1(x)\n    self.assertAllClose(ans, expected)\n    expected = x - expected_psum + 1.0\n    ans = f2(x)\n    self.assertAllClose(ans, expected)\n    shape = (replicas // 2, 2, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper_f3(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (shape[0] // 2, shape[1], shape[2]))\n    expected_psum_1 = sum_helper_f3(x[:replicas // 4])\n    expected_psum_2 = sum_helper_f3(x[replicas // 4:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f3(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f3(x, o):\n    self.assertIs(o, obj)\n    return jnp.sin(x)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "def testJitOfPmapOutputSharding(self):\n    device_count = jax.device_count()\n    if device_count == 1 or config.disable_jit.value:\n        raise SkipTest('test requires at least two devices')\n\n    @jax.jit\n    @jax.pmap\n    def foo(x):\n        return x + x\n    x = np.ones((2, 2, 2), dtype=np.float32)\n    for _ in range(10):\n        with jtu.ignore_warning(message='.*Using jit-of-pmap can lead to inefficient data movement'):\n            x = foo(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    i = jax.lax.axis_index('x')\n    return jnp.exp(x) + i.astype(x.dtype)"
  },
  {
    "test_code": "def testNestedPmaps(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2))\n    ans = foo(x)\n    expected = x * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    i = jax.lax.axis_index('x')\n    return jnp.exp(x) + i.astype(x.dtype)"
  },
  {
    "test_code": "def testNestedPmapsBools(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return jnp.logical_not(y)\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2), jnp.bool_)\n    ans = foo(x)\n    expected = jnp.zeros((jax.device_count() // 2, 2), jnp.bool_)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    i = jax.lax.axis_index('x')\n    return jnp.exp(x) + i.astype(x.dtype)"
  },
  {
    "test_code": "def testNestedPmapsError(self):\n\n    @partial(pmap, axis_name='i')\n    def foo(x):\n\n        @partial(pmap, axis_name='j', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    with self.assertRaisesRegex(ValueError, 'Nested pmap with explicit devices argument.'):\n        foo(jnp.ones((jax.device_count(), 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    i = jax.lax.axis_index('x')\n    return jnp.exp(x) + i.astype(x.dtype)"
  },
  {
    "test_code": "def testJitInPmap(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @jit\n        def bar(y):\n            return y + 1\n        return lax.psum(bar(x), 'i')\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    i = jax.lax.axis_index('x')\n    return jnp.exp(x) + i.astype(x.dtype)"
  },
  {
    "test_code": "@ignore_jit_of_pmap_warning()\ndef testPmapInJit(self):\n\n    @jit\n    def foo(x):\n\n        @partial(pmap, axis_name='i', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'i')\n        return bar(x)\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    i = jax.lax.axis_index('x')\n    return jnp.exp(x) + i.astype(x.dtype)"
  },
  {
    "test_code": "def test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def foo(x):\n        return jnp.exp(x)\n\n    @foo.defjvp\n    def foo_jvp(xs, ts):\n        (x,), (t,) = (xs, ts)\n        return (foo(x), t * 4.0)\n    f = lambda x, t: jax.jvp(foo, (x,), (t,))\n    x = jnp.arange(jax.local_device_count() * 5, dtype=jnp.dtype('float32')).reshape((jax.local_device_count(), 5))\n    self.assertAllClose(self.pmap(f)(x, x), jax.vmap(f)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    i = jax.lax.axis_index('x')\n    return jnp.exp(x) + i.astype(x.dtype)"
  },
  {
    "test_code": "def test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def foo(x):\n        return jnp.exp(x)\n\n    def foo_fwd(x):\n        return (foo(x), x)\n\n    def foo_bwd(_, g):\n        return (g * 5.0,)\n    foo.defvjp(foo_fwd, foo_bwd)\n    f = jax.grad(foo)\n    x = jnp.arange(jax.local_device_count(), dtype=jnp.dtype('float32'))\n    self.assertAllClose(self.pmap(f)(x), jax.vmap(f)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    i = jax.lax.axis_index('x')\n    return jnp.exp(x) + i.astype(x.dtype)"
  },
  {
    "test_code": "def testNestedPmaps(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2))\n    ans = foo(x)\n    expected = x * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.remat, policy=lambda *args, **kwargs: True)\ndef bar(x):\n    return shard_map(foo, mesh=Mesh(jax.devices(), ['x']), in_specs=(P('x'),), out_specs=P('x'), check_rep=False)(x)"
  },
  {
    "test_code": "def testNestedPmapsBools(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return jnp.logical_not(y)\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2), jnp.bool_)\n    ans = foo(x)\n    expected = jnp.zeros((jax.device_count() // 2, 2), jnp.bool_)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.remat, policy=lambda *args, **kwargs: True)\ndef bar(x):\n    return shard_map(foo, mesh=Mesh(jax.devices(), ['x']), in_specs=(P('x'),), out_specs=P('x'), check_rep=False)(x)"
  },
  {
    "test_code": "def testNestedPmapsError(self):\n\n    @partial(pmap, axis_name='i')\n    def foo(x):\n\n        @partial(pmap, axis_name='j', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    with self.assertRaisesRegex(ValueError, 'Nested pmap with explicit devices argument.'):\n        foo(jnp.ones((jax.device_count(), 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.remat, policy=lambda *args, **kwargs: True)\ndef bar(x):\n    return shard_map(foo, mesh=Mesh(jax.devices(), ['x']), in_specs=(P('x'),), out_specs=P('x'), check_rep=False)(x)"
  },
  {
    "test_code": "def testJitInPmap(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @jit\n        def bar(y):\n            return y + 1\n        return lax.psum(bar(x), 'i')\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.remat, policy=lambda *args, **kwargs: True)\ndef bar(x):\n    return shard_map(foo, mesh=Mesh(jax.devices(), ['x']), in_specs=(P('x'),), out_specs=P('x'), check_rep=False)(x)"
  },
  {
    "test_code": "@ignore_jit_of_pmap_warning()\ndef testPmapInJit(self):\n\n    @jit\n    def foo(x):\n\n        @partial(pmap, axis_name='i', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'i')\n        return bar(x)\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.remat, policy=lambda *args, **kwargs: True)\ndef bar(x):\n    return shard_map(foo, mesh=Mesh(jax.devices(), ['x']), in_specs=(P('x'),), out_specs=P('x'), check_rep=False)(x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_axis_size={axis_size!r}', 'axis_size': axis_size} for axis_size in [1, 2]))\ndef test_grad_of_pmap_compilation_caching(self, axis_size):\n    if len(jax.local_devices()) < axis_size:\n        raise SkipTest('too few devices for test')\n    if config.disable_jit.value:\n        raise SkipTest(\"caching doesn't apply with jit disabled\")\n\n    @jax.pmap\n    def f(x):\n        return jnp.sin(x)\n    x = jnp.ones(axis_size)\n    _, f_bwd = jax.vjp(f, x)\n    _ = f_bwd(x)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _, f_bwd2 = jax.vjp(f, x)\n        _ = f_bwd(x)\n        _ = f_bwd2(x)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f_bwd(_, g):\n    return (jax.lax.psum(g, 'i'),)"
  },
  {
    "test_code": "def testPmapPostProcess(self):\n\n    def mk_case(map_fun):\n\n        def f(x, y):\n\n            @partial(map_fun, in_axes=1, out_axes=2)\n            def h(y):\n                return jnp.sin(x + y)\n            return h(y).sum()\n        return f\n    xshape = (5, 7)\n    x = np.arange(math.prod(xshape), dtype=np.float32).reshape(xshape)\n    yshape = (5, jax.device_count(), 7)\n    y = np.arange(math.prod(yshape), dtype=np.float32).reshape(yshape)\n    self.assertAllClose(jax.grad(mk_case(pmap))(x, y), jax.grad(mk_case(vmap))(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def h():\n\n    def _make_zeros():\n        return jnp.zeros(())\n    s = jax.sharding.NamedSharding(mesh2, P())\n    y = jax.jit(_make_zeros, out_shardings=s)()\n    return y.reshape((1,))"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testNestedPmaps(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2))\n    ans = foo(x)\n    expected = x * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def bar(y):\n    return jnp.multiply(x, y)"
  },
  {
    "test_code": "def testNestedPmapsBools(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return jnp.logical_not(y)\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2), jnp.bool_)\n    ans = foo(x)\n    expected = jnp.zeros((jax.device_count() // 2, 2), jnp.bool_)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def bar(y):\n    return jnp.multiply(x, y)"
  },
  {
    "test_code": "def testNestedPmapsError(self):\n\n    @partial(pmap, axis_name='i')\n    def foo(x):\n\n        @partial(pmap, axis_name='j', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    with self.assertRaisesRegex(ValueError, 'Nested pmap with explicit devices argument.'):\n        foo(jnp.ones((jax.device_count(), 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def bar(y):\n    return jnp.multiply(x, y)"
  },
  {
    "test_code": "def testJitInPmap(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @jit\n        def bar(y):\n            return y + 1\n        return lax.psum(bar(x), 'i')\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def bar(y):\n    return jnp.multiply(x, y)"
  },
  {
    "test_code": "@ignore_jit_of_pmap_warning()\ndef testPmapInJit(self):\n\n    @jit\n    def foo(x):\n\n        @partial(pmap, axis_name='i', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'i')\n        return bar(x)\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def bar(y):\n    return jnp.multiply(x, y)"
  },
  {
    "test_code": "def testJitOfPmapOutputSharding(self):\n    device_count = jax.device_count()\n    if device_count == 1 or config.disable_jit.value:\n        raise SkipTest('test requires at least two devices')\n\n    @jax.jit\n    @jax.pmap\n    def foo(x):\n        return x + x\n    x = np.ones((2, 2, 2), dtype=np.float32)\n    for _ in range(10):\n        with jtu.ignore_warning(message='.*Using jit-of-pmap can lead to inefficient data movement'):\n            x = foo(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n\n    def bar(y):\n        return jnp.multiply(x, y)\n    return jvp(bar, (3.0,), (1.0,))[1]"
  },
  {
    "test_code": "def testNestedPmaps(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2))\n    ans = foo(x)\n    expected = x * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n\n    def bar(y):\n        return jnp.multiply(x, y)\n    return jvp(bar, (3.0,), (1.0,))[1]"
  },
  {
    "test_code": "def testNestedPmapsBools(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return jnp.logical_not(y)\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2), jnp.bool_)\n    ans = foo(x)\n    expected = jnp.zeros((jax.device_count() // 2, 2), jnp.bool_)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n\n    def bar(y):\n        return jnp.multiply(x, y)\n    return jvp(bar, (3.0,), (1.0,))[1]"
  },
  {
    "test_code": "def testNestedPmapsError(self):\n\n    @partial(pmap, axis_name='i')\n    def foo(x):\n\n        @partial(pmap, axis_name='j', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    with self.assertRaisesRegex(ValueError, 'Nested pmap with explicit devices argument.'):\n        foo(jnp.ones((jax.device_count(), 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n\n    def bar(y):\n        return jnp.multiply(x, y)\n    return jvp(bar, (3.0,), (1.0,))[1]"
  },
  {
    "test_code": "def testJitInPmap(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @jit\n        def bar(y):\n            return y + 1\n        return lax.psum(bar(x), 'i')\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n\n    def bar(y):\n        return jnp.multiply(x, y)\n    return jvp(bar, (3.0,), (1.0,))[1]"
  },
  {
    "test_code": "@ignore_jit_of_pmap_warning()\ndef testPmapInJit(self):\n\n    @jit\n    def foo(x):\n\n        @partial(pmap, axis_name='i', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'i')\n        return bar(x)\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n\n    def bar(y):\n        return jnp.multiply(x, y)\n    return jvp(bar, (3.0,), (1.0,))[1]"
  },
  {
    "test_code": "def test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def foo(x):\n        return jnp.exp(x)\n\n    @foo.defjvp\n    def foo_jvp(xs, ts):\n        (x,), (t,) = (xs, ts)\n        return (foo(x), t * 4.0)\n    f = lambda x, t: jax.jvp(foo, (x,), (t,))\n    x = jnp.arange(jax.local_device_count() * 5, dtype=jnp.dtype('float32')).reshape((jax.local_device_count(), 5))\n    self.assertAllClose(self.pmap(f)(x, x), jax.vmap(f)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n\n    def bar(y):\n        return jnp.multiply(x, y)\n    return jvp(bar, (3.0,), (1.0,))[1]"
  },
  {
    "test_code": "def test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def foo(x):\n        return jnp.exp(x)\n\n    def foo_fwd(x):\n        return (foo(x), x)\n\n    def foo_bwd(_, g):\n        return (g * 5.0,)\n    foo.defvjp(foo_fwd, foo_bwd)\n    f = jax.grad(foo)\n    x = jnp.arange(jax.local_device_count(), dtype=jnp.dtype('float32'))\n    self.assertAllClose(self.pmap(f)(x), jax.vmap(f)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n\n    def bar(y):\n        return jnp.multiply(x, y)\n    return jvp(bar, (3.0,), (1.0,))[1]"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "def testPmapPostProcess(self):\n\n    def mk_case(map_fun):\n\n        def f(x, y):\n\n            @partial(map_fun, in_axes=1, out_axes=2)\n            def h(y):\n                return jnp.sin(x + y)\n            return h(y).sum()\n        return f\n    xshape = (5, 7)\n    x = np.arange(math.prod(xshape), dtype=np.float32).reshape(xshape)\n    yshape = (5, jax.device_count(), 7)\n    y = np.arange(math.prod(yshape), dtype=np.float32).reshape(yshape)\n    self.assertAllClose(jax.grad(mk_case(pmap))(x, y), jax.grad(mk_case(vmap))(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\n@functools.partial(jax.vmap, in_axes=(1, None), out_axes=1)\ndef h(x, y):\n    return jax.pure_callback(lambda x, y: np.sin(x) + y, x, x, y, vmap_method='legacy_vectorized')"
  },
  {
    "test_code": "def testJvpAndPartialEval(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n\n    def splitjvp(x):\n        _, jvp = linearize(f, x)\n        return jvp(jnp.ones_like(x))\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.cos(x)\n    ans = splitjvp(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    make_jaxpr(splitjvp)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def testGradOfJvp(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n\n    def splitjvp(x):\n        _, jvp = linearize(f, x)\n        return jvp(jnp.ones_like(x))\n    fun = lambda x: jnp.sum(jvp(jnp.sin, (x,), (jnp.ones_like(x),))[1])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(splitjvp(x)))(x)\n    expected = grad(fun)(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_axis_size={axis_size!r}', 'axis_size': axis_size} for axis_size in [1, 2]))\ndef test_grad_of_pmap_compilation_caching(self, axis_size):\n    if len(jax.local_devices()) < axis_size:\n        raise SkipTest('too few devices for test')\n    if config.disable_jit.value:\n        raise SkipTest(\"caching doesn't apply with jit disabled\")\n\n    @jax.pmap\n    def f(x):\n        return jnp.sin(x)\n    x = jnp.ones(axis_size)\n    _, f_bwd = jax.vjp(f, x)\n    _ = f_bwd(x)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _, f_bwd2 = jax.vjp(f, x)\n        _ = f_bwd(x)\n        _ = f_bwd2(x)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'{suffix}', 'remat': remat} for suffix, remat in [('', jax.remat), ('_new', new_checkpoint)]))\ndef test_remat_of_pmap(self, remat):\n    f = remat(jax.pmap(lambda x: jnp.sin(jnp.sin(x))))\n    jtu.check_grads(f, (jnp.arange(1.0),), order=2, modes=['rev'])\n    x = jnp.arange(1.0)\n    jaxpr = jax.make_jaxpr(jax.linearize(f, x)[1])(x)\n    self.assertIn(' sin ', str(jaxpr))\n    self.assertIn(' cos ', str(jaxpr))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'{suffix}', 'remat': remat} for suffix, remat in [('', jax.remat), ('_new', new_checkpoint)]))\ndef test_remat_of_pmap_policy(self, remat):\n    g = jax.pmap(lambda x: jnp.sin(jnp.sin(x)))\n    x = jnp.arange(1.0)\n    save_cos = lambda prim, *_, **__: str(prim) == 'cos'\n    f = remat(g, policy=save_cos)\n    _, f_vjp = jax.vjp(f, x)\n    jaxpr = f_vjp.args[0].func.args[1]\n    jaxpr_text = str(jaxpr)\n    self.assertEqual(jaxpr_text.count(' sin '), 0)\n    self.assertEqual(jaxpr_text.count(' cos '), 0)\n    save_sin = lambda prim, *_, **__: str(prim) == 'sin'\n    f = remat(g, policy=save_sin)\n    _, f_vjp = jax.vjp(f, x)\n    jaxpr = f_vjp.args[0].func.args[1]\n    jaxpr_text = str(jaxpr)\n    self.assertEqual(jaxpr_text.count(' sin '), 0)\n    self.assertEqual(jaxpr_text.count(' cos '), 2)\n    save_nothing = lambda prim, *_, **__: False\n    f = remat(g, policy=save_nothing)\n    _, f_vjp = jax.vjp(f, x)\n    jaxpr = f_vjp.args[0].func.args[1]\n    jaxpr_text = str(jaxpr)\n    self.assertEqual(jaxpr_text.count(' sin '), 1)\n    self.assertEqual(jaxpr_text.count(' cos '), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def testPmapInAxesGrad(self):\n\n    def f(x, y, z):\n        return jnp.sin(x + y + z)\n    fp = pmap(f, in_axes=(1, 2, None))\n    fv = vmap(f, in_axes=(1, 2, None))\n    xshape = (5, jax.device_count(), 7)\n    x = np.arange(math.prod(xshape), dtype=np.float32).reshape(xshape)\n    yshape = (5, 7, jax.device_count())\n    y = np.arange(math.prod(yshape), dtype=np.float32).reshape(yshape)\n    zshape = (5, 7)\n    z = np.arange(math.prod(zshape), dtype=np.float32).reshape(zshape)\n    dx, dy, dz = jax.grad(lambda args: fp(*args).sum())((x, y, z))\n    assert dx.shape == xshape\n    assert dy.shape == yshape\n    assert dz.shape == zshape\n    self.assertAllClose(jax.grad(lambda args: fp(*args).sum())((x, y, z)), jax.grad(lambda args: fv(*args).sum())((x, y, z)))",
    "assertions": [
      "assert dx.shape == xshape",
      "assert dy.shape == yshape",
      "assert dz.shape == zshape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.sample_product(in_axes=all_bdims((3, 4), (3, 1), (1, 4), pmap=True), out_axes=out_bdims((3, 4), True))\ndef testPmapAllAxesGrad(self, in_axes, out_axes):\n\n    def f(x, y, z):\n        return jnp.sin(x + y) * z\n    pmapped_size = jax.device_count()\n    mapped_shapes = [(3, 4), (3, 1), (1, 4)]\n    arg_shapes = map(partial(add_bdim, pmapped_size), in_axes, mapped_shapes)\n    rng = jtu.rand_default(self.rng())\n    args = [rng(shape, jnp.float64) for shape in arg_shapes]\n    jtu.check_grads(pmap(f, in_axes=in_axes, out_axes=out_axes), args, order=2, atol=0.02, rtol=0.02, eps=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def testPmapPostProcess(self):\n\n    def mk_case(map_fun):\n\n        def f(x, y):\n\n            @partial(map_fun, in_axes=1, out_axes=2)\n            def h(y):\n                return jnp.sin(x + y)\n            return h(y).sum()\n        return f\n    xshape = (5, 7)\n    x = np.arange(math.prod(xshape), dtype=np.float32).reshape(xshape)\n    yshape = (5, jax.device_count(), 7)\n    y = np.arange(math.prod(yshape), dtype=np.float32).reshape(yshape)\n    self.assertAllClose(jax.grad(mk_case(pmap))(x, y), jax.grad(mk_case(vmap))(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@parameterized.named_parameters(jtu.named_cases_from_sampler(lambda s: ({'testcase_name': f'{shapes}_{vmap_in_axes}_{vmap_out_axes}_{pmap_in_axes}_{pmap_out_axes}', 'shapes': shapes, 'vmap_in_axes': vmap_in_axes, 'vmap_out_axes': vmap_out_axes, 'pmap_in_axes': pmap_in_axes, 'pmap_out_axes': pmap_out_axes} for arg_shapes in s(compatible_shapes) for num_args in s(range(1, 4)) for shapes in s(list(it.combinations_with_replacement(arg_shapes, num_args))) for vmap_in_axes in s(all_bdims(*shapes, pmap=False)) for pmap_in_axes in s(all_bdims(*shapes, pmap=True)) for vmap_out_axes in s(out_bdims(shapes[0], False)) for pmap_out_axes in s(out_bdims(shapes[0], True)))))\ndef testVmapOfPmap(self, shapes, vmap_in_axes, pmap_in_axes, vmap_out_axes, pmap_out_axes):\n    vmapped_size = 3\n    pmapped_size = jax.device_count()\n    rng = jtu.rand_default(self.rng())\n\n    def fun(*args):\n        return sum(args)\n    final_shapes = map(partial(add_bdim, vmapped_size), vmap_in_axes, map(partial(add_bdim, pmapped_size), pmap_in_axes, shapes))\n\n    def args_slice(vi, pi):\n        return args_slicer(args_slicer(args, vmap_in_axes)(vi), pmap_in_axes)(pi)\n    args = [rng(shape, jnp.float32) for shape in final_shapes]\n    ans = vmap(pmap(fun, in_axes=pmap_in_axes, out_axes=pmap_out_axes), in_axes=vmap_in_axes, out_axes=vmap_out_axes)(*args)\n    expected = np.stack([np.stack([fun(*args_slice(vi, pi)) for pi in range(pmapped_size)], axis=pmap_out_axes) for vi in range(vmapped_size)], axis=vmap_out_axes)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def fun(x):\n    self.assertEqual(x.dtype, jnp.complex64)\n    out_type = (jax.ShapeDtypeStruct(x.shape[:-1], x.dtype), jax.ShapeDtypeStruct(x.shape, x.dtype))\n    return jax.pure_callback(callback, out_type, x)"
  },
  {
    "test_code": "def test_num_replicas_with_switch(self):\n\n    def identity(x):\n        return x\n\n    def cond_of_pmap(x):\n        y = lax.cond(True, jax.pmap(identity), jax.pmap(identity), x)\n        return y\n    with ignore_jit_of_pmap_warning():\n        cond_of_pmap(jnp.zeros((jax.device_count(), 2)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def cond(x):\n    return jax.pure_callback(_cond_callback, jax.ShapeDtypeStruct((), np.bool_), x)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "def testPmapPostProcess(self):\n\n    def mk_case(map_fun):\n\n        def f(x, y):\n\n            @partial(map_fun, in_axes=1, out_axes=2)\n            def h(y):\n                return jnp.sin(x + y)\n            return h(y).sum()\n        return f\n    xshape = (5, 7)\n    x = np.arange(math.prod(xshape), dtype=np.float32).reshape(xshape)\n    yshape = (5, jax.device_count(), 7)\n    y = np.arange(math.prod(yshape), dtype=np.float32).reshape(yshape)\n    self.assertAllClose(jax.grad(mk_case(pmap))(x, y), jax.grad(mk_case(vmap))(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname', akwarg='hello')\ndef h(x):\n    return x + 2"
  },
  {
    "test_code": "def testGradOfPsum(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.psum(x, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    jtu.check_grads(f, (x,), 2, ['fwd', 'rev'], 0.01, 0.01, eps=1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def check_grads(f, args, order, atol=None, rtol=None, eps=None):\n    default_tol = 1e-06 if config.enable_x64.value else 0.01\n    atol = atol or default_tol\n    rtol = rtol or default_tol\n    eps = eps or default_tol\n    jtu.check_jvp(f, partial(jax.jvp, f), args, atol, rtol, eps)\n    jtu.check_vjp(f, partial(jax.vjp, f), args, atol, rtol, eps)"
  },
  {
    "test_code": "@parameterized.named_parameters(it.chain.from_iterable(([(name, prim, False, False), (name + 'Tiled', prim, True, False), (name + 'IndexGroups', prim, False, True)] for name, prim in (('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)))))\ndef testGradOf(self, prim, tiled, use_axis_index_groups):\n    axis_index_groups = None\n    devices = jax.devices()\n    if use_axis_index_groups:\n        if len(devices) < 2:\n            raise SkipTest('Need at least two devices')\n        axis_index_groups = [(l.id, r.id) for l, r in np.asarray(devices).reshape(-1, 2)]\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return prim(x, axis_name='i', tiled=tiled, axis_index_groups=axis_index_groups)\n    shape = (len(devices), 2 if axis_index_groups else jax.device_count())\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    jtu.check_grads(f, (x,), 2, ['fwd', 'rev'], 0.01, 0.01, eps=1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def check_grads(f, args, order, atol=None, rtol=None, eps=None):\n    default_tol = 1e-06 if config.enable_x64.value else 0.01\n    atol = atol or default_tol\n    rtol = rtol or default_tol\n    eps = eps or default_tol\n    jtu.check_jvp(f, partial(jax.jvp, f), args, atol, rtol, eps)\n    jtu.check_vjp(f, partial(jax.vjp, f), args, atol, rtol, eps)"
  },
  {
    "test_code": "def testCollectivePermuteCyclicGrad(self):\n    device_count = jax.device_count()\n    shift_right = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=shift_right, axis_name='i')\n    y = np.pi + np.arange(device_count, dtype=np.float32)\n    g = lambda x: jnp.sum(y * self.pmap(f, 'i')(x))\n    x = np.arange(device_count, dtype=np.float32)\n    ans = grad(g)(x)\n    expected = np.roll(np.pi + np.arange(device_count), -1)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    jtu.check_grads(g, (x,), 2, ['fwd', 'rev'], 0.01, 0.01)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def check_grads(f, args, order, atol=None, rtol=None, eps=None):\n    default_tol = 1e-06 if config.enable_x64.value else 0.01\n    atol = atol or default_tol\n    rtol = rtol or default_tol\n    eps = eps or default_tol\n    jtu.check_jvp(f, partial(jax.jvp, f), args, atol, rtol, eps)\n    jtu.check_vjp(f, partial(jax.vjp, f), args, atol, rtol, eps)"
  },
  {
    "test_code": "def testPsumZeroCotangents(self):\n\n    def loss(params, meta_params):\n        net, mpo = params\n        return meta_params * mpo * net\n\n    def inner(meta_params, params):\n        grads = jax.grad(loss)(params, meta_params)\n        grads = lax.psum(grads, axis_name='i')\n        net_grads, mpo_grads = grads\n        net = params[0] + net_grads\n        mpo = params[1]\n        return mpo * net\n\n    def outer(params):\n        meta_params = jnp.array(4.0)\n        return jax.grad(inner)(meta_params, params)\n    params = (jnp.array([2.0]), jnp.array([3.0]))\n    self.pmap(outer, axis_name='i')(params)\n    f = self.pmap(outer, axis_name='i')\n    jtu.check_grads(f, (params,), 2, ['fwd', 'rev'], 0.001, 0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def check_grads(f, args, order, atol=None, rtol=None, eps=None):\n    default_tol = 1e-06 if config.enable_x64.value else 0.01\n    atol = atol or default_tol\n    rtol = rtol or default_tol\n    eps = eps or default_tol\n    jtu.check_jvp(f, partial(jax.jvp, f), args, atol, rtol, eps)\n    jtu.check_vjp(f, partial(jax.vjp, f), args, atol, rtol, eps)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'{suffix}', 'remat': remat} for suffix, remat in [('', jax.remat), ('_new', new_checkpoint)]))\ndef test_remat_of_pmap(self, remat):\n    f = remat(jax.pmap(lambda x: jnp.sin(jnp.sin(x))))\n    jtu.check_grads(f, (jnp.arange(1.0),), order=2, modes=['rev'])\n    x = jnp.arange(1.0)\n    jaxpr = jax.make_jaxpr(jax.linearize(f, x)[1])(x)\n    self.assertIn(' sin ', str(jaxpr))\n    self.assertIn(' cos ', str(jaxpr))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def check_grads(f, args, order, atol=None, rtol=None, eps=None):\n    default_tol = 1e-06 if config.enable_x64.value else 0.01\n    atol = atol or default_tol\n    rtol = rtol or default_tol\n    eps = eps or default_tol\n    jtu.check_jvp(f, partial(jax.jvp, f), args, atol, rtol, eps)\n    jtu.check_vjp(f, partial(jax.vjp, f), args, atol, rtol, eps)"
  },
  {
    "test_code": "@jtu.sample_product(in_axes=all_bdims((3, 4), (3, 1), (1, 4), pmap=True), out_axes=out_bdims((3, 4), True))\ndef testPmapAllAxesGrad(self, in_axes, out_axes):\n\n    def f(x, y, z):\n        return jnp.sin(x + y) * z\n    pmapped_size = jax.device_count()\n    mapped_shapes = [(3, 4), (3, 1), (1, 4)]\n    arg_shapes = map(partial(add_bdim, pmapped_size), in_axes, mapped_shapes)\n    rng = jtu.rand_default(self.rng())\n    args = [rng(shape, jnp.float64) for shape in arg_shapes]\n    jtu.check_grads(pmap(f, in_axes=in_axes, out_axes=out_axes), args, order=2, atol=0.02, rtol=0.02, eps=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def check_grads(f, args, order, atol=None, rtol=None, eps=None):\n    default_tol = 1e-06 if config.enable_x64.value else 0.01\n    atol = atol or default_tol\n    rtol = rtol or default_tol\n    eps = eps or default_tol\n    jtu.check_jvp(f, partial(jax.jvp, f), args, atol, rtol, eps)\n    jtu.check_vjp(f, partial(jax.vjp, f), args, atol, rtol, eps)"
  },
  {
    "test_code": "@parameterized.named_parameters(jtu.named_cases_from_sampler(lambda s: ({'testcase_name': f'{shapes}_{vmap_in_axes}_{vmap_out_axes}_{pmap_in_axes}_{pmap_out_axes}', 'shapes': shapes, 'vmap_in_axes': vmap_in_axes, 'vmap_out_axes': vmap_out_axes, 'pmap_in_axes': pmap_in_axes, 'pmap_out_axes': pmap_out_axes} for arg_shapes in s(compatible_shapes) for num_args in s(range(1, 4)) for shapes in s(list(it.combinations_with_replacement(arg_shapes, num_args))) for vmap_in_axes in s(all_bdims(*shapes, pmap=False)) for pmap_in_axes in s(all_bdims(*shapes, pmap=True)) for vmap_out_axes in s(out_bdims(shapes[0], False)) for pmap_out_axes in s(out_bdims(shapes[0], True)))))\ndef testVmapOfPmap(self, shapes, vmap_in_axes, pmap_in_axes, vmap_out_axes, pmap_out_axes):\n    vmapped_size = 3\n    pmapped_size = jax.device_count()\n    rng = jtu.rand_default(self.rng())\n\n    def fun(*args):\n        return sum(args)\n    final_shapes = map(partial(add_bdim, vmapped_size), vmap_in_axes, map(partial(add_bdim, pmapped_size), pmap_in_axes, shapes))\n\n    def args_slice(vi, pi):\n        return args_slicer(args_slicer(args, vmap_in_axes)(vi), pmap_in_axes)(pi)\n    args = [rng(shape, jnp.float32) for shape in final_shapes]\n    ans = vmap(pmap(fun, in_axes=pmap_in_axes, out_axes=pmap_out_axes), in_axes=vmap_in_axes, out_axes=vmap_out_axes)(*args)\n    expected = np.stack([np.stack([fun(*args_slice(vi, pi)) for pi in range(pmapped_size)], axis=pmap_out_axes) for vi in range(vmapped_size)], axis=vmap_out_axes)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef fun(unpacked_indexer, x):\n    indexer = pack_indexer(unpacked_indexer)\n    return x[indexer]"
  },
  {
    "test_code": "def testAllToAllReplicaGroups(self):\n    device_count = jax.device_count()\n    if device_count % 2 != 0:\n        raise SkipTest('test requires an even number of devices')\n    shape = (device_count, device_count // 2)\n    x = np.arange(math.prod(shape)).reshape(shape)\n    axis_index_groups = np.arange(device_count, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((device_count // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n\n    @partial(self.pmap, axis_name='i')\n    def fn(x):\n        return lax.all_to_all(x, 'i', 0, 0, axis_index_groups=axis_index_groups)\n    expected = np.swapaxes(x.reshape((device_count // 2, 2, device_count // 2)), 0, 2).reshape(shape)\n    self.assertAllClose(fn(x), expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def fn(data, segment_ids):\n    return jax.ops.segment_sum(data, segment_ids, num_segments).sum()"
  },
  {
    "test_code": "def testGradOfAllToAllReplicaGroups(self):\n    device_count = jax.device_count()\n    if device_count % 2 != 0:\n        raise SkipTest('test requires an even number of devices')\n    shape = (device_count, device_count // 2, 1)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n    axis_index_groups = np.arange(device_count, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((2, device_count // 2))\n    axis_index_groups = axis_index_groups.tolist()\n\n    @partial(self.pmap, axis_name='i')\n    def fn(x, w):\n        g = lambda x: jnp.sum(lax.all_to_all(x, 'i', 0, 1, axis_index_groups=axis_index_groups) * w)\n        return grad(g)(x)\n    expected = np.ones_like(x) * w[:, np.newaxis, np.newaxis]\n    expected = np.swapaxes(expected.reshape((2, device_count // 2, device_count // 2)), 1, 2).reshape(shape)\n    self.assertAllClose(fn(x, w), expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def fn(data, segment_ids):\n    return jax.ops.segment_sum(data, segment_ids, num_segments).sum()"
  },
  {
    "test_code": "def test_typed_prng_key_sharded(self):\n    devices = jax.local_devices()\n\n    @partial(jax.pmap, in_axes=0, out_axes=0, axis_size=len(devices), axis_name='i', devices=devices)\n    def fn(key):\n        return jax.random.fold_in(key, 0)\n    sharded_key = jax.random.split(jax.random.key(0), len(devices))\n    replicated_key = jax.random.key(1)\n    sharded_key = jax.device_put_sharded(jnp.unstack(sharded_key), devices)\n    replicated_key = jax.device_put_replicated(replicated_key, devices)\n    fn(sharded_key)\n    fn(replicated_key)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def fn(data, segment_ids):\n    return jax.ops.segment_sum(data, segment_ids, num_segments).sum()"
  },
  {
    "test_code": "def test_constants_fallback(self):\n    fn = pmap(lambda x, y: x + y, in_axes=(0, None))\n    for _ in range(2):\n        fn(np.zeros((jax.device_count(), 5), dtype=np.float32), 2.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def fn(data, segment_ids):\n    return jax.ops.segment_sum(data, segment_ids, num_segments).sum()"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def ref(x):\n    return spec.ref((x, jnp.zeros_like(x)))[1]"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_num_replicas_with_switch(self):\n\n    def identity(x):\n        return x\n\n    def cond_of_pmap(x):\n        y = lax.cond(True, jax.pmap(identity), jax.pmap(identity), x)\n        return y\n    with ignore_jit_of_pmap_warning():\n        cond_of_pmap(jnp.zeros((jax.device_count(), 2)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def cond(state):\n    idx, x, _ = state\n    chunk = jax.lax.dynamic_slice_in_dim(x, idx * chunk_size, chunk_size)\n    return (idx * chunk_size < x.shape[0]) & jnp.any(chunk > 0)"
  },
  {
    "test_code": "def testJitOfPmapOutputSharding(self):\n    device_count = jax.device_count()\n    if device_count == 1 or config.disable_jit.value:\n        raise SkipTest('test requires at least two devices')\n\n    @jax.jit\n    @jax.pmap\n    def foo(x):\n        return x + x\n    x = np.ones((2, 2, 2), dtype=np.float32)\n    for _ in range(10):\n        with jtu.ignore_warning(message='.*Using jit-of-pmap can lead to inefficient data movement'):\n            x = foo(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    output = jnp.zeros_like(x, device=cpu_sharding)\n    _, _, cpu_x = jax.lax.while_loop(cond, inner, (0, x, output))\n    return cpu_x"
  },
  {
    "test_code": "def testNestedPmaps(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2))\n    ans = foo(x)\n    expected = x * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    output = jnp.zeros_like(x, device=cpu_sharding)\n    _, _, cpu_x = jax.lax.while_loop(cond, inner, (0, x, output))\n    return cpu_x"
  },
  {
    "test_code": "def testNestedPmapsBools(self):\n    if jax.device_count() % 2 != 0:\n        raise SkipTest\n    if config.disable_jit.value:\n        raise SkipTest('disable_jit requires num devices to equal axis size')\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @partial(pmap, axis_name='j')\n        def bar(y):\n            return jnp.logical_not(y)\n        return bar(x)\n    x = jnp.ones((jax.device_count() // 2, 2), jnp.bool_)\n    ans = foo(x)\n    expected = jnp.zeros((jax.device_count() // 2, 2), jnp.bool_)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    output = jnp.zeros_like(x, device=cpu_sharding)\n    _, _, cpu_x = jax.lax.while_loop(cond, inner, (0, x, output))\n    return cpu_x"
  },
  {
    "test_code": "def testNestedPmapsError(self):\n\n    @partial(pmap, axis_name='i')\n    def foo(x):\n\n        @partial(pmap, axis_name='j', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'j')\n        return bar(x)\n    with self.assertRaisesRegex(ValueError, 'Nested pmap with explicit devices argument.'):\n        foo(jnp.ones((jax.device_count(), 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    output = jnp.zeros_like(x, device=cpu_sharding)\n    _, _, cpu_x = jax.lax.while_loop(cond, inner, (0, x, output))\n    return cpu_x"
  },
  {
    "test_code": "def testJitInPmap(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def foo(x):\n\n        @jit\n        def bar(y):\n            return y + 1\n        return lax.psum(bar(x), 'i')\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices * 2\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    output = jnp.zeros_like(x, device=cpu_sharding)\n    _, _, cpu_x = jax.lax.while_loop(cond, inner, (0, x, output))\n    return cpu_x"
  },
  {
    "test_code": "@ignore_jit_of_pmap_warning()\ndef testPmapInJit(self):\n\n    @jit\n    def foo(x):\n\n        @partial(pmap, axis_name='i', devices=jax.devices())\n        def bar(y):\n            return lax.psum(y, 'i')\n        return bar(x)\n    ndevices = jax.device_count()\n    ans = foo(jnp.ones((ndevices, 1)))\n    expected = np.ones((ndevices, 1), dtype=jnp.float_) * ndevices\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    output = jnp.zeros_like(x, device=cpu_sharding)\n    _, _, cpu_x = jax.lax.while_loop(cond, inner, (0, x, output))\n    return cpu_x"
  },
  {
    "test_code": "def test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def foo(x):\n        return jnp.exp(x)\n\n    @foo.defjvp\n    def foo_jvp(xs, ts):\n        (x,), (t,) = (xs, ts)\n        return (foo(x), t * 4.0)\n    f = lambda x, t: jax.jvp(foo, (x,), (t,))\n    x = jnp.arange(jax.local_device_count() * 5, dtype=jnp.dtype('float32')).reshape((jax.local_device_count(), 5))\n    self.assertAllClose(self.pmap(f)(x, x), jax.vmap(f)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    output = jnp.zeros_like(x, device=cpu_sharding)\n    _, _, cpu_x = jax.lax.while_loop(cond, inner, (0, x, output))\n    return cpu_x"
  },
  {
    "test_code": "def test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def foo(x):\n        return jnp.exp(x)\n\n    def foo_fwd(x):\n        return (foo(x), x)\n\n    def foo_bwd(_, g):\n        return (g * 5.0,)\n    foo.defvjp(foo_fwd, foo_bwd)\n    f = jax.grad(foo)\n    x = jnp.arange(jax.local_device_count(), dtype=jnp.dtype('float32'))\n    self.assertAllClose(self.pmap(f)(x), jax.vmap(f)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def foo(x):\n    output = jnp.zeros_like(x, device=cpu_sharding)\n    _, _, cpu_x = jax.lax.while_loop(cond, inner, (0, x, output))\n    return cpu_x"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "def testPmapPostProcess(self):\n\n    def mk_case(map_fun):\n\n        def f(x, y):\n\n            @partial(map_fun, in_axes=1, out_axes=2)\n            def h(y):\n                return jnp.sin(x + y)\n            return h(y).sum()\n        return f\n    xshape = (5, 7)\n    x = np.arange(math.prod(xshape), dtype=np.float32).reshape(xshape)\n    yshape = (5, jax.device_count(), 7)\n    y = np.arange(math.prod(yshape), dtype=np.float32).reshape(yshape)\n    self.assertAllClose(jax.grad(mk_case(pmap))(x, y), jax.grad(mk_case(vmap))(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@compute_on('gpu_stream:2')\n@jax.jit\ndef h(x, y):\n    return x @ y"
  },
  {
    "test_code": "def testAllToAllReplicaGroups(self):\n    device_count = jax.device_count()\n    if device_count % 2 != 0:\n        raise SkipTest('test requires an even number of devices')\n    shape = (device_count, device_count // 2)\n    x = np.arange(math.prod(shape)).reshape(shape)\n    axis_index_groups = np.arange(device_count, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((device_count // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n\n    @partial(self.pmap, axis_name='i')\n    def fn(x):\n        return lax.all_to_all(x, 'i', 0, 0, axis_index_groups=axis_index_groups)\n    expected = np.swapaxes(x.reshape((device_count // 2, 2, device_count // 2)), 0, 2).reshape(shape)\n    self.assertAllClose(fn(x), expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@compute_on('device_host')\ndef fn():\n    k = jax.random.key(0)\n    return jax.nn.initializers.lecun_normal()(k, (2, 2), jnp.float32)"
  },
  {
    "test_code": "def testGradOfAllToAllReplicaGroups(self):\n    device_count = jax.device_count()\n    if device_count % 2 != 0:\n        raise SkipTest('test requires an even number of devices')\n    shape = (device_count, device_count // 2, 1)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n    axis_index_groups = np.arange(device_count, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((2, device_count // 2))\n    axis_index_groups = axis_index_groups.tolist()\n\n    @partial(self.pmap, axis_name='i')\n    def fn(x, w):\n        g = lambda x: jnp.sum(lax.all_to_all(x, 'i', 0, 1, axis_index_groups=axis_index_groups) * w)\n        return grad(g)(x)\n    expected = np.ones_like(x) * w[:, np.newaxis, np.newaxis]\n    expected = np.swapaxes(expected.reshape((2, device_count // 2, device_count // 2)), 1, 2).reshape(shape)\n    self.assertAllClose(fn(x, w), expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@compute_on('device_host')\ndef fn():\n    k = jax.random.key(0)\n    return jax.nn.initializers.lecun_normal()(k, (2, 2), jnp.float32)"
  },
  {
    "test_code": "def test_typed_prng_key_sharded(self):\n    devices = jax.local_devices()\n\n    @partial(jax.pmap, in_axes=0, out_axes=0, axis_size=len(devices), axis_name='i', devices=devices)\n    def fn(key):\n        return jax.random.fold_in(key, 0)\n    sharded_key = jax.random.split(jax.random.key(0), len(devices))\n    replicated_key = jax.random.key(1)\n    sharded_key = jax.device_put_sharded(jnp.unstack(sharded_key), devices)\n    replicated_key = jax.device_put_replicated(replicated_key, devices)\n    fn(sharded_key)\n    fn(replicated_key)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@compute_on('device_host')\ndef fn():\n    k = jax.random.key(0)\n    return jax.nn.initializers.lecun_normal()(k, (2, 2), jnp.float32)"
  },
  {
    "test_code": "def test_constants_fallback(self):\n    fn = pmap(lambda x, y: x + y, in_axes=(0, None))\n    for _ in range(2):\n        fn(np.zeros((jax.device_count(), 5), dtype=np.float32), 2.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@compute_on('device_host')\ndef fn():\n    k = jax.random.key(0)\n    return jax.nn.initializers.lecun_normal()(k, (2, 2), jnp.float32)"
  },
  {
    "test_code": "def testOneDevice(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    d0 = jax.devices()[0]\n    d1 = jax.devices()[1]\n    f = lambda x: jnp.dot(x, x.T)\n    f0 = pmap(f, devices=[d0])\n    f1 = pmap(f, devices=[d1])\n    x = self.rng().rand(1, 500, 500)\n    r0 = f0(x)\n    r1 = f1(x)\n    expected = np.expand_dims(np.dot(x.squeeze(), x.squeeze().T), 0)\n    self.assertAllClose(r0, expected, atol=1e-06, rtol=0.001)\n    self.assertAllClose(r1, expected, atol=1e-06, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@compute_on('device_host')\n@jax.jit\ndef f0(x):\n    return x * 2"
  },
  {
    "test_code": "def testNestedPmapReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 4 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas // 2).reshape(2, replicas // 4).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f1 = self.pmap(self.pmap(f, 'i'), 'j')\n    f2 = self.pmap(lambda x: self.pmap(f, 'i')(x) + 1.0, 'j')\n    f3 = self.pmap(self.pmap(f, 'j'), 'i')\n    shape = (2, replicas // 2, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper_f1(a):\n        return np.broadcast_to(a.sum(1, keepdims=True), (shape[0], shape[1] // 2, shape[2]))\n    expected_psum_1 = sum_helper_f1(x[:, :replicas // 4])\n    expected_psum_2 = sum_helper_f1(x[:, replicas // 4:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 1)\n    expected = x - expected_psum\n    ans = f1(x)\n    self.assertAllClose(ans, expected)\n    expected = x - expected_psum + 1.0\n    ans = f2(x)\n    self.assertAllClose(ans, expected)\n    shape = (replicas // 2, 2, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper_f3(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (shape[0] // 2, shape[1], shape[2]))\n    expected_psum_1 = sum_helper_f3(x[:replicas // 4])\n    expected_psum_2 = sum_helper_f3(x[replicas // 4:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f3(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@compute_on('device_host')\n@jax.jit\ndef f1(x):\n    x = x * 3\n    return f0(x)"
  },
  {
    "test_code": "def testOneDevice(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    d0 = jax.devices()[0]\n    d1 = jax.devices()[1]\n    f = lambda x: jnp.dot(x, x.T)\n    f0 = pmap(f, devices=[d0])\n    f1 = pmap(f, devices=[d1])\n    x = self.rng().rand(1, 500, 500)\n    r0 = f0(x)\n    r1 = f1(x)\n    expected = np.expand_dims(np.dot(x.squeeze(), x.squeeze().T), 0)\n    self.assertAllClose(r0, expected, atol=1e-06, rtol=0.001)\n    self.assertAllClose(r1, expected, atol=1e-06, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@compute_on('device_host')\n@jax.jit\ndef f1(x):\n    x = x * 3\n    return f0(x)"
  },
  {
    "test_code": "def testNestedPmapReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 4 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas // 2).reshape(2, replicas // 4).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f1 = self.pmap(self.pmap(f, 'i'), 'j')\n    f2 = self.pmap(lambda x: self.pmap(f, 'i')(x) + 1.0, 'j')\n    f3 = self.pmap(self.pmap(f, 'j'), 'i')\n    shape = (2, replicas // 2, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper_f1(a):\n        return np.broadcast_to(a.sum(1, keepdims=True), (shape[0], shape[1] // 2, shape[2]))\n    expected_psum_1 = sum_helper_f1(x[:, :replicas // 4])\n    expected_psum_2 = sum_helper_f1(x[:, replicas // 4:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 1)\n    expected = x - expected_psum\n    ans = f1(x)\n    self.assertAllClose(ans, expected)\n    expected = x - expected_psum + 1.0\n    ans = f2(x)\n    self.assertAllClose(ans, expected)\n    shape = (replicas // 2, 2, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper_f3(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (shape[0] // 2, shape[1], shape[2]))\n    expected_psum_1 = sum_helper_f3(x[:replicas // 4])\n    expected_psum_2 = sum_helper_f3(x[replicas // 4:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f3(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@jax.jit\ndef f2(xs):\n    _, res = jax.lax.scan(body2, 1, xs)\n    return res"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_axis_size={axis_size!r}', 'axis_size': axis_size} for axis_size in [1, 2]))\ndef test_grad_of_pmap_compilation_caching(self, axis_size):\n    if len(jax.local_devices()) < axis_size:\n        raise SkipTest('too few devices for test')\n    if config.disable_jit.value:\n        raise SkipTest(\"caching doesn't apply with jit disabled\")\n\n    @jax.pmap\n    def f(x):\n        return jnp.sin(x)\n    x = jnp.ones(axis_size)\n    _, f_bwd = jax.vjp(f, x)\n    _ = f_bwd(x)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _, f_bwd2 = jax.vjp(f, x)\n        _ = f_bwd(x)\n        _ = f_bwd2(x)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f_bwd(res, tx):\n    x, z = res\n    y = x * 2\n    z2 = jax.device_put(y, s.with_memory_kind('pinned_host'))\n    return (eq(z, z2),)"
  },
  {
    "test_code": "def testBasic(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testMean(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.broadcast_to(np.mean(x, 0), x.shape)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testGather(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testGatherBool(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x = (x % 2).astype(np.bool_)\n    expected = np.array([x] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testGatherNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', axis=-1), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.T] * jax.device_count())\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testGatherTiled(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x] * device_count).reshape(device_count, -1)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testGatherTiledNegativeAxis(self):\n    f = self.pmap(lambda x: lax.all_gather(x, 'i', tiled=True, axis=-1), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4, 3)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.array([x.transpose(1, 0, 2).reshape(4, -1)] * device_count)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@parameterized.named_parameters([('Gather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testVmapOf(self, prim):\n    f = self.pmap(partial(prim, axis_name='i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (4, device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    self.assertAllClose(vmap(f)(x), jnp.stack([f(xs) for xs in x], axis=0))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testReduceScatter(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i'), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testReduceScatterTiled(self):\n    f = self.pmap(lambda x: lax.psum_scatter(x, 'i', tiled=True), axis_name='i')\n    device_count = jax.device_count()\n    shape = (device_count, 4 * device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = np.sum(x, axis=0)\n    ans = f(x)\n    scatter_len = len(expected) // device_count\n    for i, actual in enumerate(ans):\n        self.assertAllClose(actual, expected[i * scatter_len:(i + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testReduceScatterReplicaGroupsTiled(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = [[i for i in range(jax.device_count()) if i % 2 == 0], [i for i in range(jax.device_count()) if i % 2 != 0]]\n    f = lambda x: lax.psum_scatter(x, 'i', axis_index_groups=axis_index_groups, tiled=True)\n    f = self.pmap(f, axis_name='i')\n    shape = (replicas, 4 * replicas)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = np.sum(x[0::2, :], axis=0)\n    group_2_result = np.sum(x[1::2, :], axis=0)\n    scatter_len = len(group_1_result) * 2 // replicas\n    for i, actual in enumerate(ans):\n        expected = group_1_result if i % 2 == 0 else group_2_result\n        self.assertAllClose(actual, expected[i // 2 * scatter_len:(i // 2 + 1) * scatter_len])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testComplexPsum(self):\n    f = self.pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4 * 2)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape).view(np.complex64)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.sample_product(split_axis=list(range(2)), concat_axis=list(range(2)), dtype=lax_test_util.all_dtypes)\ndef testAllToAll(self, split_axis, concat_axis, dtype):\n    pmap_in_axis = 0\n    shape = (jax.device_count(),) * 3\n    rng = jtu.rand_default(self.rng())\n    x = rng(shape, dtype)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return lax.all_to_all(x, 'i', split_axis, concat_axis)\n    y = f(x)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_split={split_axis}_concat={concat_axis}', 'split_axis': split_axis, 'concat_axis': concat_axis} for split_axis, concat_axis in it.product(range(2), range(2))))\ndef testAllToAllSplitAxis(self, split_axis, concat_axis):\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    pmap_in_axis = 0\n    shape = (4, 4, 4)\n    x = np.arange(math.prod(shape)).reshape(shape)\n\n    @partial(self.pmap, axis_name='i')\n    @partial(self.pmap, axis_name='j')\n    def f(x):\n        return lax.all_to_all(x, ('i', 'j'), split_axis, concat_axis)\n    unroll_shape = (2, 2, *shape[1:])\n    x_unroll = x.reshape(unroll_shape)\n    y_unroll = f(x_unroll)\n    y = y_unroll.reshape(shape)\n    if pmap_in_axis <= split_axis:\n        split_axis += 1\n    ref = jnp.moveaxis(x, (pmap_in_axis, split_axis), (concat_axis + 1, 0))\n    self.assertAllClose(y, ref)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testNestedPmapAxisSwap(self):\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least 8 devices')\n    f = jax.pmap(jax.pmap(lambda x: x, in_axes=1, out_axes=0), in_axes=0, out_axes=0)\n    A = jnp.ones((2, 4, 3))\n    self.assertAllClose(A.transpose((0, 2, 1)), f(A))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testNestedBasic(self):\n    f = lambda x: lax.psum(lax.psum(x, 'i'), 'j')\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    shape = (jax.device_count(), 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testMismatchedAxisSizes(self):\n    n = jax.device_count()\n    f = self.pmap(lambda x, y: x + y)\n    self.assertRaisesRegex(ValueError, 'pmap got inconsistent sizes for array axes to be mapped', lambda: f(self.rng().randn(n), self.rng().randn(n - 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap in_axes[0][0]')):\n        f((x, x), x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testInAxesPyTreePrefixMismatchErrorKwargs(self):\n    x = jnp.array([3.14])\n    f = self.pmap(lambda x, y: x, in_axes=((0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('each argument passed by keyword is mapped')):\n        f(x=(x, x), y=x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testOutAxesPyTreePrefixMismatchError(self):\n    x = jnp.array([3.14])\n    f = jax.pmap(lambda x, y: ((x, x), x), out_axes=((0, 0, 0), 0))\n    with self.assertRaisesRegex(ValueError, re.escape('pmap out_axes[0]')):\n        f(x, x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedShardingAndStacking(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = lambda x: x\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = x\n    self.assertEqual(ans.shape, expected.shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testPartiallyMappedNested(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n    f = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    f = self.pmap(f, axis_name='j', in_axes=(None, 0))\n    x = 3.0\n    y = np.arange(math.prod(mesh_shape), dtype=np.float32).reshape(mesh_shape)\n    expected = np.broadcast_to(x - np.sum(y, 1, keepdims=True), mesh_shape)\n    ans = f(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPsumMultiple(self):\n    f = lambda x: lax.psum(x, ('i', 'j'))\n    f = self.pmap(self.pmap(f, 'i'), 'j')\n\n    def sum_and_broadcast(x, axis):\n        return np.repeat(np.sum(x, axis, keepdims=True), x.shape[axis], axis)\n    device_count = jax.device_count()\n    num_pairs, ragged = divmod(device_count, 2)\n    if num_pairs > 1 and (not ragged):\n        shape = (num_pairs, 2, 4)\n    else:\n        shape = (device_count, 1, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = sum_and_broadcast(sum_and_broadcast(x, 0), 1)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPsumConstantReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(2.0, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected_psum = 2.0 * replicas // 2\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef testPsumUnevenReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas <= 2:\n        raise SkipTest('Test expected devices greater than 2.')\n    axis_index_groups = [[0, 1], np.arange(2, replicas)]\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (len(a), x.shape[1]))\n    expected_psum_1 = sum_helper(x[0:2])\n    expected_psum_2 = sum_helper(x[2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPsumReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas).reshape(2, replicas // 2).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (replicas // 2, x.shape[1]))\n    expected_psum_1 = sum_helper(x[:replicas // 2])\n    expected_psum_2 = sum_helper(x[replicas // 2:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testGatherReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    axis_index_groups = np.arange(replicas, dtype=np.int32)\n    axis_index_groups = axis_index_groups.reshape((replicas // 2, 2)).T\n    axis_index_groups = axis_index_groups.tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    group_1_result = x[0::2]\n    group_2_result = x[1::2]\n    expected = np.empty((replicas, replicas // 2, x.shape[1]))\n    expected[0::2] = group_1_result\n    expected[1::2] = group_2_result\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testGatherReplicaGroupsInterleaved(self):\n    replicas = jax.device_count()\n    if replicas % 2 != 0:\n        raise SkipTest('Test expected an even number of devices greater than 1.')\n    indexes = np.arange(replicas)\n    indexes = np.concatenate([indexes[::2], indexes[1::2]])\n    axis_index_groups = indexes.reshape(2, replicas // 2).tolist()\n    f = lambda x: lax.all_gather(x, 'i', axis_index_groups=axis_index_groups)\n    f = self.pmap(f, 'i')\n    shape = (replicas, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = f(x)\n    expected = np.zeros((replicas, replicas // 2, x.shape[1]))\n    expected[::2] = x[::2]\n    expected[1::2] = x[1::2]\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef testCollectiveBroadcast(self):\n    device_count = jax.device_count()\n    f = lambda x: lax.pbroadcast(x, source=0, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.take(x, [0] * device_count, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testCollectivePermute(self):\n    device_count = jax.device_count()\n    rotation = [(i, (i + 1) % device_count) for i in range(device_count)]\n    f = lambda x: lax.ppermute(x, perm=rotation, axis_name='i')\n    f = self.pmap(f, 'i')\n    x = jnp.arange(4 * device_count).reshape((device_count, 4))\n    ans = f(x)\n    expected = np.roll(x, shift=1, axis=0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPpermuteWithZipObject(self):\n    num_devices = jax.device_count()\n    perm = [num_devices - 1] + list(range(num_devices - 1))\n    f = self.pmap(lambda x: lax.ppermute(x, 'i', zip(perm, range(num_devices))), 'i')\n    result = f(jnp.arange(num_devices, dtype=jnp.float32))\n    expected = jnp.asarray(perm, dtype=jnp.float32)\n    self.assertAllClose(result, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testReduceMax(self):\n    f = self.pmap(lambda x: x - lax.pmax(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.max(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testReduceMin(self):\n    f = self.pmap(lambda x: x - lax.pmin(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.min(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testDeviceCountError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 2 * x)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: 2 * x)\n    x = np.ones((device_count + 1, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))\n    f = self.pmap(lambda x: self.pmap(lambda x: 2 * x)(x))\n    x = np.ones((device_count, 2, 10))\n    self.assertRaisesRegex(ValueError, '.*requires.*replicas', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPmapConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    if not config.disable_jit.value:\n        f = self.pmap(lambda x: (x, 3))\n        x = np.arange(device_count)\n        with jtu.assert_num_jit_and_pmap_compilations(1):\n            _, ans = f(x)\n        self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPmapConstantDevices(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    devices = jax.devices()[:-1]\n    shuffle(devices)\n    f = self.pmap(lambda x: 3, devices=devices)\n    x = jnp.arange(len(devices))\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = np.repeat(3, len(devices))\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    ans_devices = ans.sharding._device_assignment\n    if not config.disable_jit.value:\n        self.assertEqual(ans_devices, tuple(devices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPmapConstantError(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: 3)\n    x = jnp.arange(device_count + 1)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testNestedPmapConstant(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x))(expected)\n    self.assertTrue(ans.sharding._device_assignment, expected_sharded.sharding._device_assignment)\n    f = self.pmap(self.pmap(lambda x: (x, 3)))\n    x_sharded, ans = f(x)\n    self.assertEqual(ans.sharding._device_assignment, x_sharded.sharding._device_assignment)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@unittest.skip('Nested pmaps with devices not yet implemented')\ndef testNestedPmapConstantDevices(self):\n    if jax.device_count() < 6:\n        raise SkipTest('this test requires >= 6 devices')\n    devices = jax.devices()[:-2]\n    shuffle(devices)\n    f = self.pmap(self.pmap(lambda x: 3), devices=devices)\n    shape = (2, len(devices) // 2, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        ans = f(x)\n    expected = 3 * np.ones(shape[:2])\n    self.assertAllClose(ans, expected, check_dtypes=False)\n    expected_sharded = self.pmap(self.pmap(lambda x: x), devices=devices)(expected)\n    self.assertTrue(ans.sharding == expected_sharded.sharding)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testNestedPmapConstantError(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error test doesn't apply with disable_jit\")\n    f = self.pmap(self.pmap(lambda x: 3))\n    shape = (2, jax.device_count() // 2 + 1, 3)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    self.assertRaisesRegex(ValueError, 'compiling computation that requires \\\\d+ logical devices, but only \\\\d+ XLA devices are available .*', lambda: f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testCollectiveConstant(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: lax.psum(1, 'i'), 'i')\n    x = jnp.arange(device_count)\n    ans = f(x)\n    expected = np.repeat(device_count, device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testAxisIndex(self):\n    device_count = jax.device_count()\n    f = self.pmap(lambda x: x + lax.axis_index('i'), 'i')\n    x = jnp.ones(device_count, dtype='int32')\n    ans = f(x)\n    expected = 1 + np.arange(device_count)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testAxisIndexNestedPmap(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axis: self.pmap(self.pmap(lambda x: x + lax.axis_index(axis), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected_j = np.broadcast_to(1 + np.arange(2), (2, 2))\n    self.assertAllClose(f('j')(x), expected_j, check_dtypes=False)\n    self.assertAllClose(f('i')(x), expected_j.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testAxisIndexNd(self):\n    device_count = jax.device_count()\n    if device_count < 4:\n        raise SkipTest('test requires at least four devices')\n    f = lambda axes: self.pmap(self.pmap(lambda x: x + lax.axis_index(axes), 'j'), 'i')\n    x = jnp.ones((2, 2), dtype='int32')\n    expected = 1 + np.arange(4).reshape((2, 2))\n    self.assertAllClose(f(('i', 'j'))(x), expected, check_dtypes=False)\n    self.assertAllClose(f(('j', 'i'))(x), expected.T, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testAxisIndexInInitialStyle(self):\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        def body(carry, i):\n            return (carry + i + lax.axis_index('i'), None)\n        return lax.scan(body, 0, x)[0]\n    device_count = jax.device_count()\n    shape = (device_count, 10)\n    self.assertAllClose(f(jnp.ones(shape, dtype='int32')), (jnp.arange(device_count, dtype='int32') + 1) * 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testGradOfPswapaxes(self):\n    device_count = jax.device_count()\n    shape = (device_count, 1, device_count)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    w = np.arange(device_count, dtype=np.float32)\n\n    @partial(self.pmap, axis_name='i')\n    def f(x, w):\n        g = lambda x: jnp.sum(lax.pswapaxes(x, 'i', 1) * w)\n        return grad(g)(x)\n    ans = f(x, w)\n    expected = np.tile(w, reps=device_count).reshape(shape)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testArrayGetItem(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    z = y[0]\n    self.assertAllClose(z, 2 * x[0], check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testManyArgs(self):\n\n    @self.pmap\n    def f(args_list):\n        return sum(args_list)\n    vals = list(range(500))\n    ndevices = jax.device_count()\n    self.assertAllClose(f([np.array([i] * ndevices) for i in range(500)]), jnp.array([sum(vals)] * ndevices))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_collective={collective.__name__}'.replace(' ', ''), 'collective': collective} for collective in [lax.psum, lax.pmean, lax.pmax, lax.pmin]))\ndef testCollectivesWithVmap2(self, collective):\n\n    def f(map1, map2):\n\n        @partial(map1, axis_name='i')\n        @partial(map2, axis_name='j')\n        def f(x, y):\n            return x + collective(x.dot(y), ('i', 'j'))\n        return f\n    if jax.device_count() < 8:\n        raise SkipTest('test requires at least eight devices')\n    x = jnp.arange(4 * 2 * 64 * 64, dtype=float).reshape(4, 2, 64, 64)\n    y = f(jax.pmap, jax.pmap)(x, x)\n    self.assertAllClose(f(jax.vmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.pmap, jax.vmap)(x, x), y)\n    self.assertAllClose(f(jax.vmap, jax.pmap)(x, x), y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPPermuteWithVmap(self):\n    perm = [(0, 1), (1, 0)]\n\n    def f(map2):\n\n        @partial(jax.pmap, axis_name='i')\n        @partial(map2)\n        def f(x, y):\n            return x + jax.lax.ppermute(x.dot(y), 'i', perm)\n        return f\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 64, 64))\n    self.assertAllClose(f(jax.pmap)(x, x), f(jax.vmap)(x, x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@parameterized.named_parameters([('AllGather', lax.all_gather), ('ReduceScatter', lax.psum_scatter)])\ndef testWithVmap(self, prim):\n\n    def f(map2):\n        return jax.pmap(map2(partial(prim, axis_name='i')), axis_name='i')\n    if jax.device_count() < 4:\n        raise SkipTest('test requires at least four devices')\n    x = jnp.ones((2, 2, 2, 64))\n    self.assertAllClose(f(jax.pmap)(x), f(jax.vmap)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testAllDevices(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = x - np.sum(x, 0)\n    ans = f(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testNoDevicesError(self):\n    f = pmap(lambda x: x - lax.psum(x, 'i'), axis_name='i', devices=[])\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with self.assertRaisesRegex(ValueError, \"'devices' argument to pmap must be non-empty, or None.\"):\n        f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testBadAxisSizeError(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    f = pmap(lambda x: lax.psum(x, 'i'), axis_name='i', devices=jax.devices())\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=1, num_local_devices=\\\\d.'):\n        f(jnp.ones(1))\n    with self.assertRaisesRegex(ValueError, 'Leading axis size of input to pmapped function must equal the number of local devices passed to pmap. Got axis_size=\\\\d, num_local_devices=\\\\d.'):\n        f(jnp.ones(jax.device_count() + 1))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testBadAxisSizeErrorNested(self):\n    if config.disable_jit.value:\n        raise SkipTest(\"error doesn't apply when jit is disabled\")\n    f = pmap(pmap(lambda x: lax.psum(x, ('i', 'j')), axis_name='j'), axis_name='i', devices=[jax.local_devices()[0]])\n    with self.assertRaisesRegex(ValueError, 'pmapped function requires 4 local devices to run due to nested pmapped or other parallel functions, but only 1 are available.'):\n        f(jnp.ones((1, 4)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testGradBasic(self):\n\n    @partial(pmap, axis_name='i', devices=jax.devices())\n    def f(x):\n        return jnp.sin(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(jnp.sin(x)))(x)\n    expected = grad(lambda x: jnp.sum(f(x)))(x)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPmapStaticArgnums(self):\n\n    @partial(pmap, axis_name='i', static_broadcasted_argnums=1)\n    def f(x, y):\n        return jnp.sin(x + y())\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = lambda: 3.0\n    ans = f(x, y)\n    expected = np.sin(x + 3.0)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPmapInAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, 2))\n    def f(x, y):\n        return jnp.sin(x + y)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4, jax.device_count())\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), jnp.sin(x.transpose((1, 0, 2)) + y.transpose((2, 0, 1))))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPmapOutAxesBasic(self):\n\n    @partial(pmap, in_axes=(1, None), out_axes=(2, None))\n    def f(x, y):\n        return (jnp.sin(x + y), y * 2)\n    xshape = (2, jax.device_count(), 4)\n    x = np.arange(math.prod(xshape)).reshape(xshape)\n    yshape = (2, 4)\n    y = np.arange(math.prod(yshape)).reshape(yshape)\n    self.assertAllClose(f(x, y), (jnp.sin(x.transpose((1, 0, 2)) + y).transpose((1, 2, 0)), y * 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPmapDictOutAxes(self):\n\n    @partial(pmap, out_axes={'a': 0})\n    def f(x):\n        return {'a': x}\n    device_count = jax.device_count()\n    x = jnp.arange(device_count)\n    jax.tree.map(self.assertAllClose, f(x), {'a': x})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_amap(self):\n    if jax.device_count() < 2:\n        self.skipTest('Test requires >= 2 devices.')\n\n    def amap(f, xs):\n        ys = [f(jax.device_put(x, list(x.devices())[0])) for x in xs]\n        return jax.device_put_sharded(ys, jax.local_devices()[:2])\n    x = jnp.array([[1.0, 0.0, 0.0], [0.0, 2.0, 3.0]])\n    y = jax.pmap(jnp.sin)(x)\n\n    def dynamic_shape_function(y):\n        nonzero_idx = y != 0\n        results = y[nonzero_idx] ** 2\n        return y.at[nonzero_idx].set(results)\n    z = amap(dynamic_shape_function, y)\n    w = jax.pmap(jnp.cos)(z)\n    self.assertArraysEqual(w, jnp.cos(jnp.sin(x) ** 2))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testNestedPmapReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 4 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas // 2).reshape(2, replicas // 4).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f1 = self.pmap(self.pmap(f, 'i'), 'j')\n    f2 = self.pmap(lambda x: self.pmap(f, 'i')(x) + 1.0, 'j')\n    f3 = self.pmap(self.pmap(f, 'j'), 'i')\n    shape = (2, replicas // 2, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper_f1(a):\n        return np.broadcast_to(a.sum(1, keepdims=True), (shape[0], shape[1] // 2, shape[2]))\n    expected_psum_1 = sum_helper_f1(x[:, :replicas // 4])\n    expected_psum_2 = sum_helper_f1(x[:, replicas // 4:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 1)\n    expected = x - expected_psum\n    ans = f1(x)\n    self.assertAllClose(ans, expected)\n    expected = x - expected_psum + 1.0\n    ans = f2(x)\n    self.assertAllClose(ans, expected)\n    shape = (replicas // 2, 2, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper_f3(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (shape[0] // 2, shape[1], shape[2]))\n    expected_psum_1 = sum_helper_f3(x[:replicas // 4])\n    expected_psum_2 = sum_helper_f3(x[replicas // 4:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f3(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f1(x):\n    return jnp.sin(x)"
  },
  {
    "test_code": "def testOneDevice(self):\n    if jax.device_count() == 1:\n        raise SkipTest('this test requires multiple devices')\n    d0 = jax.devices()[0]\n    d1 = jax.devices()[1]\n    f = lambda x: jnp.dot(x, x.T)\n    f0 = pmap(f, devices=[d0])\n    f1 = pmap(f, devices=[d1])\n    x = self.rng().rand(1, 500, 500)\n    r0 = f0(x)\n    r1 = f1(x)\n    expected = np.expand_dims(np.dot(x.squeeze(), x.squeeze().T), 0)\n    self.assertAllClose(r0, expected, atol=1e-06, rtol=0.001)\n    self.assertAllClose(r1, expected, atol=1e-06, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f1(x):\n    return jnp.sin(x)"
  },
  {
    "test_code": "def testNestedPmapReplicaGroups(self):\n    replicas = jax.device_count()\n    if replicas % 4 != 0:\n        raise SkipTest\n    axis_index_groups = np.arange(replicas // 2).reshape(2, replicas // 4).tolist()\n    f = lambda x: x - lax.psum(x, 'i', axis_index_groups=axis_index_groups)\n    f1 = self.pmap(self.pmap(f, 'i'), 'j')\n    f2 = self.pmap(lambda x: self.pmap(f, 'i')(x) + 1.0, 'j')\n    f3 = self.pmap(self.pmap(f, 'j'), 'i')\n    shape = (2, replicas // 2, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper_f1(a):\n        return np.broadcast_to(a.sum(1, keepdims=True), (shape[0], shape[1] // 2, shape[2]))\n    expected_psum_1 = sum_helper_f1(x[:, :replicas // 4])\n    expected_psum_2 = sum_helper_f1(x[:, replicas // 4:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 1)\n    expected = x - expected_psum\n    ans = f1(x)\n    self.assertAllClose(ans, expected)\n    expected = x - expected_psum + 1.0\n    ans = f2(x)\n    self.assertAllClose(ans, expected)\n    shape = (replicas // 2, 2, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n\n    def sum_helper_f3(a):\n        return np.broadcast_to(a.sum(0, keepdims=True), (shape[0] // 2, shape[1], shape[2]))\n    expected_psum_1 = sum_helper_f3(x[:replicas // 4])\n    expected_psum_2 = sum_helper_f3(x[replicas // 4:])\n    expected_psum = np.concatenate([expected_psum_1, expected_psum_2], 0)\n    expected = x - expected_psum\n    ans = f3(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def f2(x):\n    res1 = exp_f1.call(x)\n    res2 = exp_f1.call(res1)\n    return jnp.cos(res2)"
  },
  {
    "test_code": "def testPartiallyMapped(self):\n    f = self.pmap(lambda x, y: x, in_axes=(None, 0))\n    g = self.pmap(lambda x, y: x - lax.psum(y, 'i'), axis_name='i', in_axes=(None, 0))\n    mesh_shape = (jax.device_count(),)\n    shape = mesh_shape + (4,)\n    x = np.array(3.0, dtype=np.float32)\n    y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_expected = np.broadcast_to(x, mesh_shape)\n    f_ans = f(x, y)\n    self.assertAllClose(f_ans, f_expected)\n    self.assertIsInstance(f_ans, array.ArrayImpl)\n    sharding_spec = f_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])\n    g_expected = np.broadcast_to(x - np.sum(y, 0, keepdims=True), shape)\n    g_ans = g(x, y)\n    self.assertAllClose(g_ans, g_expected)\n    self.assertIsInstance(g_ans, array.ArrayImpl)\n    sharding_spec = g_ans.sharding.sharding_spec\n    self.assertEmpty([a for a in sharding_spec.mesh_mapping if isinstance(a, pxla.Replicated)])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testTwoArgsGrad(self):\n\n    def f(x, y):\n        return lax.psum(5.0 * jnp.cos(x) * jnp.sin(y), 'i')\n    f = self.pmap(f, 'i')\n\n    def g(x, y):\n        tot = jnp.sum(5.0 * jnp.cos(x) * jnp.sin(y))\n        return tot * jnp.ones_like(x)\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = 4 + x\n    ans = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    expected = grad(lambda x, y: jnp.sum(g(x, y)))(x, y)\n    self.assertAllClose(ans, expected, check_dtypes=False)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_mesh={device_mesh_shape}'.replace(' ', ''), 'device_mesh_shape': device_mesh_shape} for device_mesh_shape in [(1, 1), (2, -1), (-1, 2)]))\ndef testNestedWithClosure(self, device_mesh_shape):\n    mesh_shape = self._getMeshShape(device_mesh_shape)\n\n    @partial(self.pmap, axis_name='i')\n    def test_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @partial(self.pmap, axis_name='j')\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n\n    @vmap\n    def baseline_fun(x):\n        y = jnp.sum(jnp.sin(x))\n\n        @vmap\n        def g(z):\n            return 3.0 * jnp.exp(jnp.sin(x).sum() * jnp.cos(y) * jnp.tan(z))\n        return grad(lambda w: jnp.sum(g(w)))(x)\n    shape = mesh_shape + (4,)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    ans = grad(lambda x: jnp.sum(test_fun(x)))(x)\n    expected = grad(lambda x: jnp.sum(baseline_fun(x)))(x)\n    self.assertAllClose(ans, expected, atol=0.001, rtol=0.001)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testArrays(self):\n    f = lambda x: 2 * x\n    f = self.pmap(f, axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    y = f(x)\n    self.assertIsInstance(y, jax.Array)\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertNotIsInstance(y, np.ndarray)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = f(y)\n    self.assertIsInstance(z, array.ArrayImpl)\n    self.assertNotIsInstance(z, np.ndarray)\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    y = f(device_put(x))\n    self.assertIsInstance(y, array.ArrayImpl)\n    self.assertAllClose(y, 2 * x, check_dtypes=False)\n    z = y + y\n    self.assertAllClose(z, 2 * 2 * x, check_dtypes=False)\n    bufs = y._arrays[::-1]\n    sharding = jax.sharding.PmapSharding([list(b.devices())[0] for b in bufs], y.sharding.sharding_spec)\n    y = jax.make_array_from_single_device_arrays(y.shape, sharding, bufs)\n    z = f(y)\n    self.assertAllClose(z, 2 * 2 * x[::-1], check_dtypes=False)\n    repr(z)\n    g = jit(lambda z: z + y)\n    self.assertAllClose(g(7), y + 7)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testCollectiveConstantNested(self):\n    device_count = jax.device_count()\n\n    @partial(self.pmap, axis_name='i')\n    def f(x):\n\n        @partial(self.pmap, axis_name='j')\n        def g(y):\n            a = lax.psum(1, 'i')\n            b = lax.psum(1, 'j')\n            c = lax.psum(1, ('i', 'j'))\n            return (a, b, c)\n        return g(x)\n    shape = (device_count, 1, 4)\n    x = jnp.arange(math.prod(shape)).reshape(shape)\n    a, b, c = f(x)\n    self.assertEqual(a.shape, shape[:-1])\n    self.assertEqual(b.shape, shape[:-1])\n    self.assertEqual(c.shape, shape[:-1])\n    self.assertEqual(a.ravel()[0], device_count)\n    self.assertEqual(b.ravel()[0], 1)\n    self.assertEqual(c.ravel()[0], device_count * 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testVmapOfPmap2(self):\n    N_DEVICES = jax.device_count()\n    keys = random.split(random.PRNGKey(1), 13)\n\n    @self.pmap\n    def g(key):\n        _ = random.normal(key, ())\n        return 0.0\n\n    @vmap\n    def s(keys):\n        keys = jax.tree.map(lambda x: jnp.broadcast_to(x, (N_DEVICES,) + x.shape), keys)\n        return g(keys)\n    ans = s(keys)\n    self.assertEqual(ans.shape, (13, N_DEVICES))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testCompositionWithJitTwice(self):\n\n    @jit\n    def f(x):\n        y = jnp.float32(2) * x\n\n        @jit\n        def g(z):\n            return self.pmap(lambda x: x[jnp.newaxis] * y)(z)\n        return g(x)\n    f(np.arange(1.0, dtype='float32').reshape((1, 1)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPsumWithNoAxisDoesntLeakFunctions(self):\n    x = jnp.ones((1, 1024), dtype=np.float32)\n    f = lambda _: x\n    w = weakref.ref(f)\n    g = self.pmap(f)\n    g(np.ones((1,), dtype=np.float32)).block_until_ready()\n    del f, g\n    gc.collect()\n    self.assertIs(w(), None)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testLowerCompile(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x)\n    lowered = f.lower(x)\n    compiled = lowered.compile()\n    ans = compiled(x)\n    self.assertAllClose(ans, expected)\n    for obj in [lowered, compiled]:\n        self.assertFalse(obj._no_kwargs)\n        self.assertEqual(obj.in_tree, jax.tree.flatten(((0,), {}))[1])\n        self.assertEqual(obj.in_avals, ((core.ShapedArray(x.shape, x.dtype),), {}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerCompileInTreeMismatch(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f_exe = f.lower(x).compile()\n    self.assertRaisesRegex(TypeError, 'Function compiled with input pytree does not match the input pytree it was called with', lambda: f_exe([x]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerCompileTrivial(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x)\n    f_exe = f.lower(x).compile()\n    ans = f_exe(x)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerCompileTrivialInTreeMismatch(self):\n    f = self.pmap(lambda x: x, axis_name='i')\n    x = np.arange(jax.device_count(), dtype=np.float32)\n    f_exe = f.lower(x).compile()\n    self.assertRaisesRegex(TypeError, 'Function compiled with input pytree does not match the input pytree it was called with', lambda: f_exe([x]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerCompileArgTypeMismatch(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=int).reshape(shape)\n    x_f32 = x.astype(jnp.float32)\n    x_i32 = x.astype(jnp.int32)\n    f_exe = f.lower(x_f32).compile()\n    self.assertRaisesRegex(TypeError, \"Argument types differ .*The mismatches are:\\\\nArgument 'x' compiled with.*float32.*and called with.*int32.*\", lambda: f_exe(x_i32))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerCompileMultiArg(self):\n    f = self.pmap(lambda x, y: x - lax.pmean(y, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = y = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerCompileTrivialMultiArg(self):\n    f = self.pmap(lambda x, y: (x, y), axis_name='i')\n    x = y = np.arange(jax.device_count(), dtype=np.float32)\n    expected = f(x, y)\n    f_exe = f.lower(x, y).compile()\n    ans = f_exe(x, y)\n    self.assertAllClose(ans, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerAsText(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f = f.lower(x)\n    self.assertIsInstance(f.as_text(), str)\n    self.assertIsInstance(f.as_text(dialect='hlo'), str)\n    self.assertIsInstance(f.as_text(dialect='stablehlo'), str)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerCompilerIR(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f = f.lower(x)\n    self.assertIsNotNone(f.compiler_ir())\n    self.assertIsNotNone(f.compiler_ir(dialect='hlo'))\n    self.assertIsNotNone(f.compiler_ir(dialect='stablehlo'))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerCompileCompilerIR(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f = f.lower(x).compile()\n    self.assertIsNotNone(f.runtime_executable())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerCompileAsText(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f = f.lower(x).compile()\n    self.assertIsInstance(f.as_text(), (str, type(None)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerCostAnalysis(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f = f.lower(x)\n    f.cost_analysis()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerCompileCostAnalysis(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f = f.lower(x).compile()\n    f.cost_analysis()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerCompileMemoryAnalysis(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f = f.lower(x).compile()\n    f.memory_analysis()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerCompileExecutable(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    f = f.lower(x).compile()\n    self.assertIsNotNone(f.runtime_executable())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def test_jit_lower_compile_with_compiler_options(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    lowered = f.lower(x)\n    lowered.compile(compiler_options={'xla_embed_ir_in_executable': True})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def test_jit_lower_compile_with_compiler_options_invalid(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    lowered = f.lower(x)\n    self.assertRaisesRegex(xla_extension.XlaRuntimeError, \"No such compile option: 'invalid_key'\", lambda: lowered.compile(compiler_options={'invalid_key': 'invalid_value'}))\n    self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'is not a valid bool value.', lambda: lowered.compile(compiler_options={'xla_embed_ir_in_executable': 'invalid_value'}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def test_jit_lower_compile_with_compiler_options_multiple(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    lowered = f.lower(x)\n    l1 = lowered.compile()\n    l2 = lowered.compile(compiler_options={'xla_embed_ir_in_executable': True})\n    l3 = lowered.compile(compiler_options={'xla_embed_ir_in_executable': False})\n    self.assertTrue(l1 is not l2)\n    self.assertTrue(l1 is not l3)\n    self.assertTrue(l2 is not l3)\n    self.assertRaisesRegex(xla_extension.XlaRuntimeError, \"No such compile option: 'invalid_key'\", lambda: lowered.compile(compiler_options={'invalid_key': 'invalid_value'}))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerShapedArray(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    shape = (jax.device_count(), 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    x_shape = core.ShapedArray(x.shape, x.dtype)\n    self.assertAllClose(f.lower(x_shape).compile()(x), f(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testLowerHasReplicaAttributes(self):\n    f = self.pmap(lambda x: x - lax.pmean(x, 'i'), axis_name='i')\n    num_devices = jax.device_count()\n    shape = (num_devices, 4)\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    lowered = f.lower(x)\n    hlo = lowered.as_text('stablehlo')\n    self.assertIn(f'mhlo.num_replicas = {num_devices}', hlo)\n    self.assertIn('mhlo.num_partitions = 1', hlo)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "@jtu.ignore_warning(message='.*Using jit-of-pmap can lead to inefficient data movement')\ndef testJitOfPmapLowerHasReplicaAttributes(self):\n    device_count = jax.device_count()\n    if device_count == 1 or config.disable_jit.value:\n        raise SkipTest('test requires at least two devices')\n\n    @jax.jit\n    @jax.pmap\n    def foo(x):\n        return x + x\n    x = np.ones((2, 2, 2), dtype=np.float32)\n    hlo = foo.lower(x).as_text('stablehlo')\n    self.assertIn(f'mhlo.num_replicas = {2}', hlo)\n    self.assertIn('mhlo.num_partitions = 1', hlo)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def test_pmap_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x, y: x * y)\n    out = f(input_array, input_array)\n    expected = input_data * input_data\n    self.assertIsInstance(out, array.ArrayImpl)\n    for s in out.addressable_shards:\n        self.assertArraysEqual(s.data, expected[s.index])\n    self.assertArraysEqual(out, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def create_input_array_for_pmap(input_shape, in_axes=0, input_data=None, devices=None, sharded_dim_size=None):\n    if input_data is None:\n        input_data = np.arange(math.prod(input_shape)).reshape(input_shape)\n    sharding_spec = sharding_specs.create_pmap_sharding_spec(input_shape, in_axes, sharded_dim_size)\n    if devices is None:\n        devices = jax.devices()\n    pmap_sharding = jax.sharding.PmapSharding(np.array(devices), sharding_spec)\n    return (array.make_array_from_callback(input_shape, pmap_sharding, lambda idx: input_data[idx]), input_data)"
  },
  {
    "test_code": "def test_pmap_double_input_array_output_array(self):\n    input_shape = (jax.device_count(), 2)\n    input_array, input_data = create_input_array_for_pmap(input_shape)\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == (2,)\n        return (x, y)\n    f = jax.pmap(f)\n    out1, out2 = f(input_array, input_array)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    for s1, s2 in safe_zip(out1.addressable_shards, out2.addressable_shards):\n        self.assertArraysEqual(s1.data, input_data[s1.index])\n        self.assertArraysEqual(s2.data, input_data[s2.index])\n    self.assertArraysEqual(out1, input_data)\n    self.assertArraysEqual(out2, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == (2,)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def create_input_array_for_pmap(input_shape, in_axes=0, input_data=None, devices=None, sharded_dim_size=None):\n    if input_data is None:\n        input_data = np.arange(math.prod(input_shape)).reshape(input_shape)\n    sharding_spec = sharding_specs.create_pmap_sharding_spec(input_shape, in_axes, sharded_dim_size)\n    if devices is None:\n        devices = jax.devices()\n    pmap_sharding = jax.sharding.PmapSharding(np.array(devices), sharding_spec)\n    return (array.make_array_from_callback(input_shape, pmap_sharding, lambda idx: input_data[idx]), input_data)"
  },
  {
    "test_code": "def test_pmap_array_in_axes_out_axes(self):\n    dc = jax.device_count()\n    input_shape = (dc, 2)\n    a1, input_data = create_input_array_for_pmap(input_shape, in_axes=0)\n    a2, _ = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=a1.shape[0])\n\n    def f(x, y):\n        assert x.shape == (2,)\n        assert y.shape == input_shape\n        return (x, y)\n    f = jax.pmap(f, in_axes=(0, None), out_axes=(None, 0))\n    out1, out2 = f(a1, a2)\n    self.assertIsInstance(out1, array.ArrayImpl)\n    self.assertIsInstance(out2, array.ArrayImpl)\n    self.assertEqual(out1.shape, (2,))\n    self.assertEqual(out2.shape, (dc, dc, 2))\n    for i, (s1, s2) in enumerate(safe_zip(out1.addressable_shards, out2.addressable_shards)):\n        self.assertArraysEqual(s1.data, input_data[i])\n        if config.pmap_no_rank_reduction.value:\n            self.assertArraysEqual(s2.data, input_data[None])\n        else:\n            self.assertArraysEqual(s2.data, input_data)",
    "assertions": [
      "assert x.shape == (2,)",
      "assert y.shape == input_shape"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def create_input_array_for_pmap(input_shape, in_axes=0, input_data=None, devices=None, sharded_dim_size=None):\n    if input_data is None:\n        input_data = np.arange(math.prod(input_shape)).reshape(input_shape)\n    sharding_spec = sharding_specs.create_pmap_sharding_spec(input_shape, in_axes, sharded_dim_size)\n    if devices is None:\n        devices = jax.devices()\n    pmap_sharding = jax.sharding.PmapSharding(np.array(devices), sharding_spec)\n    return (array.make_array_from_callback(input_shape, pmap_sharding, lambda idx: input_data[idx]), input_data)"
  },
  {
    "test_code": "def test_pmap_array_sharding_mismatch(self):\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape, in_axes=None, sharded_dim_size=input_shape[0])\n    f = jax.pmap(lambda x: x, in_axes=0, out_axes=0)\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def create_input_array_for_pmap(input_shape, in_axes=0, input_data=None, devices=None, sharded_dim_size=None):\n    if input_data is None:\n        input_data = np.arange(math.prod(input_shape)).reshape(input_shape)\n    sharding_spec = sharding_specs.create_pmap_sharding_spec(input_shape, in_axes, sharded_dim_size)\n    if devices is None:\n        devices = jax.devices()\n    pmap_sharding = jax.sharding.PmapSharding(np.array(devices), sharding_spec)\n    return (array.make_array_from_callback(input_shape, pmap_sharding, lambda idx: input_data[idx]), input_data)"
  },
  {
    "test_code": "def test_pmap_array_devices_mismatch(self):\n    if jax.device_count() <= 1:\n        raise unittest.SkipTest('Skipping because this test needs more than 1 device.')\n    input_shape = (jax.device_count(), 2)\n    a1, inp_data = create_input_array_for_pmap(input_shape)\n    f = jax.pmap(lambda x: x, devices=jax.devices()[::-1])\n    out_array = f(a1)\n    self.assertArraysEqual(out_array, inp_data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def create_input_array_for_pmap(input_shape, in_axes=0, input_data=None, devices=None, sharded_dim_size=None):\n    if input_data is None:\n        input_data = np.arange(math.prod(input_shape)).reshape(input_shape)\n    sharding_spec = sharding_specs.create_pmap_sharding_spec(input_shape, in_axes, sharded_dim_size)\n    if devices is None:\n        devices = jax.devices()\n    pmap_sharding = jax.sharding.PmapSharding(np.array(devices), sharding_spec)\n    return (array.make_array_from_callback(input_shape, pmap_sharding, lambda idx: input_data[idx]), input_data)"
  },
  {
    "test_code": "def test_same_out_sharding_id(self):\n    if config.disable_jit.value:\n        self.skipTest('Skip this under eager pmap mode.')\n    shape = (jax.device_count(), 2)\n    arr, inp_data = create_input_array_for_pmap(shape)\n    f = pmap(lambda x: x)\n    out1 = f(arr)\n    self.assertArraysEqual(out1, inp_data)\n    out1_sharding_id = id(out1.sharding)\n    out2 = f(out1)\n    self.assertArraysEqual(out2, inp_data)\n    out2_sharding_id = id(out2.sharding)\n    out3 = f(out2)\n    self.assertArraysEqual(out3, inp_data)\n    out3_sharding_id = id(out3.sharding)\n    self.assertEqual(out1_sharding_id, out2_sharding_id)\n    self.assertEqual(out1_sharding_id, out3_sharding_id)\n    self.assertEqual(out2_sharding_id, out3_sharding_id)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def create_input_array_for_pmap(input_shape, in_axes=0, input_data=None, devices=None, sharded_dim_size=None):\n    if input_data is None:\n        input_data = np.arange(math.prod(input_shape)).reshape(input_shape)\n    sharding_spec = sharding_specs.create_pmap_sharding_spec(input_shape, in_axes, sharded_dim_size)\n    if devices is None:\n        devices = jax.devices()\n    pmap_sharding = jax.sharding.PmapSharding(np.array(devices), sharding_spec)\n    return (array.make_array_from_callback(input_shape, pmap_sharding, lambda idx: input_data[idx]), input_data)"
  },
  {
    "test_code": "def test_array_with_pmap_sharding_copy_without_round_trip(self):\n\n    def _compare_if_equal(out, out_copy):\n        self.assertArraysEqual(out, out_copy)\n        self.assertIsInstance(out_copy.sharding, jax.sharding.PmapSharding)\n        self.assertEqual(out.sharding, out_copy.sharding)\n        for o, o_copy in safe_zip(out.addressable_shards, out_copy.addressable_shards):\n            self.assertArraysEqual(o.data, o_copy.data)\n            self.assertEqual(o.device, o_copy.device)\n            self.assertEqual(o.index, o_copy.index)\n            self.assertEqual(o.replica_id, o_copy.replica_id)\n            self.assertNotEqual(o.data.unsafe_buffer_pointer(), o_copy.data.unsafe_buffer_pointer())\n    out, _ = create_input_array_for_pmap((jax.device_count(),))\n    out_copy = jnp.copy(out)\n    _compare_if_equal(out, out_copy)\n    out1, _ = create_input_array_for_pmap((1, jax.device_count()), in_axes=1)\n    out_copy1 = jnp.copy(out1)\n    _compare_if_equal(out1, out_copy1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pmap_test.py",
    "function": "def create_input_array_for_pmap(input_shape, in_axes=0, input_data=None, devices=None, sharded_dim_size=None):\n    if input_data is None:\n        input_data = np.arange(math.prod(input_shape)).reshape(input_shape)\n    sharding_spec = sharding_specs.create_pmap_sharding_spec(input_shape, in_axes, sharded_dim_size)\n    if devices is None:\n        devices = jax.devices()\n    pmap_sharding = jax.sharding.PmapSharding(np.array(devices), sharding_spec)\n    return (array.make_array_from_callback(input_shape, pmap_sharding, lambda idx: input_data[idx]), input_data)"
  }
]