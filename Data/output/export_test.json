[
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_call_name_conflict(self):\n\n    @jax.jit\n    def inner(x):\n        return jnp.where(x > 0, jnp.ones_like(x), jnp.zeros_like(x))\n    x = jnp.arange(-20, 20, dtype=np.int32)\n    exp_inner = export.export(inner)(x)\n    self.assertIn('@_where(', str(exp_inner.mlir_module()))\n\n    @jax.jit\n    def outer(x):\n        x = exp_inner.call(x)\n        return inner(x)\n    export.export(outer)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_pytree_namedtuple(self):\n    if not CAN_SERIALIZE:\n        raise unittest.SkipTest('test requires flatbuffers')\n    T = collections.namedtuple('SomeType', ('a', 'b', 'c'))\n    export.register_namedtuple_serialization(T, serialized_name='test_pytree_namedtuple.SomeType')\n    x = T(a=1, b=2, c=3)\n\n    def f(x):\n        return (x, x)\n    exp = export.export(jax.jit(f))(x)\n    res = exp.call(x)\n    self.assertEqual(tree_util.tree_structure(res), tree_util.tree_structure((x, x)))\n    self.assertEqual(type(res[0]), type(x))\n    self.assertEqual(type(res[1]), type(x))\n    ser = exp.serialize()\n    exp2 = export.deserialize(ser)\n    self.assertEqual(exp2.in_tree, exp.in_tree)\n    self.assertEqual(exp2.out_tree, exp.out_tree)\n    res2 = exp2.call(x)\n    self.assertEqual(tree_util.tree_structure(res2), tree_util.tree_structure(res))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_pytree_custom_types(self):\n    if not CAN_SERIALIZE:\n        raise unittest.SkipTest('test requires flatbuffers')\n    x1 = collections.OrderedDict([('foo', 34), ('baz', 101), ('something', -42)])\n\n    @tree_util.register_pytree_node_class\n    class CustomType:\n\n        def __init__(self, a: int, b: CustomType | None, string: str):\n            self.a = a\n            self.b = b\n            self.string = string\n\n        def tree_flatten(self):\n            return ((self.a, self.b), self.string)\n\n        @classmethod\n        def tree_unflatten(cls, aux_data, children):\n            string = aux_data\n            return cls(*children, string)\n    export.register_pytree_node_serialization(CustomType, serialized_name='test_pytree_custom_types.CustomType', serialize_auxdata=lambda aux: aux.encode('utf-8'), deserialize_auxdata=lambda b: b.decode('utf-8'))\n    x2 = CustomType(4, 5, 'foo')\n\n    def f(x1, x2):\n        return (x1, x2, x1, x2)\n    exp = export.export(jax.jit(f))(x1, x2)\n    res = exp.call(x1, x2)\n    self.assertEqual(tree_util.tree_structure(res), tree_util.tree_structure((x1, x2, x1, x2)))\n    self.assertEqual(type(res[0]), type(x1))\n    self.assertEqual(type(res[1]), type(x2))\n    self.assertEqual(type(res[2]), type(x1))\n    self.assertEqual(type(res[3]), type(x2))\n    ser = exp.serialize()\n    exp2 = export.deserialize(ser)\n    self.assertEqual(exp2.in_tree, exp.in_tree)\n    self.assertEqual(exp2.out_tree, exp.out_tree)\n    res2 = exp2.call(x1, x2)\n    self.assertEqual(tree_util.tree_structure(res2), tree_util.tree_structure(res))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_error_wrong_intree(self):\n\n    def f(a_b_pair, *, c):\n        return jnp.sin(a_b_pair[0]) + jnp.cos(a_b_pair[1]) + c\n    a = b = c = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f))((a, b), c=c)\n    with self.assertRaisesRegex(ValueError, 'The invocation args and kwargs must have the same pytree structure'):\n        exp_f.call(a, b, c=(a, b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_error_wrong_avals(self):\n\n    def f(a, *, b):\n        return jnp.sin(a) + jnp.cos(b)\n    f32_4 = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f))(f32_4, b=f32_4)\n    with self.assertRaisesRegex(ValueError, 'Shape mismatch for args\\\\[0\\\\].shape\\\\[0\\\\]'):\n        exp_f.call(np.arange(6, dtype=np.float32), b=f32_4)\n    with self.assertRaisesRegex(ValueError, \"Shape mismatch for kwargs\\\\['b'\\\\].shape\\\\[0\\\\]\"):\n        exp_f.call(f32_4, b=np.arange(6, dtype=np.float32))\n    with self.assertRaisesRegex(ValueError, 'Rank mismatch for args\\\\[0\\\\]'):\n        exp_f.call(f32_4.reshape((1, 4)), b=f32_4)\n    with self.assertRaisesRegex(ValueError, 'Dtype mismatch for args\\\\[0\\\\]'):\n        exp_f.call(f32_4.astype(np.float16), b=f32_4)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: kw['platform'], kwargs=[dict(platform=p) for p in ('cpu', 'cuda', 'rocm', 'tpu')])\ndef test_error_wrong_platform(self, platform):\n    a = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(jnp.sin, platforms=(platform,))(a)\n    if xb.canonicalize_platform(jtu.device_under_test()) == platform:\n        raise unittest.SkipTest('Uninteresting scenario')\n    with self.assertRaisesRegex(ValueError, 'Function .* was exported for platform'):\n        exp_f.call(a)\n    exp_f_no_platform_check = get_exported(jnp.sin, platforms=(platform,), disabled_checks=[export.DisabledSafetyCheck.platform()])(a)\n    res = exp_f_no_platform_check.call(a)\n    self.assertAllClose(res, jnp.sin(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_roundtrip(self):\n\n    def f1(x):\n        return jnp.sin(x)\n    a = np.arange(4, dtype=np.float32)\n    exp_f1 = get_exported(jax.jit(f1))(a)\n\n    def f2(x):\n        res1 = exp_f1.call(x)\n        res2 = exp_f1.call(res1)\n        return jnp.cos(res2)\n    exp_f2 = get_exported(jax.jit(f2))(a)\n    self.assertAllClose(jnp.cos(jnp.sin(jnp.sin(a))), exp_f2.call(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(kwargs=[dict(v=v) for v in range(export.minimum_supported_calling_convention_version - 1, export.maximum_supported_calling_convention_version + 2)])\ndef test_poly_basic_versions(self, v: int):\n    with config.jax_export_calling_convention_version(v):\n        logging.info('Using JAX calling convention version %s', config.jax_export_calling_convention_version.value)\n        with contextlib.ExitStack() as e:\n            if not export.minimum_supported_calling_convention_version <= v <= export.maximum_supported_calling_convention_version:\n                e.enter_context(self.assertRaisesRegex(ValueError, f'The requested export calling convention version {v} is outside the range of supported versions'))\n            exp = get_exported(jnp.sin)(jax.ShapeDtypeStruct(export.symbolic_shape('w, h'), np.float32))\n            x = np.arange(30, dtype=np.float32).reshape((5, 6))\n            res = exp.call(x)\n            self.assertAllClose(res, np.sin(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'inner={kw['inner_poly_spec']}_outer={kw['outer_poly_spec']}', kwargs=[dict(inner_poly_spec='3,4,12', outer_poly_spec='3,4,12'), dict(inner_poly_spec='3,a,a+b', outer_poly_spec='3,4,12'), dict(inner_poly_spec='3,4,3*a', outer_poly_spec='3,4,12'), dict(inner_poly_spec='3,a,a', outer_poly_spec='3,4,12', expect_error_outer_exp=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 12) and the specification 'a' (= 4)\")), dict(inner_poly_spec='3,4,5*a', outer_poly_spec='3,4,12', expect_error_outer_exp=re.escape(\"Division had remainder 2 when computing the value of 'a'\")), dict(inner_poly_spec='3,4,12+a', outer_poly_spec='3,4,12', expect_error_outer_exp=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 12). Obtained dimension variables: 'a' = 0 from specification 'a + 12' for dimension args[0].shape[2] (= 12)\")), dict(inner_poly_spec='3,a,b', outer_poly_spec='3,4,c'), dict(inner_poly_spec='3,4,3*a', outer_poly_spec='3,4,6*c'), dict(inner_poly_spec='3,a,a+8', outer_poly_spec='3,c+2,c+10'), dict(inner_poly_spec='3,a,a+b', outer_poly_spec='3,4,c', expect_error_outer_exp=re.escape(\"Expected value >= 1 for dimension variable 'b'. Using the following polymorphic shapes specifications: args[0].shape = (3, a, b + a). Obtained dimension variables: 'a' = 4 from specification 'a' for dimension args[0].shape[1] (= 4), 'b' = c - 4 from specification 'b + a' for dimension args[0].shape[2] (= c),\")), dict(inner_poly_spec='3,a,a', outer_poly_spec='3,4,c', expect_error_outer_exp=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= c) and the specification 'a' (= 4)\")), dict(inner_poly_spec='3,a,a', arg_shape=(3, 4), outer_poly_spec='3,c', expect_error_outer_exp='Rank mismatch for args\\\\[0\\\\]'), dict(inner_poly_spec='3,a,a+b', arg_dtype=np.int32, outer_poly_spec='3,c,d', expect_error_outer_exp='Dtype mismatch for args\\\\[0\\\\]'), dict(inner_poly_spec='3,4,5*a', outer_poly_spec='3,4,c', expect_error_outer_exp=re.escape(\"Division had remainder mod(c, 5) when computing the value of 'a'\")), dict(inner_poly_spec='3,a,a+b', outer_poly_spec='3,c,c', expect_error_outer_exp=re.escape(\"Expected value >= 1 for dimension variable 'b'. Using the following polymorphic shapes specifications: args[0].shape = (3, a, b + a). Obtained dimension variables: 'a' = c from specification 'a' for dimension args[0].shape[1] (= c), 'b' = 0 from specification 'b + a' for dimension args[0].shape[2] (= c)\")), dict(inner_poly_spec='3,a,a+b', outer_poly_spec='c,4,12', expect_error_outer_exp=re.escape('Shape mismatch for args[0].shape[0] (expected same constant)')), dict(inner_poly_spec='3,4,5*a', outer_poly_spec='3,4,25*c', expect_error_run=re.escape(\"Division had remainder 12 when computing the value of 'c'\")), dict(inner_poly_spec='3,a,b', outer_poly_spec='3,c+4,12', expect_error_run=re.escape(\"Expected value >= 1 for dimension variable 'c'. Using the following polymorphic shapes specifications: args[0].shape = (3, c + 4, 12). Obtained dimension variables: 'c' = 0\")), dict(inner_poly_spec='3,a,a', outer_poly_spec='3,a,a', expect_error_run=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 12) and the specification 'a' (= 4)\"))])\ndef test_poly_shape_checks_nested(self, inner_poly_spec='3,4,5*a', arg_shape=(3, 4, 12), arg_dtype=np.float32, outer_poly_spec='3,4,25*c', expect_error_outer_exp=None, expect_error_run=None):\n\n    def inner(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    inner_exp = get_exported(jax.jit(inner))(jax.ShapeDtypeStruct(export.symbolic_shape(inner_poly_spec), np.float32))\n    self.assertEqual(inner_exp.uses_global_constants, inner_poly_spec != '3,4,12')\n\n    def outer(x):\n        return inner_exp.call(x) + inner(x)\n    with contextlib.ExitStack() as stack:\n        if expect_error_outer_exp is not None:\n            stack.push(self.assertRaisesRegex(ValueError, expect_error_outer_exp))\n        outer_exp = get_exported(jax.jit(outer))(jax.ShapeDtypeStruct(export.symbolic_shape(outer_poly_spec), arg.dtype))\n    if expect_error_outer_exp is not None:\n        return\n    self.assertEqual(outer_exp.uses_global_constants, inner_poly_spec != '3,4,12' or outer_poly_spec != '3,4,12')\n    with contextlib.ExitStack() as stack:\n        if expect_error_run is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error_run))\n        res = outer_exp.call(arg)\n    if expect_error_run is not None:\n        return\n    self.assertAllClose(2.0 * inner(arg), res)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: kw['shape'], kwargs=[dict(shape=(8, 2, 9), poly_spec='(a + 2*b, a, a + b + c)'), dict(shape=(2, 2, 6), poly_spec='(a + 2*b, a, a + b + c)', expect_error=\"Input shapes do not match the polymorphic shapes specification. Expected value >= 1 for dimension variable 'b'. Using the following polymorphic shapes specifications: args[0].shape = (2*b + a, a, c + b + a). Obtained dimension variables: 'a' = 2 from specification 'a' for dimension args[0].shape[1] (= 2), 'b' = 0 from specification '2*b + a' for dimension args[0].shape[0] (= 2), . Please see https://jax.readthedocs.io/en/latest/export/shape_poly.html#shape-assertion-errors for more details.\"), dict(shape=(3, 2, 6), poly_spec='(a + 2*b, a, a + b + c)', expect_error=\"Input shapes do not match the polymorphic shapes specification. Division had remainder 1 when computing the value of 'b'. Using the following polymorphic shapes specifications: args[0].shape = (2*b + a, a, c + b + a). Obtained dimension variables: 'a' = 2 from specification 'a' for dimension args[0].shape[1] (= 2), . Please see https://jax.readthedocs.io/en/latest/export/shape_poly.html#shape-assertion-errors for more details.\"), dict(shape=(8, 2, 6), poly_spec='(a + 2*b, a, a + b)', expect_error=\"Input shapes do not match the polymorphic shapes specification. Found inconsistency between dimension size args[0].shape[0] (= 8) and the specification '2*b + a' (= 10). Using the following polymorphic shapes specifications: args[0].shape = (2*b + a, a, b + a). Obtained dimension variables: 'a' = 2 from specification 'a' for dimension args[0].shape[1] (= 2), 'b' = 4 from specification 'b + a' for dimension args[0].shape[2] (= 6), . Please see https://jax.readthedocs.io/en/latest/export/shape_poly.html#shape-assertion-errors for more details.\"), dict(shape=(7, 2, 36), poly_spec='(2 * a + b, a, c * c)', expect_error=\"Cannot solve for values of dimension variables {'c'}. We can only solve linear uni-variate constraints. Using the following polymorphic shapes specifications: args[0].shape = (b + 2*a, a, c^2). Unprocessed specifications: 'c^2' for dimension size args[0].shape[2]. Please see https://jax.readthedocs.io/en/latest/export/shape_poly.html#dimension-variables-must-be-solvable-from-the-input-shapes for more details.\")])\ndef test_shape_constraints_errors(self, *, shape, poly_spec: str, expect_error: str | None=None):\n\n    def f_jax(x):\n        return 0.0\n    x = np.arange(math.prod(shape), dtype=np.float32).reshape(shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, re.escape(expect_error)))\n        exp = get_exported(jax.jit(f_jax))(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), x.dtype))\n        exp.call(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_poly_booleans(self):\n\n    @jax.jit\n    def f_jax(x):\n        return jnp.logical_not(x)\n    x = np.array([True, False, True, False], dtype=np.bool_)\n    exp = get_exported(f_jax)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(f_jax(x), res)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(kwargs=[dict(dtype=dtype) for dtype in dtypes._jax_types if dtype != np.dtype('bool')])\ndef test_poly_numeric_dtypes(self, dtype=np.int32):\n    if str(dtype) in {'float8_e4m3b11fnuz', 'float8_e4m3fnuz', 'float8_e5m2fnuz', 'int2', 'int4', 'uint2', 'uint4'}:\n        self.skipTest(f'TODO: serialization not supported for {str(dtype)}')\n    if dtype == dtypes.float8_e8m0fnu and jtu.test_device_matches(['tpu']):\n        self.skipTest('TPU does not support float8_e8m0fnu.')\n\n    @jax.jit\n    def f_jax(x):\n        return x + x\n    x = np.arange(6, dtype=dtype)\n    exp = get_exported(f_jax)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(f_jax(x), res)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_with_donation(self):\n    f = jax.jit(jnp.sin, donate_argnums=(0,))\n    x = np.arange(3, dtype=np.float32)\n    exp = export.export(f)(x)\n\n    def caller(x):\n        y = exp.call(x)\n        return x + y\n    res = jax.jit(caller)(x)\n    self.assertAllClose(res, x + np.sin(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_with_sharding(self):\n    nr_devices = 2\n    if len(jax.devices()) < nr_devices:\n        self.skipTest('Need at least 2 devices')\n    export_devices = jax.devices()[0:nr_devices]\n    export_mesh = Mesh(export_devices, axis_names=('x',))\n    a = np.arange(16 * 4, dtype=np.float32).reshape((16, 4))\n\n    @functools.partial(jax.jit, in_shardings=(jax.sharding.NamedSharding(export_mesh, P('x', None)),), out_shardings=jax.sharding.NamedSharding(export_mesh, P(None, 'x')))\n    def f_jax(b):\n        return b * 2.0\n    res_native = f_jax(a)\n    exp = get_exported(f_jax)(a)\n    self.assertEqual(exp.nr_devices, len(export_devices))\n    run_devices = export_devices[::-1]\n    run_mesh = Mesh(run_devices, 'y')\n    a_device = jax.device_put(a, jax.sharding.NamedSharding(run_mesh, P()))\n    if config.use_shardy_partitioner.value:\n        expected_re = re.compile('func.func .* @main\\\\(%arg0: tensor<16x4xf32>.*sdy.sharding = #sdy.sharding<@mesh_0, \\\\[\\\\{\\\\}\\\\, \\\\{\\\\}\\\\]>}\\\\).*.*sdy.sharding_constraint %arg0 <@mesh, \\\\[\\\\{\\\\\"x\\\\\"\\\\}\\\\, \\\\{\\\\}\\\\]>.*%1 = .*call @call_exported_f_jax.*.*sdy.sharding_constraint %1 <@mesh, \\\\[\\\\{\\\\}, \\\\{\\\\\"x\\\\\"\\\\}\\\\]>.*', re.DOTALL)\n    else:\n        expected_re = re.compile('func.func .* @main\\\\(%arg0: tensor<16x4xf32>.*mhlo.sharding = \\\\\"{replicated}\\\\\"}\\\\).*.*custom_call @Sharding\\\\(%arg0\\\\).*mhlo.sharding = \\\\\"{devices=\\\\[2,1\\\\]<=\\\\[2\\\\]}\\\\\"}.*%1 = .*call @call_exported_f_jax.*.*custom_call @Sharding\\\\(%1\\\\).*mhlo.sharding = \\\\\"{devices=\\\\[1,2\\\\]<=\\\\[2\\\\]}\\\\\"}.*', re.DOTALL)\n    hlo = jax.jit(exp.call).lower(a_device).as_text()\n    self.assertRegex(hlo, expected_re)\n    res_exported = exp.call(a_device)\n    self.assertAllClose(res_native, res_exported)\n    with self.assertRaisesRegex(ValueError, 'Function .* was exported for 2 devices and is called in a context with 1 device'):\n        _ = exp.call(a)\n    with self.assertRaisesRegex(ValueError, 'Function .* was exported for 2 devices and is called in a context with 1 device'):\n        mesh1 = Mesh(jax.devices()[0:1], axis_names=('x',))\n        _ = jax.jit(exp.call, in_shardings=(jax.sharding.NamedSharding(mesh1, P('x', None)),))(a)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_input_shardings_unused_args(self):\n    nr_devices = 2\n    if len(jax.devices()) < nr_devices:\n        self.skipTest('Need at least 2 devices')\n    devices = jax.devices()[0:nr_devices]\n    export_mesh = Mesh(np.array(devices), axis_names=('x',))\n    a = np.arange(16 * 4, dtype=np.float32).reshape((16, 4))\n    f = jax.jit(lambda x, y: jnp.sin(x), in_shardings=(jax.sharding.NamedSharding(export_mesh, P('x', None)), None), out_shardings=jax.sharding.NamedSharding(export_mesh, P('x', None)))\n    exp = get_exported(f)(a, a)\n    run_devices = devices[::-1]\n    run_mesh = Mesh(run_devices, 'a')\n    run_input_shardings = exp.in_shardings_jax(run_mesh)\n    a_run = jax.device_put(a, run_input_shardings[0])\n    b_run = jax.device_put(a, run_input_shardings[1])\n    res = exp.call(a_run, b_run)\n    self.assertEqual(res.addressable_shards[0].device, run_devices[0])\n    self.assertEqual(res.addressable_shards[1].device, run_devices[1])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_call_single_device_export_with_different_no_of_devices(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n\n    @jax.jit\n    def f_without_shardings(x):\n        return jnp.sum(x ** 2, axis=0)\n    a = jnp.arange(jax.local_device_count() * 10, dtype=np.float32).reshape((jax.local_device_count(), 10))\n    res_native = f_without_shardings(a)\n    exp = get_exported(f_without_shardings)(a)\n    self.assertEqual(exp.nr_devices, 1)\n    run_devices = jax.local_devices()\n    run_mesh = Mesh(run_devices, 'i')\n    b = jax.device_put(a, jax.sharding.NamedSharding(run_mesh, P('i')))\n    res_exported = exp.call(b)\n    self.assertAllClose(res_native, res_exported)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_call_with_different_no_of_devices_error_has_in_shardings(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    mesh_1 = Mesh(jax.local_devices()[:1], 'i')\n\n    @functools.partial(pjit.pjit, in_shardings=NamedSharding(mesh_1, P('i')))\n    def f_with_sharding(x):\n        return jnp.sum(x ** 2, axis=0)\n    a = jnp.arange(jax.device_count() * 10, dtype=np.float32).reshape((jax.device_count(), 10))\n    exp = get_exported(f_with_sharding)(a)\n    self.assertEqual(exp.nr_devices, 1)\n    run_devices = jax.local_devices()\n    run_mesh = Mesh(run_devices, 'i')\n    b = jax.device_put(a, jax.sharding.NamedSharding(run_mesh, P('i')))\n    with self.assertRaisesRegex(ValueError, f'Function .* was exported for 1 devices and is called in a context with {jax.local_device_count()} devices.* function contains non-replicated sharding annotations'):\n        exp.call(b)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_call_with_different_no_of_devices_error_has_sharding_constraint(self):\n    if jax.device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    mesh_1 = Mesh(jax.local_devices()[:1], 'i')\n\n    @jax.jit\n    def f_with_sharding(x):\n        x = jax.lax.with_sharding_constraint(x, NamedSharding(mesh_1, P('i')))\n        return jnp.sum(x ** 2, axis=0)\n    a = jnp.arange(jax.device_count() * 10, dtype=np.float32).reshape((jax.device_count(), 10))\n    exp = get_exported(f_with_sharding)(a)\n    self.assertEqual(exp.nr_devices, 1)\n    run_devices = jax.local_devices()\n    run_mesh = Mesh(run_devices, 'i')\n    b = jax.device_put(a, jax.sharding.NamedSharding(run_mesh, P('i')))\n    with self.assertRaisesRegex(ValueError, f'Function .* was exported for 1 devices and is called in a context with {jax.local_device_count()} devices.* function contains non-replicated sharding annotations'):\n        exp.call(b)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_multi_platform(self):\n    x = np.arange(8, dtype=np.float32)\n    exp = get_exported(jax.jit(_testing_multi_platform_func), platforms=('tpu', 'cpu', 'cuda', 'rocm'))(x)\n    self.assertEqual(exp.platforms, ('tpu', 'cpu', 'cuda', 'rocm'))\n    module_str = str(exp.mlir_module())\n    expected_main_re = '@main\\\\(%arg0: tensor<i..>.*jax.global_constant = \\\\\"_platform_index\\\\\".*, %arg1: tensor<8xf32>.*->'\n    self.assertRegex(module_str, expected_main_re)\n    self.assertIn('jax.uses_shape_polymorphism = true', module_str)\n    for platform in self.platforms:\n        x_device = jax.device_put(x, jax.devices(platform)[0])\n        res_exp = exp.call(x_device)\n        self.assertAllClose(res_exp, _testing_multi_platform_fun_expected(x, platform=platform))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_multi_platform_nested(self):\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(jax.jit(lambda x: _testing_multi_platform_func(jnp.sin(x))), platforms=('cpu', 'tpu', 'cuda', 'rocm'))(x)\n    self.assertEqual(exp.platforms, ('cpu', 'tpu', 'cuda', 'rocm'))\n    exp2 = get_exported(jax.jit(exp.call), platforms=('cpu', 'cuda', 'rocm'))(x)\n    exp2_module_str = str(exp2.mlir_module())\n    count_sine = len(re.findall('stablehlo.sine', exp2_module_str))\n    self.assertEqual(1, count_sine)\n    for platform in self.platforms:\n        if platform == 'tpu':\n            continue\n        x_device = jax.device_put(x, jax.devices(platform)[0])\n        res_exp = exp2.call(x_device)\n        self.assertAllClose(res_exp, _testing_multi_platform_fun_expected(np.sin(x), platform=platform))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_multi_platform_nested_inside_single_platform_export(self):\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(jax.jit(_testing_multi_platform_func), platforms=('cpu', 'tpu', 'cuda', 'rocm'))(x)\n    self.assertEqual(exp.platforms, ('cpu', 'tpu', 'cuda', 'rocm'))\n    exp2 = get_exported(jax.jit(exp.call))(x)\n    module_str = str(exp2.mlir_module())\n    self.assertIn('jax.uses_shape_polymorphism = true', module_str)\n    res2 = exp2.call(x)\n    self.assertAllClose(res2, _testing_multi_platform_fun_expected(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_multi_platform_mlir_lower_fun_with_platform_specific_primitives(self):\n\n    def times_n_lowering(n: int, ctx: mlir.LoweringRuleContext, x: mlir.ir.Value) -> Sequence[mlir.ir.Value]:\n        res = x\n        for i in range(n - 1):\n            res = mlir.hlo.AddOp(res, x)\n        return res.results\n    times_2 = core.Primitive('__testing_times_2')\n    times_2.def_abstract_eval(lambda x: x)\n    mlir.register_lowering(times_2, functools.partial(times_n_lowering, 2), 'cpu')\n    times_3 = core.Primitive('__testing_times_3')\n    times_3.def_abstract_eval(lambda x: x)\n    mlir.register_lowering(times_3, functools.partial(times_n_lowering, 3), 'rocm')\n    mlir.register_lowering(times_3, functools.partial(times_n_lowering, 3), 'cuda')\n    times_4 = core.Primitive('__testing_times_4')\n    times_4.def_abstract_eval(lambda x: x)\n    mlir.register_lowering(times_4, functools.partial(times_n_lowering, 4), 'tpu')\n    times_2_or_3 = core.Primitive('__testing_times_2_or_3')\n    times_2_or_3.def_abstract_eval(lambda x: x)\n    mlir.register_lowering(times_2_or_3, mlir.lower_fun(times_2.bind, multiple_results=False), 'cpu')\n    mlir.register_lowering(times_2_or_3, mlir.lower_fun(times_3.bind, multiple_results=False), 'rocm')\n    mlir.register_lowering(times_2_or_3, mlir.lower_fun(times_3.bind, multiple_results=False), 'cuda')\n    times_2_or_3_or_4 = core.Primitive('__testing_times_2_or_3_or_4')\n    times_2_or_3_or_4.def_abstract_eval(lambda x: x)\n    times_2_or_3_or_4_lowering_cpu_gpu = mlir.lower_fun(times_2_or_3.bind, multiple_results=False)\n    for platform in ['cpu', 'cuda', 'rocm']:\n        mlir.register_lowering(times_2_or_3_or_4, times_2_or_3_or_4_lowering_cpu_gpu, platform)\n    mlir.register_lowering(times_2_or_3_or_4, mlir.lower_fun(times_4.bind, multiple_results=False), 'tpu')\n\n    @jax.jit\n    def f(x):\n        return times_2_or_3_or_4.bind(x)\n    x = np.float32(42.0)\n    exp = export.export(f, platforms=['cpu', 'cuda', 'rocm', 'tpu'])(x)\n    expected = x * np.float32(dict(cpu=2, gpu=3, tpu=4)[jtu.device_under_test()])\n    self.assertAllClose(exp.call(x), expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_multi_platform_with_donation(self):\n    f = jax.jit(jnp.sin, donate_argnums=(0,))\n    x = np.arange(3, dtype=np.float32)\n    exp = export.export(f, platforms=['cpu', 'tpu'])(x)\n    if jtu.device_under_test() not in ['cpu', 'tpu']:\n        self.skipTest('other platform')\n\n    def caller(x):\n        y = exp.call(x)\n        return x + y\n    res = jax.jit(caller)(x)\n    self.assertAllClose(res, x + np.sin(x))\n    with self.assertRaisesRegex(NotImplementedError, 'In multi-platform lowering either all or no lowering platforms should support donation'):\n        export.export(f, platforms=['cpu', 'tpu', 'other'])(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_multi_platform_and_poly(self):\n    if jtu.test_device_matches(['gpu']):\n        raise unittest.SkipTest('Not intended for running on GPU')\n    exp = get_exported(jax.jit(lambda x: jnp.reshape(_testing_multi_platform_func(x), (-1,))), platforms=('cpu', 'tpu'))(jax.ShapeDtypeStruct(export.symbolic_shape('b1, b2'), np.float32))\n    x = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res = exp.call(x)\n    self.assertAllClose(res, _testing_multi_platform_fun_expected(x).reshape((-1,)))\n    exp2 = get_exported(jax.jit(exp.call))(x)\n    res2 = exp2.call(x)\n    self.assertAllClose(res2, _testing_multi_platform_fun_expected(x).reshape((-1,)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_multi_platform_and_sharding(self):\n    export_devices = jax.devices()[0:2]\n    export_mesh = Mesh(export_devices, axis_names=('x',))\n    a = np.arange(16 * 4, dtype=np.float32).reshape((16, 4))\n\n    @functools.partial(jax.jit, in_shardings=(jax.sharding.NamedSharding(export_mesh, P('x', None)),), out_shardings=jax.sharding.NamedSharding(export_mesh, P(None, 'x')))\n    def f_jax(b):\n        return b * 2.0\n    res_native = f_jax(a)\n    exp = get_exported(f_jax, platforms=('cpu', 'tpu', 'cuda', 'rocm'))(a)\n    for platform in self.platforms:\n        run_devices = jax.devices(platform)[0:len(export_devices)]\n        if len(run_devices) != len(export_devices):\n            continue\n        run_mesh = Mesh(run_devices, ('x',))\n        a_device = jax.device_put(a, jax.sharding.NamedSharding(run_mesh, P()))\n        res_exp = exp.call(a_device)\n        self.assertArraysAllClose(res_native, res_exp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(kwargs=[dict(v=v) for v in range(export.minimum_supported_calling_convention_version, export.maximum_supported_calling_convention_version + 1)])\ndef test_ordered_effects_basic(self, *, v: int):\n    with config.jax_export_calling_convention_version(v):\n        logging.info('Using JAX serialization version %s', config.jax_export_calling_convention_version.value)\n        x = np.arange(3, dtype=np.float32)\n\n        def f_jax(x):\n\n            def f_jax_inner(x):\n                return testing_primitive_with_effect_p.bind(x, effect_class_name='ForTestingOrderedEffect2') + testing_primitive_with_effect_p.bind(x, effect_class_name='ForTestingUnorderedEffect1')\n            return 10.0 + jax.jit(f_jax_inner)(x) + testing_primitive_with_effect_p.bind(x, effect_class_name='ForTestingOrderedEffect1') + testing_primitive_with_effect_p.bind(x, effect_class_name='ForTestingOrderedEffect2')\n        exp = get_exported(jax.jit(f_jax))(x)\n        self.assertEqual(['ForTestingOrderedEffect1()', 'ForTestingOrderedEffect2()'], sorted((str(e) for e in exp.ordered_effects)))\n        self.assertEqual(['ForTestingUnorderedEffect1()'], [str(e) for e in exp.unordered_effects])\n        mlir_module_str = str(exp.mlir_module())\n        inner_fun_expected_re = 'func.func private @f_jax_inner\\\\(%arg0: !stablehlo.token .*jax.token = true.*%arg1: tensor<3xf32>.*->.*!stablehlo.token .*jax.token = true.*tensor<3xf32>'\n        self.assertRegex(mlir_module_str, inner_fun_expected_re)\n        wrapped_main_expected_re = '@_wrapped_jax_export_main\\\\(%arg0: !stablehlo.token .*jax.token = true.*%arg1: !stablehlo.token .*jax.token = true.*->.*!stablehlo.token .*jax.token = true.*!stablehlo.token .*jax.token = true.*'\n        self.assertRegex(mlir_module_str, wrapped_main_expected_re)\n        main_expected_re = wrapped_main_expected_re.replace('@_wrapped_jax_export_main', '@main')\n        self.assertRegex(mlir_module_str, main_expected_re)\n\n        def f_outer(x):\n            return testing_primitive_with_effect_p.bind(x, effect_class_name='ForTestingOrderedEffect2') + testing_primitive_with_effect_p.bind(x, effect_class_name='ForTestingUnorderedEffect1') + exp.call(x)\n        lowered_outer = jax.jit(f_outer).lower(x)\n        self.assertEqual(['ForTestingOrderedEffect1()', 'ForTestingOrderedEffect2()'], sorted((str(e) for e in lowered_outer._lowering.compile_args['ordered_effects'])))\n        self.assertEqual(['ForTestingUnorderedEffect1()'], sorted([str(e) for e in lowered_outer._lowering.compile_args['unordered_effects']]))\n        mlir_outer_module_str = str(lowered_outer.compiler_ir())\n        self.assertRegex(mlir_outer_module_str, main_expected_re)\n        res = jax.jit(f_outer)(x)\n        self.assertAllClose(2.0 * 2.0 * x + 10.0 + 4.0 * 2.0 * x, res)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(kwargs=[dict(v=v) for v in range(export.minimum_supported_calling_convention_version, export.maximum_supported_calling_convention_version + 1)])\ndef test_ordered_effects_poly(self, *, v: int):\n    with config.jax_export_calling_convention_version(v):\n        logging.info('Using JAX serialization version %s', config.jax_export_calling_convention_version.value)\n        x = np.arange(12, dtype=np.float32).reshape((3, 4))\n\n        def f_jax(x):\n            return 10.0 + testing_primitive_with_effect_p.bind(x, effect_class_name='ForTestingOrderedEffect1')\n        exp = get_exported(jax.jit(f_jax))(jax.ShapeDtypeStruct(export.symbolic_shape('b2, b1'), x.dtype))\n        mlir_module_str = str(exp.mlir_module())\n        wrapped_main_expected_re = '@_wrapped_jax_export_main\\\\(%arg0: tensor<i..> {jax.global_constant = \\\\\"b1\\\\\".* %arg1: tensor<i..> {jax.global_constant = \\\\\"b2\\\\\".* %arg2: !stablehlo.token {jax.token = true.* %arg3: tensor<\\\\?x\\\\?xf32>.*\\\\) -> \\\\(!stablehlo.token {jax.token = true.*, tensor<\\\\?x\\\\?xf32>.*\\\\)'\n        self.assertRegex(mlir_module_str, wrapped_main_expected_re)\n        main_expected_re = '@main\\\\(%arg0: !stablehlo.token {jax.token = true.*, %arg1: tensor<\\\\?x\\\\?xf32>.*\\\\) -> \\\\(!stablehlo.token {jax.token = true.*, tensor<\\\\?x\\\\?xf32>.*\\\\)'\n        self.assertRegex(mlir_module_str, main_expected_re)\n        res = exp.call(x)\n        self.assertAllClose(10.0 + 2.0 * x, res)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(kwargs=[dict(v=v) for v in range(export.minimum_supported_calling_convention_version, export.maximum_supported_calling_convention_version + 1)])\ndef test_ordered_effects_multi_platform_and_poly(self, *, v: int):\n    with config.jax_export_calling_convention_version(v):\n        logging.info('Using JAX serialization version %s', config.jax_export_calling_convention_version.value)\n        if jtu.device_under_test() == 'gpu':\n            raise unittest.SkipTest('Not intended for running on GPU')\n        x = np.ones((3, 4), dtype=np.float32)\n\n        def f_jax(x):\n            return 10.0 + _testing_multi_platform_func(x, effect_class_name='ForTestingOrderedEffect1')\n        exp = get_exported(jax.jit(f_jax), platforms=('cpu', 'tpu'))(jax.ShapeDtypeStruct(export.symbolic_shape('b1, b2'), x.dtype))\n        mlir_module_str = str(exp.mlir_module())\n        wrapped_main_expected_re = '@_wrapped_jax_export_main\\\\(%arg0: tensor<i..> {jax.global_constant = \\\\\"_platform_index\\\\\".*, %arg1: tensor<i..> {jax.global_constant = \\\\\"b1\\\\\".*, %arg2: tensor<i..> {jax.global_constant = \\\\\"b2\\\\\".*, %arg3: !stablehlo.token {jax.token = true.*, %arg4: tensor<\\\\?x\\\\?xf32>.*\\\\) -> \\\\(!stablehlo.token {jax.token = true.*, tensor<\\\\?x\\\\?xf32>.*\\\\)'\n        self.assertRegex(mlir_module_str, wrapped_main_expected_re)\n        main_expected_re = '@main\\\\(%arg0: tensor<i..> {jax.global_constant = \\\\\"_platform_index\\\\\".*, %arg1: !stablehlo.token {jax.token = true.*, %arg2: tensor<\\\\?x\\\\?xf32>.*\\\\) -> \\\\(!stablehlo.token {jax.token = true.*, tensor<\\\\?x\\\\?xf32>.*\\\\)'\n        self.assertRegex(mlir_module_str, main_expected_re)\n        res = exp.call(x)\n        self.assertAllClose(10.0 + _testing_multi_platform_fun_expected(x), res)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(kwargs=[{'m': 5, 'k': 4, 'n': 3, 'group_sizes': [5]}, {'m': 10, 'k': 9, 'n': 8, 'group_sizes': [3, 7]}])\ndef test_ragged_dot(self, m, k, n, group_sizes):\n\n    def f_jax(x, y, gs):\n        return jax.lax.ragged_dot(x, y, gs)\n    dtype = np.float32\n    group_sizes = np.array(group_sizes, dtype=np.int32)\n    lhs = np.arange(m * k, dtype=dtype).reshape((m, k))\n    num_groups = group_sizes.shape[0]\n    rhs = np.arange(num_groups * k * n, dtype=dtype).reshape((num_groups, k, n))\n    res_native = f_jax(lhs, rhs, group_sizes)\n    exp_f = get_exported(jax.jit(f_jax))(jax.ShapeDtypeStruct(lhs.shape, dtype=lhs.dtype), jax.ShapeDtypeStruct(rhs.shape, dtype=rhs.dtype), jax.ShapeDtypeStruct(group_sizes.shape, dtype=group_sizes.dtype))\n    res_exported = exp_f.call(lhs, rhs, group_sizes)\n    self.assertAllClose(res_native, res_exported)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def call(platform, x):\n    target_name = dict(cpu='lapack_sgeqrf_ffi', rocm='hipsolver_geqrf_ffi', cuda='cusolver_geqrf_ffi')[platform]\n    f = jex.ffi.ffi_call if _use_extend else jax.ffi.ffi_call\n    return f(target_name, output_types, input_output_aliases={0: 0}, input_layouts=[x_major_to_minor], output_layouts=[x_major_to_minor, None], **kwargs)(x)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(kwargs=[dict(testcase_name=f'_poly={poly}', poly=poly) for poly in (None, '2*b1,_', '_,b2', '2*b1,b2')])\ndef test_shard_map_collective_permute(self, poly=None):\n    if len(jax.devices()) < 2:\n        self.skipTest('Test requires at least 2 local devices')\n    devices = np.array(jax.devices()[:2])\n    mesh = Mesh(devices, axis_names=('x',))\n    a = np.arange(4 * 4, dtype=np.float32).reshape((4, 4))\n\n    @functools.partial(pjit.pjit, in_shardings=NamedSharding(mesh, P('x', None)), out_shardings=NamedSharding(mesh, P('x', None)))\n    @functools.partial(shard_map, mesh=mesh, in_specs=(P('x', None),), out_specs=P('x', None))\n    def f_jax(b):\n        axis_size = lax.psum(1, 'x')\n        perm = [(j, (j + 1) % axis_size) for j in range(axis_size)]\n        return lax.ppermute(b, 'x', perm=perm)\n    args_specs = export.symbolic_args_specs((a,), poly)\n    exp = get_exported(f_jax)(*args_specs)\n    res_jax = f_jax(a)\n    b0, b1 = np.split(a, 2, axis=0)\n    b0, b1 = (b1, b0)\n    expected = np.concatenate([b0, b1], axis=0)\n    self.assertAllClose(res_jax, expected)\n    self.assertLen(res_jax.addressable_shards, len(devices))\n    f_r = exp.call\n    with self.assertRaisesRegex(Exception, 'Function .* was exported for 2 devices and is called in a context with 1 devices'):\n        _ = f_r(a)\n    a_replicated = jax.device_put(a, NamedSharding(mesh, P()))\n    res_r = f_r(a_replicated)\n    self.assertAllClose(res_r, expected)\n    self.assertLen(res_r.addressable_shards, len(devices))\n    for i in range(len(devices)):\n        self.assertEqual(res_jax.addressable_shards[i].device, res_r.addressable_shards[i].device)\n        self.assertEqual(res_jax.addressable_shards[i].index, res_r.addressable_shards[i].index)\n        self.assertAllClose(res_jax.addressable_shards[i].data, res_r.addressable_shards[i].data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def ppermute(input):\n    return jax.lax.ppermute(input, axis_name='i', perm=[[0, 1], [1, 0]])"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(kwargs=[dict(testcase_name=f'_poly={poly}', poly=poly) for poly in (None, '2*b1,_', '_,b2', '2*b1,b2')])\ndef test_shard_map_collective_permute(self, poly=None):\n    if len(jax.devices()) < 2:\n        self.skipTest('Test requires at least 2 local devices')\n    devices = np.array(jax.devices()[:2])\n    mesh = Mesh(devices, axis_names=('x',))\n    a = np.arange(4 * 4, dtype=np.float32).reshape((4, 4))\n\n    @functools.partial(pjit.pjit, in_shardings=NamedSharding(mesh, P('x', None)), out_shardings=NamedSharding(mesh, P('x', None)))\n    @functools.partial(shard_map, mesh=mesh, in_specs=(P('x', None),), out_specs=P('x', None))\n    def f_jax(b):\n        axis_size = lax.psum(1, 'x')\n        perm = [(j, (j + 1) % axis_size) for j in range(axis_size)]\n        return lax.ppermute(b, 'x', perm=perm)\n    args_specs = export.symbolic_args_specs((a,), poly)\n    exp = get_exported(f_jax)(*args_specs)\n    res_jax = f_jax(a)\n    b0, b1 = np.split(a, 2, axis=0)\n    b0, b1 = (b1, b0)\n    expected = np.concatenate([b0, b1], axis=0)\n    self.assertAllClose(res_jax, expected)\n    self.assertLen(res_jax.addressable_shards, len(devices))\n    f_r = exp.call\n    with self.assertRaisesRegex(Exception, 'Function .* was exported for 2 devices and is called in a context with 1 devices'):\n        _ = f_r(a)\n    a_replicated = jax.device_put(a, NamedSharding(mesh, P()))\n    res_r = f_r(a_replicated)\n    self.assertAllClose(res_r, expected)\n    self.assertLen(res_r.addressable_shards, len(devices))\n    for i in range(len(devices)):\n        self.assertEqual(res_jax.addressable_shards[i].device, res_r.addressable_shards[i].device)\n        self.assertEqual(res_jax.addressable_shards[i].index, res_r.addressable_shards[i].index)\n        self.assertAllClose(res_jax.addressable_shards[i].data, res_r.addressable_shards[i].data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def split(self) -> jax.Array:\n    key = jax_getattr(self, 'key')\n    new_key, returned_key = jax.random.split(key)\n    jax_setattr(self, 'key', new_key)\n    return returned_key"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_call_name_conflict(self):\n\n    @jax.jit\n    def inner(x):\n        return jnp.where(x > 0, jnp.ones_like(x), jnp.zeros_like(x))\n    x = jnp.arange(-20, 20, dtype=np.int32)\n    exp_inner = export.export(inner)(x)\n    self.assertIn('@_where(', str(exp_inner.mlir_module()))\n\n    @jax.jit\n    def outer(x):\n        x = exp_inner.call(x)\n        return inner(x)\n    export.export(outer)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_vjp\ndef inner(carry, scale):\n    del scale\n    return carry"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'inner={kw['inner_poly_spec']}_outer={kw['outer_poly_spec']}', kwargs=[dict(inner_poly_spec='3,4,12', outer_poly_spec='3,4,12'), dict(inner_poly_spec='3,a,a+b', outer_poly_spec='3,4,12'), dict(inner_poly_spec='3,4,3*a', outer_poly_spec='3,4,12'), dict(inner_poly_spec='3,a,a', outer_poly_spec='3,4,12', expect_error_outer_exp=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 12) and the specification 'a' (= 4)\")), dict(inner_poly_spec='3,4,5*a', outer_poly_spec='3,4,12', expect_error_outer_exp=re.escape(\"Division had remainder 2 when computing the value of 'a'\")), dict(inner_poly_spec='3,4,12+a', outer_poly_spec='3,4,12', expect_error_outer_exp=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 12). Obtained dimension variables: 'a' = 0 from specification 'a + 12' for dimension args[0].shape[2] (= 12)\")), dict(inner_poly_spec='3,a,b', outer_poly_spec='3,4,c'), dict(inner_poly_spec='3,4,3*a', outer_poly_spec='3,4,6*c'), dict(inner_poly_spec='3,a,a+8', outer_poly_spec='3,c+2,c+10'), dict(inner_poly_spec='3,a,a+b', outer_poly_spec='3,4,c', expect_error_outer_exp=re.escape(\"Expected value >= 1 for dimension variable 'b'. Using the following polymorphic shapes specifications: args[0].shape = (3, a, b + a). Obtained dimension variables: 'a' = 4 from specification 'a' for dimension args[0].shape[1] (= 4), 'b' = c - 4 from specification 'b + a' for dimension args[0].shape[2] (= c),\")), dict(inner_poly_spec='3,a,a', outer_poly_spec='3,4,c', expect_error_outer_exp=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= c) and the specification 'a' (= 4)\")), dict(inner_poly_spec='3,a,a', arg_shape=(3, 4), outer_poly_spec='3,c', expect_error_outer_exp='Rank mismatch for args\\\\[0\\\\]'), dict(inner_poly_spec='3,a,a+b', arg_dtype=np.int32, outer_poly_spec='3,c,d', expect_error_outer_exp='Dtype mismatch for args\\\\[0\\\\]'), dict(inner_poly_spec='3,4,5*a', outer_poly_spec='3,4,c', expect_error_outer_exp=re.escape(\"Division had remainder mod(c, 5) when computing the value of 'a'\")), dict(inner_poly_spec='3,a,a+b', outer_poly_spec='3,c,c', expect_error_outer_exp=re.escape(\"Expected value >= 1 for dimension variable 'b'. Using the following polymorphic shapes specifications: args[0].shape = (3, a, b + a). Obtained dimension variables: 'a' = c from specification 'a' for dimension args[0].shape[1] (= c), 'b' = 0 from specification 'b + a' for dimension args[0].shape[2] (= c)\")), dict(inner_poly_spec='3,a,a+b', outer_poly_spec='c,4,12', expect_error_outer_exp=re.escape('Shape mismatch for args[0].shape[0] (expected same constant)')), dict(inner_poly_spec='3,4,5*a', outer_poly_spec='3,4,25*c', expect_error_run=re.escape(\"Division had remainder 12 when computing the value of 'c'\")), dict(inner_poly_spec='3,a,b', outer_poly_spec='3,c+4,12', expect_error_run=re.escape(\"Expected value >= 1 for dimension variable 'c'. Using the following polymorphic shapes specifications: args[0].shape = (3, c + 4, 12). Obtained dimension variables: 'c' = 0\")), dict(inner_poly_spec='3,a,a', outer_poly_spec='3,a,a', expect_error_run=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 12) and the specification 'a' (= 4)\"))])\ndef test_poly_shape_checks_nested(self, inner_poly_spec='3,4,5*a', arg_shape=(3, 4, 12), arg_dtype=np.float32, outer_poly_spec='3,4,25*c', expect_error_outer_exp=None, expect_error_run=None):\n\n    def inner(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    inner_exp = get_exported(jax.jit(inner))(jax.ShapeDtypeStruct(export.symbolic_shape(inner_poly_spec), np.float32))\n    self.assertEqual(inner_exp.uses_global_constants, inner_poly_spec != '3,4,12')\n\n    def outer(x):\n        return inner_exp.call(x) + inner(x)\n    with contextlib.ExitStack() as stack:\n        if expect_error_outer_exp is not None:\n            stack.push(self.assertRaisesRegex(ValueError, expect_error_outer_exp))\n        outer_exp = get_exported(jax.jit(outer))(jax.ShapeDtypeStruct(export.symbolic_shape(outer_poly_spec), arg.dtype))\n    if expect_error_outer_exp is not None:\n        return\n    self.assertEqual(outer_exp.uses_global_constants, inner_poly_spec != '3,4,12' or outer_poly_spec != '3,4,12')\n    with contextlib.ExitStack() as stack:\n        if expect_error_run is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error_run))\n        res = outer_exp.call(arg)\n    if expect_error_run is not None:\n        return\n    self.assertAllClose(2.0 * inner(arg), res)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_vjp\ndef inner(carry, scale):\n    del scale\n    return carry"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "def test_poly_booleans(self):\n\n    @jax.jit\n    def f_jax(x):\n        return jnp.logical_not(x)\n    x = np.array([True, False, True, False], dtype=np.bool_)\n    exp = get_exported(f_jax)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(f_jax(x), res)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f_jax(x):\n    key = random.PRNGKey(123)\n    broadcast_keys = lax.broadcast_in_dim(key, x.shape, ())\n    gather_keys = lax.broadcast_in_dim(broadcast_keys[0], (1, x.shape[1]), (1,))\n    slice_keys1 = lax.slice(broadcast_keys, (0, 0), (1, x.shape[1]), (1, 1))\n    slice_keys2 = lax.dynamic_slice(broadcast_keys, (0, 0), slice_sizes=(1, x.shape[1]))\n    upd1 = lax.dynamic_update_slice(slice_keys2, slice_keys1, start_indices=(0, 0))\n    _ = lax.dynamic_update_slice(upd1, gather_keys, start_indices=(0, 0))\n    xs = broadcast_keys\n    counts = jnp.arange(broadcast_keys.shape[0], dtype=np.int32)\n\n    def f_vmap_jax(counts, xs):\n\n        def inner(count, x):\n            return lax.fori_loop(0, count, lambda _, acc: acc, x)\n        return jax.vmap(inner)(counts, xs)\n    _ = f_vmap_jax(counts, xs)\n    return x"
  },
  {
    "test_code": "@jtu.parameterized_filterable(kwargs=[dict(dtype=dtype) for dtype in dtypes._jax_types if dtype != np.dtype('bool')])\ndef test_poly_numeric_dtypes(self, dtype=np.int32):\n    if str(dtype) in {'float8_e4m3b11fnuz', 'float8_e4m3fnuz', 'float8_e5m2fnuz', 'int2', 'int4', 'uint2', 'uint4'}:\n        self.skipTest(f'TODO: serialization not supported for {str(dtype)}')\n    if dtype == dtypes.float8_e8m0fnu and jtu.test_device_matches(['tpu']):\n        self.skipTest('TPU does not support float8_e8m0fnu.')\n\n    @jax.jit\n    def f_jax(x):\n        return x + x\n    x = np.arange(6, dtype=dtype)\n    exp = get_exported(f_jax)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(f_jax(x), res)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f_jax(x):\n    key = random.PRNGKey(123)\n    broadcast_keys = lax.broadcast_in_dim(key, x.shape, ())\n    gather_keys = lax.broadcast_in_dim(broadcast_keys[0], (1, x.shape[1]), (1,))\n    slice_keys1 = lax.slice(broadcast_keys, (0, 0), (1, x.shape[1]), (1, 1))\n    slice_keys2 = lax.dynamic_slice(broadcast_keys, (0, 0), slice_sizes=(1, x.shape[1]))\n    upd1 = lax.dynamic_update_slice(slice_keys2, slice_keys1, start_indices=(0, 0))\n    _ = lax.dynamic_update_slice(upd1, gather_keys, start_indices=(0, 0))\n    xs = broadcast_keys\n    counts = jnp.arange(broadcast_keys.shape[0], dtype=np.int32)\n\n    def f_vmap_jax(counts, xs):\n\n        def inner(count, x):\n            return lax.fori_loop(0, count, lambda _, acc: acc, x)\n        return jax.vmap(inner)(counts, xs)\n    _ = f_vmap_jax(counts, xs)\n    return x"
  },
  {
    "test_code": "def test_with_sharding(self):\n    nr_devices = 2\n    if len(jax.devices()) < nr_devices:\n        self.skipTest('Need at least 2 devices')\n    export_devices = jax.devices()[0:nr_devices]\n    export_mesh = Mesh(export_devices, axis_names=('x',))\n    a = np.arange(16 * 4, dtype=np.float32).reshape((16, 4))\n\n    @functools.partial(jax.jit, in_shardings=(jax.sharding.NamedSharding(export_mesh, P('x', None)),), out_shardings=jax.sharding.NamedSharding(export_mesh, P(None, 'x')))\n    def f_jax(b):\n        return b * 2.0\n    res_native = f_jax(a)\n    exp = get_exported(f_jax)(a)\n    self.assertEqual(exp.nr_devices, len(export_devices))\n    run_devices = export_devices[::-1]\n    run_mesh = Mesh(run_devices, 'y')\n    a_device = jax.device_put(a, jax.sharding.NamedSharding(run_mesh, P()))\n    if config.use_shardy_partitioner.value:\n        expected_re = re.compile('func.func .* @main\\\\(%arg0: tensor<16x4xf32>.*sdy.sharding = #sdy.sharding<@mesh_0, \\\\[\\\\{\\\\}\\\\, \\\\{\\\\}\\\\]>}\\\\).*.*sdy.sharding_constraint %arg0 <@mesh, \\\\[\\\\{\\\\\"x\\\\\"\\\\}\\\\, \\\\{\\\\}\\\\]>.*%1 = .*call @call_exported_f_jax.*.*sdy.sharding_constraint %1 <@mesh, \\\\[\\\\{\\\\}, \\\\{\\\\\"x\\\\\"\\\\}\\\\]>.*', re.DOTALL)\n    else:\n        expected_re = re.compile('func.func .* @main\\\\(%arg0: tensor<16x4xf32>.*mhlo.sharding = \\\\\"{replicated}\\\\\"}\\\\).*.*custom_call @Sharding\\\\(%arg0\\\\).*mhlo.sharding = \\\\\"{devices=\\\\[2,1\\\\]<=\\\\[2\\\\]}\\\\\"}.*%1 = .*call @call_exported_f_jax.*.*custom_call @Sharding\\\\(%1\\\\).*mhlo.sharding = \\\\\"{devices=\\\\[1,2\\\\]<=\\\\[2\\\\]}\\\\\"}.*', re.DOTALL)\n    hlo = jax.jit(exp.call).lower(a_device).as_text()\n    self.assertRegex(hlo, expected_re)\n    res_exported = exp.call(a_device)\n    self.assertAllClose(res_native, res_exported)\n    with self.assertRaisesRegex(ValueError, 'Function .* was exported for 2 devices and is called in a context with 1 device'):\n        _ = exp.call(a)\n    with self.assertRaisesRegex(ValueError, 'Function .* was exported for 2 devices and is called in a context with 1 device'):\n        mesh1 = Mesh(jax.devices()[0:1], axis_names=('x',))\n        _ = jax.jit(exp.call, in_shardings=(jax.sharding.NamedSharding(mesh1, P('x', None)),))(a)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f_jax(x):\n    key = random.PRNGKey(123)\n    broadcast_keys = lax.broadcast_in_dim(key, x.shape, ())\n    gather_keys = lax.broadcast_in_dim(broadcast_keys[0], (1, x.shape[1]), (1,))\n    slice_keys1 = lax.slice(broadcast_keys, (0, 0), (1, x.shape[1]), (1, 1))\n    slice_keys2 = lax.dynamic_slice(broadcast_keys, (0, 0), slice_sizes=(1, x.shape[1]))\n    upd1 = lax.dynamic_update_slice(slice_keys2, slice_keys1, start_indices=(0, 0))\n    _ = lax.dynamic_update_slice(upd1, gather_keys, start_indices=(0, 0))\n    xs = broadcast_keys\n    counts = jnp.arange(broadcast_keys.shape[0], dtype=np.int32)\n\n    def f_vmap_jax(counts, xs):\n\n        def inner(count, x):\n            return lax.fori_loop(0, count, lambda _, acc: acc, x)\n        return jax.vmap(inner)(counts, xs)\n    _ = f_vmap_jax(counts, xs)\n    return x"
  },
  {
    "test_code": "def test_call_with_different_no_of_devices_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    @jax.jit\n    def f_jax(x):\n        return jnp.sum(x ** 2, axis=0)\n    a = jnp.arange(100, dtype=jnp.float32).reshape((1, 100))\n    res_native = f_jax(a)\n    exp = get_exported(f_jax)(a)\n    self.assertEqual(exp.nr_devices, 1)\n    b = jnp.arange(jax.device_count() * 100, dtype=jnp.float32).reshape((-1, 1, 100))\n    res_exported = jax.pmap(exp.call)(b)\n    self.assertAllClose(res_native, res_exported[0])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f_jax(x):\n    key = random.PRNGKey(123)\n    broadcast_keys = lax.broadcast_in_dim(key, x.shape, ())\n    gather_keys = lax.broadcast_in_dim(broadcast_keys[0], (1, x.shape[1]), (1,))\n    slice_keys1 = lax.slice(broadcast_keys, (0, 0), (1, x.shape[1]), (1, 1))\n    slice_keys2 = lax.dynamic_slice(broadcast_keys, (0, 0), slice_sizes=(1, x.shape[1]))\n    upd1 = lax.dynamic_update_slice(slice_keys2, slice_keys1, start_indices=(0, 0))\n    _ = lax.dynamic_update_slice(upd1, gather_keys, start_indices=(0, 0))\n    xs = broadcast_keys\n    counts = jnp.arange(broadcast_keys.shape[0], dtype=np.int32)\n\n    def f_vmap_jax(counts, xs):\n\n        def inner(count, x):\n            return lax.fori_loop(0, count, lambda _, acc: acc, x)\n        return jax.vmap(inner)(counts, xs)\n    _ = f_vmap_jax(counts, xs)\n    return x"
  },
  {
    "test_code": "@jtu.parameterized_filterable(kwargs=[dict(testcase_name=f'_poly={poly}', poly=poly) for poly in (None, '2*b1,_', '_,b2', '2*b1,b2')])\ndef test_shard_map_collective_permute(self, poly=None):\n    if len(jax.devices()) < 2:\n        self.skipTest('Test requires at least 2 local devices')\n    devices = np.array(jax.devices()[:2])\n    mesh = Mesh(devices, axis_names=('x',))\n    a = np.arange(4 * 4, dtype=np.float32).reshape((4, 4))\n\n    @functools.partial(pjit.pjit, in_shardings=NamedSharding(mesh, P('x', None)), out_shardings=NamedSharding(mesh, P('x', None)))\n    @functools.partial(shard_map, mesh=mesh, in_specs=(P('x', None),), out_specs=P('x', None))\n    def f_jax(b):\n        axis_size = lax.psum(1, 'x')\n        perm = [(j, (j + 1) % axis_size) for j in range(axis_size)]\n        return lax.ppermute(b, 'x', perm=perm)\n    args_specs = export.symbolic_args_specs((a,), poly)\n    exp = get_exported(f_jax)(*args_specs)\n    res_jax = f_jax(a)\n    b0, b1 = np.split(a, 2, axis=0)\n    b0, b1 = (b1, b0)\n    expected = np.concatenate([b0, b1], axis=0)\n    self.assertAllClose(res_jax, expected)\n    self.assertLen(res_jax.addressable_shards, len(devices))\n    f_r = exp.call\n    with self.assertRaisesRegex(Exception, 'Function .* was exported for 2 devices and is called in a context with 1 devices'):\n        _ = f_r(a)\n    a_replicated = jax.device_put(a, NamedSharding(mesh, P()))\n    res_r = f_r(a_replicated)\n    self.assertAllClose(res_r, expected)\n    self.assertLen(res_r.addressable_shards, len(devices))\n    for i in range(len(devices)):\n        self.assertEqual(res_jax.addressable_shards[i].device, res_r.addressable_shards[i].device)\n        self.assertEqual(res_jax.addressable_shards[i].index, res_r.addressable_shards[i].index)\n        self.assertAllClose(res_jax.addressable_shards[i].data, res_r.addressable_shards[i].data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f_jax(x):\n    key = random.PRNGKey(123)\n    broadcast_keys = lax.broadcast_in_dim(key, x.shape, ())\n    gather_keys = lax.broadcast_in_dim(broadcast_keys[0], (1, x.shape[1]), (1,))\n    slice_keys1 = lax.slice(broadcast_keys, (0, 0), (1, x.shape[1]), (1, 1))\n    slice_keys2 = lax.dynamic_slice(broadcast_keys, (0, 0), slice_sizes=(1, x.shape[1]))\n    upd1 = lax.dynamic_update_slice(slice_keys2, slice_keys1, start_indices=(0, 0))\n    _ = lax.dynamic_update_slice(upd1, gather_keys, start_indices=(0, 0))\n    xs = broadcast_keys\n    counts = jnp.arange(broadcast_keys.shape[0], dtype=np.int32)\n\n    def f_vmap_jax(counts, xs):\n\n        def inner(count, x):\n            return lax.fori_loop(0, count, lambda _, acc: acc, x)\n        return jax.vmap(inner)(counts, xs)\n    _ = f_vmap_jax(counts, xs)\n    return x"
  },
  {
    "test_code": "def test_multi_platform_and_sharding(self):\n    export_devices = jax.devices()[0:2]\n    export_mesh = Mesh(export_devices, axis_names=('x',))\n    a = np.arange(16 * 4, dtype=np.float32).reshape((16, 4))\n\n    @functools.partial(jax.jit, in_shardings=(jax.sharding.NamedSharding(export_mesh, P('x', None)),), out_shardings=jax.sharding.NamedSharding(export_mesh, P(None, 'x')))\n    def f_jax(b):\n        return b * 2.0\n    res_native = f_jax(a)\n    exp = get_exported(f_jax, platforms=('cpu', 'tpu', 'cuda', 'rocm'))(a)\n    for platform in self.platforms:\n        run_devices = jax.devices(platform)[0:len(export_devices)]\n        if len(run_devices) != len(export_devices):\n            continue\n        run_mesh = Mesh(run_devices, ('x',))\n        a_device = jax.device_put(a, jax.sharding.NamedSharding(run_mesh, P()))\n        res_exp = exp.call(a_device)\n        self.assertArraysAllClose(res_native, res_exp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f_jax(x):\n    key = random.PRNGKey(123)\n    broadcast_keys = lax.broadcast_in_dim(key, x.shape, ())\n    gather_keys = lax.broadcast_in_dim(broadcast_keys[0], (1, x.shape[1]), (1,))\n    slice_keys1 = lax.slice(broadcast_keys, (0, 0), (1, x.shape[1]), (1, 1))\n    slice_keys2 = lax.dynamic_slice(broadcast_keys, (0, 0), slice_sizes=(1, x.shape[1]))\n    upd1 = lax.dynamic_update_slice(slice_keys2, slice_keys1, start_indices=(0, 0))\n    _ = lax.dynamic_update_slice(upd1, gather_keys, start_indices=(0, 0))\n    xs = broadcast_keys\n    counts = jnp.arange(broadcast_keys.shape[0], dtype=np.int32)\n\n    def f_vmap_jax(counts, xs):\n\n        def inner(count, x):\n            return lax.fori_loop(0, count, lambda _, acc: acc, x)\n        return jax.vmap(inner)(counts, xs)\n    _ = f_vmap_jax(counts, xs)\n    return x"
  },
  {
    "test_code": "@jtu.parameterized_filterable(kwargs=[{'m': 5, 'k': 4, 'n': 3, 'group_sizes': [5]}, {'m': 10, 'k': 9, 'n': 8, 'group_sizes': [3, 7]}])\ndef test_ragged_dot(self, m, k, n, group_sizes):\n\n    def f_jax(x, y, gs):\n        return jax.lax.ragged_dot(x, y, gs)\n    dtype = np.float32\n    group_sizes = np.array(group_sizes, dtype=np.int32)\n    lhs = np.arange(m * k, dtype=dtype).reshape((m, k))\n    num_groups = group_sizes.shape[0]\n    rhs = np.arange(num_groups * k * n, dtype=dtype).reshape((num_groups, k, n))\n    res_native = f_jax(lhs, rhs, group_sizes)\n    exp_f = get_exported(jax.jit(f_jax))(jax.ShapeDtypeStruct(lhs.shape, dtype=lhs.dtype), jax.ShapeDtypeStruct(rhs.shape, dtype=rhs.dtype), jax.ShapeDtypeStruct(group_sizes.shape, dtype=group_sizes.dtype))\n    res_exported = exp_f.call(lhs, rhs, group_sizes)\n    self.assertAllClose(res_native, res_exported)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f_jax(x):\n    key = random.PRNGKey(123)\n    broadcast_keys = lax.broadcast_in_dim(key, x.shape, ())\n    gather_keys = lax.broadcast_in_dim(broadcast_keys[0], (1, x.shape[1]), (1,))\n    slice_keys1 = lax.slice(broadcast_keys, (0, 0), (1, x.shape[1]), (1, 1))\n    slice_keys2 = lax.dynamic_slice(broadcast_keys, (0, 0), slice_sizes=(1, x.shape[1]))\n    upd1 = lax.dynamic_update_slice(slice_keys2, slice_keys1, start_indices=(0, 0))\n    _ = lax.dynamic_update_slice(upd1, gather_keys, start_indices=(0, 0))\n    xs = broadcast_keys\n    counts = jnp.arange(broadcast_keys.shape[0], dtype=np.int32)\n\n    def f_vmap_jax(counts, xs):\n\n        def inner(count, x):\n            return lax.fori_loop(0, count, lambda _, acc: acc, x)\n        return jax.vmap(inner)(counts, xs)\n    _ = f_vmap_jax(counts, xs)\n    return x"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "def test_basic_export_only(self):\n\n    @jax.jit\n    def my_fun(x):\n        return jnp.sin(x)\n    exp = get_exported(my_fun)(jax.ShapeDtypeStruct((4,), dtype=np.float32))\n    self.assertEqual('my_fun', exp.fun_name)\n    expected_lowering_platform = xb.canonicalize_platform(jax.default_backend())\n    self.assertEqual((expected_lowering_platform,), exp.platforms)\n    self.assertEqual(jax.tree.flatten(((1,), {}))[1], exp.in_tree)\n    self.assertEqual((core.ShapedArray((4,), dtype=np.float32),), exp.in_avals)\n    self.assertEqual((core.ShapedArray((4,), dtype=np.float32),), exp.out_avals)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_export_error_no_jit(self):\n    with self.assertRaisesRegex(ValueError, 'Function to be exported must be the result of `jit`'):\n        _ = export.export(lambda x: jnp.sin(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_error_wrong_intree(self):\n\n    def f(a_b_pair, *, c):\n        return jnp.sin(a_b_pair[0]) + jnp.cos(a_b_pair[1]) + c\n    a = b = c = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f))((a, b), c=c)\n    with self.assertRaisesRegex(ValueError, 'The invocation args and kwargs must have the same pytree structure'):\n        exp_f.call(a, b, c=(a, b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_error_wrong_avals(self):\n\n    def f(a, *, b):\n        return jnp.sin(a) + jnp.cos(b)\n    f32_4 = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f))(f32_4, b=f32_4)\n    with self.assertRaisesRegex(ValueError, 'Shape mismatch for args\\\\[0\\\\].shape\\\\[0\\\\]'):\n        exp_f.call(np.arange(6, dtype=np.float32), b=f32_4)\n    with self.assertRaisesRegex(ValueError, \"Shape mismatch for kwargs\\\\['b'\\\\].shape\\\\[0\\\\]\"):\n        exp_f.call(f32_4, b=np.arange(6, dtype=np.float32))\n    with self.assertRaisesRegex(ValueError, 'Rank mismatch for args\\\\[0\\\\]'):\n        exp_f.call(f32_4.reshape((1, 4)), b=f32_4)\n    with self.assertRaisesRegex(ValueError, 'Dtype mismatch for args\\\\[0\\\\]'):\n        exp_f.call(f32_4.astype(np.float16), b=f32_4)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: kw['platform'], kwargs=[dict(platform=p) for p in ('cpu', 'cuda', 'rocm', 'tpu')])\ndef test_error_wrong_platform(self, platform):\n    a = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(jnp.sin, platforms=(platform,))(a)\n    if xb.canonicalize_platform(jtu.device_under_test()) == platform:\n        raise unittest.SkipTest('Uninteresting scenario')\n    with self.assertRaisesRegex(ValueError, 'Function .* was exported for platform'):\n        exp_f.call(a)\n    exp_f_no_platform_check = get_exported(jnp.sin, platforms=(platform,), disabled_checks=[export.DisabledSafetyCheck.platform()])(a)\n    res = exp_f_no_platform_check.call(a)\n    self.assertAllClose(res, jnp.sin(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_grad(self):\n    f = lambda x: jnp.sum(jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)(x)\n    f1 = exp_f.call\n    self.assertAllClose(jax.grad(f)(x), jax.grad(f1)(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_roundtrip(self):\n\n    def f1(x):\n        return jnp.sin(x)\n    a = np.arange(4, dtype=np.float32)\n    exp_f1 = get_exported(jax.jit(f1))(a)\n\n    def f2(x):\n        res1 = exp_f1.call(x)\n        res2 = exp_f1.call(res1)\n        return jnp.cos(res2)\n    exp_f2 = get_exported(jax.jit(f2))(a)\n    self.assertAllClose(jnp.cos(jnp.sin(jnp.sin(a))), exp_f2.call(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_poly_export_callable_with_no_name(self):\n\n    class MyCallable:\n\n        def __call__(self, x):\n            return jnp.sin(x)\n\n        def lower(self, x, _experimental_lowering_parameters=None):\n            return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)\n\n        def trace(self, x, _experimental_lowering_parameters=None):\n            return jax.jit(self.__call__).trace(x, _experimental_lowering_parameters=_experimental_lowering_parameters)\n    a, = export.symbolic_shape('a,')\n    _ = get_exported(jax.jit(MyCallable()))(jax.ShapeDtypeStruct((a, a), dtype=np.float32))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(kwargs=[dict(v=v) for v in range(export.minimum_supported_calling_convention_version - 1, export.maximum_supported_calling_convention_version + 2)])\ndef test_poly_basic_versions(self, v: int):\n    with config.jax_export_calling_convention_version(v):\n        logging.info('Using JAX calling convention version %s', config.jax_export_calling_convention_version.value)\n        with contextlib.ExitStack() as e:\n            if not export.minimum_supported_calling_convention_version <= v <= export.maximum_supported_calling_convention_version:\n                e.enter_context(self.assertRaisesRegex(ValueError, f'The requested export calling convention version {v} is outside the range of supported versions'))\n            exp = get_exported(jnp.sin)(jax.ShapeDtypeStruct(export.symbolic_shape('w, h'), np.float32))\n            x = np.arange(30, dtype=np.float32).reshape((5, 6))\n            res = exp.call(x)\n            self.assertAllClose(res, np.sin(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_with_donation(self):\n    f = jax.jit(jnp.sin, donate_argnums=(0,))\n    x = np.arange(3, dtype=np.float32)\n    exp = export.export(f)(x)\n\n    def caller(x):\n        y = exp.call(x)\n        return x + y\n    res = jax.jit(caller)(x)\n    self.assertAllClose(res, x + np.sin(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_input_shardings_unused_args(self):\n    nr_devices = 2\n    if len(jax.devices()) < nr_devices:\n        self.skipTest('Need at least 2 devices')\n    devices = jax.devices()[0:nr_devices]\n    export_mesh = Mesh(np.array(devices), axis_names=('x',))\n    a = np.arange(16 * 4, dtype=np.float32).reshape((16, 4))\n    f = jax.jit(lambda x, y: jnp.sin(x), in_shardings=(jax.sharding.NamedSharding(export_mesh, P('x', None)), None), out_shardings=jax.sharding.NamedSharding(export_mesh, P('x', None)))\n    exp = get_exported(f)(a, a)\n    run_devices = devices[::-1]\n    run_mesh = Mesh(run_devices, 'a')\n    run_input_shardings = exp.in_shardings_jax(run_mesh)\n    a_run = jax.device_put(a, run_input_shardings[0])\n    b_run = jax.device_put(a, run_input_shardings[1])\n    res = exp.call(a_run, b_run)\n    self.assertEqual(res.addressable_shards[0].device, run_devices[0])\n    self.assertEqual(res.addressable_shards[1].device, run_devices[1])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(kwargs=[dict(in_shardings=in_shardings, out_shardings=out_shardings, with_mesh_context=with_mesh_context) for in_shardings in ('missing', None, 'P') for out_shardings in ('missing', None, 'P') for with_mesh_context in (True, False)])\ndef test_grad_with_sharding(self, in_shardings='P', out_shardings=None, with_mesh_context=False):\n    if len(jax.devices()) < 2:\n        self.skipTest('Test requires at least 2 devices')\n    x_shape = (10, 20)\n    x = np.arange(np.prod(x_shape), dtype=np.float32).reshape(x_shape)\n\n    def f_jax(x):\n        return jnp.sin(x.T)\n    mesh = Mesh(jax.devices()[:2], 'd')\n    pjit_kwargs = {}\n    if with_mesh_context:\n        sharding_None_d = P(None, 'd')\n        sharding_d_None = P('d', None)\n    else:\n        sharding_None_d = NamedSharding(mesh, P(None, 'd'))\n        sharding_d_None = NamedSharding(mesh, P('d', None))\n    if in_shardings != 'missing':\n        pjit_kwargs['in_shardings'] = sharding_None_d if in_shardings == 'P' else None\n    if out_shardings != 'missing':\n        pjit_kwargs['out_shardings'] = sharding_d_None if out_shardings == 'P' else None\n    f_jax_pjit = pjit.pjit(f_jax, **pjit_kwargs)\n    with contextlib.ExitStack() as stack:\n        if with_mesh_context:\n            stack.enter_context(mesh)\n        exp = get_exported(f_jax_pjit, vjp_order=2)(x)\n        exp_vjp = exp.vjp()\n        exp_vjp2 = exp_vjp.vjp()\n    vjp_module_str = str(exp_vjp.mlir_module())\n    arg0_attrs, arg1_attrs, res_attrs = re.search('func.func public @main\\\\(%arg0: tensor<10x20xf32> (.*), %arg1: tensor<20x10xf32> (.*)\\\\) -> \\\\(tensor<10x20xf32> (.*)', vjp_module_str).groups()\n    if in_shardings == 'P':\n        self.assertRegex(arg0_attrs, re.escape('{devices=[1,2]<=[2]}'))\n        self.assertRegex(res_attrs, re.escape('{devices=[1,2]<=[2]}'))\n        primal_in_sharding = '{devices=[1,2]<=[2]}'\n    else:\n        primal_in_sharding = '{replicated}'\n        if with_mesh_context:\n            self.assertRegex(arg0_attrs, re.escape('replicated'))\n            self.assertRegex(res_attrs, re.escape('replicated'))\n        else:\n            self.assertNotIn('mhlo.sharding', arg0_attrs)\n            self.assertNotIn('mhlo.sharding', res_attrs)\n    if out_shardings == 'P':\n        self.assertRegex(arg1_attrs, re.escape('{devices=[2,1]<=[2]}'))\n        primal_out_sharding = '{devices=[2,1]<=[2]}'\n    else:\n        primal_out_sharding = '{replicated}'\n        if with_mesh_context:\n            self.assertRegex(arg1_attrs, re.escape('replicated'))\n        else:\n            self.assertNotIn('mhlo.sharding', arg1_attrs)\n    primal_in_sharding_calls = re.findall('custom_call @Sharding.*mhlo.sharding = \\\\\"(.+)\\\\\".*:.*tensor<10x20xf32>', vjp_module_str)\n    self.assertTrue(all((s == primal_in_sharding for s in primal_in_sharding_calls)), primal_in_sharding_calls)\n    primal_out_sharding_calls = re.findall('custom_call @Sharding.*mhlo.sharding = \\\\\"(.+)\\\\\".*:.*tensor<20x10xf32>', vjp_module_str)\n    self.assertTrue(all((s == primal_out_sharding for s in primal_out_sharding_calls)), primal_out_sharding_calls)\n    if in_shardings != 'P' and out_shardings != 'P' and (not with_mesh_context):\n        self.assertEqual(exp_vjp.nr_devices, 1)\n        self.assertEqual(exp_vjp2.nr_devices, 1)\n        call_mesh = Mesh(jax.devices()[:1], 'e')\n    else:\n        self.assertEqual(exp_vjp.nr_devices, 2)\n        self.assertEqual(exp_vjp2.nr_devices, 2)\n        call_mesh = Mesh(jax.devices()[:2], 'e')\n    g1 = pjit.pjit(exp_vjp.call, in_shardings=(NamedSharding(call_mesh, P()), NamedSharding(call_mesh, P())))(x, x.T)\n    _, f_jax_vjp = jax.vjp(f_jax, x)\n    xbar = f_jax_vjp(x.T)\n    self.assertAllClose(xbar, g1)\n    g2 = pjit.pjit(exp_vjp2.call, in_shardings=(NamedSharding(call_mesh, P()), NamedSharding(call_mesh, P()), NamedSharding(call_mesh, P())))(x, x.T, x)\n    _, f_jax_vjp2 = jax.vjp(f_jax_vjp, x.T)\n    xbar2, = f_jax_vjp2((x,))\n    self.assertAllClose(xbar2, g2[1])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_multi_platform_nested(self):\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(jax.jit(lambda x: _testing_multi_platform_func(jnp.sin(x))), platforms=('cpu', 'tpu', 'cuda', 'rocm'))(x)\n    self.assertEqual(exp.platforms, ('cpu', 'tpu', 'cuda', 'rocm'))\n    exp2 = get_exported(jax.jit(exp.call), platforms=('cpu', 'cuda', 'rocm'))(x)\n    exp2_module_str = str(exp2.mlir_module())\n    count_sine = len(re.findall('stablehlo.sine', exp2_module_str))\n    self.assertEqual(1, count_sine)\n    for platform in self.platforms:\n        if platform == 'tpu':\n            continue\n        x_device = jax.device_put(x, jax.devices(platform)[0])\n        res_exp = exp2.call(x_device)\n        self.assertAllClose(res_exp, _testing_multi_platform_fun_expected(np.sin(x), platform=platform))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_multi_platform_with_donation(self):\n    f = jax.jit(jnp.sin, donate_argnums=(0,))\n    x = np.arange(3, dtype=np.float32)\n    exp = export.export(f, platforms=['cpu', 'tpu'])(x)\n    if jtu.device_under_test() not in ['cpu', 'tpu']:\n        self.skipTest('other platform')\n\n    def caller(x):\n        y = exp.call(x)\n        return x + y\n    res = jax.jit(caller)(x)\n    self.assertAllClose(res, x + np.sin(x))\n    with self.assertRaisesRegex(NotImplementedError, 'In multi-platform lowering either all or no lowering platforms should support donation'):\n        export.export(f, platforms=['cpu', 'tpu', 'other'])(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "def test_pytree_export_only(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp = get_exported(jax.jit(f), platforms=('cpu',))((a, b), a=a, b=b)\n    a_aval = core.ShapedArray(a.shape, a.dtype)\n    b_aval = core.ShapedArray(b.shape, b.dtype)\n    self.assertEqual(exp.platforms, ('cpu',))\n    args = ((a, b),)\n    kwargs = dict(a=a, b=b)\n    self.assertEqual(exp.in_tree, jax.tree.flatten((args, kwargs))[1])\n    self.assertEqual(exp.in_avals, (a_aval, b_aval, a_aval, b_aval))\n    self.assertEqual(exp.out_tree, jax.tree.flatten(f(*args, **kwargs))[1])\n    self.assertEqual(exp.out_avals, (a_aval, b_aval, a_aval, b_aval, a_aval, b_aval))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_basic(self):\n    f = jnp.sin\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_call_exported_lambda(self):\n    f = jax.jit(lambda x: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    exp_f = get_exported(f)(x)\n    self.assertAllClose(f(x), exp_f.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_unused_args(self):\n    f = jax.jit(lambda x, y: jnp.sin(x))\n    x = np.arange(4, dtype=np.float32)\n    y = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(f)(x, y)\n    self.assertAllClose(f(x, y), exp_f.call(x, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_pytree(self):\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n\n    def f(a_b_pair, a, b):\n        return (dict(res=a_b_pair, a=a, b=b), jnp.sin(a), jnp.cos(b))\n    exp_f = get_exported(jax.jit(f))((a, b), a=a, b=b)\n    self.assertAllClose(f((a, b), a=a, b=b), exp_f.call((a, b), a=a, b=b))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_lowering_parameters_for_export(self):\n    test_primitive = core.Primitive('_test_primitive_for_export')\n    test_primitive.def_abstract_eval(lambda in_aval: in_aval)\n    context = {}\n\n    def test_primitive_lowering(ctx, arg):\n        context['for_export'] = ctx.module_context.lowering_parameters.for_export\n        context['export_ignore_forward_compatibility'] = ctx.module_context.lowering_parameters.export_ignore_forward_compatibility\n        return mlir.hlo.AddOp(arg, arg).results\n    mlir.register_lowering(test_primitive, test_primitive_lowering)\n    self.addCleanup(lambda: mlir.register_lowering(test_primitive, None))\n    f = jax.jit(test_primitive.bind)\n    a = np.arange(3, dtype=np.float32)\n    context.clear()\n    res = f(a)\n    self.assertAllClose(res, a + a)\n    self.assertEqual(context, dict(for_export=False, export_ignore_forward_compatibility=False))\n    context.clear()\n    f.lower(a)\n    self.assertEqual(context, {})\n    _ = export.export(f)(a)\n    self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=False))\n    context.clear()\n    with config.export_ignore_forward_compatibility(True):\n        _ = export.export(f)(a)\n        self.assertEqual(context, dict(for_export=True, export_ignore_forward_compatibility=True))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_pytree_vjp(self):\n\n    def f(a_b_pair, *, a, b):\n        return (dict(res=a_b_pair, a=2.0 * a, b=3.0 * b), jnp.sin(4.0 * a))\n    a = np.arange(4, dtype=np.float32)\n    b = np.arange(6, dtype=np.float32)\n    exp_f = get_exported(jax.jit(f), vjp_order=1)((a, b), a=a, b=b)\n    out_ct = f((a, b), a=a, b=b)\n\n    def f1_jax(a, b):\n        res = f((a, b), a=a, b=b)\n        return res\n\n    def f1_exp(a, b):\n        res = exp_f.call((a, b), a=a, b=b)\n        return res\n    jax_vjp = jax.vjp(f1_jax, a, b)[1](out_ct)\n    exp_vjp = jax.vjp(f1_exp, a, b)[1](out_ct)\n    self.assertAllClose(jax_vjp, exp_vjp)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'poly_spec={kw['poly_spec']}_arg_shape={kw['arg_shape']}', kwargs=[dict(poly_spec='3,4,12', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,12', arg_shape=(3, 4, 13), expect_error=re.escape('Shape mismatch for args[0].shape[2] (expected same constant)')), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 12)), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 12)), dict(poly_spec='3,4,a+1', arg_shape=(3, 4, 1), expect_error=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 1). Obtained dimension variables: 'a' = 0\")), dict(poly_spec='3,4,6*a', arg_shape=(3, 4, 13), expect_error=re.escape(\"Division had remainder 1 when computing the value of 'a'\")), dict(poly_spec='3,a,a+8', arg_shape=(3, 4, 13), expect_error=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 13) and the specification 'a + 8' (= 12)\"))])\ndef test_poly_shape_checks(self, poly_spec='3,a,a+8', arg_shape=(3, 4, 12), arg_dtype=np.float32, expect_error=None):\n\n    def f(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    disabled_checks = ()\n    exp_f = get_exported(jax.jit(f), disabled_checks=disabled_checks)(jax.ShapeDtypeStruct(export.symbolic_shape(poly_spec), np.float32))\n    self.assertEqual(exp_f.uses_global_constants, poly_spec != '3,4,12')\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    with contextlib.ExitStack() as stack:\n        if expect_error is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error))\n        assert core.is_constant_shape(arg.shape)\n        res = exp_f.call(arg)\n    if not expect_error:\n        self.assertAllClose(res, f(arg))",
    "assertions": [
      "assert core.is_constant_shape(arg.shape)"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_poly_expressions(self):\n\n    def output_shape(b):\n        return (b + b, b - b, b * b, (b + 13) // b, (b + 13) % b, core.max_dim(b - 5, 0))\n\n    @jax.jit\n    def f(x):\n        b = x.shape[0]\n        return jnp.ones(output_shape(b), dtype=x.dtype)\n    x = np.arange(5, dtype=np.float32)\n    exp = get_exported(f)(jax.ShapeDtypeStruct(export.symbolic_shape('b'), x.dtype))\n    res = exp.call(x)\n    self.assertAllClose(res, f(x))\n    x_spec = jax.ShapeDtypeStruct(export.symbolic_shape('a'), x.dtype)\n    exp2 = get_exported(jax.jit(exp.call))(x_spec)\n    a = exp2.in_avals[0].shape[0]\n    self.assertEqual(exp2.out_avals[0].shape, output_shape(a))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_poly_call_pmap(self):\n    if len(jax.devices()) < 2:\n        self.skipTest('Need at least 2 devices')\n\n    def f(x):\n        return x + jnp.arange(x.shape[0], dtype=x.dtype).reshape((x.shape[0], 1))\n    a, = export.symbolic_shape('a')\n    exp = export.export(jax.jit(f))(jax.ShapeDtypeStruct((a, 4), np.float32))\n    f_exp = exp.call\n    x_jit = np.arange(12, dtype=np.float32).reshape((3, 4))\n    res_jit = jax.jit(f_exp)(x_jit)\n    self.assertAllClose(res_jit, f(x_jit))\n    x_pmap = np.arange(24, dtype=np.float32).reshape((2, 3, 4))\n    res_pmap = jax.pmap(f_exp)(x_pmap)\n    self.assertAllClose(res_pmap, jnp.stack([f(x) for x in x_pmap]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_export_abstract_mesh(self):\n    if jax.local_device_count() < 2:\n        self.skipTest('Need at least 2 devices')\n    abs_mesh = jax.sharding.AbstractMesh((('x', 2),))\n    input_sharding = jax.sharding.NamedSharding(abs_mesh, P('x', None))\n    output_sharding = jax.sharding.NamedSharding(abs_mesh, P(None, 'x'))\n\n    @jax.jit\n    def f(a):\n        b = a @ a.T\n        return jax.lax.with_sharding_constraint(b, output_sharding)\n    exp = get_exported(f)(jax.ShapeDtypeStruct((16, 16), dtype=np.float32, sharding=input_sharding))\n    devices = jax.local_devices()[:2]\n    run_mesh = Mesh(devices, ('x',))\n    a_sharding = jax.sharding.NamedSharding(run_mesh, P('x', None))\n    a = jnp.arange(16 * 16, dtype=np.float32).reshape((16, 16))\n    a = jax.device_put(a, a_sharding)\n    res = exp.call(a)\n    self.assertAllClose(res, f(a))\n    self.assertLen(res.addressable_shards, 2)\n    self.assertEqual(res.addressable_shards[0].index, (slice(None), slice(0, 8)))\n    self.assertEqual(res.addressable_shards[1].index, (slice(None), slice(8, 16)))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_call_name_conflict(self):\n\n    @jax.jit\n    def inner(x):\n        return jnp.where(x > 0, jnp.ones_like(x), jnp.zeros_like(x))\n    x = jnp.arange(-20, 20, dtype=np.int32)\n    exp_inner = export.export(inner)(x)\n    self.assertIn('@_where(', str(exp_inner.mlir_module()))\n\n    @jax.jit\n    def outer(x):\n        x = exp_inner.call(x)\n        return inner(x)\n    export.export(outer)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def inner(state):\n    idx, x, output = state\n    chunk = jax.lax.dynamic_slice_in_dim(x, idx * chunk_size, chunk_size)\n    chunk_host = jax.device_put(chunk, TransferToMemoryKind('pinned_host'))\n    output = jax.lax.dynamic_update_slice_in_dim(output, chunk_host, idx * chunk_size, axis=0)\n    return (idx + 1, x, output)"
  },
  {
    "test_code": "@jtu.parameterized_filterable(testcase_name=lambda kw: f'inner={kw['inner_poly_spec']}_outer={kw['outer_poly_spec']}', kwargs=[dict(inner_poly_spec='3,4,12', outer_poly_spec='3,4,12'), dict(inner_poly_spec='3,a,a+b', outer_poly_spec='3,4,12'), dict(inner_poly_spec='3,4,3*a', outer_poly_spec='3,4,12'), dict(inner_poly_spec='3,a,a', outer_poly_spec='3,4,12', expect_error_outer_exp=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 12) and the specification 'a' (= 4)\")), dict(inner_poly_spec='3,4,5*a', outer_poly_spec='3,4,12', expect_error_outer_exp=re.escape(\"Division had remainder 2 when computing the value of 'a'\")), dict(inner_poly_spec='3,4,12+a', outer_poly_spec='3,4,12', expect_error_outer_exp=re.escape(\"Expected value >= 1 for dimension variable 'a'. Using the following polymorphic shapes specifications: args[0].shape = (3, 4, a + 12). Obtained dimension variables: 'a' = 0 from specification 'a + 12' for dimension args[0].shape[2] (= 12)\")), dict(inner_poly_spec='3,a,b', outer_poly_spec='3,4,c'), dict(inner_poly_spec='3,4,3*a', outer_poly_spec='3,4,6*c'), dict(inner_poly_spec='3,a,a+8', outer_poly_spec='3,c+2,c+10'), dict(inner_poly_spec='3,a,a+b', outer_poly_spec='3,4,c', expect_error_outer_exp=re.escape(\"Expected value >= 1 for dimension variable 'b'. Using the following polymorphic shapes specifications: args[0].shape = (3, a, b + a). Obtained dimension variables: 'a' = 4 from specification 'a' for dimension args[0].shape[1] (= 4), 'b' = c - 4 from specification 'b + a' for dimension args[0].shape[2] (= c),\")), dict(inner_poly_spec='3,a,a', outer_poly_spec='3,4,c', expect_error_outer_exp=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= c) and the specification 'a' (= 4)\")), dict(inner_poly_spec='3,a,a', arg_shape=(3, 4), outer_poly_spec='3,c', expect_error_outer_exp='Rank mismatch for args\\\\[0\\\\]'), dict(inner_poly_spec='3,a,a+b', arg_dtype=np.int32, outer_poly_spec='3,c,d', expect_error_outer_exp='Dtype mismatch for args\\\\[0\\\\]'), dict(inner_poly_spec='3,4,5*a', outer_poly_spec='3,4,c', expect_error_outer_exp=re.escape(\"Division had remainder mod(c, 5) when computing the value of 'a'\")), dict(inner_poly_spec='3,a,a+b', outer_poly_spec='3,c,c', expect_error_outer_exp=re.escape(\"Expected value >= 1 for dimension variable 'b'. Using the following polymorphic shapes specifications: args[0].shape = (3, a, b + a). Obtained dimension variables: 'a' = c from specification 'a' for dimension args[0].shape[1] (= c), 'b' = 0 from specification 'b + a' for dimension args[0].shape[2] (= c)\")), dict(inner_poly_spec='3,a,a+b', outer_poly_spec='c,4,12', expect_error_outer_exp=re.escape('Shape mismatch for args[0].shape[0] (expected same constant)')), dict(inner_poly_spec='3,4,5*a', outer_poly_spec='3,4,25*c', expect_error_run=re.escape(\"Division had remainder 12 when computing the value of 'c'\")), dict(inner_poly_spec='3,a,b', outer_poly_spec='3,c+4,12', expect_error_run=re.escape(\"Expected value >= 1 for dimension variable 'c'. Using the following polymorphic shapes specifications: args[0].shape = (3, c + 4, 12). Obtained dimension variables: 'c' = 0\")), dict(inner_poly_spec='3,a,a', outer_poly_spec='3,a,a', expect_error_run=re.escape(\"Found inconsistency between dimension size args[0].shape[2] (= 12) and the specification 'a' (= 4)\"))])\ndef test_poly_shape_checks_nested(self, inner_poly_spec='3,4,5*a', arg_shape=(3, 4, 12), arg_dtype=np.float32, outer_poly_spec='3,4,25*c', expect_error_outer_exp=None, expect_error_run=None):\n\n    def inner(x):\n        return jnp.reshape(x, (-1, x.shape[1]))\n    arg = np.arange(np.prod(arg_shape), dtype=arg_dtype).reshape(arg_shape)\n    inner_exp = get_exported(jax.jit(inner))(jax.ShapeDtypeStruct(export.symbolic_shape(inner_poly_spec), np.float32))\n    self.assertEqual(inner_exp.uses_global_constants, inner_poly_spec != '3,4,12')\n\n    def outer(x):\n        return inner_exp.call(x) + inner(x)\n    with contextlib.ExitStack() as stack:\n        if expect_error_outer_exp is not None:\n            stack.push(self.assertRaisesRegex(ValueError, expect_error_outer_exp))\n        outer_exp = get_exported(jax.jit(outer))(jax.ShapeDtypeStruct(export.symbolic_shape(outer_poly_spec), arg.dtype))\n    if expect_error_outer_exp is not None:\n        return\n    self.assertEqual(outer_exp.uses_global_constants, inner_poly_spec != '3,4,12' or outer_poly_spec != '3,4,12')\n    with contextlib.ExitStack() as stack:\n        if expect_error_run is not None:\n            stack.push(self.assertRaisesRegex(Exception, expect_error_run))\n        res = outer_exp.call(arg)\n    if expect_error_run is not None:\n        return\n    self.assertAllClose(2.0 * inner(arg), res)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def inner(state):\n    idx, x, output = state\n    chunk = jax.lax.dynamic_slice_in_dim(x, idx * chunk_size, chunk_size)\n    chunk_host = jax.device_put(chunk, TransferToMemoryKind('pinned_host'))\n    output = jax.lax.dynamic_update_slice_in_dim(output, chunk_host, idx * chunk_size, axis=0)\n    return (idx + 1, x, output)"
  },
  {
    "test_code": "def test_jit_static_arg(self):\n    with self.subTest('static_argnames'):\n\n        @functools.partial(jax.jit, static_argnames=['c'])\n        def f(x, *, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_f = get_exported(f)(x, c=0.1)\n        self.assertAllClose(f(x, c=0.1), exp_f.call(x))\n    with self.subTest('static_argnums'):\n\n        @functools.partial(jax.jit, static_argnums=[1])\n        def g(x, c):\n            return c * jnp.sin(x)\n        x = np.arange(4, dtype=np.float32)\n        exp_g = get_exported(g)(x, 0.1)\n        self.assertAllClose(g(x, 0.1), exp_g.call(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "def test_call_twice_exported(self):\n\n    def f(x):\n        return jnp.sin(x)\n    x = np.arange(4, dtype=np.float32)\n\n    @jax.jit\n    def f1(x):\n        exp_f = get_exported(jax.jit(f))(x)\n        return exp_f.call(x) + exp_f.call(x)\n    self.assertAllClose(2.0 * f(x), f1(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/export_test.py",
    "function": "@compute_on('device_host')\n@jax.jit\ndef f1(x):\n    x = x * 3\n    return f0(x)"
  }
]