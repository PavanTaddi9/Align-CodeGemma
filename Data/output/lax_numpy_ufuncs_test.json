[
  {
    "test_code": "@jtu.sample_product(SCALAR_FUNCS, lhs_shape=broadcast_compatible_shapes, rhs_shape=broadcast_compatible_shapes, dtype=jtu.dtypes.floating)\n@jax.numpy_rank_promotion('allow')\ndef test_frompyfunc_call(self, func, nin, nout, identity, lhs_shape, rhs_shape, dtype):\n    jnp_fun = jnp.frompyfunc(func, nin=nin, nout=nout, identity=identity)\n    np_fun = cast_outputs(np.frompyfunc(func, nin=nin, nout=nout, identity=identity))\n    rng = jtu.rand_default(self.rng())\n    args_maker = lambda: [rng(lhs_shape, dtype), rng(rhs_shape, dtype)]\n    self._CheckAgainstNumpy(jnp_fun, np_fun, args_maker)\n    self._CompileAndCheck(jnp_fun, args_maker)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/lax_numpy_ufuncs_test.py",
    "function": "def cast_outputs(fun):\n\n    def wrapped(*args, **kwargs):\n        dtype = np.asarray(args[0]).dtype\n        return jax.tree.map(lambda x: np.asarray(x, dtype=dtype), fun(*args, **kwargs))\n    return wrapped"
  },
  {
    "test_code": "@jtu.sample_product(SCALAR_FUNCS, lhs_shape=broadcast_compatible_shapes, rhs_shape=broadcast_compatible_shapes, dtype=jtu.dtypes.floating)\ndef test_frompyfunc_outer(self, func, nin, nout, identity, lhs_shape, rhs_shape, dtype):\n    if (nin, nout) != (2, 1):\n        self.skipTest(f'outer requires (nin, nout)=(2, 1); got (nin, nout)={(nin, nout)!r}')\n    jnp_fun = jnp.frompyfunc(func, nin=nin, nout=nout, identity=identity).outer\n    np_fun = cast_outputs(np.frompyfunc(func, nin=nin, nout=nout, identity=identity).outer)\n    rng = jtu.rand_default(self.rng())\n    args_maker = lambda: [rng(lhs_shape, dtype), rng(rhs_shape, dtype)]\n    self._CheckAgainstNumpy(jnp_fun, np_fun, args_maker)\n    self._CompileAndCheck(jnp_fun, args_maker)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/lax_numpy_ufuncs_test.py",
    "function": "def cast_outputs(fun):\n\n    def wrapped(*args, **kwargs):\n        dtype = np.asarray(args[0]).dtype\n        return jax.tree.map(lambda x: np.asarray(x, dtype=dtype), fun(*args, **kwargs))\n    return wrapped"
  },
  {
    "test_code": "@jtu.sample_product(SCALAR_FUNCS, [{'shape': shape, 'axis': axis} for shape in nonscalar_shapes for axis in [None, *range(-len(shape), len(shape))]], dtype=jtu.dtypes.floating)\ndef test_frompyfunc_reduce(self, func, nin, nout, identity, shape, axis, dtype):\n    if (nin, nout) != (2, 1):\n        self.skipTest(f'reduce requires (nin, nout)=(2, 1); got (nin, nout)={(nin, nout)!r}')\n    jnp_fun = partial(jnp.frompyfunc(func, nin=nin, nout=nout, identity=identity).reduce, axis=axis)\n    np_fun = cast_outputs(partial(np.frompyfunc(func, nin=nin, nout=nout, identity=identity).reduce, axis=axis))\n    rng = jtu.rand_default(self.rng())\n    args_maker = lambda: [rng(shape, dtype)]\n    self._CheckAgainstNumpy(jnp_fun, np_fun, args_maker)\n    self._CompileAndCheck(jnp_fun, args_maker)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/lax_numpy_ufuncs_test.py",
    "function": "def cast_outputs(fun):\n\n    def wrapped(*args, **kwargs):\n        dtype = np.asarray(args[0]).dtype\n        return jax.tree.map(lambda x: np.asarray(x, dtype=dtype), fun(*args, **kwargs))\n    return wrapped"
  },
  {
    "test_code": "@jtu.sample_product(SCALAR_FUNCS, [{'shape': shape, 'axis': axis} for shape in nonscalar_shapes for axis in range(-len(shape), len(shape))], dtype=jtu.dtypes.floating)\ndef test_frompyfunc_accumulate(self, func, nin, nout, identity, shape, axis, dtype):\n    if (nin, nout) != (2, 1):\n        self.skipTest(f'accumulate requires (nin, nout)=(2, 1); got (nin, nout)={(nin, nout)!r}')\n    jnp_fun = partial(jnp.frompyfunc(func, nin=nin, nout=nout, identity=identity).accumulate, axis=axis)\n    np_fun = cast_outputs(partial(np.frompyfunc(func, nin=nin, nout=nout, identity=identity).accumulate, axis=axis))\n    rng = jtu.rand_default(self.rng())\n    args_maker = lambda: [rng(shape, dtype)]\n    self._CheckAgainstNumpy(jnp_fun, np_fun, args_maker)\n    self._CompileAndCheck(jnp_fun, args_maker)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/lax_numpy_ufuncs_test.py",
    "function": "def cast_outputs(fun):\n\n    def wrapped(*args, **kwargs):\n        dtype = np.asarray(args[0]).dtype\n        return jax.tree.map(lambda x: np.asarray(x, dtype=dtype), fun(*args, **kwargs))\n    return wrapped"
  },
  {
    "test_code": "@jtu.sample_product(SCALAR_FUNCS, [{'shape': shape, 'axis': axis} for shape in nonscalar_shapes for axis in [*range(-len(shape), len(shape))]], idx_shape=[(0,), (3,), (5,)], dtype=jtu.dtypes.floating)\ndef test_frompyfunc_reduceat(self, func, nin, nout, identity, shape, axis, idx_shape, dtype):\n    if (nin, nout) != (2, 1):\n        self.skipTest(f'accumulate requires (nin, nout)=(2, 1); got (nin, nout)={(nin, nout)!r}')\n    jnp_fun = partial(jnp.frompyfunc(func, nin=nin, nout=nout, identity=identity).reduceat, axis=axis)\n    np_fun = cast_outputs(partial(np.frompyfunc(func, nin=nin, nout=nout, identity=identity).reduceat, axis=axis))\n    rng = jtu.rand_default(self.rng())\n    idx_rng = jtu.rand_int(self.rng(), low=0, high=shape[axis])\n    args_maker = lambda: [rng(shape, dtype), idx_rng(idx_shape, 'int32')]\n    self._CheckAgainstNumpy(jnp_fun, np_fun, args_maker)\n    self._CompileAndCheck(jnp_fun, args_maker)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/lax_numpy_ufuncs_test.py",
    "function": "def cast_outputs(fun):\n\n    def wrapped(*args, **kwargs):\n        dtype = np.asarray(args[0]).dtype\n        return jax.tree.map(lambda x: np.asarray(x, dtype=dtype), fun(*args, **kwargs))\n    return wrapped"
  }
]