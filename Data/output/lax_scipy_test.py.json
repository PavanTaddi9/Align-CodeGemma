[
  {
    "test_code": "def testIssue980(self):\n    x = np.full((4,), -1e+20, dtype=np.float32)\n    self.assertAllClose(np.zeros((4,), dtype=np.float32), lsp_special.expit(x))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/lax_scipy_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "@jtu.sample_product(n_zero_sv=n_zero_svs, degeneracy=degeneracies, geometric_spectrum=geometric_spectra, max_sv=max_svs, shape=polar_shapes, method=methods, side=sides, nonzero_condition_number=nonzero_condition_numbers, dtype=jtu.dtypes.inexact, seed=seeds)\ndef testPolar(self, n_zero_sv, degeneracy, geometric_spectrum, max_sv, shape, method, side, nonzero_condition_number, dtype, seed):\n    \"\"\" Tests jax.scipy.linalg.polar.\"\"\"\n    if not jtu.test_device_matches(['cpu']):\n        if jnp.dtype(dtype).name in ('bfloat16', 'float16'):\n            raise unittest.SkipTest('Skip half precision off CPU.')\n    m, n = shape\n    if method == 'qdwh' and (side == 'left' and m >= n or (side == 'right' and m < n)):\n        raise unittest.SkipTest('method=qdwh does not support these sizes')\n    matrix, _ = _initialize_polar_test(self.rng(), shape, n_zero_sv, degeneracy, geometric_spectrum, max_sv, nonzero_condition_number, dtype)\n    if jnp.dtype(dtype).name in ('bfloat16', 'float16'):\n        self.assertRaises(NotImplementedError, jsp.linalg.polar, matrix, method=method, side=side)\n        return\n    unitary, posdef = jsp.linalg.polar(matrix, method=method, side=side)\n    if shape[0] >= shape[1]:\n        should_be_eye = np.matmul(unitary.conj().T, unitary)\n    else:\n        should_be_eye = np.matmul(unitary, unitary.conj().T)\n    tol = 650 * float(jnp.finfo(matrix.dtype).eps)\n    eye_mat = np.eye(should_be_eye.shape[0], dtype=should_be_eye.dtype)\n    with self.subTest('Test unitarity.'):\n        self.assertAllClose(eye_mat, should_be_eye, atol=tol * 1000 * min(shape))\n    with self.subTest('Test Hermiticity.'):\n        self.assertAllClose(posdef, posdef.conj().T, atol=tol * jnp.linalg.norm(posdef))\n    ev, _ = np.linalg.eigh(posdef)\n    ev = ev[np.abs(ev) > tol * np.linalg.norm(posdef)]\n    negative_ev = jnp.sum(ev < 0.0)\n    with self.subTest('Test positive definiteness.'):\n        self.assertEqual(negative_ev, 0)\n    if side == 'right':\n        recon = jnp.matmul(unitary, posdef, precision=lax.Precision.HIGHEST)\n    elif side == 'left':\n        recon = jnp.matmul(posdef, unitary, precision=lax.Precision.HIGHEST)\n    with self.subTest('Test reconstruction.'):\n        self.assertAllClose(matrix, recon, atol=tol * jnp.linalg.norm(matrix))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/lax_scipy_test.py",
    "function": "def norm(x):\n    norm = np.linalg.norm(x, axis=(-2, -1))\n    return norm / ((inner_dimension + 1) * jnp.finfo(dtype).eps)"
  },
  {
    "test_code": "@jtu.sample_product(n_zero_sv=n_zero_svs, degeneracy=degeneracies, geometric_spectrum=geometric_spectra, max_sv=max_svs, shape=polar_shapes, method=methods, side=sides, nonzero_condition_number=nonzero_condition_numbers, dtype=jtu.dtypes.inexact, seed=seeds)\ndef testPolar(self, n_zero_sv, degeneracy, geometric_spectrum, max_sv, shape, method, side, nonzero_condition_number, dtype, seed):\n    \"\"\" Tests jax.scipy.linalg.polar.\"\"\"\n    if not jtu.test_device_matches(['cpu']):\n        if jnp.dtype(dtype).name in ('bfloat16', 'float16'):\n            raise unittest.SkipTest('Skip half precision off CPU.')\n    m, n = shape\n    if method == 'qdwh' and (side == 'left' and m >= n or (side == 'right' and m < n)):\n        raise unittest.SkipTest('method=qdwh does not support these sizes')\n    matrix, _ = _initialize_polar_test(self.rng(), shape, n_zero_sv, degeneracy, geometric_spectrum, max_sv, nonzero_condition_number, dtype)\n    if jnp.dtype(dtype).name in ('bfloat16', 'float16'):\n        self.assertRaises(NotImplementedError, jsp.linalg.polar, matrix, method=method, side=side)\n        return\n    unitary, posdef = jsp.linalg.polar(matrix, method=method, side=side)\n    if shape[0] >= shape[1]:\n        should_be_eye = np.matmul(unitary.conj().T, unitary)\n    else:\n        should_be_eye = np.matmul(unitary, unitary.conj().T)\n    tol = 650 * float(jnp.finfo(matrix.dtype).eps)\n    eye_mat = np.eye(should_be_eye.shape[0], dtype=should_be_eye.dtype)\n    with self.subTest('Test unitarity.'):\n        self.assertAllClose(eye_mat, should_be_eye, atol=tol * 1000 * min(shape))\n    with self.subTest('Test Hermiticity.'):\n        self.assertAllClose(posdef, posdef.conj().T, atol=tol * jnp.linalg.norm(posdef))\n    ev, _ = np.linalg.eigh(posdef)\n    ev = ev[np.abs(ev) > tol * np.linalg.norm(posdef)]\n    negative_ev = jnp.sum(ev < 0.0)\n    with self.subTest('Test positive definiteness.'):\n        self.assertEqual(negative_ev, 0)\n    if side == 'right':\n        recon = jnp.matmul(unitary, posdef, precision=lax.Precision.HIGHEST)\n    elif side == 'left':\n        recon = jnp.matmul(posdef, unitary, precision=lax.Precision.HIGHEST)\n    with self.subTest('Test reconstruction.'):\n        self.assertAllClose(matrix, recon, atol=tol * jnp.linalg.norm(matrix))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/lax_scipy_test.py",
    "function": "def _initialize_polar_test(rng, shape, n_zero_svs, degeneracy, geometric_spectrum, max_sv, nonzero_condition_number, dtype):\n    n_rows, n_cols = shape\n    min_dim = min(shape)\n    left_vecs = rng.randn(n_rows, min_dim).astype(np.float64)\n    left_vecs, _ = np.linalg.qr(left_vecs)\n    right_vecs = rng.randn(n_cols, min_dim).astype(np.float64)\n    right_vecs, _ = np.linalg.qr(right_vecs)\n    min_nonzero_sv = max_sv / nonzero_condition_number\n    num_nonzero_svs = min_dim - n_zero_svs\n    if geometric_spectrum:\n        nonzero_svs = np.geomspace(min_nonzero_sv, max_sv, num=num_nonzero_svs, dtype=np.float64)\n    else:\n        nonzero_svs = np.linspace(min_nonzero_sv, max_sv, num=num_nonzero_svs, dtype=np.float64)\n    half_point = n_zero_svs // 2\n    for i in range(half_point, half_point + degeneracy):\n        nonzero_svs[i] = nonzero_svs[half_point]\n    svs = np.zeros(min(shape), dtype=np.float64)\n    svs[n_zero_svs:] = nonzero_svs\n    svs = svs[::-1]\n    result = np.dot(left_vecs * svs, right_vecs.conj().T)\n    result = jnp.array(result).astype(dtype)\n    spectrum = jnp.array(svs).astype(dtype)\n    return (result, spectrum)"
  }
]