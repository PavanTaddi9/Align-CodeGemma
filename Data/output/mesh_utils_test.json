[
  {
    "test_code": "@parameterized.named_parameters(('1x2x1_t', (1, 2, 1), True), ('4x4x4_t', (4, 4, 4), True), ('4x4x4_f', (4, 4, 4), False), ('8x8x16_t', (8, 8, 16), True), ('8x8x16_f', (8, 8, 16), False))\ndef test_get_physical_tpu_mesh(self, xyz, reorder):\n    x, y, z = xyz\n    jax_devices = mock_tpu_devices(x, y, z, 'TPU v4', True, reorder=reorder)\n    normalized = mesh_utils._get_physical_tpu_mesh(jax_devices)\n    self.assertEqual(normalized.shape, xyz)\n    for i in range(x):\n        for j in range(y):\n            for k in range(z):\n                self.assertEqual(normalized[i, j, k].coords, (i, j, k))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/mesh_utils_test.py",
    "function": "def mock_tpu_devices(x, y, z, dev_kind, one_device_per_chip, num_slices=1, reorder=False):\n    \"\"\"Produce fake jax.devices() output for a TPU slice.\"\"\"\n    assert x > 0 and y > 0 and (z > 0)\n    cores_per_chip = 1 if one_device_per_chip else 2\n    nxd, nyd, nzd = (min(x, 2), min(y, 2), 1)\n    nxp, nyp, nzp = (x // nxd, y // nyd, z // nzd)\n    assert nxp * nxd == x\n    assert nyp * nyd == y\n    assert nzp * nzd == z\n\n    def mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index):\n        process_index = xp + nxp * (yp + nyp * (zp + nzp * slice_index))\n        coords = (xd + nxd * xp, yd + nyd * yp, zd + nzd * zp)\n        device_id = core_on_chip + cores_per_chip * (xd + nxd * (xp + nxp * (yd + nyd * (yp + nyp * (zd + nzd * (zp + nzp * slice_index))))))\n        return MockTpuDevice(device_id, 'tpu', dev_kind, process_index, coords, core_on_chip, slice_index)\n    devices = [mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index) for slice_index in range(num_slices) for zp in range(nzp) for yp in range(nyp) for xp in range(nxp) for zd in range(nzd) for yd in range(nyd) for xd in range(nxd) for core_on_chip in range(cores_per_chip)]\n    if reorder:\n        devices = devices[::-1]\n    num_local_chips = nxd * nyd\n    if num_local_chips < 4:\n        num_all_chips = x * y * z\n        assert num_all_chips == num_local_chips, f'Bad shape: x={x!r}, y={y!r}, z={z!r}'\n        assert z == 1\n        _validate_mocked_devices_for_subhost_slice(devices, x, y, cores_per_chip)\n    else:\n        _validate_mocked_devices(devices, num_local_chips * cores_per_chip)\n    return devices"
  },
  {
    "test_code": "def test_get_physical_tpu_mesh_with_subslice_TPU_v2_1x1(self):\n    one_device_per_chip = False\n    device_list = mock_tpu_devices(1, 1, 1, 'TPU v2', one_device_per_chip)\n    device_array = mesh_utils._get_physical_tpu_mesh(device_list)\n    self.assertEqual(device_array.shape, (1, 1, 2))\n    subslice0 = mesh_utils._get_physical_tpu_mesh([device_array[0, 0, 0]])\n    self.assertEqual(subslice0.shape, (1, 1, 1))\n    self.assertEqual(subslice0[0, 0, 0], device_array[0, 0, 0])\n    self.assertEqual(subslice0[0, 0, 0].coords, (0, 0, 0))\n    self.assertEqual(subslice0[0, 0, 0].core_on_chip, 0)\n    subslice1 = mesh_utils._get_physical_tpu_mesh([device_array[0, 0, 1]])\n    self.assertEqual(subslice1.shape, (1, 1, 1))\n    self.assertEqual(subslice1[0, 0, 0], device_array[0, 0, 1])\n    self.assertEqual(subslice1[0, 0, 0].coords, (0, 0, 0))\n    self.assertEqual(subslice1[0, 0, 0].core_on_chip, 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/mesh_utils_test.py",
    "function": "def mock_tpu_devices(x, y, z, dev_kind, one_device_per_chip, num_slices=1, reorder=False):\n    \"\"\"Produce fake jax.devices() output for a TPU slice.\"\"\"\n    assert x > 0 and y > 0 and (z > 0)\n    cores_per_chip = 1 if one_device_per_chip else 2\n    nxd, nyd, nzd = (min(x, 2), min(y, 2), 1)\n    nxp, nyp, nzp = (x // nxd, y // nyd, z // nzd)\n    assert nxp * nxd == x\n    assert nyp * nyd == y\n    assert nzp * nzd == z\n\n    def mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index):\n        process_index = xp + nxp * (yp + nyp * (zp + nzp * slice_index))\n        coords = (xd + nxd * xp, yd + nyd * yp, zd + nzd * zp)\n        device_id = core_on_chip + cores_per_chip * (xd + nxd * (xp + nxp * (yd + nyd * (yp + nyp * (zd + nzd * (zp + nzp * slice_index))))))\n        return MockTpuDevice(device_id, 'tpu', dev_kind, process_index, coords, core_on_chip, slice_index)\n    devices = [mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index) for slice_index in range(num_slices) for zp in range(nzp) for yp in range(nyp) for xp in range(nxp) for zd in range(nzd) for yd in range(nyd) for xd in range(nxd) for core_on_chip in range(cores_per_chip)]\n    if reorder:\n        devices = devices[::-1]\n    num_local_chips = nxd * nyd\n    if num_local_chips < 4:\n        num_all_chips = x * y * z\n        assert num_all_chips == num_local_chips, f'Bad shape: x={x!r}, y={y!r}, z={z!r}'\n        assert z == 1\n        _validate_mocked_devices_for_subhost_slice(devices, x, y, cores_per_chip)\n    else:\n        _validate_mocked_devices(devices, num_local_chips * cores_per_chip)\n    return devices"
  },
  {
    "test_code": "def test_get_physical_tpu_mesh_with_subslice_TPU_v4_1x2x1(self):\n    one_device_per_chip = True\n    device_list = mock_tpu_devices(1, 2, 1, 'TPU v4', one_device_per_chip)\n    device_array = mesh_utils._get_physical_tpu_mesh(device_list)\n    self.assertEqual(device_array.shape, (1, 2, 1))\n    subslice0 = mesh_utils._get_physical_tpu_mesh([device_array[0, 0, 0]])\n    self.assertEqual(subslice0.shape, (1, 1, 1))\n    self.assertEqual(subslice0[0, 0, 0], device_array[0, 0, 0])\n    subslice1 = mesh_utils._get_physical_tpu_mesh([device_array[0, 1, 0]])\n    self.assertEqual(subslice1.shape, (1, 1, 1))\n    self.assertEqual(subslice1[0, 0, 0], device_array[0, 1, 0])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/mesh_utils_test.py",
    "function": "def mock_tpu_devices(x, y, z, dev_kind, one_device_per_chip, num_slices=1, reorder=False):\n    \"\"\"Produce fake jax.devices() output for a TPU slice.\"\"\"\n    assert x > 0 and y > 0 and (z > 0)\n    cores_per_chip = 1 if one_device_per_chip else 2\n    nxd, nyd, nzd = (min(x, 2), min(y, 2), 1)\n    nxp, nyp, nzp = (x // nxd, y // nyd, z // nzd)\n    assert nxp * nxd == x\n    assert nyp * nyd == y\n    assert nzp * nzd == z\n\n    def mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index):\n        process_index = xp + nxp * (yp + nyp * (zp + nzp * slice_index))\n        coords = (xd + nxd * xp, yd + nyd * yp, zd + nzd * zp)\n        device_id = core_on_chip + cores_per_chip * (xd + nxd * (xp + nxp * (yd + nyd * (yp + nyp * (zd + nzd * (zp + nzp * slice_index))))))\n        return MockTpuDevice(device_id, 'tpu', dev_kind, process_index, coords, core_on_chip, slice_index)\n    devices = [mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index) for slice_index in range(num_slices) for zp in range(nzp) for yp in range(nyp) for xp in range(nxp) for zd in range(nzd) for yd in range(nyd) for xd in range(nxd) for core_on_chip in range(cores_per_chip)]\n    if reorder:\n        devices = devices[::-1]\n    num_local_chips = nxd * nyd\n    if num_local_chips < 4:\n        num_all_chips = x * y * z\n        assert num_all_chips == num_local_chips, f'Bad shape: x={x!r}, y={y!r}, z={z!r}'\n        assert z == 1\n        _validate_mocked_devices_for_subhost_slice(devices, x, y, cores_per_chip)\n    else:\n        _validate_mocked_devices(devices, num_local_chips * cores_per_chip)\n    return devices"
  },
  {
    "test_code": "def test_get_physical_tpu_mesh_with_subslice_TPU_v5e_4x4(self):\n    one_device_per_chip = True\n    device_list = mock_tpu_devices(4, 4, 1, 'TPU v5e', one_device_per_chip)\n    device_array = mesh_utils._get_physical_tpu_mesh(device_list)\n    self.assertEqual(device_array.shape, (4, 4, 1))\n    for start_y in (0, 2):\n        subslice_devices = []\n        for x in range(4):\n            for delta_y in range(2):\n                subslice_devices.append(device_array[x, start_y + delta_y, 0])\n        logging.info('start_y=%s subslice_devices=%s', start_y, subslice_devices)\n        subslice = mesh_utils._get_physical_tpu_mesh(subslice_devices)\n        self.assertEqual(subslice.shape, (4, 2, 1))\n        for x in range(4):\n            for delta_y in range(2):\n                self.assertEqual(subslice[x, delta_y], device_array[x, start_y + delta_y, 0])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/mesh_utils_test.py",
    "function": "def mock_tpu_devices(x, y, z, dev_kind, one_device_per_chip, num_slices=1, reorder=False):\n    \"\"\"Produce fake jax.devices() output for a TPU slice.\"\"\"\n    assert x > 0 and y > 0 and (z > 0)\n    cores_per_chip = 1 if one_device_per_chip else 2\n    nxd, nyd, nzd = (min(x, 2), min(y, 2), 1)\n    nxp, nyp, nzp = (x // nxd, y // nyd, z // nzd)\n    assert nxp * nxd == x\n    assert nyp * nyd == y\n    assert nzp * nzd == z\n\n    def mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index):\n        process_index = xp + nxp * (yp + nyp * (zp + nzp * slice_index))\n        coords = (xd + nxd * xp, yd + nyd * yp, zd + nzd * zp)\n        device_id = core_on_chip + cores_per_chip * (xd + nxd * (xp + nxp * (yd + nyd * (yp + nyp * (zd + nzd * (zp + nzp * slice_index))))))\n        return MockTpuDevice(device_id, 'tpu', dev_kind, process_index, coords, core_on_chip, slice_index)\n    devices = [mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index) for slice_index in range(num_slices) for zp in range(nzp) for yp in range(nyp) for xp in range(nxp) for zd in range(nzd) for yd in range(nyd) for xd in range(nxd) for core_on_chip in range(cores_per_chip)]\n    if reorder:\n        devices = devices[::-1]\n    num_local_chips = nxd * nyd\n    if num_local_chips < 4:\n        num_all_chips = x * y * z\n        assert num_all_chips == num_local_chips, f'Bad shape: x={x!r}, y={y!r}, z={z!r}'\n        assert z == 1\n        _validate_mocked_devices_for_subhost_slice(devices, x, y, cores_per_chip)\n    else:\n        _validate_mocked_devices(devices, num_local_chips * cores_per_chip)\n    return devices"
  },
  {
    "test_code": "def test_get_physical_tpu_mesh_with_bad_subslice(self):\n    one_device_per_chip = True\n    device_list = mock_tpu_devices(4, 4, 1, 'TPU v5e', one_device_per_chip)\n    device_array = mesh_utils._get_physical_tpu_mesh(device_list)\n    self.assertEqual(device_array.shape, (4, 4, 1))\n    start_y = 2\n    subslice_devices = []\n    for x in range(4):\n        for delta_y in range(2):\n            if x == 0 and delta_y == 0:\n                continue\n            subslice_devices.append(device_array[x, start_y + delta_y, 0])\n    with self.assertRaises(AssertionError):\n        mesh_utils._get_physical_tpu_mesh(subslice_devices)\n    subslice_devices.append(device_array[2, 2, 0])\n    with self.assertRaisesRegex(AssertionError, 'not a contiguous cuboid'):\n        mesh_utils._get_physical_tpu_mesh(subslice_devices)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/mesh_utils_test.py",
    "function": "def mock_tpu_devices(x, y, z, dev_kind, one_device_per_chip, num_slices=1, reorder=False):\n    \"\"\"Produce fake jax.devices() output for a TPU slice.\"\"\"\n    assert x > 0 and y > 0 and (z > 0)\n    cores_per_chip = 1 if one_device_per_chip else 2\n    nxd, nyd, nzd = (min(x, 2), min(y, 2), 1)\n    nxp, nyp, nzp = (x // nxd, y // nyd, z // nzd)\n    assert nxp * nxd == x\n    assert nyp * nyd == y\n    assert nzp * nzd == z\n\n    def mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index):\n        process_index = xp + nxp * (yp + nyp * (zp + nzp * slice_index))\n        coords = (xd + nxd * xp, yd + nyd * yp, zd + nzd * zp)\n        device_id = core_on_chip + cores_per_chip * (xd + nxd * (xp + nxp * (yd + nyd * (yp + nyp * (zd + nzd * (zp + nzp * slice_index))))))\n        return MockTpuDevice(device_id, 'tpu', dev_kind, process_index, coords, core_on_chip, slice_index)\n    devices = [mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index) for slice_index in range(num_slices) for zp in range(nzp) for yp in range(nyp) for xp in range(nxp) for zd in range(nzd) for yd in range(nyd) for xd in range(nxd) for core_on_chip in range(cores_per_chip)]\n    if reorder:\n        devices = devices[::-1]\n    num_local_chips = nxd * nyd\n    if num_local_chips < 4:\n        num_all_chips = x * y * z\n        assert num_all_chips == num_local_chips, f'Bad shape: x={x!r}, y={y!r}, z={z!r}'\n        assert z == 1\n        _validate_mocked_devices_for_subhost_slice(devices, x, y, cores_per_chip)\n    else:\n        _validate_mocked_devices(devices, num_local_chips * cores_per_chip)\n    return devices"
  },
  {
    "test_code": "@parameterized.named_parameters(('2X4x4x4a', (1, 16, 4), (2, 1, 1)), ('2X4x4x4b', (1, 4, 16), (1, 2, 1)))\ndef test_create_hybrid_device_mesh(self, mesh_shape, dcn_mesh_shape):\n    devices = mock_tpu_devices(4, 4, 4, 'TPU v4', True, 2)\n    mesh = mesh_utils.create_hybrid_device_mesh(mesh_shape, dcn_mesh_shape, devices)\n    total_mesh_shape = tuple((m1 * m2 for m1, m2 in zip(mesh_shape, dcn_mesh_shape)))\n    self.assertEqual(mesh.shape, total_mesh_shape)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/mesh_utils_test.py",
    "function": "def mock_tpu_devices(x, y, z, dev_kind, one_device_per_chip, num_slices=1, reorder=False):\n    \"\"\"Produce fake jax.devices() output for a TPU slice.\"\"\"\n    assert x > 0 and y > 0 and (z > 0)\n    cores_per_chip = 1 if one_device_per_chip else 2\n    nxd, nyd, nzd = (min(x, 2), min(y, 2), 1)\n    nxp, nyp, nzp = (x // nxd, y // nyd, z // nzd)\n    assert nxp * nxd == x\n    assert nyp * nyd == y\n    assert nzp * nzd == z\n\n    def mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index):\n        process_index = xp + nxp * (yp + nyp * (zp + nzp * slice_index))\n        coords = (xd + nxd * xp, yd + nyd * yp, zd + nzd * zp)\n        device_id = core_on_chip + cores_per_chip * (xd + nxd * (xp + nxp * (yd + nyd * (yp + nyp * (zd + nzd * (zp + nzp * slice_index))))))\n        return MockTpuDevice(device_id, 'tpu', dev_kind, process_index, coords, core_on_chip, slice_index)\n    devices = [mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index) for slice_index in range(num_slices) for zp in range(nzp) for yp in range(nyp) for xp in range(nxp) for zd in range(nzd) for yd in range(nyd) for xd in range(nxd) for core_on_chip in range(cores_per_chip)]\n    if reorder:\n        devices = devices[::-1]\n    num_local_chips = nxd * nyd\n    if num_local_chips < 4:\n        num_all_chips = x * y * z\n        assert num_all_chips == num_local_chips, f'Bad shape: x={x!r}, y={y!r}, z={z!r}'\n        assert z == 1\n        _validate_mocked_devices_for_subhost_slice(devices, x, y, cores_per_chip)\n    else:\n        _validate_mocked_devices(devices, num_local_chips * cores_per_chip)\n    return devices"
  },
  {
    "test_code": "@parameterized.named_parameters(('2X4x4x4a', (1, 16, 4), (2, 1, 1)), ('2X4x4x4b', (1, 4, 16), (1, 2, 1)))\ndef test_create_hybrid_device_mesh_device_sorting(self, mesh_shape: tuple[int, ...], dcn_mesh_shape: tuple[int, ...]):\n    devices = mock_tpu_devices(4, 4, 4, 'TPU v4', True, 2)\n    reversed_slices_devices = list(np.flip(np.array(devices).reshape(2, -1), axis=0).flat)\n    mesh = mesh_utils.create_hybrid_device_mesh(mesh_shape, dcn_mesh_shape, devices, should_sort_granules_by_key=False)\n    sorted_slices_mesh = mesh_utils.create_hybrid_device_mesh(mesh_shape, dcn_mesh_shape, reversed_slices_devices, should_sort_granules_by_key=True)\n    np.testing.assert_array_equal(mesh, sorted_slices_mesh)\n    self.assertSetEqual({0, 1}, {d.slice_index for d in sorted_slices_mesh.flat})\n    reversed_slices_mesh = mesh_utils.create_hybrid_device_mesh(mesh_shape, dcn_mesh_shape, reversed_slices_devices, should_sort_granules_by_key=False)\n    self.assertSetEqual({1, 0}, {d.slice_index for d in reversed_slices_mesh.flat})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/mesh_utils_test.py",
    "function": "def mock_tpu_devices(x, y, z, dev_kind, one_device_per_chip, num_slices=1, reorder=False):\n    \"\"\"Produce fake jax.devices() output for a TPU slice.\"\"\"\n    assert x > 0 and y > 0 and (z > 0)\n    cores_per_chip = 1 if one_device_per_chip else 2\n    nxd, nyd, nzd = (min(x, 2), min(y, 2), 1)\n    nxp, nyp, nzp = (x // nxd, y // nyd, z // nzd)\n    assert nxp * nxd == x\n    assert nyp * nyd == y\n    assert nzp * nzd == z\n\n    def mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index):\n        process_index = xp + nxp * (yp + nyp * (zp + nzp * slice_index))\n        coords = (xd + nxd * xp, yd + nyd * yp, zd + nzd * zp)\n        device_id = core_on_chip + cores_per_chip * (xd + nxd * (xp + nxp * (yd + nyd * (yp + nyp * (zd + nzd * (zp + nzp * slice_index))))))\n        return MockTpuDevice(device_id, 'tpu', dev_kind, process_index, coords, core_on_chip, slice_index)\n    devices = [mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index) for slice_index in range(num_slices) for zp in range(nzp) for yp in range(nyp) for xp in range(nxp) for zd in range(nzd) for yd in range(nyd) for xd in range(nxd) for core_on_chip in range(cores_per_chip)]\n    if reorder:\n        devices = devices[::-1]\n    num_local_chips = nxd * nyd\n    if num_local_chips < 4:\n        num_all_chips = x * y * z\n        assert num_all_chips == num_local_chips, f'Bad shape: x={x!r}, y={y!r}, z={z!r}'\n        assert z == 1\n        _validate_mocked_devices_for_subhost_slice(devices, x, y, cores_per_chip)\n    else:\n        _validate_mocked_devices(devices, num_local_chips * cores_per_chip)\n    return devices"
  },
  {
    "test_code": "def test_create_contiguous_submeshes_for_tpu_v4(self):\n    v4 = mesh_utils._TPU_V4\n    for topology, mesh_shapes in mesh_utils._TRANSPOSE_TRICKS.items():\n        logging.vlog(1, 'topology: %s', topology)\n        devices = mock_tpu_devices(topology[0], topology[1], topology[2], v4, one_device_per_chip=True)\n        for mesh_shape in mesh_shapes:\n            logging.vlog(1, '  mesh_shape: %s', mesh_shape)\n            mesh = mesh_utils.create_device_mesh(mesh_shape, devices=devices, contiguous_submeshes=True)\n            self._assert_contiguous_submeshes(mesh)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/mesh_utils_test.py",
    "function": "def mock_tpu_devices(x, y, z, dev_kind, one_device_per_chip, num_slices=1, reorder=False):\n    \"\"\"Produce fake jax.devices() output for a TPU slice.\"\"\"\n    assert x > 0 and y > 0 and (z > 0)\n    cores_per_chip = 1 if one_device_per_chip else 2\n    nxd, nyd, nzd = (min(x, 2), min(y, 2), 1)\n    nxp, nyp, nzp = (x // nxd, y // nyd, z // nzd)\n    assert nxp * nxd == x\n    assert nyp * nyd == y\n    assert nzp * nzd == z\n\n    def mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index):\n        process_index = xp + nxp * (yp + nyp * (zp + nzp * slice_index))\n        coords = (xd + nxd * xp, yd + nyd * yp, zd + nzd * zp)\n        device_id = core_on_chip + cores_per_chip * (xd + nxd * (xp + nxp * (yd + nyd * (yp + nyp * (zd + nzd * (zp + nzp * slice_index))))))\n        return MockTpuDevice(device_id, 'tpu', dev_kind, process_index, coords, core_on_chip, slice_index)\n    devices = [mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index) for slice_index in range(num_slices) for zp in range(nzp) for yp in range(nyp) for xp in range(nxp) for zd in range(nzd) for yd in range(nyd) for xd in range(nxd) for core_on_chip in range(cores_per_chip)]\n    if reorder:\n        devices = devices[::-1]\n    num_local_chips = nxd * nyd\n    if num_local_chips < 4:\n        num_all_chips = x * y * z\n        assert num_all_chips == num_local_chips, f'Bad shape: x={x!r}, y={y!r}, z={z!r}'\n        assert z == 1\n        _validate_mocked_devices_for_subhost_slice(devices, x, y, cores_per_chip)\n    else:\n        _validate_mocked_devices(devices, num_local_chips * cores_per_chip)\n    return devices"
  },
  {
    "test_code": "def test_create_contiguous_submeshes_for_tpu_v4_leading_1_dims(self):\n    v4 = mesh_utils._TPU_V4\n    for topology, mesh_shapes in mesh_utils._TRANSPOSE_TRICKS.items():\n        logging.vlog(1, 'topology: %s', topology)\n        devices = mock_tpu_devices(topology[0], topology[1], topology[2], v4, one_device_per_chip=True)\n        for mesh_shape in mesh_shapes:\n            logging.vlog(1, '  mesh_shape: %s', (1, 1) + mesh_shape + (1, 1))\n            mesh = mesh_utils.create_device_mesh((1, 1) + mesh_shape + (1, 1), devices=devices, contiguous_submeshes=True)\n            self._assert_contiguous_submeshes(mesh)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/mesh_utils_test.py",
    "function": "def mock_tpu_devices(x, y, z, dev_kind, one_device_per_chip, num_slices=1, reorder=False):\n    \"\"\"Produce fake jax.devices() output for a TPU slice.\"\"\"\n    assert x > 0 and y > 0 and (z > 0)\n    cores_per_chip = 1 if one_device_per_chip else 2\n    nxd, nyd, nzd = (min(x, 2), min(y, 2), 1)\n    nxp, nyp, nzp = (x // nxd, y // nyd, z // nzd)\n    assert nxp * nxd == x\n    assert nyp * nyd == y\n    assert nzp * nzd == z\n\n    def mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index):\n        process_index = xp + nxp * (yp + nyp * (zp + nzp * slice_index))\n        coords = (xd + nxd * xp, yd + nyd * yp, zd + nzd * zp)\n        device_id = core_on_chip + cores_per_chip * (xd + nxd * (xp + nxp * (yd + nyd * (yp + nyp * (zd + nzd * (zp + nzp * slice_index))))))\n        return MockTpuDevice(device_id, 'tpu', dev_kind, process_index, coords, core_on_chip, slice_index)\n    devices = [mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index) for slice_index in range(num_slices) for zp in range(nzp) for yp in range(nyp) for xp in range(nxp) for zd in range(nzd) for yd in range(nyd) for xd in range(nxd) for core_on_chip in range(cores_per_chip)]\n    if reorder:\n        devices = devices[::-1]\n    num_local_chips = nxd * nyd\n    if num_local_chips < 4:\n        num_all_chips = x * y * z\n        assert num_all_chips == num_local_chips, f'Bad shape: x={x!r}, y={y!r}, z={z!r}'\n        assert z == 1\n        _validate_mocked_devices_for_subhost_slice(devices, x, y, cores_per_chip)\n    else:\n        _validate_mocked_devices(devices, num_local_chips * cores_per_chip)\n    return devices"
  },
  {
    "test_code": "def test_create_contiguous_submeshes_errors(self):\n    v4 = mesh_utils._TPU_V4\n    topology = (4, 4, 8)\n    mesh_shape = (1, 16, 8)\n    devices = mock_tpu_devices(topology[0], topology[1], topology[2], v4, one_device_per_chip=True)\n    with self.assertRaisesWithLiteralMatch(ValueError, 'create_device_mesh cannot create contiguous submeshes for physical mesh topology (4, 4, 8)'):\n        mesh_utils.create_device_mesh(mesh_shape, devices=devices, contiguous_submeshes=True)\n    topology = (4, 8, 8)\n    mesh_shape = (1, 128, 2)\n    devices = mock_tpu_devices(topology[0], topology[1], topology[2], v4, one_device_per_chip=True)\n    with self.assertRaisesWithLiteralMatch(ValueError, 'create_device_mesh cannot create contiguous submeshes for mesh_shape (1, 128, 2) and physical mesh topology (4, 8, 8). Available mesh_shapes: [(64, 4), (4, 64)]'):\n        mesh_utils.create_device_mesh(mesh_shape, devices=devices, contiguous_submeshes=True)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/mesh_utils_test.py",
    "function": "def mock_tpu_devices(x, y, z, dev_kind, one_device_per_chip, num_slices=1, reorder=False):\n    \"\"\"Produce fake jax.devices() output for a TPU slice.\"\"\"\n    assert x > 0 and y > 0 and (z > 0)\n    cores_per_chip = 1 if one_device_per_chip else 2\n    nxd, nyd, nzd = (min(x, 2), min(y, 2), 1)\n    nxp, nyp, nzp = (x // nxd, y // nyd, z // nzd)\n    assert nxp * nxd == x\n    assert nyp * nyd == y\n    assert nzp * nzd == z\n\n    def mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index):\n        process_index = xp + nxp * (yp + nyp * (zp + nzp * slice_index))\n        coords = (xd + nxd * xp, yd + nyd * yp, zd + nzd * zp)\n        device_id = core_on_chip + cores_per_chip * (xd + nxd * (xp + nxp * (yd + nyd * (yp + nyp * (zd + nzd * (zp + nzp * slice_index))))))\n        return MockTpuDevice(device_id, 'tpu', dev_kind, process_index, coords, core_on_chip, slice_index)\n    devices = [mock_tpu_device(core_on_chip, xd, yd, zd, xp, yp, zp, slice_index) for slice_index in range(num_slices) for zp in range(nzp) for yp in range(nyp) for xp in range(nxp) for zd in range(nzd) for yd in range(nyd) for xd in range(nxd) for core_on_chip in range(cores_per_chip)]\n    if reorder:\n        devices = devices[::-1]\n    num_local_chips = nxd * nyd\n    if num_local_chips < 4:\n        num_all_chips = x * y * z\n        assert num_all_chips == num_local_chips, f'Bad shape: x={x!r}, y={y!r}, z={z!r}'\n        assert z == 1\n        _validate_mocked_devices_for_subhost_slice(devices, x, y, cores_per_chip)\n    else:\n        _validate_mocked_devices(devices, num_local_chips * cores_per_chip)\n    return devices"
  }
]