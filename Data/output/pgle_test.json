[
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.custom_jvp\ndef h(x):\n    return x"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def h():\n\n    def _make_zeros():\n        return jnp.zeros(())\n    s = jax.sharding.NamedSharding(mesh2, P())\n    y = jax.jit(_make_zeros, out_shardings=s)()\n    return y.reshape((1,))"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\n@functools.partial(jax.vmap, in_axes=(1, None), out_axes=1)\ndef h(x, y):\n    return jax.pure_callback(lambda x, y: np.sin(x) + y, x, x, y, vmap_method='legacy_vectorized')"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname', akwarg='hello')\ndef h(x):\n    return x + 2"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@compute_on('gpu_stream:2')\n@jax.jit\ndef h(x, y):\n    return x @ y"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfile(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options={'xla_gpu_enable_latency_hiding_scheduler': 'True'})\n    def f(x, y):\n        return x @ y\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    y = x + 1\n    with config.pgle_profiling_runs(0):\n        f_lowered = f.lower(x, y)\n        compiled = f_lowered.compile()\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            compiled(x, y)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertIsNotNone(fdo_profile)\n    self.assertIn(b'custom', fdo_profile)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testAutoPgleWithAot(self):\n\n    @jax.jit\n    def f(x):\n        return x * 2\n    x = jnp.arange(1)\n    expected = x * 2\n    f_lowered = f.lower(x)\n    serialized, in_tree, out_tree = serialize(f_lowered.compile())\n    compiled = deserialize_and_load(serialized, in_tree, out_tree)\n    with config.pgle_profiling_runs(1), config.enable_pgle(True):\n        with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n            self.assertArraysEqual(compiled(x), expected)\n        self.assertEqual(cache_miss_count(), 0)\n        with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n            self.assertArraysEqual(compiled(x), expected)\n        self.assertEqual(cache_miss_count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testPassingFDOProfile(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options={'xla_gpu_enable_latency_hiding_scheduler': 'True'})\n    def f(x, y):\n        return x @ y\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    y = x + 1\n    with config.pgle_profiling_runs(0):\n        f_lowered = f.lower(x, y)\n        compiled = f_lowered.compile()\n    with tempfile.TemporaryDirectory() as cache_dir:\n        jax.profiler.start_trace(cache_dir)\n        compiled(x, y)\n        jax.profiler.stop_trace()\n        directories = glob.glob(os.path.join(cache_dir, 'plugins/profile/**/'))\n        directories = [d for d in directories if os.path.isdir(d)]\n        rundir = directories[-1]\n        logging.info('rundir: %s', rundir)\n        fdo_profile = exp_profiler.get_profiled_instructions_proto(rundir)\n    if jtu.test_device_matches(['gpu']) and jtu.is_device_cuda():\n        self.assertIn(b'custom', fdo_profile)\n    logging.info('fdo_profile: %s', fdo_profile)\n    f_lowered.compile(compiler_options={'fdo_profile': fdo_profile})",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfile(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options={'xla_gpu_enable_latency_hiding_scheduler': 'True'})\n    def f(x, y):\n        return x @ y\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    y = x + 1\n    with config.pgle_profiling_runs(0):\n        f_lowered = f.lower(x, y)\n        compiled = f_lowered.compile()\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            compiled(x, y)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertIsNotNone(fdo_profile)\n    self.assertIn(b'custom', fdo_profile)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def trace(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).trace(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def trace(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).trace(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jit\ndef g(z):\n    return self.pmap(lambda x: x[jnp.newaxis] * y)(z)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@partial(map_fun, in_axes=1, out_axes=2)\ndef h(y):\n    return jnp.sin(x + y)"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef g(y):\n    return y"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@jax.jit\ndef h(x):\n    with use_auto_axes('x'):\n        return reshard(x, P('y', None))"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def g(weights, x, h_0, c_0):\n    W_ih, W_hh, b_ih, b_hh = rnn.unpack_lstm_weights(weights, input_size, hidden_size, num_layers, bidirectional)\n    y_ref, h_n_ref, c_n_ref = rnn.lstm_ref(x, h_0, c_0, W_ih, W_hh, b_ih, b_hh, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)\n    seq_length_mask = jnp.tile(jnp.arange(seq_len, dtype=jnp.int32)[None], [batch_size, 1]) < seq_lengths[:, None]\n    loss = jnp.sum(jnp.where(seq_length_mask[..., None], y_ref, 0.0))\n    return (loss, (y_ref, h_n_ref, c_n_ref))"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def testPGLEProfilerGetFDOProfileLarge(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    its = 500\n    compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True'}\n    compiler_options['xla_gpu_enable_command_buffer'] = ''\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    pgle_profiler = profiler.PGLEProfiler(1, 90)\n    with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n            f(x)\n    fdo_profile = pgle_profiler.consume_fdo_profile()\n    self.assertEqual(fdo_profile.count(b'custom'), its)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def testAutoPgle(self):\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compile_options)\n        def f(x):\n            return x * 2\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_before_pgle, 2)\n            self.assertEqual(os.path.getsize(os.path.join(dump_dir, fdo_profiles_before_pgle[0])), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertEqual(cache_miss_count(), 2)\n            fdo_profiles_after_pgle = self.get_fdo_profiles(dump_dir)\n            self.assertLen(fdo_profiles_after_pgle, 4)\n            for fdo_profile in fdo_profiles_after_pgle:\n                if fdo_profile not in fdo_profiles_before_pgle:\n                    self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                self.assertArraysEqual(f(x), expected)\n            self.assertLess(cache_miss_count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def testAutoPgleWithPersistentCache(self):\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n    with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {'xla_gpu_enable_latency_hiding_scheduler': 'True', 'xla_dump_to': dump_dir, 'xla_gpu_experimental_dump_fdo_profiles': 'True'}\n\n        @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\n        def f(x):\n            agg = x\n            for _ in range(its):\n                agg = agg @ x\n            return agg\n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(2), tempfile.TemporaryDirectory() as cache_dir:\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_profiled_files = os.listdir(cache_dir)\n            self.assertNotEmpty(non_pgle_profiled_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_before_pgle = self.get_fdo_profiles(dump_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            fdo_profiles_after_pgle = [x for x in self.get_fdo_profiles(dump_dir) if x not in fdo_profiles_before_pgle]\n            self.assertNotEmpty(fdo_profiles_after_pgle)\n            for fdo_profile in fdo_profiles_after_pgle:\n                self.assertGreater(os.path.getsize(os.path.join(dump_dir, fdo_profile)), 0)\n            for pgle_profiler in pjit._pgle_profiler_dict.values():\n                self.assertTrue(pgle_profiler.is_enabled())\n                self.assertTrue(pgle_profiler.is_fdo_consumed())\n            files_after_pgle_profile = os.listdir(cache_dir)\n            self.assertGreater(len(files_after_pgle_profile), len(non_pgle_profiled_files))\n            for non_pgle_file in non_pgle_profiled_files:\n                path = os.path.join(cache_dir, non_pgle_file)\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    shutil.rmtree(path)\n            api.clear_caches()\n            pjit._pgle_profiler_dict.clear()\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def testPersistentCachePopulatedWithAutoPgle(self):\n    self.skipTest('Test does not cleanly reset the compilation cache')\n    its = 50\n    mesh = jtu.create_mesh((2,), ('x',))\n\n    @partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')))\n    def f(x):\n        agg = x\n        for _ in range(its):\n            agg = agg @ x\n        return agg\n\n    @jax.jit\n    def g(x):\n        return x + 4\n\n    @jax.jit\n    def h(x):\n        return x * 42\n    shape = (16, 16)\n    x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    with tempfile.TemporaryDirectory() as cache_dir:\n        with config.enable_compilation_cache(True), config.enable_pgle(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.pgle_profiling_runs(1):\n            cc.reset_cache()\n            cc.set_cache_dir(cache_dir)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEmpty(non_pgle_f_files)\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                f(x)\n            self.assertGreater(cache_miss_count(), 0)\n            pgle_and_non_pgle_f_files = set(os.listdir(cache_dir))\n            self.assertNotEqual(non_pgle_f_files, pgle_and_non_pgle_f_files)\n            for non_pgle_file in non_pgle_f_files:\n                os.remove(os.path.join(cache_dir, non_pgle_file))\n            with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                g(x)\n            self.assertGreater(cache_miss_count(), 0)\n        api.clear_caches()\n        pjit._pgle_profiler_dict.clear()\n        with config.enable_compilation_cache(True), config.raise_persistent_cache_errors(True), config.persistent_cache_min_entry_size_bytes(0), config.persistent_cache_min_compile_time_secs(0), config.compilation_cache_expect_pgle(True):\n            cache_hit = 0\n\n            def check_if_cache_hit(event):\n                nonlocal cache_hit\n                if event == '/jax/compilation_cache/cache_hits':\n                    cache_hit += 1\n            monitoring.register_event_listener(check_if_cache_hit)\n            f(x)\n            monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n            self.assertGreater(cache_hit, 0)\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                cache_hit = 0\n                monitoring.register_event_listener(check_if_cache_hit)\n                g(x)\n                monitoring._unregister_event_listener_by_callback(check_if_cache_hit)\n                self.assertEqual(cache_hit, 1)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE MISS for PGLE-optimized jit_g despite non-PGLE hit', str(w[0].message))\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n                    h(x)\n                self.assertGreater(cache_miss_count(), 0)\n                if len(w) != 1:\n                    print('Warnings:', [str(w_) for w_ in w], flush=True)\n                self.assertLen(w, 1)\n                self.assertIn('PERSISTENT CACHE WRITE with key jit_h-', str(w[0].message))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/pgle_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  }
]