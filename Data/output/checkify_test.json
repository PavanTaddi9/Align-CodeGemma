[
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_dynamic_update_slice_oobs(self):\n\n    def raises_oob(fn, x, y, idx, *expected_strs):\n        err, _ = checkify.checkify(jax.jit(fn), errors=checkify.index_checks)(x, y, idx)\n        error_txt = err.get()\n        self.assertIsNotNone(error_txt)\n        self.assertStartsWith(error_txt, 'out-of-bounds indexing')\n        for s in expected_strs:\n            self.assertIn(s, error_txt)\n    x = jnp.ones((2, 3, 7))\n    y = jnp.zeros((1, 1, 1))\n    raises_oob(lax.dynamic_update_slice, x, y, (2, 0, 0), 'index 2')\n    raises_oob(lax.dynamic_update_slice, x, y, (-3, 0, 0), 'index -1')\n    raises_oob(lax.dynamic_update_slice, x, y, (0, 3, 0), 'index 3')\n    raises_oob(lax.dynamic_update_slice, x, y, (0, -5, 0), 'index -2')\n    raises_oob(lax.dynamic_update_slice, x, y, (0, 1, 8), 'index 8')\n    raises_oob(lax.dynamic_update_slice, x, y, (0, 1, -10), 'index -3')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "def test_pmap_one_device(self):\n\n    @jax.pmap\n    def f(x, y):\n        return x / y\n    cf = checkify.checkify(f, errors=checkify.automatic_checks)\n    errs, _ = cf(jnp.ones((1,)), jnp.zeros((1,)))\n    self.assertIsNotNone(errs.get())\n    self.assertIn('division by zero', errs.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_remat(self, jit):\n\n    def fn(x: jax.Array):\n        checkify.check(jnp.all(x > 0), 'x must be positive')\n        return x + 1\n    fn = jax.remat(fn)\n    if jit:\n        fn = jax.jit(fn)\n    fn = checkify.checkify(fn)\n    err, y = fn(jnp.array([1, 2, 3]))\n    self.assertIsNone(err.get())\n    self.assertAllClose(y, jnp.array([2, 3, 4]), check_dtypes=False)\n    err, _ = fn(jnp.array([0, 2, 3]))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef fn(n, x):\n    return lax.broadcast_in_dim(x, (n,), ())"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    return jnp.zeros(n) + x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_cond_basic(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            return jnp.sin(x)\n\n        def false_fun(x):\n            checkify.check(x > -1, 'oh no')\n            return x / 0.0\n        return lax.cond(x > 0, true_fun, false_fun, x)\n    checked_f = checkify.checkify(f, errors=checkify.all_checks)\n    err, _ = checked_f(3.0)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    err, _ = checked_f(-jnp.inf)\n    self.assertStartsWith(err.get(), 'oh no')\n    err, _ = checked_f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(state):\n    it, _, fx, _ = state\n    return (jnp.max(jnp.abs(fx)) > tol) & (it < max_it)"
  },
  {
    "test_code": "def test_cond_different_payloads(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            checkify.check(~x, '{one}', one=x)\n\n        def false_fun(x):\n            checkify.check(x, '{one} and {two}', one=x, two=x)\n        return lax.cond(x, true_fun, false_fun, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(True)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'True')\n    err, _ = checked_f(False)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'False and False')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(state):\n    it, _, fx, _ = state\n    return (jnp.max(jnp.abs(fx)) > tol) & (it < max_it)"
  },
  {
    "test_code": "def test_cond_nd_payloads(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            checkify.check(jnp.all(x > 0), '{one}', one=x)\n\n        def false_fun(x):\n            checkify.check(jnp.all(x < 0), '{one} and {two}', one=x, two=x)\n        return lax.cond(jnp.all(x < 0), true_fun, false_fun, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(jnp.arange(0, 4))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), '[0 1 2 3] and [0 1 2 3]')\n    err, _ = checked_f(jnp.arange(-4, -1))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), '[-4 -3 -2]')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(state):\n    it, _, fx, _ = state\n    return (jnp.max(jnp.abs(fx)) > tol) & (it < max_it)"
  },
  {
    "test_code": "def test_assert_discharging_cond(self):\n\n    def true_branch(x):\n        checkify.check(jnp.all(x != 0.0), 'x cannot be 0')\n        return 1 / x\n\n    def false_branch(x):\n        checkify.check(jnp.all(x >= 0), 'x must be positive')\n        return x * 2\n\n    @jax.jit\n    def f(pred, x):\n        return lax.cond(pred, true_branch, false_branch, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(True, 0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x cannot be 0')\n    err, _ = checked_f(False, 0.0)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(False, -1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must be positive')\n    err, _ = checked_f(True, -1.0)\n    self.assertIsNone(err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(state):\n    it, _, fx, _ = state\n    return (jnp.max(jnp.abs(fx)) > tol) & (it < max_it)"
  },
  {
    "test_code": "def test_cond_of_named_call(self):\n\n    def g(x):\n        branch = jax.named_call(lambda x: x)\n        out = jax.lax.cond(True, branch, branch, x)\n        return out\n    checkify.checkify(g)(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(state):\n    it, _, fx, _ = state\n    return (jnp.max(jnp.abs(fx)) > tol) & (it < max_it)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(state):\n    it, _, fx, _ = state\n    return (jnp.max(jnp.abs(fx)) > tol) & (it < max_it)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g():\n    return jax.lax.cond(True, lambda: data[0], lambda: data[1])"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_remat(self, jit):\n\n    def fn(x: jax.Array):\n        checkify.check(jnp.all(x > 0), 'x must be positive')\n        return x + 1\n    fn = jax.remat(fn)\n    if jit:\n        fn = jax.jit(fn)\n    fn = checkify.checkify(fn)\n    err, y = fn(jnp.array([1, 2, 3]))\n    self.assertIsNone(err.get())\n    self.assertAllClose(y, jnp.array([2, 3, 4]), check_dtypes=False)\n    err, _ = fn(jnp.array([0, 2, 3]))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\ndef fn(a, b):\n    m1, v1 = a\n    m2, v2 = b\n    return (m1 + m2, jsp.linalg.solve(m1, v2) + jsp.linalg.solve(m2, v1))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def scan(y):\n\n    def body(carry, x):\n        return (carry, jnp.dot(x, x))\n    return jax.lax.scan(body, 1.0, y, unroll=False)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def scan(y):\n\n    def body(carry, x):\n        return (carry, jnp.dot(x, x))\n    return jax.lax.scan(body, 1.0, y, unroll=False)"
  },
  {
    "test_code": "def test_scan_consts(self):\n\n    def f(xs):\n\n        def scan_body(carry, _):\n            return (carry + 1, xs[carry])\n        return lax.scan(scan_body, 1, xs)\n    checked_f = checkify.checkify(f, errors=checkify.index_checks)\n    err, _ = checked_f(jnp.ones((7,)))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'out-of-bounds indexing')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def scan(y):\n\n    def body(carry, x):\n        return (carry, jnp.dot(x, x))\n    return jax.lax.scan(body, 1.0, y, unroll=False)"
  },
  {
    "test_code": "def test_scan_consts2(self):\n\n    def f(xs):\n\n        def scan_body(carry, _):\n            _ = (xs[carry], xs[carry], jnp.sin(np.arange(11.0)))\n            return (carry + 1, xs[carry])\n        return lax.scan(scan_body, 1, xs)[1]\n    checked_f = checkify.checkify(f, errors=checkify.index_checks)\n    err, _ = checked_f(jnp.ones((7, 3)))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'out-of-bounds indexing')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def scan(y):\n\n    def body(carry, x):\n        return (carry, jnp.dot(x, x))\n    return jax.lax.scan(body, 1.0, y, unroll=False)"
  },
  {
    "test_code": "def test_scan_xs_mapped_correctly(self):\n\n    def f(_, x):\n        return (None, jnp.reshape(x, (2, 2)))\n\n    @jax.jit\n    def g(x):\n        return jax.lax.scan(f, None, x)\n    checked_f = checkify.checkify(g)\n    checked_f = jax.jit(checked_f)\n    err, _ = checked_f(jnp.ones((2, 4)))\n    self.assertIsNone(err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def scan(y):\n\n    def body(carry, x):\n        return (carry, jnp.dot(x, x))\n    return jax.lax.scan(body, 1.0, y, unroll=False)"
  },
  {
    "test_code": "def test_assert_discharging_scan(self):\n\n    def body(carry, x):\n        checkify.check(jnp.all(x > 0), 'must be positive')\n        return (carry, x)\n\n    def f(x):\n        return jax.lax.scan(body, (None,), x)\n    err, _ = checkify.checkify(f)(jnp.array([-1]))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    err, _ = checkify.checkify(f)(jnp.array([1, 0, -1]))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def scan(y):\n\n    def body(carry, x):\n        return (carry, jnp.dot(x, x))\n    return jax.lax.scan(body, 1.0, y, unroll=False)"
  },
  {
    "test_code": "def test_check_error_scanned(self):\n\n    def body(carry, x):\n        checkify.check(jnp.all(x > 0), 'should be positive')\n        return (carry, x)\n\n    def checked_body(carry, x):\n        err, (carry, x) = checkify.checkify(body)(carry, x)\n        return (carry, (x, err))\n\n    def f(x):\n        _, (xs, errs) = jax.lax.scan(checked_body, (None,), x)\n        checkify.check_error(errs)\n        return xs\n    err, _ = checkify.checkify(f)(jnp.array([-1]))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'should be positive')\n    err, _ = checkify.checkify(f)(jnp.array([1, 0, -1]))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'should be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def scan(y):\n\n    def body(carry, x):\n        return (carry, jnp.dot(x, x))\n    return jax.lax.scan(body, 1.0, y, unroll=False)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(a, b):\n    c = jnp.zeros_like(a)\n    _, b, c, _ = for_impl(5, body2, (a, b, c, 0))\n    return (b, c)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    _, _, attr_tangents = attrs.jvp(f, (), (), [(thing, 'x', 1.0)])\n    (thing_, attr_, tangent_), = attr_tangents\n    self.assertIs(thing, thing_)\n    self.assertEqual(attr_, 'x')\n    return (jax_getattr(thing, 'x'), tangent_)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@pjit\ndef g(y):\n    return jnp.sin(y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_cond_basic(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            return jnp.sin(x)\n\n        def false_fun(x):\n            checkify.check(x > -1, 'oh no')\n            return x / 0.0\n        return lax.cond(x > 0, true_fun, false_fun, x)\n    checked_f = checkify.checkify(f, errors=checkify.all_checks)\n    err, _ = checked_f(3.0)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    err, _ = checked_f(-jnp.inf)\n    self.assertStartsWith(err.get(), 'oh no')\n    err, _ = checked_f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.named_scope('bar_cond')\ndef cond(x):\n    return x < 5.0"
  },
  {
    "test_code": "def test_cond_different_payloads(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            checkify.check(~x, '{one}', one=x)\n\n        def false_fun(x):\n            checkify.check(x, '{one} and {two}', one=x, two=x)\n        return lax.cond(x, true_fun, false_fun, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(True)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'True')\n    err, _ = checked_f(False)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'False and False')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.named_scope('bar_cond')\ndef cond(x):\n    return x < 5.0"
  },
  {
    "test_code": "def test_cond_nd_payloads(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            checkify.check(jnp.all(x > 0), '{one}', one=x)\n\n        def false_fun(x):\n            checkify.check(jnp.all(x < 0), '{one} and {two}', one=x, two=x)\n        return lax.cond(jnp.all(x < 0), true_fun, false_fun, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(jnp.arange(0, 4))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), '[0 1 2 3] and [0 1 2 3]')\n    err, _ = checked_f(jnp.arange(-4, -1))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), '[-4 -3 -2]')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.named_scope('bar_cond')\ndef cond(x):\n    return x < 5.0"
  },
  {
    "test_code": "def test_assert_discharging_cond(self):\n\n    def true_branch(x):\n        checkify.check(jnp.all(x != 0.0), 'x cannot be 0')\n        return 1 / x\n\n    def false_branch(x):\n        checkify.check(jnp.all(x >= 0), 'x must be positive')\n        return x * 2\n\n    @jax.jit\n    def f(pred, x):\n        return lax.cond(pred, true_branch, false_branch, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(True, 0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x cannot be 0')\n    err, _ = checked_f(False, 0.0)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(False, -1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must be positive')\n    err, _ = checked_f(True, -1.0)\n    self.assertIsNone(err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.named_scope('bar_cond')\ndef cond(x):\n    return x < 5.0"
  },
  {
    "test_code": "def test_cond_of_named_call(self):\n\n    def g(x):\n        branch = jax.named_call(lambda x: x)\n        out = jax.lax.cond(True, branch, branch, x)\n        return out\n    checkify.checkify(g)(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.named_scope('bar_cond')\ndef cond(x):\n    return x < 5.0"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.named_scope('bar_cond')\ndef cond(x):\n    return x < 5.0"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.remat\ndef g(x):\n    jax.jit(lambda: 0 if jnp.add(1, 1) else 0)()\n    return lax.sin(x)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_remat(self, jit):\n\n    def fn(x: jax.Array):\n        checkify.check(jnp.all(x > 0), 'x must be positive')\n        return x + 1\n    fn = jax.remat(fn)\n    if jit:\n        fn = jax.jit(fn)\n    fn = checkify.checkify(fn)\n    err, y = fn(jnp.array([1, 2, 3]))\n    self.assertIsNone(err.get())\n    self.assertAllClose(y, jnp.array([2, 3, 4]), check_dtypes=False)\n    err, _ = fn(jnp.array([0, 2, 3]))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@custom_transpose_with_example_out(jnp.ones(2))\ndef fn(r, x):\n    tracer_spy.append(r)\n    tracer_spy.append(x['c'])\n    return dict(b=x['c'] / r)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.pmap\ndef g(z):\n    return f(z, z + 77)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    z = x * 2\n    return shard_alike(x, z)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_cond_basic(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            return jnp.sin(x)\n\n        def false_fun(x):\n            checkify.check(x > -1, 'oh no')\n            return x / 0.0\n        return lax.cond(x > 0, true_fun, false_fun, x)\n    checked_f = checkify.checkify(f, errors=checkify.all_checks)\n    err, _ = checked_f(3.0)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    err, _ = checked_f(-jnp.inf)\n    self.assertStartsWith(err.get(), 'oh no')\n    err, _ = checked_f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(x):\n    return jnp.linalg.norm(matvec(x) - b) > tolerance"
  },
  {
    "test_code": "def test_cond_different_payloads(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            checkify.check(~x, '{one}', one=x)\n\n        def false_fun(x):\n            checkify.check(x, '{one} and {two}', one=x, two=x)\n        return lax.cond(x, true_fun, false_fun, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(True)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'True')\n    err, _ = checked_f(False)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'False and False')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(x):\n    return jnp.linalg.norm(matvec(x) - b) > tolerance"
  },
  {
    "test_code": "def test_cond_nd_payloads(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            checkify.check(jnp.all(x > 0), '{one}', one=x)\n\n        def false_fun(x):\n            checkify.check(jnp.all(x < 0), '{one} and {two}', one=x, two=x)\n        return lax.cond(jnp.all(x < 0), true_fun, false_fun, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(jnp.arange(0, 4))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), '[0 1 2 3] and [0 1 2 3]')\n    err, _ = checked_f(jnp.arange(-4, -1))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), '[-4 -3 -2]')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(x):\n    return jnp.linalg.norm(matvec(x) - b) > tolerance"
  },
  {
    "test_code": "def test_assert_discharging_cond(self):\n\n    def true_branch(x):\n        checkify.check(jnp.all(x != 0.0), 'x cannot be 0')\n        return 1 / x\n\n    def false_branch(x):\n        checkify.check(jnp.all(x >= 0), 'x must be positive')\n        return x * 2\n\n    @jax.jit\n    def f(pred, x):\n        return lax.cond(pred, true_branch, false_branch, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(True, 0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x cannot be 0')\n    err, _ = checked_f(False, 0.0)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(False, -1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must be positive')\n    err, _ = checked_f(True, -1.0)\n    self.assertIsNone(err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(x):\n    return jnp.linalg.norm(matvec(x) - b) > tolerance"
  },
  {
    "test_code": "def test_cond_of_named_call(self):\n\n    def g(x):\n        branch = jax.named_call(lambda x: x)\n        out = jax.lax.cond(True, branch, branch, x)\n        return out\n    checkify.checkify(g)(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(x):\n    return jnp.linalg.norm(matvec(x) - b) > tolerance"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(x):\n    return jnp.linalg.norm(matvec(x) - b) > tolerance"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef g(x):\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_goodfellow_custom_jvp(self):\n\n    def h(fext):\n        checkify.check(True, '')\n        return jax.nn.relu(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef h(x):\n    return x"
  },
  {
    "test_code": "def test_goodfellow_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n\n    def h(fext):\n        checkify.check(True, '')\n        return sin(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef h(x):\n    return x"
  },
  {
    "test_code": "@parameterized.named_parameters(('get', lambda x: x.get()), ('set', lambda x: x.set(1)), ('add', lambda x: x.add(1)), ('mul', lambda x: x.multiply(1)), ('div', lambda x: x.divide(1)), ('pow', lambda x: x.power(1)), ('min', lambda x: x.min(1)), ('max', lambda x: x.max(1)))\ndef test_jit_oob_update(self, update_fn):\n    f = jax.jit(lambda x, i: update_fn(x.at[i]))\n    checked_f = checkify.checkify(f, errors=checkify.index_checks)\n    err, _ = checked_f(jnp.arange(3), 2)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(jnp.arange(3), 3)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'out-of-bounds indexing')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@staticmethod\ndef add(dt, x, y):\n    fromscale = partial(jax.lax.convert_element_type, new_dtype=dt.float_dtype)\n    toscale = partial(jax.lax.convert_element_type, new_dtype=dt)\n    return toscale(jax.lax.max(fromscale(x), fromscale(y)))"
  },
  {
    "test_code": "@parameterized.named_parameters(('gather', lambda x: x.get()), ('scatter_update', lambda x: x.set(1.0)), ('scatter_add', lambda x: x.add(1.0)), ('scatter_mul', lambda x: x.multiply(1.0)), ('scatter_div', lambda x: x.divide(1.0)), ('scatter_pow', lambda x: x.power(1.0)), ('scatter_min', lambda x: x.min(1.0)), ('scatter_max', lambda x: x.max(1.0)))\ndef test_numpy_indexing_oobs(self, update_op):\n\n    def raises_oob(fn, idx, *expected_strs):\n        err, _ = checkify.checkify(jax.jit(fn), errors=checkify.index_checks)(x, idx)\n        error_txt = err.get()\n        self.assertIsNotNone(error_txt)\n        self.assertStartsWith(error_txt, 'out-of-bounds indexing')\n        for s in expected_strs:\n            self.assertIn(s, error_txt)\n    x = jnp.ones((2, 3, 7))\n    axis0_msg = 'axis 0 with size 2'\n    axis1_msg = 'axis 1 with size 3'\n    axis2_msg = 'axis 2 with size 7'\n    single_idx = lambda x, i: update_op(x.at[i])\n    raises_oob(single_idx, 5, 'index 5', axis0_msg)\n    raises_oob(single_idx, -5, 'index -3', axis0_msg)\n    raises_oob(single_idx, (0, 100), 'index 100', axis1_msg)\n    raises_oob(single_idx, (0, 5, 100), 'index 5', axis1_msg)\n    raises_oob(single_idx, (0, 0, 100), 'index 100', axis2_msg)\n    raises_oob(single_idx, ((1, 20), (1, 4)), 'index 20', axis0_msg)\n    raises_oob(single_idx, ((1, 20), (3, 4)), 'index 3', axis1_msg)\n    raises_oob(single_idx, (((1, 1), (1, 20)), 3), 'index 3', axis1_msg)\n    raises_oob(single_idx, (((1, 1), (1, 20)), 0), 'index 20', axis0_msg)\n    multi_idx = lambda x, i: update_op(x.at[i[0], :, i[1]])\n    raises_oob(multi_idx, (0, 9), 'index 9', axis2_msg)\n    raises_oob(multi_idx, (-5, 9), 'index -3', axis0_msg)\n    raises_oob(multi_idx, (5, -9), 'index 5', axis0_msg)\n    raises_oob(multi_idx, ((0, 9), 0), 'index 9', axis0_msg)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@staticmethod\ndef add(dt, x, y):\n    fromscale = partial(jax.lax.convert_element_type, new_dtype=dt.float_dtype)\n    toscale = partial(jax.lax.convert_element_type, new_dtype=dt)\n    return toscale(jax.lax.max(fromscale(x), fromscale(y)))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    if x > 0.0:\n        return x * 2\n    else:\n        return x + 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('x', 'y'), out_specs=out_spec)\ndef g(x):\n    result = lax.psum(x, axis_name=reduce_along)\n\n    def check_rep(result):\n        self.assertEqual(jax.experimental.shard_map.get_replication(result), set(reduce_along))\n        return result\n    result = check_rep(result)\n    result = jax.vmap(check_rep)(result)\n    return result"
  },
  {
    "test_code": "def test_goodfellow_custom_jvp(self):\n\n    def h(fext):\n        checkify.check(True, '')\n        return jax.nn.relu(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def h():\n\n    def _make_zeros():\n        return jnp.zeros(())\n    s = jax.sharding.NamedSharding(mesh2, P())\n    y = jax.jit(_make_zeros, out_shardings=s)()\n    return y.reshape((1,))"
  },
  {
    "test_code": "def test_goodfellow_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n\n    def h(fext):\n        checkify.check(True, '')\n        return sin(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def h():\n\n    def _make_zeros():\n        return jnp.zeros(())\n    s = jax.sharding.NamedSharding(mesh2, P())\n    y = jax.jit(_make_zeros, out_shardings=s)()\n    return y.reshape((1,))"
  },
  {
    "test_code": "@parameterized.named_parameters(('get', lambda x: x.get()), ('set', lambda x: x.set(1)), ('add', lambda x: x.add(1)), ('mul', lambda x: x.multiply(1)), ('div', lambda x: x.divide(1)), ('pow', lambda x: x.power(1)), ('min', lambda x: x.min(1)), ('max', lambda x: x.max(1)))\ndef test_jit_oob_update(self, update_fn):\n    f = jax.jit(lambda x, i: update_fn(x.at[i]))\n    checked_f = checkify.checkify(f, errors=checkify.index_checks)\n    err, _ = checked_f(jnp.arange(3), 2)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(jnp.arange(3), 3)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'out-of-bounds indexing')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef update_fn(params, batch):\n\n    def grad_fn(batch):\n        return jax.value_and_grad(loss_fn)(params, batch)\n    return shard_map(jax.vmap(grad_fn), mesh=mesh, in_specs=P('data'), out_specs=P('data'), check_rep=False)(batch)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(x):\n    return jax.pure_callback(lambda x: x, x, x)"
  },
  {
    "test_code": "def test_goodfellow_custom_jvp(self):\n\n    def h(fext):\n        checkify.check(True, '')\n        return jax.nn.relu(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\n@functools.partial(jax.vmap, in_axes=(1, None), out_axes=1)\ndef h(x, y):\n    return jax.pure_callback(lambda x, y: np.sin(x) + y, x, x, y, vmap_method='legacy_vectorized')"
  },
  {
    "test_code": "def test_goodfellow_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n\n    def h(fext):\n        checkify.check(True, '')\n        return sin(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\n@functools.partial(jax.vmap, in_axes=(1, None), out_axes=1)\ndef h(x, y):\n    return jax.pure_callback(lambda x, y: np.sin(x) + y, x, x, y, vmap_method='legacy_vectorized')"
  },
  {
    "test_code": "@jtu.sample_product(jit=[False, True])\n@jtu.skip_on_devices('tpu')\ndef test_jit_nan(self, jit):\n\n    def f(x1, x2):\n        y1 = jnp.sin(x1)\n        y2 = jnp.sin(x2)\n        return y1 + y2\n    f = jax.jit(f) if jit else f\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    err, _ = checked_f(3.0, 4.0)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(3.0, jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.sample_product(jit=[False, True])\ndef test_jit_oob(self, jit):\n\n    def f(x, i):\n        y = jnp.sin(x)\n        z = y[i]\n        w = jnp.cos(z)\n        return w\n    f = jax.jit(f) if jit else f\n    checked_f = checkify.checkify(f, errors=checkify.index_checks)\n    err, _ = checked_f(jnp.arange(3), 2)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(jnp.arange(3), 5)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'out-of-bounds indexing')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.sample_product(jit=[False, True])\ndef test_jit_ordering(self, jit):\n\n    def f(x, i):\n        y = x[i]\n        z = jnp.sin(x)\n        return y * z\n    f = jax.jit(f) if jit else f\n    checked_f = checkify.checkify(f, errors=checkify.automatic_checks)\n    err, _ = checked_f(jnp.array([0.0, 1.0, jnp.inf]), 5)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'out-of-bounds indexing')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_pmap_basic(self):\n    if len(jax.devices()) < 2:\n        raise unittest.SkipTest('requires at least 2 devices')\n\n    @jax.pmap\n    def f(x):\n        y1 = jnp.sin(1.0 / x)\n        y2 = jnp.sin(x)\n        return y1 + y2\n    checked_f = checkify.checkify(f, errors=checkify.nan_checks)\n    xs = jnp.array([1.0, 2.0])\n    err, _ = checked_f(xs)\n    self.assertIsNone(err.get())\n    xs = jnp.array([3.0, 0.0])\n    err, _ = checked_f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_cond_basic(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            return jnp.sin(x)\n\n        def false_fun(x):\n            checkify.check(x > -1, 'oh no')\n            return x / 0.0\n        return lax.cond(x > 0, true_fun, false_fun, x)\n    checked_f = checkify.checkify(f, errors=checkify.all_checks)\n    err, _ = checked_f(3.0)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    err, _ = checked_f(-jnp.inf)\n    self.assertStartsWith(err.get(), 'oh no')\n    err, _ = checked_f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error_and_false(self):\n\n    def while_cond(val):\n        possible_nan = jnp.sin(1.0 / val)\n        return jnp.logical_not(jnp.isnan(possible_nan))\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, lambda val: val - 1, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 0.0\n    err, _ = checked_f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    init_val = 1.0\n    err, _ = checked_f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_and_cond_error(self):\n\n    def while_cond(val):\n        i, cond_val, _ = val\n        _ = jnp.sin(cond_val)\n        return i < 2\n\n    def while_body(val):\n        i, cond_val, body_val = val\n        possible_nan = jnp.cos(body_val)\n        return (i + 1.0, cond_val, possible_nan)\n\n    @jax.jit\n    def f(cond_val, body_val):\n        return lax.while_loop(while_cond, while_body, (0.0, cond_val, body_val))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    cond_val = jnp.inf\n    body_val = 1.0\n    err, _ = checked_f(cond_val, body_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    cond_val = 1.0\n    body_val = jnp.inf\n    err, _ = checked_f(cond_val, body_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: cos')\n    cond_val = jnp.inf\n    body_val = jnp.inf\n    err, _ = checked_f(cond_val, body_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_empty_enabled_errors(self):\n\n    def multi_errors(x):\n        x = x / 0\n        x = jnp.sin(x)\n        x = x[500]\n        checkify.check(x < 0, 'must be negative!')\n        return x\n    x = jnp.ones((2,))\n    err, _ = checkify.checkify(multi_errors, errors=set())(x)\n    self.assertIsNone(err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@parameterized.named_parameters(('assert', checkify.user_checks, 'must be negative!'), ('div', checkify.div_checks, 'division by zero'), ('nan', checkify.nan_checks, 'nan generated'), ('oob', checkify.index_checks, 'out-of-bounds indexing'), ('automatic_checks', checkify.automatic_checks, 'division by zero'))\n@jtu.skip_on_devices('tpu')\ndef test_enabled_errors(self, error_set, expected_error):\n\n    def multi_errors(x):\n        checkify.check(jnp.all(x < 0), 'must be negative!')\n        x = x / 0\n        x = jnp.sin(x)\n        x = x[500]\n        return x\n    x = jnp.ones((2,))\n    err, _ = checkify.checkify(multi_errors, errors=error_set)(x)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), expected_error)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_scan_consts2(self):\n\n    def f(xs):\n\n        def scan_body(carry, _):\n            _ = (xs[carry], xs[carry], jnp.sin(np.arange(11.0)))\n            return (carry + 1, xs[carry])\n        return lax.scan(scan_body, 1, xs)[1]\n    checked_f = checkify.checkify(f, errors=checkify.index_checks)\n    err, _ = checked_f(jnp.ones((7, 3)))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'out-of-bounds indexing')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_while_consts(self):\n\n    def f(xs):\n\n        def while_cond(carry):\n            i, _ = carry\n            _ = (xs[i], jnp.sin(np.arange(11.0)))\n            return i > -1\n\n        def while_body(carry):\n            i, _ = carry\n            x = xs[i]\n            return (i - 1, x / i)\n        return lax.while_loop(while_cond, while_body, (0, jnp.zeros_like(xs[0])))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    err, _ = checked_f(jnp.ones((7, 3)))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_goodfellow_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n\n    def h(fext):\n        checkify.check(True, '')\n        return sin(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.custom_jvp\ndef sin(x):\n    return jax.pure_callback(np.sin, x, x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_cond_basic(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            return jnp.sin(x)\n\n        def false_fun(x):\n            checkify.check(x > -1, 'oh no')\n            return x / 0.0\n        return lax.cond(x > 0, true_fun, false_fun, x)\n    checked_f = checkify.checkify(f, errors=checkify.all_checks)\n    err, _ = checked_f(3.0)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    err, _ = checked_f(-jnp.inf)\n    self.assertStartsWith(err.get(), 'oh no')\n    err, _ = checked_f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(x):\n    return jax.pure_callback(_cond_callback, jax.ShapeDtypeStruct((), np.bool_), x)"
  },
  {
    "test_code": "def test_cond_different_payloads(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            checkify.check(~x, '{one}', one=x)\n\n        def false_fun(x):\n            checkify.check(x, '{one} and {two}', one=x, two=x)\n        return lax.cond(x, true_fun, false_fun, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(True)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'True')\n    err, _ = checked_f(False)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'False and False')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(x):\n    return jax.pure_callback(_cond_callback, jax.ShapeDtypeStruct((), np.bool_), x)"
  },
  {
    "test_code": "def test_cond_nd_payloads(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            checkify.check(jnp.all(x > 0), '{one}', one=x)\n\n        def false_fun(x):\n            checkify.check(jnp.all(x < 0), '{one} and {two}', one=x, two=x)\n        return lax.cond(jnp.all(x < 0), true_fun, false_fun, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(jnp.arange(0, 4))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), '[0 1 2 3] and [0 1 2 3]')\n    err, _ = checked_f(jnp.arange(-4, -1))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), '[-4 -3 -2]')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(x):\n    return jax.pure_callback(_cond_callback, jax.ShapeDtypeStruct((), np.bool_), x)"
  },
  {
    "test_code": "def test_assert_discharging_cond(self):\n\n    def true_branch(x):\n        checkify.check(jnp.all(x != 0.0), 'x cannot be 0')\n        return 1 / x\n\n    def false_branch(x):\n        checkify.check(jnp.all(x >= 0), 'x must be positive')\n        return x * 2\n\n    @jax.jit\n    def f(pred, x):\n        return lax.cond(pred, true_branch, false_branch, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(True, 0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x cannot be 0')\n    err, _ = checked_f(False, 0.0)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(False, -1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must be positive')\n    err, _ = checked_f(True, -1.0)\n    self.assertIsNone(err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(x):\n    return jax.pure_callback(_cond_callback, jax.ShapeDtypeStruct((), np.bool_), x)"
  },
  {
    "test_code": "def test_cond_of_named_call(self):\n\n    def g(x):\n        branch = jax.named_call(lambda x: x)\n        out = jax.lax.cond(True, branch, branch, x)\n        return out\n    checkify.checkify(g)(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(x):\n    return jax.pure_callback(_cond_callback, jax.ShapeDtypeStruct((), np.bool_), x)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(x):\n    return jax.pure_callback(_cond_callback, jax.ShapeDtypeStruct((), np.bool_), x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(a, b):\n    an, ai = a\n    bn, bi = b\n    which = an >= bn\n    return (jnp.where(which, an, bn), jnp.where(which, ai, bi))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname')\ndef g(x):\n    return x + 2"
  },
  {
    "test_code": "def test_goodfellow_custom_jvp(self):\n\n    def h(fext):\n        checkify.check(True, '')\n        return jax.nn.relu(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname', akwarg='hello')\ndef h(x):\n    return x + 2"
  },
  {
    "test_code": "def test_goodfellow_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n\n    def h(fext):\n        checkify.check(True, '')\n        return sin(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.profiler.annotate_function, name='aname', akwarg='hello')\ndef h(x):\n    return x + 2"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_remat(self, jit):\n\n    def fn(x: jax.Array):\n        checkify.check(jnp.all(x > 0), 'x must be positive')\n        return x + 1\n    fn = jax.remat(fn)\n    if jit:\n        fn = jax.jit(fn)\n    fn = checkify.checkify(fn)\n    err, y = fn(jnp.array([1, 2, 3]))\n    self.assertIsNone(err.get())\n    self.assertAllClose(y, jnp.array([2, 3, 4]), check_dtypes=False)\n    err, _ = fn(jnp.array([0, 2, 3]))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def fn(data, segment_ids):\n    return jax.ops.segment_sum(data, segment_ids, num_segments).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, donate_argnums=0, out_shardings=Layout(DLL.AUTO))\ndef g(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g():\n    x = x_ref[...] * y_ref[...]\n    y_ref[...] = x * 2\n    x_ref[...] = y_ref[...] + x_ref[...]"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_cond_basic(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            return jnp.sin(x)\n\n        def false_fun(x):\n            checkify.check(x > -1, 'oh no')\n            return x / 0.0\n        return lax.cond(x > 0, true_fun, false_fun, x)\n    checked_f = checkify.checkify(f, errors=checkify.all_checks)\n    err, _ = checked_f(3.0)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    err, _ = checked_f(-jnp.inf)\n    self.assertStartsWith(err.get(), 'oh no')\n    err, _ = checked_f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(state):\n    idx, x, _ = state\n    chunk = jax.lax.dynamic_slice_in_dim(x, idx * chunk_size, chunk_size)\n    return (idx * chunk_size < x.shape[0]) & jnp.any(chunk > 0)"
  },
  {
    "test_code": "def test_cond_different_payloads(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            checkify.check(~x, '{one}', one=x)\n\n        def false_fun(x):\n            checkify.check(x, '{one} and {two}', one=x, two=x)\n        return lax.cond(x, true_fun, false_fun, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(True)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'True')\n    err, _ = checked_f(False)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'False and False')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(state):\n    idx, x, _ = state\n    chunk = jax.lax.dynamic_slice_in_dim(x, idx * chunk_size, chunk_size)\n    return (idx * chunk_size < x.shape[0]) & jnp.any(chunk > 0)"
  },
  {
    "test_code": "def test_cond_nd_payloads(self):\n\n    @jax.jit\n    def f(x):\n\n        def true_fun(x):\n            checkify.check(jnp.all(x > 0), '{one}', one=x)\n\n        def false_fun(x):\n            checkify.check(jnp.all(x < 0), '{one} and {two}', one=x, two=x)\n        return lax.cond(jnp.all(x < 0), true_fun, false_fun, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(jnp.arange(0, 4))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), '[0 1 2 3] and [0 1 2 3]')\n    err, _ = checked_f(jnp.arange(-4, -1))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), '[-4 -3 -2]')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(state):\n    idx, x, _ = state\n    chunk = jax.lax.dynamic_slice_in_dim(x, idx * chunk_size, chunk_size)\n    return (idx * chunk_size < x.shape[0]) & jnp.any(chunk > 0)"
  },
  {
    "test_code": "def test_assert_discharging_cond(self):\n\n    def true_branch(x):\n        checkify.check(jnp.all(x != 0.0), 'x cannot be 0')\n        return 1 / x\n\n    def false_branch(x):\n        checkify.check(jnp.all(x >= 0), 'x must be positive')\n        return x * 2\n\n    @jax.jit\n    def f(pred, x):\n        return lax.cond(pred, true_branch, false_branch, x)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(True, 0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x cannot be 0')\n    err, _ = checked_f(False, 0.0)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(False, -1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must be positive')\n    err, _ = checked_f(True, -1.0)\n    self.assertIsNone(err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(state):\n    idx, x, _ = state\n    chunk = jax.lax.dynamic_slice_in_dim(x, idx * chunk_size, chunk_size)\n    return (idx * chunk_size < x.shape[0]) & jnp.any(chunk > 0)"
  },
  {
    "test_code": "def test_cond_of_named_call(self):\n\n    def g(x):\n        branch = jax.named_call(lambda x: x)\n        out = jax.lax.cond(True, branch, branch, x)\n        return out\n    checkify.checkify(g)(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(state):\n    idx, x, _ = state\n    chunk = jax.lax.dynamic_slice_in_dim(x, idx * chunk_size, chunk_size)\n    return (idx * chunk_size < x.shape[0]) & jnp.any(chunk > 0)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def cond(state):\n    idx, x, _ = state\n    chunk = jax.lax.dynamic_slice_in_dim(x, idx * chunk_size, chunk_size)\n    return (idx * chunk_size < x.shape[0]) & jnp.any(chunk > 0)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(ys, _):\n    y, _ = ys\n    y = checkpoint_name(jnp.sin(y), 'y')\n    z = checkpoint_name(jnp.sin(y), 'z')\n    z = jax.lax.with_sharding_constraint(z, s)\n    z = z.T\n    w = checkpoint_name(jnp.sin(z), 'w')\n    return ((w.T, jnp.sum(w)), None)"
  },
  {
    "test_code": "def test_goodfellow_custom_jvp(self):\n\n    def h(fext):\n        checkify.check(True, '')\n        return jax.nn.relu(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@compute_on('gpu_stream:2')\n@jax.jit\ndef h(x, y):\n    return x @ y"
  },
  {
    "test_code": "def test_goodfellow_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n\n    def h(fext):\n        checkify.check(True, '')\n        return sin(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@compute_on('gpu_stream:2')\n@jax.jit\ndef h(x, y):\n    return x @ y"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_remat(self, jit):\n\n    def fn(x: jax.Array):\n        checkify.check(jnp.all(x > 0), 'x must be positive')\n        return x + 1\n    fn = jax.remat(fn)\n    if jit:\n        fn = jax.jit(fn)\n    fn = checkify.checkify(fn)\n    err, y = fn(jnp.array([1, 2, 3]))\n    self.assertIsNone(err.get())\n    self.assertAllClose(y, jnp.array([2, 3, 4]), check_dtypes=False)\n    err, _ = fn(jnp.array([0, 2, 3]))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@compute_on('device_host')\ndef fn():\n    k = jax.random.key(0)\n    return jax.nn.initializers.lecun_normal()(k, (2, 2), jnp.float32)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@functools.partial(jax.jit, static_argnums=[1])\ndef g(x, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jit\ndef g(z):\n    return self.pmap(lambda x: x[jnp.newaxis] * y)(z)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jit\ndef g(z):\n    return self.pmap(lambda x: x[jnp.newaxis] * y)(z)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jit\ndef g(z):\n    return self.pmap(lambda x: x[jnp.newaxis] * y)(z)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jit\ndef g(z):\n    return self.pmap(lambda x: x[jnp.newaxis] * y)(z)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jit\ndef g(z):\n    return self.pmap(lambda x: x[jnp.newaxis] * y)(z)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jit\ndef g(z):\n    return self.pmap(lambda x: x[jnp.newaxis] * y)(z)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_remat(self, jit):\n\n    def fn(x: jax.Array):\n        checkify.check(jnp.all(x > 0), 'x must be positive')\n        return x + 1\n    fn = jax.remat(fn)\n    if jit:\n        fn = jax.jit(fn)\n    fn = checkify.checkify(fn)\n    err, y = fn(jnp.array([1, 2, 3]))\n    self.assertIsNone(err.get())\n    self.assertAllClose(y, jnp.array([2, 3, 4]), check_dtypes=False)\n    err, _ = fn(jnp.array([0, 2, 3]))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def fn(indices):\n    return jnp.equal(indices, jnp.arange(3)).astype(jnp.float32)"
  },
  {
    "test_code": "def test_goodfellow_custom_jvp(self):\n\n    def h(fext):\n        checkify.check(True, '')\n        return jax.nn.relu(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(map_fun, in_axes=1, out_axes=2)\ndef h(y):\n    return jnp.sin(x + y)"
  },
  {
    "test_code": "def test_goodfellow_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n\n    def h(fext):\n        checkify.check(True, '')\n        return sin(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(map_fun, in_axes=1, out_axes=2)\ndef h(y):\n    return jnp.sin(x + y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(y):\n    return y"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(y):\n    return y"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(y):\n    return y"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(y):\n    return y"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(y):\n    return y"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(y):\n    return y"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_remat(self, jit):\n\n    def fn(x: jax.Array):\n        checkify.check(jnp.all(x > 0), 'x must be positive')\n        return x + 1\n    fn = jax.remat(fn)\n    if jit:\n        fn = jax.jit(fn)\n    fn = checkify.checkify(fn)\n    err, y = fn(jnp.array([1, 2, 3]))\n    self.assertIsNone(err.get())\n    self.assertAllClose(y, jnp.array([2, 3, 4]), check_dtypes=False)\n    err, _ = fn(jnp.array([0, 2, 3]))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef fn(key):\n    x = jnp.arange(113003)\n    x = with_sharding_constraint(x, P('data'))\n    y = jnp.arange(65536)\n    y = with_sharding_constraint(y.reshape(-1), P('data'))\n    z = jnp.concatenate([x, y], axis=0)\n    z = with_sharding_constraint(z, P('data'))\n    return (x, y, z)"
  },
  {
    "test_code": "def test_goodfellow_custom_jvp(self):\n\n    def h(fext):\n        checkify.check(True, '')\n        return jax.nn.relu(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef h(x):\n    with use_auto_axes('x'):\n        return reshard(x, P('y', None))"
  },
  {
    "test_code": "def test_goodfellow_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n\n    def h(fext):\n        checkify.check(True, '')\n        return sin(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef h(x):\n    with use_auto_axes('x'):\n        return reshard(x, P('y', None))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(weights, x, h_0, c_0):\n    W_ih, W_hh, b_ih, b_hh = rnn.unpack_lstm_weights(weights, input_size, hidden_size, num_layers, bidirectional)\n    y_ref, h_n_ref, c_n_ref = rnn.lstm_ref(x, h_0, c_0, W_ih, W_hh, b_ih, b_hh, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)\n    seq_length_mask = jnp.tile(jnp.arange(seq_len, dtype=jnp.int32)[None], [batch_size, 1]) < seq_lengths[:, None]\n    loss = jnp.sum(jnp.where(seq_length_mask[..., None], y_ref, 0.0))\n    return (loss, (y_ref, h_n_ref, c_n_ref))"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(weights, x, h_0, c_0):\n    W_ih, W_hh, b_ih, b_hh = rnn.unpack_lstm_weights(weights, input_size, hidden_size, num_layers, bidirectional)\n    y_ref, h_n_ref, c_n_ref = rnn.lstm_ref(x, h_0, c_0, W_ih, W_hh, b_ih, b_hh, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)\n    seq_length_mask = jnp.tile(jnp.arange(seq_len, dtype=jnp.int32)[None], [batch_size, 1]) < seq_lengths[:, None]\n    loss = jnp.sum(jnp.where(seq_length_mask[..., None], y_ref, 0.0))\n    return (loss, (y_ref, h_n_ref, c_n_ref))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(weights, x, h_0, c_0):\n    W_ih, W_hh, b_ih, b_hh = rnn.unpack_lstm_weights(weights, input_size, hidden_size, num_layers, bidirectional)\n    y_ref, h_n_ref, c_n_ref = rnn.lstm_ref(x, h_0, c_0, W_ih, W_hh, b_ih, b_hh, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)\n    seq_length_mask = jnp.tile(jnp.arange(seq_len, dtype=jnp.int32)[None], [batch_size, 1]) < seq_lengths[:, None]\n    loss = jnp.sum(jnp.where(seq_length_mask[..., None], y_ref, 0.0))\n    return (loss, (y_ref, h_n_ref, c_n_ref))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(weights, x, h_0, c_0):\n    W_ih, W_hh, b_ih, b_hh = rnn.unpack_lstm_weights(weights, input_size, hidden_size, num_layers, bidirectional)\n    y_ref, h_n_ref, c_n_ref = rnn.lstm_ref(x, h_0, c_0, W_ih, W_hh, b_ih, b_hh, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)\n    seq_length_mask = jnp.tile(jnp.arange(seq_len, dtype=jnp.int32)[None], [batch_size, 1]) < seq_lengths[:, None]\n    loss = jnp.sum(jnp.where(seq_length_mask[..., None], y_ref, 0.0))\n    return (loss, (y_ref, h_n_ref, c_n_ref))"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(weights, x, h_0, c_0):\n    W_ih, W_hh, b_ih, b_hh = rnn.unpack_lstm_weights(weights, input_size, hidden_size, num_layers, bidirectional)\n    y_ref, h_n_ref, c_n_ref = rnn.lstm_ref(x, h_0, c_0, W_ih, W_hh, b_ih, b_hh, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)\n    seq_length_mask = jnp.tile(jnp.arange(seq_len, dtype=jnp.int32)[None], [batch_size, 1]) < seq_lengths[:, None]\n    loss = jnp.sum(jnp.where(seq_length_mask[..., None], y_ref, 0.0))\n    return (loss, (y_ref, h_n_ref, c_n_ref))"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def g(weights, x, h_0, c_0):\n    W_ih, W_hh, b_ih, b_hh = rnn.unpack_lstm_weights(weights, input_size, hidden_size, num_layers, bidirectional)\n    y_ref, h_n_ref, c_n_ref = rnn.lstm_ref(x, h_0, c_0, W_ih, W_hh, b_ih, b_hh, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)\n    seq_length_mask = jnp.tile(jnp.arange(seq_len, dtype=jnp.int32)[None], [batch_size, 1]) < seq_lengths[:, None]\n    loss = jnp.sum(jnp.where(seq_length_mask[..., None], y_ref, 0.0))\n    return (loss, (y_ref, h_n_ref, c_n_ref))"
  },
  {
    "test_code": "@parameterized.named_parameters(('get', lambda x: x.get()), ('set', lambda x: x.set(1)), ('add', lambda x: x.add(1)), ('mul', lambda x: x.multiply(1)), ('div', lambda x: x.divide(1)), ('pow', lambda x: x.power(1)), ('min', lambda x: x.min(1)), ('max', lambda x: x.max(1)))\ndef test_jit_oob_update(self, update_fn):\n    f = jax.jit(lambda x, i: update_fn(x.at[i]))\n    checked_f = checkify.checkify(f, errors=checkify.index_checks)\n    err, _ = checked_f(jnp.arange(3), 2)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(jnp.arange(3), 3)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'out-of-bounds indexing')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def add(self, x: jax.Array) -> jax.Array:\n    self.value += np.asarray(x)\n    return jax.device_put(self.value, x.sharding)"
  },
  {
    "test_code": "@parameterized.named_parameters(('gather', lambda x: x.get()), ('scatter_update', lambda x: x.set(1.0)), ('scatter_add', lambda x: x.add(1.0)), ('scatter_mul', lambda x: x.multiply(1.0)), ('scatter_div', lambda x: x.divide(1.0)), ('scatter_pow', lambda x: x.power(1.0)), ('scatter_min', lambda x: x.min(1.0)), ('scatter_max', lambda x: x.max(1.0)))\ndef test_numpy_indexing_oobs(self, update_op):\n\n    def raises_oob(fn, idx, *expected_strs):\n        err, _ = checkify.checkify(jax.jit(fn), errors=checkify.index_checks)(x, idx)\n        error_txt = err.get()\n        self.assertIsNotNone(error_txt)\n        self.assertStartsWith(error_txt, 'out-of-bounds indexing')\n        for s in expected_strs:\n            self.assertIn(s, error_txt)\n    x = jnp.ones((2, 3, 7))\n    axis0_msg = 'axis 0 with size 2'\n    axis1_msg = 'axis 1 with size 3'\n    axis2_msg = 'axis 2 with size 7'\n    single_idx = lambda x, i: update_op(x.at[i])\n    raises_oob(single_idx, 5, 'index 5', axis0_msg)\n    raises_oob(single_idx, -5, 'index -3', axis0_msg)\n    raises_oob(single_idx, (0, 100), 'index 100', axis1_msg)\n    raises_oob(single_idx, (0, 5, 100), 'index 5', axis1_msg)\n    raises_oob(single_idx, (0, 0, 100), 'index 100', axis2_msg)\n    raises_oob(single_idx, ((1, 20), (1, 4)), 'index 20', axis0_msg)\n    raises_oob(single_idx, ((1, 20), (3, 4)), 'index 3', axis1_msg)\n    raises_oob(single_idx, (((1, 1), (1, 20)), 3), 'index 3', axis1_msg)\n    raises_oob(single_idx, (((1, 1), (1, 20)), 0), 'index 20', axis0_msg)\n    multi_idx = lambda x, i: update_op(x.at[i[0], :, i[1]])\n    raises_oob(multi_idx, (0, 9), 'index 9', axis2_msg)\n    raises_oob(multi_idx, (-5, 9), 'index -3', axis0_msg)\n    raises_oob(multi_idx, (5, -9), 'index 5', axis0_msg)\n    raises_oob(multi_idx, ((0, 9), 0), 'index 9', axis0_msg)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def add(self, x: jax.Array) -> jax.Array:\n    self.value += np.asarray(x)\n    return jax.device_put(self.value, x.sharding)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x + 4"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x + 4"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x + 4"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x + 4"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x + 4"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return x + 4"
  },
  {
    "test_code": "def test_goodfellow_custom_jvp(self):\n\n    def h(fext):\n        checkify.check(True, '')\n        return jax.nn.relu(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef h(x):\n    return x * 42"
  },
  {
    "test_code": "def test_goodfellow_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n\n    def h(fext):\n        checkify.check(True, '')\n        return sin(fext)\n    h = checkify.checkify(h)\n\n    def h_out(fext):\n        _, out = h(fext)\n        return out\n    h_grad = jax.grad(h_out)\n    h_grad(0.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef h(x):\n    return x * 42"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_remat(self, jit):\n\n    def fn(x: jax.Array):\n        checkify.check(jnp.all(x > 0), 'x must be positive')\n        return x + 1\n    fn = jax.remat(fn)\n    if jit:\n        fn = jax.jit(fn)\n    fn = checkify.checkify(fn)\n    err, y = fn(jnp.array([1, 2, 3]))\n    self.assertIsNone(err.get())\n    self.assertAllClose(y, jnp.array([2, 3, 4]), check_dtypes=False)\n    err, _ = fn(jnp.array([0, 2, 3]))\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.vmap\ndef fn(x):\n    R1 = jnp.array([[x[0], 0, 0], [0, x[0], 0], [0, 0, x[0]]])\n    R2 = jnp.array([[x[0], 0, 0], [0, x[1], 0], [0, 0, x[2]]])\n    H = jnp.eye(4)\n    H = H.at[:3, :3].set(R2.T)\n    pos = H @ jnp.concatenate([x, jnp.array([1.0])])\n    return (pos, R1)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_map(self):\n\n    def scan_body(_, x):\n        return (None, jnp.sin(x))\n\n    @jax.jit\n    def f(xs):\n        return lax.scan(scan_body, None, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    xs = jnp.array([0.0, 2.0])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    xs = jnp.array([3.0, jnp.inf])\n    err, (_, ch_outs) = checked_f(xs)\n    _, outs = f(xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    self.assertArraysEqual(ch_outs, outs)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_scan_carry(self):\n\n    def scan_body(carry, x):\n        carry = carry - 1.0\n        possible_nan = jnp.sin(1.0 / carry)\n        return (carry, x + possible_nan)\n\n    @jax.jit\n    def f(carry, xs):\n        return lax.scan(scan_body, carry, xs)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    carry, xs = (3.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (1.0, jnp.ones((2,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)\n    carry, xs = (2.0, jnp.ones((4,)))\n    err, (ch_out_carry, ch_outs) = checked_f(carry, xs)\n    out_carry, outs = f(carry, xs)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_outs, outs)\n    self.assertArraysEqual(ch_out_carry, out_carry)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_body_error(self):\n\n    def while_cond(val):\n        i, _ = val\n        return i < 2\n\n    def while_body(val):\n        i, x = val\n        possible_nan = jnp.sin(1.0 / i)\n        return (i + 1.0, x + possible_nan)\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, (init_val, 0.0))\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_while_loop_cond_error(self):\n\n    def while_cond(val):\n        _ = jnp.sin(1.0 / val)\n        return val < 2.0\n\n    def while_body(val):\n        return val + 1.0\n\n    @jax.jit\n    def f(init_val):\n        return lax.while_loop(while_cond, while_body, init_val)\n    checked_f = checkify.checkify(f, errors=checkify.float_checks)\n    init_val = 1.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNone(err.get())\n    self.assertArraysEqual(ch_out, out)\n    init_val = 0.0\n    err, ch_out = checked_f(init_val)\n    out = f(init_val)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'division by zero')\n    self.assertArraysEqual(ch_out, out)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_vjp(self):\n\n    @jax.custom_vjp\n    def sin(x):\n        return jnp.sin(x)\n\n    def sin_fwd(x):\n        return (jnp.sin(x), 2.0 * x)\n\n    def sin_bwd(x2, g):\n        return (jnp.cos(x2 / 2.0) * g,)\n    sin.defvjp(sin_fwd, sin_bwd)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), f_vjp = jax.vjp(f, 3.0)\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(3.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    err, y = checkify.checkify(jax.grad(sin), errors=checkify.float_checks)(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_retracing(self):\n    f = checkify.checkify(jax.jit(lambda x: jnp.sin(x) ** 2))\n    _ = f(3.0)\n    with jtu.count_jit_and_pmap_lowerings() as count:\n        _ = f(3.0)\n    self.assertEqual(count(), 0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_closed_call(self):\n    y = jnp.array([3.14])\n    summify = lambda f: lambda x: f(x).sum()\n    f = checkify.checkify(jax.grad(summify(jax.remat(partial(partial, jax.lax.map)(lambda x: jnp.sin(x * y))))))\n    f(jnp.array([3.0]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_assert_primitive_impl(self):\n\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_assert_primitive_lowering(self):\n\n    @jax.jit\n    def f():\n        checkify.check(False, 'hi')\n    with self.assertRaisesRegex(ValueError, 'Cannot abstractly evaluate'):\n        f()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_assert_discharging(self):\n\n    @checkify.checkify\n    def f(x):\n        checkify.check(x > 0, 'must be positive!')\n        return jnp.log(x)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')\n    f = jax.jit(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_assert_batching_rule(self):\n\n    @jax.vmap\n    def f(x):\n        checkify.check(jnp.sum(x) == 1.0, 'x must sum to one.')\n        return x\n    no_failures = jnp.array([[0.5, 0.5], [1.0, 0.0]])\n    one_batch_fails = jnp.array([[0.5, 0.5], [1, 1]])\n    mult_batch_fail = jnp.array([[0.5, 0.5], [1, 1], [2, 2]])\n    f(no_failures)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(one_batch_fails)\n    with self.assertRaisesRegex(JaxRuntimeError, 'x must sum to one.'):\n        f(mult_batch_fail)\n    checked_f = checkify.checkify(f)\n    err, _ = checked_f(no_failures)\n    self.assertIsNone(err.get())\n    err, _ = checked_f(one_batch_fails)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')\n    err, _ = checked_f(mult_batch_fail)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'x must sum to one')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_check_error(self):\n\n    def g():\n        checkify.check(False, 'hi')\n\n    def f():\n        err, _ = checkify.checkify(g)()\n        checkify.check_error(err)\n    with self.assertRaisesRegex(JaxRuntimeError, 'hi'):\n        f()\n    f = checkify.checkify(f)\n    err, none = f()\n    self.assertIsNone(none)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_discharge_recharge(self):\n\n    def ejit(f):\n        f = checkify.checkify(f)\n        f = jax.jit(f)\n\n        def jitted_f(*args):\n            err, out = f(*args)\n            checkify.check_error(err)\n            return out\n        return jitted_f\n\n    @ejit\n    def f(pred):\n        assert python_should_be_running\n        checkify.check(pred, 'foo')\n    python_should_be_running = True\n    f(True)\n    python_should_be_running = False\n    f(True)\n    with self.assertRaisesRegex(JaxRuntimeError, 'foo'):\n        f(False)",
    "assertions": [
      "assert python_should_be_running"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_grad(self):\n\n    @jax.grad\n    def f(x):\n        checkify.check(jnp.all(x > 0), 'should be positive!')\n        return x\n    f = checkify.checkify(f)\n    err, _ = f(1.0)\n    self.assertIsNone(err.get())\n    err, _ = f(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('should be positive', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_assert_cond_no_data_dependence(self):\n\n    def true_fun():\n        return checkify.check(False, 'hi!')\n\n    def false_fun():\n        return checkify.check(False, 'bye!')\n\n    def f():\n        return jax.lax.cond(True, true_fun, false_fun)\n    f = checkify.checkify(f)\n    err, _ = f()\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'hi!')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_debug_check_noop(self):\n\n    def f(x):\n        checkify.debug_check(jnp.all(x != x), '{x} cannot be {x}', x=x)\n        return x\n    x = jnp.ones(())\n    f(x)\n    jax.jit(f)(x)\n    jax.vmap(f)(jnp.ones((2,)))\n    jax.grad(f)(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "@jtu.run_on_devices('cpu', 'gpu')\ndef test_jit(self):\n\n    @jax.jit\n    def f(x):\n        checkify.check(x > 0, 'x needs to be positive')\n        return x\n    with self.assertRaisesRegex(xla_extension.XlaRuntimeError, 'x needs to be positive'):\n        f(-1.0)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_pjit(self):\n\n    def f(x):\n        return x / x\n\n    def g(x, y):\n        return x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    ps = NamedSharding(mesh, jax.sharding.PartitionSpec('dev'))\n    inp = np.arange(8)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = pjit.pjit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = pjit.pjit(g, in_shardings=ps, out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    with mesh:\n        u_err, _ = f(x)\n        b_err, _ = g(x, x)\n    self.assertIsNotNone(u_err.get())\n    self.assertStartsWith(u_err.get(), 'division by zero')\n    self.assertIsNotNone(b_err.get())\n    self.assertStartsWith(b_err.get(), 'division by zero')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return callback_p.bind(x, callback=log_value, effect=log_effect, out_avals=[])"
  },
  {
    "test_code": "@parameterized.parameters(True, False)\ndef test_shard_map(self, check_rep):\n\n    def f(x):\n        return jax.lax.axis_index('dev') * x / x\n\n    def g(x, y):\n        return jax.lax.axis_index('dev') * x / y\n    devices = jax.local_devices()[:8]\n    mesh = jax.sharding.Mesh(np.array(devices), ['dev'])\n    pspec = jax.sharding.PartitionSpec('dev')\n    ps = NamedSharding(mesh, pspec)\n    inp = np.tile(np.arange(4, dtype=np.int32), 2)\n    x = array.make_array_from_callback(inp.shape, ps, lambda idx: inp[idx])\n    f = shard_map.shard_map(f, mesh, in_specs=pspec, out_specs=pspec, check_rep=check_rep)\n    f = jax.jit(f, in_shardings=ps, out_shardings=ps)\n    f = checkify.checkify(f, errors=checkify.float_checks)\n    g = shard_map.shard_map(g, mesh, in_specs=(pspec, pspec), out_specs=pspec, check_rep=check_rep)\n    g = jax.jit(g, in_shardings=(ps, ps), out_shardings=ps)\n    g = checkify.checkify(g, errors=checkify.float_checks)\n    u_err, _ = f(x)\n    b_err, _ = g(x, x)\n    divbyzero = 'division by zero'\n    expected_err = f'at mapped index 0: {divbyzero}'\n    if (next_device_with_zero := (len(devices) // 2)) != 0:\n        expected_err += f'\\nat mapped index {next_device_with_zero}: {divbyzero}'\n    self.assertIsNotNone(u_err.get())\n    self.assertEqual(u_err.get(), expected_err)\n    self.assertIsNotNone(b_err.get())\n    self.assertEqual(b_err.get(), expected_err)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return callback_p.bind(x, callback=log_value, effect=log_effect, out_avals=[])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_call(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.jit\n        def f(y):\n            return jnp.sin(x * y)\n        return f(jnp.inf)\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return callback_p.bind(x, callback=log_value, effect=log_effect, out_avals=[])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_post_process_map(self):\n\n    @partial(checkify.checkify, errors=checkify.float_checks)\n    def g(x):\n\n        @jax.pmap\n        def f(y):\n            return (jnp.sin(x * y), jnp.cos(x * y))\n        return f(jnp.array([jnp.inf]))[0]\n    err, _ = g(2.0)\n    self.assertIsNotNone(err.get())\n    self.assertIn('nan generated by primitive: sin', err.get())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return callback_p.bind(x, callback=log_value, effect=log_effect, out_avals=[])"
  },
  {
    "test_code": "@jtu.skip_on_devices('tpu')\ndef test_custom_jvp(self):\n\n    @jax.custom_jvp\n    def sin(x):\n        return jnp.sin(x)\n\n    @sin.defjvp\n    def sin_jvp(primals, tangents):\n        (x,), (xdot,) = (primals, tangents)\n        return (sin(x), jnp.cos(x) * xdot)\n    f = checkify.checkify(sin, errors=checkify.float_checks)\n    err, y = f(3.0)\n    self.assertIsNone(err.get())\n    err, y = f(jnp.inf)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')\n    (err, y), (errdot, ydot) = jax.jvp(f, (3.0,), (1.0,))\n    self.assertIsNone(err.get())\n    self.assertEmpty(err._metadata)\n    self.assertEmpty(errdot._metadata)\n    y_expected, ydot_expected = jax.jvp(jnp.sin, (3.0,), (1.0,))\n    self.assertAllClose(y, y_expected)\n    self.assertAllClose(ydot, ydot_expected)\n    x_bar = jax.grad(lambda x: f(x)[1])(3.0)\n    self.assertAllClose(x_bar, jnp.cos(3.0))\n    g = checkify.checkify(lambda x, xdot: jax.jvp(sin, (x,), (xdot,)), errors=checkify.float_checks)\n    err, (y, ydot) = g(3.0, 1.0)\n    self.assertIsNone(err.get())\n    self.assertNotEmpty(err._metadata)\n    self.assertAllClose(y, jnp.sin(3.0))\n    self.assertAllClose(ydot, jnp.cos(3.0))\n    err, _ = g(jnp.inf, 1.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'nan generated by primitive: sin')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return callback_p.bind(x, callback=log_value, effect=log_effect, out_avals=[])"
  },
  {
    "test_code": "def test_assert_discharging_no_data_dependence(self):\n\n    @jax.jit\n    def g(x):\n\n        @checkify.checkify\n        def f():\n            checkify.check(x > 0, 'must be positive!')\n            return jnp.log(x)\n        return f()\n    err, _ = g(1.0)\n    self.assertIsNone(err.get())\n    err, _ = g(0.0)\n    self.assertIsNotNone(err.get())\n    self.assertStartsWith(err.get(), 'must be positive')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/checkify_test.py",
    "function": "@jax.jit\ndef g(x):\n    return callback_p.bind(x, callback=log_value, effect=log_effect, out_avals=[])"
  }
]