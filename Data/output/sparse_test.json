[
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_{cls.__name__}{(N, M, k)}', 'cls': cls, 'N': N, 'M': M, 'k': k} for cls in [sparse.CSR, sparse.CSC, sparse.COO, sparse.BCOO] for N in [2, 5] for M in [None, 3] for k in [-2, 0, 1]))\ndef test_eye(self, cls, N, M, k):\n    sparse_format = cls.__name__.lower()\n    func = partial(sparse.eye, N, M, k, sparse_format=sparse_format)\n    expected = jnp.eye(N, M, k)\n    expected_nse = jnp.count_nonzero(expected)\n    mat = func()\n    self.assertIsInstance(mat, cls)\n    self.assertArraysEqual(mat.todense(), expected)\n    self.assertEqual(mat.nse, expected_nse)\n    mat_jit = jit(func)()\n    self.assertIsInstance(mat_jit, cls)\n    self.assertArraysEqual(mat_jit.todense(), expected)\n    self.assertEqual(mat_jit.nse, expected_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def func(x):\n    x, = promote_dtypes_complex(x)\n    return jnp.fft.irfft(jnp.concatenate([jnp.zeros_like(x, shape=1), x[:2] + 1j * x[2:]]))"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_{cls.__name__}{(N, M, k)}', 'cls': cls, 'N': N, 'M': M, 'k': k} for cls in [sparse.CSR, sparse.CSC, sparse.COO, sparse.BCOO] for N in [2, 5] for M in [None, 3] for k in [-2, 0, 1]))\ndef test_eye(self, cls, N, M, k):\n    sparse_format = cls.__name__.lower()\n    func = partial(sparse.eye, N, M, k, sparse_format=sparse_format)\n    expected = jnp.eye(N, M, k)\n    expected_nse = jnp.count_nonzero(expected)\n    mat = func()\n    self.assertIsInstance(mat, cls)\n    self.assertArraysEqual(mat.todense(), expected)\n    self.assertEqual(mat.nse, expected_nse)\n    mat_jit = jit(func)()\n    self.assertIsInstance(mat_jit, cls)\n    self.assertArraysEqual(mat_jit.todense(), expected)\n    self.assertEqual(mat_jit.nse, expected_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def func(size):\n    lhs_one_d = jnp.arange(size, dtype='int32') + 1\n    lhs_two_d = jax.lax.broadcast_in_dim(lhs_one_d, (size, 2), (0,))\n    rhs = jax.lax.broadcasted_iota('int32', (2, 4), 0) + 1\n    return jnp.dot(lhs_two_d, rhs)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_{cls.__name__}{(N, M, k)}', 'cls': cls, 'N': N, 'M': M, 'k': k} for cls in [sparse.CSR, sparse.CSC, sparse.COO, sparse.BCOO] for N in [2, 5] for M in [None, 3] for k in [-2, 0, 1]))\ndef test_eye(self, cls, N, M, k):\n    sparse_format = cls.__name__.lower()\n    func = partial(sparse.eye, N, M, k, sparse_format=sparse_format)\n    expected = jnp.eye(N, M, k)\n    expected_nse = jnp.count_nonzero(expected)\n    mat = func()\n    self.assertIsInstance(mat, cls)\n    self.assertArraysEqual(mat.todense(), expected)\n    self.assertEqual(mat.nse, expected_nse)\n    mat_jit = jit(func)()\n    self.assertIsInstance(mat_jit, cls)\n    self.assertArraysEqual(mat_jit.todense(), expected)\n    self.assertEqual(mat_jit.nse, expected_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def func(x):\n    return jax.random.uniform(x, (2, 4), dtype=np.float32)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_{cls.__name__}{(N, M, k)}', 'cls': cls, 'N': N, 'M': M, 'k': k} for cls in [sparse.CSR, sparse.CSC, sparse.COO, sparse.BCOO] for N in [2, 5] for M in [None, 3] for k in [-2, 0, 1]))\ndef test_eye(self, cls, N, M, k):\n    sparse_format = cls.__name__.lower()\n    func = partial(sparse.eye, N, M, k, sparse_format=sparse_format)\n    expected = jnp.eye(N, M, k)\n    expected_nse = jnp.count_nonzero(expected)\n    mat = func()\n    self.assertIsInstance(mat, cls)\n    self.assertArraysEqual(mat.todense(), expected)\n    self.assertEqual(mat.nse, expected_nse)\n    mat_jit = jit(func)()\n    self.assertIsInstance(mat_jit, cls)\n    self.assertArraysEqual(mat_jit.todense(), expected)\n    self.assertEqual(mat_jit.nse, expected_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def func(xs):\n    return jnp.array(list(xs))"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "@jtu.run_on_devices('gpu')\ndef test_gpu_translation_rule(self):\n    version = xla_bridge.get_backend().platform_version\n    if 'rocm' not in version.split():\n        cuda_version = None if version == '<unknown>' else int(version.split()[-1])\n        if cuda_version is None or cuda_version < 11000:\n            self.assertFalse(gpu_sparse and gpu_sparse.cuda_is_supported)\n            self.assertNotIn(sparse.csr_todense_p, mlir._platform_specific_lowerings['cuda'])\n        else:\n            self.assertTrue(gpu_sparse and gpu_sparse.cuda_is_supported)\n            self.assertIn(sparse.csr_todense_p, mlir._platform_specific_lowerings['cuda'])\n    else:\n        self.assertTrue(gpu_sparse and gpu_sparse.rocm_is_supported)\n        self.assertIn(sparse.csr_todense_p, mlir._platform_specific_lowerings['rocm'])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def split(self) -> jax.Array:\n    key = jax_getattr(self, 'key')\n    new_key, returned_key = jax.random.split(key)\n    jax_setattr(self, 'key', new_key)\n    return returned_key"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "@jtu.sample_product(size=[10, 20, 50], dtype=jtu.dtypes.floating)\n@jtu.run_on_devices('cpu', 'cuda')\ndef test_sparse_qr_linear_solver_grads(self, size, dtype):\n    rng = sptu.rand_sparse(self.rng())\n    a = rng((size, size), dtype)\n    nse = (a != 0).sum()\n    data, indices, indptr = sparse_csr._csr_fromdense(a, nse=nse)\n    rng_k = jtu.rand_default(self.rng())\n    b = rng_k([size], dtype)\n\n    def sparse_solve(data, b, tol=1e-08):\n        return sparse.linalg.spsolve(data, indices, indptr, b, tol=tol)\n    jtu.check_grads(sparse_solve, (data, b), order=1, rtol=0.05, atol=0.05)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def check_grads(f, args, order, atol=None, rtol=None, eps=None):\n    default_tol = 1e-06 if config.enable_x64.value else 0.01\n    atol = atol or default_tol\n    rtol = rtol or default_tol\n    eps = eps or default_tol\n    jtu.check_jvp(f, partial(jax.jvp, f), args, atol, rtol, eps)\n    jtu.check_vjp(f, partial(jax.vjp, f), args, atol, rtol, eps)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_{cls.__name__}', 'cls': cls} for cls in [sparse.CSR, sparse.CSC, sparse.COO, sparse.BCOO, sparse.BCSR]))\ndef test_pytree_flattening(self, cls):\n    sparse_format = cls.__name__.lower()\n    M = sparse.empty((2, 4), sparse_format=sparse_format)\n    self.assertIsInstance(M, cls)\n    buffers, tree = jax.tree.flatten(M)\n    self.assertTrue(all((isinstance(buffer, jax.Array) for buffer in buffers)))\n    M_out = jax.tree.unflatten(tree, buffers)\n    self.assertEqual(M.dtype, M_out.dtype)\n    self.assertEqual(M.shape, M_out.shape)\n    self.assertEqual(M.nse, M_out.nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_{cls.__name__}', 'cls': cls} for cls in [sparse.BCOO, sparse.BCSR]))\ndef test_vmappable(self, cls):\n    M = jnp.arange(24).reshape((2, 3, 4))\n    Msp = cls.fromdense(M, n_batch=1)\n\n    def from_elt(x):\n        assert x.ndim == 2\n        return sparse.empty(x.shape, x.dtype, sparse_format=cls.__name__.lower())\n    with self.subTest('from_elt'):\n        M_out = vmap(from_elt)(M)\n        self.assertIsInstance(M_out, cls)\n        self.assertEqual(M_out.n_batch, 1)\n        self.assertEqual(M.shape, M_out.shape)\n\n    def to_elt(x):\n        assert x.ndim == 2\n        assert x.n_sparse == 2\n        return jnp.empty(x.shape, x.dtype)\n    with self.subTest('to_elt'):\n        M_out = vmap(to_elt)(Msp)\n        self.assertIsInstance(M_out, jax.Array)\n        self.assertEqual(Msp.shape, M_out.shape)\n    with self.subTest('axis_None'):\n        x, y = vmap(lambda *args: args, in_axes=(0, None), out_axes=(0, None))(Msp, Msp)\n        self.assertIsInstance(x, cls)\n        self.assertEqual(x.n_batch, 1)\n        self.assertEqual(x.shape, Msp.shape)\n        self.assertEqual(x._info, Msp._info)\n        self.assertIsInstance(y, cls)\n        self.assertEqual(y.n_batch, 1)\n        self.assertEqual(y.shape, Msp.shape)\n        self.assertEqual(y._info, Msp._info)",
    "assertions": [
      "assert x.ndim == 2",
      "assert x.ndim == 2",
      "assert x.n_sparse == 2"
    ],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_{cls.__name__}', 'cls': cls} for cls in [sparse.CSR, sparse.CSC, sparse.COO, sparse.BCOO]))\ndef test_jit_lower(self, cls):\n    sparse_format = cls.__name__.lower()\n    M = sparse.empty((2, 4), sparse_format=sparse_format)\n    self.assertIsInstance(M, cls)\n    jax.jit(lambda x: x).lower(M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_{cls.__name__}{shape}', 'cls': cls, 'shape': shape} for cls in [sparse.CSR, sparse.CSC, sparse.COO, sparse.BCOO] for shape in ([2, 5], [5, 3])))\ndef test_empty(self, cls, shape):\n    sparse_format = cls.__name__.lower()\n    M = sparse.empty(shape, sparse_format=sparse_format)\n    self.assertIsInstance(M, cls)\n    self.assertEqual(M.nse, 0)\n    self.assertArraysEqual(M.todense(), jnp.empty(shape))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_{cls.__name__}{(N, M, k)}', 'cls': cls, 'N': N, 'M': M, 'k': k} for cls in [sparse.CSR, sparse.CSC, sparse.COO, sparse.BCOO] for N in [2, 5] for M in [None, 3] for k in [-2, 0, 1]))\ndef test_eye(self, cls, N, M, k):\n    sparse_format = cls.__name__.lower()\n    func = partial(sparse.eye, N, M, k, sparse_format=sparse_format)\n    expected = jnp.eye(N, M, k)\n    expected_nse = jnp.count_nonzero(expected)\n    mat = func()\n    self.assertIsInstance(mat, cls)\n    self.assertArraysEqual(mat.todense(), expected)\n    self.assertEqual(mat.nse, expected_nse)\n    mat_jit = jit(func)()\n    self.assertIsInstance(mat_jit, cls)\n    self.assertArraysEqual(mat_jit.todense(), expected)\n    self.assertEqual(mat_jit.nse, expected_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def lower(self, x, _experimental_lowering_parameters=None):\n    return jax.jit(self.__call__).lower(x, _experimental_lowering_parameters=_experimental_lowering_parameters)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_{cls.__name__}{(N, M, k)}', 'cls': cls, 'N': N, 'M': M, 'k': k} for cls in [sparse.CSR, sparse.CSC, sparse.COO, sparse.BCOO] for N in [2, 5] for M in [None, 3] for k in [-2, 0, 1]))\ndef test_eye(self, cls, N, M, k):\n    sparse_format = cls.__name__.lower()\n    func = partial(sparse.eye, N, M, k, sparse_format=sparse_format)\n    expected = jnp.eye(N, M, k)\n    expected_nse = jnp.count_nonzero(expected)\n    mat = func()\n    self.assertIsInstance(mat, cls)\n    self.assertArraysEqual(mat.todense(), expected)\n    self.assertEqual(mat.nse, expected_nse)\n    mat_jit = jit(func)()\n    self.assertIsInstance(mat_jit, cls)\n    self.assertArraysEqual(mat_jit.todense(), expected)\n    self.assertEqual(mat_jit.nse, expected_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(self.pmap, axis_name='i')\ndef func(_):\n    return jax.lax.psum(dtype(0), axis_name='i')"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(_, y):\n    input_effect(y, index=0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@checkify.checkify\ndef f():\n    checkify.check(x > 0, 'must be positive!')\n    return jnp.log(x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@checkify.checkify\ndef f():\n    checkify.check(x > 0, 'must be positive!')\n    return jnp.log(x)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@checkify.checkify\ndef f():\n    checkify.check(x > 0, 'must be positive!')\n    return jnp.log(x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@checkify.checkify\ndef f():\n    checkify.check(x > 0, 'must be positive!')\n    return jnp.log(x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@checkify.checkify\ndef f():\n    checkify.check(x > 0, 'must be positive!')\n    return jnp.log(x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(z):\n    y = odeint(dz_dt, z, jnp.arange(10.0))\n    return jnp.sum(y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(z):\n    y = odeint(dz_dt, z, jnp.arange(10.0))\n    return jnp.sum(y)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(z):\n    y = odeint(dz_dt, z, jnp.arange(10.0))\n    return jnp.sum(y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(z):\n    y = odeint(dz_dt, z, jnp.arange(10.0))\n    return jnp.sum(y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(z):\n    y = odeint(dz_dt, z, jnp.arange(10.0))\n    return jnp.sum(y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return x.at[1].apply(jax.numpy.sin)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return x.at[1].apply(jax.numpy.sin)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return x.at[1].apply(jax.numpy.sin)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return x.at[1].apply(jax.numpy.sin)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return x.at[1].apply(jax.numpy.sin)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_{cls.__name__}{(N, M, k)}', 'cls': cls, 'N': N, 'M': M, 'k': k} for cls in [sparse.CSR, sparse.CSC, sparse.COO, sparse.BCOO] for N in [2, 5] for M in [None, 3] for k in [-2, 0, 1]))\ndef test_eye(self, cls, N, M, k):\n    sparse_format = cls.__name__.lower()\n    func = partial(sparse.eye, N, M, k, sparse_format=sparse_format)\n    expected = jnp.eye(N, M, k)\n    expected_nse = jnp.count_nonzero(expected)\n    mat = func()\n    self.assertIsInstance(mat, cls)\n    self.assertArraysEqual(mat.todense(), expected)\n    self.assertEqual(mat.nse, expected_nse)\n    mat_jit = jit(func)()\n    self.assertIsInstance(mat_jit, cls)\n    self.assertArraysEqual(mat_jit.todense(), expected)\n    self.assertEqual(mat_jit.nse, expected_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@self.sparsify\ndef func(x):\n    return jit(lambda x: jnp.sum(x, 1))(x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    bits = prng.threefry_random_bits(jnp.array([0, 0], dtype='uint32'), 32, x.shape)\n    return bits + x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    bits = prng.threefry_random_bits(jnp.array([0, 0], dtype='uint32'), 32, x.shape)\n    return bits + x"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    bits = prng.threefry_random_bits(jnp.array([0, 0], dtype='uint32'), 32, x.shape)\n    return bits + x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    bits = prng.threefry_random_bits(jnp.array([0, 0], dtype='uint32'), 32, x.shape)\n    return bits + x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    bits = prng.threefry_random_bits(jnp.array([0, 0], dtype='uint32'), 32, x.shape)\n    return bits + x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, P('x')), out_shardings=NamedSharding(mesh, P('x')))\ndef f(x, y):\n    z = x @ y\n    return z @ y"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, P('x')), out_shardings=NamedSharding(mesh, P('x')))\ndef f(x, y):\n    z = x @ y\n    return z @ y"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, P('x')), out_shardings=NamedSharding(mesh, P('x')))\ndef f(x, y):\n    z = x @ y\n    return z @ y"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, P('x')), out_shardings=NamedSharding(mesh, P('x')))\ndef f(x, y):\n    z = x @ y\n    return z @ y"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, P('x')), out_shardings=NamedSharding(mesh, P('x')))\ndef f(x, y):\n    z = x @ y\n    return z @ y"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    debugging.inspect_array_sharding(x, callback=_cb)\n    return jnp.square(x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    debugging.inspect_array_sharding(x, callback=_cb)\n    return jnp.square(x)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    debugging.inspect_array_sharding(x, callback=_cb)\n    return jnp.square(x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    debugging.inspect_array_sharding(x, callback=_cb)\n    return jnp.square(x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    debugging.inspect_array_sharding(x, callback=_cb)\n    return jnp.square(x)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, inline=True)\ndef f(x):\n    return lax.add(x, 3)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, inline=True)\ndef f(x):\n    return lax.add(x, 3)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, inline=True)\ndef f(x):\n    return lax.add(x, 3)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, inline=True)\ndef f(x):\n    return lax.add(x, 3)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@partial(jax.jit, inline=True)\ndef f(x):\n    return lax.add(x, 3)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    key = jax.random.key(0)\n    return jax.random.bits(key) + jax.random.bits(key)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    key = jax.random.key(0)\n    return jax.random.bits(key) + jax.random.bits(key)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    key = jax.random.key(0)\n    return jax.random.bits(key) + jax.random.bits(key)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    key = jax.random.key(0)\n    return jax.random.bits(key) + jax.random.bits(key)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f():\n    key = jax.random.key(0)\n    return jax.random.bits(key) + jax.random.bits(key)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    nonlocal num_traces\n    num_traces += 1\n    return x + x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    nonlocal num_traces\n    num_traces += 1\n    return x + x"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    nonlocal num_traces\n    num_traces += 1\n    return x + x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    nonlocal num_traces\n    num_traces += 1\n    return x + x"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(x):\n    nonlocal num_traces\n    num_traces += 1\n    return x + x"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_{cls.__name__}{(N, M, k)}', 'cls': cls, 'N': N, 'M': M, 'k': k} for cls in [sparse.CSR, sparse.CSC, sparse.COO, sparse.BCOO] for N in [2, 5] for M in [None, 3] for k in [-2, 0, 1]))\ndef test_eye(self, cls, N, M, k):\n    sparse_format = cls.__name__.lower()\n    func = partial(sparse.eye, N, M, k, sparse_format=sparse_format)\n    expected = jnp.eye(N, M, k)\n    expected_nse = jnp.count_nonzero(expected)\n    mat = func()\n    self.assertIsInstance(mat, cls)\n    self.assertArraysEqual(mat.todense(), expected)\n    self.assertEqual(mat.nse, expected_nse)\n    mat_jit = jit(func)()\n    self.assertIsInstance(mat_jit, cls)\n    self.assertArraysEqual(mat_jit.todense(), expected)\n    self.assertEqual(mat_jit.nse, expected_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def func(D0):\n\n    def shift(R, dR, **unused_kwargs):\n        return R + dR\n\n    def apply_fn(R):\n        return D0 * R\n    Rinit = jax.random.uniform(split, (n, 3), minval=0.0, maxval=5.0, dtype=jnp.float32)\n\n    def move(R, i):\n        F = apply_fn(R)\n        return (shift(R, 0.001 * F), jnp.array([0.0]))\n    move = remat(move)\n    R, temp = lax.scan(move, Rinit, jnp.arange(2))\n    return R[0, 0]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@jtu.sample_product([dict(shape=shape, bshape=bshape) for shape in [(5, 8), (8, 5), (5, 5), (8, 8)] for bshape in [shape[-1:] + s for s in [(), (1,), (3,)]]], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\n@jax.default_matmul_precision('float32')\ndef test_csr_matmul_ad(self, shape, dtype, bshape):\n    csr_matmul = sparse_csr._csr_matvec if len(bshape) == 1 else sparse_csr._csr_matmat\n    tol = {np.float32: 2e-05, np.float64: 1e-12, np.complex64: 1e-05, np.complex128: 1e-12}\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    rng_b = jtu.rand_default(self.rng())\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    x = rng_b(bshape, dtype)\n    xdot = rng_b(bshape, dtype)\n    f_dense = lambda x: M @ x\n    f_sparse = lambda x: csr_matmul(data, indices, indptr, x, shape=M.shape)\n    v_sparse, t_sparse = jax.jvp(f_sparse, [x], [xdot])\n    v_dense, t_dense = jax.jvp(f_dense, [x], [xdot])\n    self.assertAllClose(v_sparse, v_dense, atol=tol, rtol=tol)\n    self.assertAllClose(t_sparse, t_dense, atol=tol, rtol=tol)\n    primals_dense, vjp_dense = jax.vjp(f_dense, x)\n    primals_sparse, vjp_sparse = jax.vjp(f_sparse, x)\n    out_dense, = vjp_dense(primals_dense)\n    out_sparse, = vjp_sparse(primals_sparse)\n    self.assertAllClose(primals_dense[0], primals_sparse[0], atol=tol, rtol=tol)\n    self.assertAllClose(out_dense, out_sparse, atol=tol, rtol=tol)\n    f_sparse = lambda data: csr_matmul(data, indices, indptr, x, shape=M.shape)\n    f_dense = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape) @ x\n    data = rng((len(data),), data.dtype)\n    data_dot = rng((len(data),), data.dtype)\n    v_sparse, t_sparse = jax.jvp(f_sparse, [data], [data_dot])\n    v_dense, t_dense = jax.jvp(f_dense, [data], [data_dot])\n    self.assertAllClose(v_sparse, v_dense, atol=tol, rtol=tol)\n    self.assertAllClose(t_sparse, t_dense, atol=tol, rtol=tol)\n    primals_dense, vjp_dense = jax.vjp(f_dense, data)\n    primals_sparse, vjp_sparse = jax.vjp(f_sparse, data)\n    out_dense, = vjp_dense(primals_dense)\n    out_sparse, = vjp_sparse(primals_sparse)\n    self.assertAllClose(primals_dense[0], primals_sparse[0], atol=tol, rtol=tol)\n    self.assertAllClose(out_dense, out_sparse, atol=tol, rtol=tol)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@jtu.sample_product([dict(shape=shape, bshape=bshape) for shape in [(5, 8), (8, 5), (5, 5), (8, 8)] for bshape in [shape[-1:] + s for s in [(), (1,), (3,)]]], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\n@jax.default_matmul_precision('float32')\ndef test_coo_matmul_ad(self, shape, dtype, bshape):\n    coo_matmul = sparse_coo._coo_matvec if len(bshape) == 1 else sparse_coo._coo_matmat\n    tol = {np.float32: 1e-05, np.float64: 1e-12, np.complex64: 1e-05, np.complex128: 1e-12}\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    rng_b = jtu.rand_default(self.rng())\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    x = rng_b(bshape, dtype)\n    xdot = rng_b(bshape, dtype)\n    spinfo = sparse_coo.COOInfo(shape=M.shape, rows_sorted=True)\n    f_dense = lambda x: M @ x\n    f_sparse = lambda x: coo_matmul(data, row, col, x, spinfo=spinfo)\n    v_sparse, t_sparse = jax.jvp(f_sparse, [x], [xdot])\n    v_dense, t_dense = jax.jvp(f_dense, [x], [xdot])\n    self.assertAllClose(v_sparse, v_dense, atol=tol, rtol=tol)\n    self.assertAllClose(t_sparse, t_dense, atol=tol, rtol=tol)\n    primals_dense, vjp_dense = jax.vjp(f_dense, x)\n    primals_sparse, vjp_sparse = jax.vjp(f_sparse, x)\n    out_dense, = vjp_dense(primals_dense)\n    out_sparse, = vjp_sparse(primals_sparse)\n    self.assertAllClose(primals_dense[0], primals_sparse[0], atol=tol, rtol=tol)\n    self.assertAllClose(out_dense, out_sparse, atol=tol, rtol=tol)\n    f_sparse = lambda data: coo_matmul(data, row, col, x, spinfo=spinfo)\n    f_dense = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=spinfo) @ x\n    data = rng((len(data),), data.dtype)\n    data_dot = rng((len(data),), data.dtype)\n    v_sparse, t_sparse = jax.jvp(f_sparse, [data], [data_dot])\n    v_dense, t_dense = jax.jvp(f_dense, [data], [data_dot])\n    self.assertAllClose(v_sparse, v_dense, atol=tol, rtol=tol)\n    self.assertAllClose(t_sparse, t_dense, atol=tol, rtol=tol)\n    primals_dense, vjp_dense = jax.vjp(f_dense, data)\n    primals_sparse, vjp_sparse = jax.vjp(f_sparse, data)\n    out_dense, = vjp_dense(primals_dense)\n    out_sparse, = vjp_sparse(primals_sparse)\n    self.assertAllClose(primals_dense[0], primals_sparse[0], atol=tol, rtol=tol)\n    self.assertAllClose(out_dense, out_sparse, atol=tol, rtol=tol)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(4, 5), (3, 4), (5, 4)], dtype=_lowerings.SUPPORTED_DATA_DTYPES, transpose=[True, False])\n@jtu.run_on_devices('gpu')\ndef test_csr_spmv(self, shape, dtype, transpose):\n    rng_sparse = sptu.rand_sparse(self.rng())\n    rng_dense = jtu.rand_default(self.rng())\n    mat = rng_sparse(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(mat, nse=(mat != 0).sum())\n    vec = rng_dense(shape[0] if transpose else shape[1], dtype)\n    expected = (mat.T if transpose else mat) @ vec\n    actual = _lowerings.csr_spmv_p.bind(data, indices.astype('int32'), indptr.astype('int32'), vec, transpose=transpose, shape=mat.shape)\n    self.assertArraysAllClose(actual, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(4, 5), (3, 4), (5, 4)], dtype=_lowerings.SUPPORTED_DATA_DTYPES, transpose=[True, False])\n@jtu.run_on_devices('gpu')\ndef test_csr_spmm(self, shape, dtype, transpose):\n    rng_sparse = sptu.rand_sparse(self.rng())\n    rng_dense = jtu.rand_default(self.rng())\n    mat = rng_sparse(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(mat, nse=(mat != 0).sum())\n    vec = rng_dense((shape[0] if transpose else shape[1], 3), dtype)\n    expected = (mat.T if transpose else mat) @ vec\n    actual = _lowerings.csr_spmm_p.bind(data, indices.astype('int32'), indptr.astype('int32'), vec, transpose=transpose, shape=mat.shape)\n    self.assertArraysAllClose(actual, expected)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@jtu.sample_product(has_aux=[True, False])\ndef test_sparse_value_and_grad(self, has_aux):\n    rng_sparse = sptu.rand_sparse(self.rng())\n    rng = jtu.rand_default(self.rng())\n    y = rng(5, 'float32')\n    X = rng_sparse((10, 5), 'float32')\n    Xsp = sparse.BCOO.fromdense(X)\n\n    def f(X, y):\n        if has_aux:\n            return (jnp.sum(X @ y), {'X': X.shape, 'y': y.shape})\n        return jnp.sum(X @ y)\n    with self.subTest('wrt sparse'):\n        val_de, grad_de = jax.value_and_grad(f, argnums=0, has_aux=has_aux)(X, y)\n        val_sp, grad_sp = sparse.value_and_grad(f, argnums=0, has_aux=has_aux)(Xsp, y)\n        self.assertIsInstance(grad_sp, sparse.BCOO)\n        self.assertAllClose(val_de, val_sp)\n        self.assertAllClose(grad_sp.data, sparse_bcoo._bcoo_extract(grad_sp.indices, grad_de))\n    with self.subTest('wrt dense'):\n        self.assertAllClose(jax.value_and_grad(f, argnums=1, has_aux=has_aux)(X, y), sparse.value_and_grad(f, argnums=1, has_aux=has_aux)(Xsp, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@jtu.sample_product(has_aux=[True, False])\ndef test_sparse_grad(self, has_aux):\n    rng_sparse = sptu.rand_sparse(self.rng())\n    rng = jtu.rand_default(self.rng())\n    y = rng(5, 'float32')\n    X = rng_sparse((10, 5), 'float32')\n    Xsp = sparse.BCOO.fromdense(X)\n\n    def f(X, y):\n        if has_aux:\n            return (jnp.sum(X @ y), {'X': X.shape, 'y': y.shape})\n        return jnp.sum(X @ y)\n    with self.subTest('wrt sparse'):\n        grad_de = jax.grad(f, argnums=0, has_aux=has_aux)(X, y)\n        grad_sp = sparse.grad(f, argnums=0, has_aux=has_aux)(Xsp, y)\n        if has_aux:\n            grad_de, aux_de = grad_de\n            grad_sp, aux_sp = grad_sp\n            self.assertAllClose(aux_de, aux_sp)\n        self.assertIsInstance(grad_sp, sparse.BCOO)\n        self.assertAllClose(grad_sp.data, sparse_bcoo._bcoo_extract(grad_sp.indices, grad_de))\n    with self.subTest('wrt dense'):\n        self.assertAllClose(jax.grad(f, argnums=1, has_aux=has_aux)(X, y), sparse.grad(f, argnums=1, has_aux=has_aux)(Xsp, y))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@jtu.sample_product(has_aux=[True, False], deep=[True, False], arg0=[True, False], bias=[True, False])\ndef test_sparse_pytree_grad(self, has_aux, deep, arg0, bias):\n    rng_sparse = sptu.rand_sparse(self.rng())\n    rng = jtu.rand_default(self.rng())\n    y = rng(5, 'float32')\n    X = rng_sparse((10, 5), 'float32')\n    b = rng(10, 'float32')\n    Xsp = sparse.BCOO.fromdense(X)\n    Xtree_sp = {'deep': {'X': Xsp}, 'X': Xsp, 'list': [None, (b, None)]}\n    Xtree_de = {'deep': {'X': X}, 'X': X, 'list': [None, (b, None)]}\n\n    def f(Xtree, y):\n        if deep:\n            out = Xtree['deep']['X'] @ y\n        else:\n            out = Xtree['X'] @ y\n        if bias:\n            out += Xtree['list'][1][0]\n        out = jnp.sum(out)\n        if has_aux:\n            return (out, {'y': y.shape})\n        else:\n            return out\n\n    def g(y, Xtree):\n        if deep:\n            out = Xtree['deep']['X'] @ y\n        else:\n            out = Xtree['X'] @ y\n        if bias:\n            out += Xtree['list'][1][0]\n        out = jnp.sum(out)\n        if has_aux:\n            return (out, {'y': y.shape})\n        return out\n    with self.subTest('wrt sparse'):\n        if arg0:\n            grad_de = jax.grad(f, argnums=0, has_aux=has_aux)(Xtree_de, y)\n            grad_sp = sparse.grad(f, argnums=0, has_aux=has_aux)(Xtree_sp, y)\n        else:\n            grad_de = jax.grad(g, argnums=1, has_aux=has_aux)(y, Xtree_de)\n            grad_sp = sparse.grad(g, argnums=1, has_aux=has_aux)(y, Xtree_sp)\n        if has_aux:\n            grad_de, aux_de = grad_de\n            grad_sp, aux_sp = grad_sp\n            self.assertAllClose(aux_de, aux_sp)\n        is_bcoo = lambda x: isinstance(x, sparse.bcoo.BCOO)\n        grad_densified = jax.tree_util.tree_map(sparse.todense, grad_sp, is_leaf=is_bcoo)\n        self.assertEqual(jax.tree_util.tree_structure(grad_de), jax.tree_util.tree_structure(grad_densified))\n        if deep:\n            grad_sp_arr = grad_sp['deep']['X']\n            grad_de_arr = grad_de['deep']['X']\n        else:\n            grad_sp_arr = grad_sp['X']\n            grad_de_arr = grad_de['X']\n        self.assertIsInstance(grad_sp_arr, sparse.BCOO)\n        self.assertAllClose(grad_sp_arr.data, sparse_bcoo._bcoo_extract(grad_sp_arr.indices, grad_de_arr))\n        if bias:\n            self.assertAllClose(grad_sp['list'][1][0], grad_de['list'][1][0])\n    with self.subTest('wrt dense'):\n        if arg0:\n            self.assertAllClose(jax.grad(f, argnums=1, has_aux=has_aux)(Xtree_de, y), sparse.grad(f, argnums=1, has_aux=has_aux)(Xtree_sp, y))\n        else:\n            self.assertAllClose(jax.grad(g, argnums=0, has_aux=has_aux)(y, Xtree_de), sparse.grad(g, argnums=0, has_aux=has_aux)(y, Xtree_sp))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@parameterized.named_parameters(({'testcase_name': f'_{Obj.__name__}', 'Obj': Obj} for Obj in [sparse.CSR, sparse.CSC, sparse.COO, sparse.BCOO, sparse.BCSR]))\ndef test_attrs(self, Obj, shape=(5, 8), dtype=np.float32):\n    rng = sptu.rand_sparse(self.rng(), post=Obj.fromdense)\n    M = rng(shape, dtype)\n    self.assertIsInstance(M, Obj)\n    self.assertEqual(M.shape, shape)\n    self.assertEqual(M.size, math.prod(shape))\n    self.assertEqual(M.ndim, len(shape))\n    self.assertEqual(M.dtype, dtype)\n    self.assertEqual(M.nse, (M.todense() != 0).sum())\n    self.assertEqual(M.data.dtype, dtype)\n    self.assertEqual(len(M), M.shape[0])\n    with self.assertRaises(TypeError):\n        hash(M)\n    if isinstance(M, sparse.CSR):\n        self.assertEqual(len(M.data), len(M.indices))\n        self.assertEqual(len(M.indptr), M.shape[0] + 1)\n    elif isinstance(M, sparse.CSC):\n        self.assertEqual(len(M.data), len(M.indices))\n        self.assertEqual(len(M.indptr), M.shape[1] + 1)\n    elif isinstance(M, sparse.COO):\n        self.assertEqual(len(M.data), len(M.row))\n        self.assertEqual(len(M.data), len(M.col))\n    elif isinstance(M, sparse.BCOO):\n        self.assertEqual(M.data.shape[M.n_batch], M.indices.shape[-2])\n        self.assertEqual(M.indices.shape[-1], M.n_sparse)\n    elif isinstance(M, sparse.BCSR):\n        self.assertEqual(M.data.shape[M.n_batch], M.indices.shape[-1])\n        self.assertEqual(M.indptr.shape[-1], M.shape[M.n_batch] + 1)\n    else:\n        raise ValueError(f'Obj={Obj!r} not expected.')",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "def test_bcoo_methods(self):\n    M = jnp.arange(12).reshape(3, 4)\n    Msp = sparse.BCOO.fromdense(M)\n    self.assertArraysEqual(-M, (-Msp).todense())\n    self.assertArraysEqual(2 * M, (2 * Msp).todense())\n    self.assertArraysEqual(M * 2, (Msp * 2).todense())\n    self.assertArraysEqual(M + M, (Msp + Msp).todense())\n    self.assertArraysEqual(M.sum(0), Msp.sum(0).todense())\n    self.assertArraysEqual(M.sum(1), Msp.sum(1).todense())\n    self.assertArraysEqual(M.sum(), Msp.sum())\n    self.assertArraysEqual(M.astype(float), Msp.astype(float).todense())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@jtu.sample_product([dict(shape=shape, n_batch=layout.n_batch, n_dense=layout.n_dense) for shape in [(5,), (5, 8), (8, 5), (3, 4, 5), (3, 4, 3, 2)] for layout in sptu.iter_sparse_layouts(shape)], dtype=jtu.dtypes.floating, indices_dtype=jtu.dtypes.integer)\ndef test_random_bcoo(self, shape, dtype, indices_dtype, n_batch, n_dense):\n    key = jax.random.PRNGKey(1701)\n    with jax.legacy_prng_key('allow'):\n        mat = sparse.random_bcoo(key, shape=shape, dtype=dtype, indices_dtype=indices_dtype, n_batch=n_batch, n_dense=n_dense)\n    mat_dense = mat.todense()\n    self.assertEqual(mat_dense.shape, shape)\n    self.assertEqual(mat_dense.dtype, dtype)\n    self.assertEqual(mat.indices.dtype, indices_dtype)\n    n_sparse = len(shape) - n_batch - n_dense\n    batch_shape, sparse_shape, dense_shape = split_list(shape, [n_batch, n_sparse])\n    approx_expected_num_nonzero = np.ceil(0.2 * math.prod(sparse_shape)) * math.prod(batch_shape) * math.prod(dense_shape)\n    num_nonzero = (mat_dense != 0).sum()\n    self.assertAlmostEqual(int(num_nonzero), approx_expected_num_nonzero, delta=2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@jtu.sample_product(size=[20, 50, 100], reorder=[0, 1, 2, 3], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\n@jtu.run_on_devices('cpu', 'cuda')\ndef test_sparse_qr_linear_solver(self, size, reorder, dtype):\n    rng = sptu.rand_sparse(self.rng())\n    a = rng((size, size), dtype)\n    nse = (a != 0).sum()\n    data, indices, indptr = sparse_csr._csr_fromdense(a, nse=nse)\n    rng_k = jtu.rand_default(self.rng())\n    b = rng_k([size], dtype)\n\n    def args_maker():\n        return (data, indices, indptr, b)\n    tol = 1e-08\n\n    def sparse_solve(data, indices, indptr, b):\n        return sparse.linalg.spsolve(data, indices, indptr, b, tol, reorder)\n    x = sparse_solve(data, indices, indptr, b)\n    self.assertAllClose(a @ x, b, rtol=0.01, atol=0.001)\n    self._CompileAndCheck(sparse_solve, args_maker)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@jtu.sample_product(size=[10, 20, 50], dtype=jtu.dtypes.floating)\n@jtu.run_on_devices('cpu', 'cuda')\ndef test_sparse_qr_linear_solver_grads(self, size, dtype):\n    rng = sptu.rand_sparse(self.rng())\n    a = rng((size, size), dtype)\n    nse = (a != 0).sum()\n    data, indices, indptr = sparse_csr._csr_fromdense(a, nse=nse)\n    rng_k = jtu.rand_default(self.rng())\n    b = rng_k([size], dtype)\n\n    def sparse_solve(data, b, tol=1e-08):\n        return sparse.linalg.spsolve(data, indices, indptr, b, tol=tol)\n    jtu.check_grads(sparse_solve, (data, b), order=1, rtol=0.05, atol=0.05)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.custom_jvp\ndef sum(x):\n    return jnp.sum(x, axis=0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(a, b):\n    with set_xla_metadata(key2='val2'):\n        return a + b"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(a, b):\n    with set_xla_metadata(key2='val2'):\n        return a + b"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(a, b):\n    with set_xla_metadata(key2='val2'):\n        return a + b"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(a, b):\n    with set_xla_metadata(key2='val2'):\n        return a + b"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(a, b):\n    with set_xla_metadata(key2='val2'):\n        return a + b"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(n):\n    token = lax.create_token(n)\n    token = lax.fori_loop(0, n, doubler, token)\n    return n"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(n):\n    token = lax.create_token(n)\n    token = lax.fori_loop(0, n, doubler, token)\n    return n"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(n):\n    token = lax.create_token(n)\n    token = lax.fori_loop(0, n, doubler, token)\n    return n"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(n):\n    token = lax.create_token(n)\n    token = lax.fori_loop(0, n, doubler, token)\n    return n"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "@jax.jit\ndef f(n):\n    token = lax.create_token(n)\n    token = lax.fori_loop(0, n, doubler, token)\n    return n"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jnp.full_like(x, 2.0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jnp.full_like(x, 2.0)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jnp.full_like(x, 2.0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jnp.full_like(x, 2.0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x):\n    return jnp.full_like(x, 2.0)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(b):\n    return jax.scipy.sparse.linalg.cg(matvec, (b, b))[0]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(b):\n    return jax.scipy.sparse.linalg.cg(matvec, (b, b))[0]"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(b):\n    return jax.scipy.sparse.linalg.cg(matvec, (b, b))[0]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(b):\n    return jax.scipy.sparse.linalg.cg(matvec, (b, b))[0]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(b):\n    return jax.scipy.sparse.linalg.cg(matvec, (b, b))[0]"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, indices, indptr = sparse_csr._csr_fromdense(M, nse=(M != 0).sum())\n    row, col = sparse_util._csr_to_coo(indices, indptr)\n    f = lambda data: sparse_csr._csr_todense(data, indices, indptr, shape=M.shape)\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n\n    @jax.jit\n    def g(x):\n        return x * y\n    return g(x) + g(y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_csr_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_csr._csr_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n\n    @jax.jit\n    def g(x):\n        return x * y\n    return g(x) + g(y)"
  },
  {
    "test_code": "def test_coo_matmat_layout(self):\n    d = jnp.array([1.0, 2.0, 3.0, 4.0])\n    i = jnp.array([0, 0, 1, 2])\n    j = jnp.array([0, 2, 0, 0])\n    shape = (3, 3)\n    x = jnp.arange(9).reshape(3, 3).astype(d.dtype)\n\n    def f(x):\n        return sparse_coo._coo_matmat(d, i, j, x.T, spinfo=sparse_coo.COOInfo(shape=shape, rows_sorted=True))\n    result = f(x)\n    result_jit = jit(f)(x)\n    self.assertAllClose(result, result_jit)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n\n    @jax.jit\n    def g(x):\n        return x * y\n    return g(x) + g(y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_todense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    data, row, col = sparse_coo._coo_fromdense(M, nse=(M != 0).sum())\n    f = lambda data: sparse_coo._coo_todense(data, row, col, spinfo=sparse_coo.COOInfo(shape=M.shape, rows_sorted=True))\n    primals, tangents = jax.jvp(f, [data], [jnp.ones_like(data)])\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(tangents, jnp.zeros_like(M).at[row, col].set(1))\n    primals, vjp_fun = jax.vjp(f, data)\n    data_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals, f(data))\n    self.assertArraysEqual(data_out, data)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n\n    @jax.jit\n    def g(x):\n        return x * y\n    return g(x) + g(y)"
  },
  {
    "test_code": "@jtu.sample_product(shape=[(5, 8), (8, 5), (5, 5), (8, 8)], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\ndef test_coo_fromdense_ad(self, shape, dtype):\n    rng = sptu.rand_sparse(self.rng(), post=jnp.array)\n    M = rng(shape, dtype)\n    nse = (M != 0).sum()\n    f = lambda M: sparse_coo._coo_fromdense(M, nse=nse)\n    primals, tangents = jax.jvp(f, [M], [jnp.ones_like(M)])\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(tangents[0], jnp.ones(nse, dtype=dtype))\n    self.assertEqual(tangents[1].dtype, dtypes.float0)\n    self.assertEqual(tangents[2].dtype, dtypes.float0)\n    primals, vjp_fun = jax.vjp(f, M)\n    M_out, = vjp_fun(primals)\n    self.assertArraysEqual(primals[0], f(M)[0])\n    self.assertArraysEqual(primals[1], f(M)[1])\n    self.assertArraysEqual(primals[2], f(M)[2])\n    self.assertArraysEqual(M_out, M)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_test.py",
    "function": "def f(x, y):\n\n    @jax.jit\n    def g(x):\n        return x * y\n    return g(x) + g(y)"
  }
]