[
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_bcoo_extract_batching(self):\n    indices = jnp.zeros((4, 1, 1), dtype=int)\n    mat = jnp.arange(4.0).reshape((4, 1))\n    expected = jnp.vstack([sparse_bcoo._bcoo_extract(i, mat[0]) for i in indices])\n    actual = vmap(sparse_bcoo._bcoo_extract, in_axes=(0, None))(indices, mat[0])\n    self.assertArraysEqual(expected, actual)\n    expected = jnp.vstack([sparse_bcoo._bcoo_extract(indices[0], m) for m in mat])\n    actual = vmap(sparse_bcoo._bcoo_extract, in_axes=(None, 0))(indices[0], mat)\n    self.assertArraysEqual(expected, actual)\n    expected = jnp.vstack([sparse_bcoo._bcoo_extract(i, m) for i, m in zip(indices, mat)])\n    actual = vmap(sparse_bcoo._bcoo_extract, in_axes=0)(indices, mat)\n    self.assertArraysEqual(expected, actual)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "def test_bcoo_extract_zero_nse(self):\n    args_maker = lambda: (jnp.zeros((3, 2, 0), dtype='int32'), jnp.arange(3))\n    self._CompileAndCheck(sparse_bcoo._bcoo_extract, args_maker)\n    args_maker = lambda: (jnp.zeros((2, 0), dtype='int32'), jnp.arange(3))\n    self._CompileAndCheck(sparse_bcoo._bcoo_extract, args_maker)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "@jtu.sample_product([dict(n_batch=n_batch, n_dense=n_dense, lhs_shape=lhs_shape, rhs_shape=rhs_shape, dimension_numbers=dimension_numbers) for lhs_shape, rhs_shape, dimension_numbers, n_batch, n_dense in [((3, 3, 2), (3, 2, 4), (([2], [1]), ([0], [0])), 1, 0), ((3, 3, 2), (3, 2, 4), (([2], [1]), ([0], [0])), 1, 1), ((3, 3, 2), (3, 2, 4), (([2], [1]), ([0], [0])), 2, 0), ((3, 3, 2), (2, 3, 4), (([2], [0]), ([0], [1])), 1, 0), ((3, 3, 2), (2, 3, 4), (([2], [0]), ([0], [1])), 1, 1), ((3, 3, 2), (2, 3, 4), (([2], [0]), ([0], [1])), 2, 0), ((3, 4, 2, 4), (3, 4, 3, 2), (([2], [3]), ([0, 1], [0, 1])), 2, 0), ((3, 4, 2, 4), (3, 4, 3, 2), (([2], [3]), ([0, 1], [0, 1])), 2, 1)]], dtype=jtu.dtypes.floating)\n@jax.default_matmul_precision('float32')\ndef test_bcoo_dot_general_sampled_ad(self, lhs_shape, rhs_shape, dtype, dimension_numbers, n_batch, n_dense):\n    rng = jtu.rand_default(self.rng())\n    sprng = sptu.rand_sparse(self.rng())\n    out_shape = lax.dot_general(jnp.zeros(lhs_shape), jnp.zeros(rhs_shape), dimension_numbers=dimension_numbers).shape\n    lhs = rng(lhs_shape, dtype)\n    rhs = rng(rhs_shape, dtype)\n    indices = sparse.BCOO.fromdense(sprng(out_shape, dtype), n_batch=n_batch, n_dense=n_dense).indices\n\n    def dense_fun(lhs, rhs, indices):\n        AB = lax.dot_general(lhs, rhs, dimension_numbers=dimension_numbers)\n        return sparse_bcoo._bcoo_extract(indices, AB)\n\n    def sparse_fun(lhs, rhs, indices):\n        return sparse.bcoo_dot_general_sampled(lhs, rhs, indices, dimension_numbers=dimension_numbers)\n    jf_dense = jax.jacfwd(dense_fun)(lhs, rhs, indices)\n    jf_sparse = jax.jacfwd(sparse_fun)(lhs, rhs, indices)\n    jr_dense = jax.jacrev(dense_fun)(lhs, rhs, indices)\n    jr_sparse = jax.jacrev(sparse_fun)(lhs, rhs, indices)\n    self.assertAllClose(jf_sparse, jf_dense)\n    self.assertAllClose(jr_sparse, jr_dense)\n    self.assertAllClose(jf_sparse, jr_sparse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "@jtu.sample_product([dict(lhs_n_batch=lhs_n_batch, rhs_n_batch=rhs_n_batch, lhs_shape=lhs_shape, rhs_shape=rhs_shape, dimension_numbers=dimension_numbers) for lhs_shape, lhs_n_batch, rhs_shape, rhs_n_batch, dimension_numbers in [((5,), 0, (6,), 0, (([], []), ([], []))), ((3, 5), 0, (2, 4), 0, (([], []), ([], []))), ((3, 5), 1, (3, 4), 1, (([], []), ([0], [0]))), ((5,), 0, (5,), 0, (([0], [0]), ([], []))), ((7,), 0, (7,), 0, (([0], [0]), ([], []))), ((5, 7), 1, (7,), 0, (([1], [0]), ([], []))), ((2, 3, 4), 2, (2, 4), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4), 2, (2, 4), 1, (([2], [1]), ([], []))), ((2, 3, 4), 2, (3, 4), 1, (([2], [1]), ([1], [0]))), ((2, 3, 4), 2, (3, 4), 1, (([2], [1]), ([], []))), ((5, 7), 0, (7,), 0, (([1], [0]), ([], []))), ((2, 3, 4), 1, (4,), 0, (([2], [0]), ([], []))), ((2, 3, 4), 1, (2, 4), 1, (([2], [1]), ([0], [0]))), ((3, 2, 4), 1, (3, 4), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4), 0, (2,), 0, (([0], [0]), ([], []))), ((5, 7), 0, (7, 3), 0, (([1], [0]), ([], []))), ((2, 3, 4), 1, (4, 3), 0, (([2], [0]), ([], []))), ((2, 3, 4), 1, (2, 4, 3), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4, 3), 1, (2, 4, 3, 4), 1, (([2, 3], [1, 2]), ([0], [0]))), ((2, 3, 4, 3, 1), 2, (3, 2, 3, 4), 2, (([2, 3], [3, 2]), ([0, 1], [1, 0])))]], swap=[True, False], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\n@jax.default_matmul_precision('float32')\n@jtu.skip_on_flag('jax_skip_slow_tests', True)\ndef test_bcoo_spdot_general(self, lhs_shape, lhs_n_batch, rhs_shape, rhs_n_batch, dtype, swap, dimension_numbers):\n    if swap:\n        dimension_numbers = tuple((d[::-1] for d in dimension_numbers))\n        lhs_shape, rhs_shape = (rhs_shape, lhs_shape)\n        lhs_n_batch, rhs_n_batch = (rhs_n_batch, lhs_n_batch)\n    lhs_n_sparse = len(lhs_shape) - lhs_n_batch\n    rhs_batch = dimension_numbers[1][1]\n    lhs_contracting = dimension_numbers[0][0]\n    should_error = rhs_n_batch > len(rhs_batch) and lhs_n_sparse > len(lhs_contracting)\n    sprng = sptu.rand_bcoo(self.rng())\n    args_maker = lambda: [sprng(lhs_shape, dtype, n_batch=lhs_n_batch), sprng(rhs_shape, dtype, n_batch=rhs_n_batch)]\n\n    def f_dense(x, y):\n        return lax.dot_general(x, y, dimension_numbers=dimension_numbers)\n\n    def f_sparse(xsp, ysp):\n        return sparse.bcoo_dot_general(xsp, ysp, dimension_numbers=dimension_numbers)\n    if should_error:\n        with self.assertRaisesRegex(ValueError, '.*cannot have unused batch dims on rhs with unused sparse dims on lhs.'):\n            f_sparse(*args_maker())\n    else:\n        tol = {'float32': 1e-05, 'complex64': 1e-05, 'float64': 1e-14, 'complex128': 1e-14}\n        self._CheckAgainstDense(f_dense, f_sparse, args_maker, tol=tol)\n        self._CheckBatchingSparse(f_dense, f_sparse, args_maker, tol=tol)\n        if jnp.issubdtype(dtype, jnp.floating):\n            self._CheckGradsSparse(f_dense, f_sparse, args_maker, modes=['fwd'])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    \"\"\"Test the set of inputs np.geomspace is well-defined on.\"\"\"\n    start, stop = self._GetArgsMaker(rng, [start_shape, stop_shape], [dtype, dtype])()\n    start, stop = jnp.broadcast_arrays(start, stop)\n    if dtype in complex_dtypes:\n        return (start, stop)\n    start = start * jnp.sign(start) * jnp.sign(stop)\n    return (start, stop)"
  },
  {
    "test_code": "@jtu.sample_product([dict(shape=shape, n_batch=layout.n_batch, n_dense=layout.n_dense) for shape in [(), (5,), (5, 8), (3, 4, 5), (3, 4, 3, 2)] for layout in sptu.iter_sparse_layouts(shape)], dtype=jtu.dtypes.numeric)\ndef test_bcoo_slice(self, shape, dtype, n_batch, n_dense):\n    rng = self.rng()\n    sprng = sptu.rand_bcoo(rng, n_batch=n_batch, n_dense=n_dense)\n    args_maker = lambda: [sprng(shape, dtype)]\n    slices = rng.randint(0, np.array(shape) + 1, (2, len(shape))).T\n    slices.sort(1)\n    start_indices, limit_indices = unzip2(slices)\n    strides = list(rng.randint(1, 4, len(shape)))\n    kwds = dict(start_indices=start_indices, limit_indices=limit_indices, strides=strides)\n    dense_func = partial(lax.slice, **kwds)\n    sparse_func = partial(sparse.bcoo_slice, **kwds)\n    self._CheckAgainstDense(dense_func, sparse_func, args_maker)\n    if jnp.issubdtype(dtype, jnp.floating):\n        self._CheckGradsSparse(dense_func, sparse_func, args_maker)\n    mat, = args_maker()\n    out = sparse_func(mat)\n    self.assertEqual(mat.n_batch, out.n_batch)\n    self.assertEqual(mat.n_sparse, out.n_sparse)\n    self.assertEqual(mat.n_dense, out.n_dense)\n    max_nse = math.prod(out.shape[out.n_batch:out.n_batch + out.n_sparse])\n    self.assertLessEqual(out.nse, max_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    \"\"\"Test the set of inputs np.geomspace is well-defined on.\"\"\"\n    start, stop = self._GetArgsMaker(rng, [start_shape, stop_shape], [dtype, dtype])()\n    start, stop = jnp.broadcast_arrays(start, stop)\n    if dtype in complex_dtypes:\n        return (start, stop)\n    start = start * jnp.sign(start) * jnp.sign(stop)\n    return (start, stop)"
  },
  {
    "test_code": "@jtu.sample_product([dict(shape=shape, n_batch=layout.n_batch, n_dense=layout.n_dense) for shape in [(), (5,), (5, 8), (3, 4, 5), (3, 4, 3, 2)] for layout in sptu.iter_sparse_layouts(shape)], dtype=jtu.dtypes.numeric)\ndef test_bcoo_dynamic_slice(self, shape, dtype, n_batch, n_dense):\n    rng = self.rng()\n    sprng = sptu.rand_bcoo(rng, n_batch=n_batch, n_dense=n_dense)\n    args_maker = lambda: [sprng(shape, dtype)]\n    rng = self.rng()\n    start_indices = rng.randint(-max(shape, default=0), max(shape, default=0), len(shape))\n    slice_sizes = rng.randint(0, shape, len(shape))\n    kwds = dict(start_indices=start_indices, slice_sizes=slice_sizes)\n    dense_func = partial(lax.dynamic_slice, **kwds)\n    sparse_func = partial(sparse.bcoo_dynamic_slice, **kwds)\n    self._CheckAgainstDense(dense_func, sparse_func, args_maker)\n    if jnp.issubdtype(dtype, jnp.floating):\n        self._CheckGradsSparse(dense_func, sparse_func, args_maker)\n    mat, = args_maker()\n    out = sparse_func(mat)\n    self.assertEqual(mat.n_batch, out.n_batch)\n    self.assertEqual(mat.n_sparse, out.n_sparse)\n    self.assertEqual(mat.n_dense, out.n_dense)\n    max_nse = math.prod(out.shape[out.n_batch:out.n_batch + out.n_sparse])\n    self.assertLessEqual(out.nse, max_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    \"\"\"Test the set of inputs np.geomspace is well-defined on.\"\"\"\n    start, stop = self._GetArgsMaker(rng, [start_shape, stop_shape], [dtype, dtype])()\n    start, stop = jnp.broadcast_arrays(start, stop)\n    if dtype in complex_dtypes:\n        return (start, stop)\n    start = start * jnp.sign(start) * jnp.sign(stop)\n    return (start, stop)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "@jtu.sample_product([dict(lhs_n_batch=lhs_n_batch, rhs_n_batch=rhs_n_batch, lhs_shape=lhs_shape, rhs_shape=rhs_shape, dimension_numbers=dimension_numbers) for lhs_shape, lhs_n_batch, rhs_shape, rhs_n_batch, dimension_numbers in [((5,), 0, (6,), 0, (([], []), ([], []))), ((3, 5), 0, (2, 4), 0, (([], []), ([], []))), ((3, 5), 1, (3, 4), 1, (([], []), ([0], [0]))), ((5,), 0, (5,), 0, (([0], [0]), ([], []))), ((7,), 0, (7,), 0, (([0], [0]), ([], []))), ((5, 7), 1, (7,), 0, (([1], [0]), ([], []))), ((2, 3, 4), 2, (2, 4), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4), 2, (2, 4), 1, (([2], [1]), ([], []))), ((2, 3, 4), 2, (3, 4), 1, (([2], [1]), ([1], [0]))), ((2, 3, 4), 2, (3, 4), 1, (([2], [1]), ([], []))), ((5, 7), 0, (7,), 0, (([1], [0]), ([], []))), ((2, 3, 4), 1, (4,), 0, (([2], [0]), ([], []))), ((2, 3, 4), 1, (2, 4), 1, (([2], [1]), ([0], [0]))), ((3, 2, 4), 1, (3, 4), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4), 0, (2,), 0, (([0], [0]), ([], []))), ((5, 7), 0, (7, 3), 0, (([1], [0]), ([], []))), ((2, 3, 4), 1, (4, 3), 0, (([2], [0]), ([], []))), ((2, 3, 4), 1, (2, 4, 3), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4, 3), 1, (2, 4, 3, 4), 1, (([2, 3], [1, 2]), ([0], [0]))), ((2, 3, 4, 3, 1), 2, (3, 2, 3, 4), 2, (([2, 3], [3, 2]), ([0, 1], [1, 0])))]], swap=[True, False], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\n@jax.default_matmul_precision('float32')\n@jtu.skip_on_flag('jax_skip_slow_tests', True)\ndef test_bcoo_spdot_general(self, lhs_shape, lhs_n_batch, rhs_shape, rhs_n_batch, dtype, swap, dimension_numbers):\n    if swap:\n        dimension_numbers = tuple((d[::-1] for d in dimension_numbers))\n        lhs_shape, rhs_shape = (rhs_shape, lhs_shape)\n        lhs_n_batch, rhs_n_batch = (rhs_n_batch, lhs_n_batch)\n    lhs_n_sparse = len(lhs_shape) - lhs_n_batch\n    rhs_batch = dimension_numbers[1][1]\n    lhs_contracting = dimension_numbers[0][0]\n    should_error = rhs_n_batch > len(rhs_batch) and lhs_n_sparse > len(lhs_contracting)\n    sprng = sptu.rand_bcoo(self.rng())\n    args_maker = lambda: [sprng(lhs_shape, dtype, n_batch=lhs_n_batch), sprng(rhs_shape, dtype, n_batch=rhs_n_batch)]\n\n    def f_dense(x, y):\n        return lax.dot_general(x, y, dimension_numbers=dimension_numbers)\n\n    def f_sparse(xsp, ysp):\n        return sparse.bcoo_dot_general(xsp, ysp, dimension_numbers=dimension_numbers)\n    if should_error:\n        with self.assertRaisesRegex(ValueError, '.*cannot have unused batch dims on rhs with unused sparse dims on lhs.'):\n            f_sparse(*args_maker())\n    else:\n        tol = {'float32': 1e-05, 'complex64': 1e-05, 'float64': 1e-14, 'complex128': 1e-14}\n        self._CheckAgainstDense(f_dense, f_sparse, args_maker, tol=tol)\n        self._CheckBatchingSparse(f_dense, f_sparse, args_maker, tol=tol)\n        if jnp.issubdtype(dtype, jnp.floating):\n            self._CheckGradsSparse(f_dense, f_sparse, args_maker, modes=['fwd'])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    \"\"\"Test the set of inputs np.geomspace is well-defined on.\"\"\"\n    start, stop = self._GetArgsMaker(rng, [start_shape, stop_shape], [dtype, dtype])()\n    start, stop = jnp.broadcast_arrays(start, stop)\n    if dtype in complex_dtypes:\n        return (start, stop)\n    start = start * jnp.sign(start) * jnp.sign(stop)\n    return (start, stop)"
  },
  {
    "test_code": "@jtu.sample_product([dict(shape=shape, n_batch=layout.n_batch, n_dense=layout.n_dense) for shape in [(), (5,), (5, 8), (3, 4, 5), (3, 4, 3, 2)] for layout in sptu.iter_sparse_layouts(shape)], dtype=jtu.dtypes.numeric)\ndef test_bcoo_slice(self, shape, dtype, n_batch, n_dense):\n    rng = self.rng()\n    sprng = sptu.rand_bcoo(rng, n_batch=n_batch, n_dense=n_dense)\n    args_maker = lambda: [sprng(shape, dtype)]\n    slices = rng.randint(0, np.array(shape) + 1, (2, len(shape))).T\n    slices.sort(1)\n    start_indices, limit_indices = unzip2(slices)\n    strides = list(rng.randint(1, 4, len(shape)))\n    kwds = dict(start_indices=start_indices, limit_indices=limit_indices, strides=strides)\n    dense_func = partial(lax.slice, **kwds)\n    sparse_func = partial(sparse.bcoo_slice, **kwds)\n    self._CheckAgainstDense(dense_func, sparse_func, args_maker)\n    if jnp.issubdtype(dtype, jnp.floating):\n        self._CheckGradsSparse(dense_func, sparse_func, args_maker)\n    mat, = args_maker()\n    out = sparse_func(mat)\n    self.assertEqual(mat.n_batch, out.n_batch)\n    self.assertEqual(mat.n_sparse, out.n_sparse)\n    self.assertEqual(mat.n_dense, out.n_dense)\n    max_nse = math.prod(out.shape[out.n_batch:out.n_batch + out.n_sparse])\n    self.assertLessEqual(out.nse, max_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    \"\"\"Test the set of inputs np.geomspace is well-defined on.\"\"\"\n    start, stop = self._GetArgsMaker(rng, [start_shape, stop_shape], [dtype, dtype])()\n    start, stop = jnp.broadcast_arrays(start, stop)\n    if dtype in complex_dtypes:\n        return (start, stop)\n    start = start * jnp.sign(start) * jnp.sign(stop)\n    return (start, stop)"
  },
  {
    "test_code": "@jtu.sample_product([dict(shape=shape, n_batch=layout.n_batch, n_dense=layout.n_dense) for shape in [(), (5,), (5, 8), (3, 4, 5), (3, 4, 3, 2)] for layout in sptu.iter_sparse_layouts(shape)], dtype=jtu.dtypes.numeric)\ndef test_bcoo_dynamic_slice(self, shape, dtype, n_batch, n_dense):\n    rng = self.rng()\n    sprng = sptu.rand_bcoo(rng, n_batch=n_batch, n_dense=n_dense)\n    args_maker = lambda: [sprng(shape, dtype)]\n    rng = self.rng()\n    start_indices = rng.randint(-max(shape, default=0), max(shape, default=0), len(shape))\n    slice_sizes = rng.randint(0, shape, len(shape))\n    kwds = dict(start_indices=start_indices, slice_sizes=slice_sizes)\n    dense_func = partial(lax.dynamic_slice, **kwds)\n    sparse_func = partial(sparse.bcoo_dynamic_slice, **kwds)\n    self._CheckAgainstDense(dense_func, sparse_func, args_maker)\n    if jnp.issubdtype(dtype, jnp.floating):\n        self._CheckGradsSparse(dense_func, sparse_func, args_maker)\n    mat, = args_maker()\n    out = sparse_func(mat)\n    self.assertEqual(mat.n_batch, out.n_batch)\n    self.assertEqual(mat.n_sparse, out.n_sparse)\n    self.assertEqual(mat.n_dense, out.n_dense)\n    max_nse = math.prod(out.shape[out.n_batch:out.n_batch + out.n_sparse])\n    self.assertLessEqual(out.nse, max_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    \"\"\"Test the set of inputs np.geomspace is well-defined on.\"\"\"\n    start, stop = self._GetArgsMaker(rng, [start_shape, stop_shape], [dtype, dtype])()\n    start, stop = jnp.broadcast_arrays(start, stop)\n    if dtype in complex_dtypes:\n        return (start, stop)\n    start = start * jnp.sign(start) * jnp.sign(stop)\n    return (start, stop)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "@jtu.sample_product([dict(lhs_n_batch=lhs_n_batch, rhs_n_batch=rhs_n_batch, lhs_shape=lhs_shape, rhs_shape=rhs_shape, dimension_numbers=dimension_numbers) for lhs_shape, lhs_n_batch, rhs_shape, rhs_n_batch, dimension_numbers in [((5,), 0, (6,), 0, (([], []), ([], []))), ((3, 5), 0, (2, 4), 0, (([], []), ([], []))), ((3, 5), 1, (3, 4), 1, (([], []), ([0], [0]))), ((5,), 0, (5,), 0, (([0], [0]), ([], []))), ((7,), 0, (7,), 0, (([0], [0]), ([], []))), ((5, 7), 1, (7,), 0, (([1], [0]), ([], []))), ((2, 3, 4), 2, (2, 4), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4), 2, (2, 4), 1, (([2], [1]), ([], []))), ((2, 3, 4), 2, (3, 4), 1, (([2], [1]), ([1], [0]))), ((2, 3, 4), 2, (3, 4), 1, (([2], [1]), ([], []))), ((5, 7), 0, (7,), 0, (([1], [0]), ([], []))), ((2, 3, 4), 1, (4,), 0, (([2], [0]), ([], []))), ((2, 3, 4), 1, (2, 4), 1, (([2], [1]), ([0], [0]))), ((3, 2, 4), 1, (3, 4), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4), 0, (2,), 0, (([0], [0]), ([], []))), ((5, 7), 0, (7, 3), 0, (([1], [0]), ([], []))), ((2, 3, 4), 1, (4, 3), 0, (([2], [0]), ([], []))), ((2, 3, 4), 1, (2, 4, 3), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4, 3), 1, (2, 4, 3, 4), 1, (([2, 3], [1, 2]), ([0], [0]))), ((2, 3, 4, 3, 1), 2, (3, 2, 3, 4), 2, (([2, 3], [3, 2]), ([0, 1], [1, 0])))]], swap=[True, False], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\n@jax.default_matmul_precision('float32')\n@jtu.skip_on_flag('jax_skip_slow_tests', True)\ndef test_bcoo_spdot_general(self, lhs_shape, lhs_n_batch, rhs_shape, rhs_n_batch, dtype, swap, dimension_numbers):\n    if swap:\n        dimension_numbers = tuple((d[::-1] for d in dimension_numbers))\n        lhs_shape, rhs_shape = (rhs_shape, lhs_shape)\n        lhs_n_batch, rhs_n_batch = (rhs_n_batch, lhs_n_batch)\n    lhs_n_sparse = len(lhs_shape) - lhs_n_batch\n    rhs_batch = dimension_numbers[1][1]\n    lhs_contracting = dimension_numbers[0][0]\n    should_error = rhs_n_batch > len(rhs_batch) and lhs_n_sparse > len(lhs_contracting)\n    sprng = sptu.rand_bcoo(self.rng())\n    args_maker = lambda: [sprng(lhs_shape, dtype, n_batch=lhs_n_batch), sprng(rhs_shape, dtype, n_batch=rhs_n_batch)]\n\n    def f_dense(x, y):\n        return lax.dot_general(x, y, dimension_numbers=dimension_numbers)\n\n    def f_sparse(xsp, ysp):\n        return sparse.bcoo_dot_general(xsp, ysp, dimension_numbers=dimension_numbers)\n    if should_error:\n        with self.assertRaisesRegex(ValueError, '.*cannot have unused batch dims on rhs with unused sparse dims on lhs.'):\n            f_sparse(*args_maker())\n    else:\n        tol = {'float32': 1e-05, 'complex64': 1e-05, 'float64': 1e-14, 'complex128': 1e-14}\n        self._CheckAgainstDense(f_dense, f_sparse, args_maker, tol=tol)\n        self._CheckBatchingSparse(f_dense, f_sparse, args_maker, tol=tol)\n        if jnp.issubdtype(dtype, jnp.floating):\n            self._CheckGradsSparse(f_dense, f_sparse, args_maker, modes=['fwd'])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    x = jnp.array(rng(shape, dtype))\n    if out_dtype in unsigned_dtypes:\n        x = 10 * jnp.abs(x)\n    return [x]"
  },
  {
    "test_code": "@jtu.sample_product([dict(shape=shape, n_batch=layout.n_batch, n_dense=layout.n_dense) for shape in [(), (5,), (5, 8), (3, 4, 5), (3, 4, 3, 2)] for layout in sptu.iter_sparse_layouts(shape)], dtype=jtu.dtypes.numeric)\ndef test_bcoo_slice(self, shape, dtype, n_batch, n_dense):\n    rng = self.rng()\n    sprng = sptu.rand_bcoo(rng, n_batch=n_batch, n_dense=n_dense)\n    args_maker = lambda: [sprng(shape, dtype)]\n    slices = rng.randint(0, np.array(shape) + 1, (2, len(shape))).T\n    slices.sort(1)\n    start_indices, limit_indices = unzip2(slices)\n    strides = list(rng.randint(1, 4, len(shape)))\n    kwds = dict(start_indices=start_indices, limit_indices=limit_indices, strides=strides)\n    dense_func = partial(lax.slice, **kwds)\n    sparse_func = partial(sparse.bcoo_slice, **kwds)\n    self._CheckAgainstDense(dense_func, sparse_func, args_maker)\n    if jnp.issubdtype(dtype, jnp.floating):\n        self._CheckGradsSparse(dense_func, sparse_func, args_maker)\n    mat, = args_maker()\n    out = sparse_func(mat)\n    self.assertEqual(mat.n_batch, out.n_batch)\n    self.assertEqual(mat.n_sparse, out.n_sparse)\n    self.assertEqual(mat.n_dense, out.n_dense)\n    max_nse = math.prod(out.shape[out.n_batch:out.n_batch + out.n_sparse])\n    self.assertLessEqual(out.nse, max_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    x = jnp.array(rng(shape, dtype))\n    if out_dtype in unsigned_dtypes:\n        x = 10 * jnp.abs(x)\n    return [x]"
  },
  {
    "test_code": "@jtu.sample_product([dict(shape=shape, n_batch=layout.n_batch, n_dense=layout.n_dense) for shape in [(), (5,), (5, 8), (3, 4, 5), (3, 4, 3, 2)] for layout in sptu.iter_sparse_layouts(shape)], dtype=jtu.dtypes.numeric)\ndef test_bcoo_dynamic_slice(self, shape, dtype, n_batch, n_dense):\n    rng = self.rng()\n    sprng = sptu.rand_bcoo(rng, n_batch=n_batch, n_dense=n_dense)\n    args_maker = lambda: [sprng(shape, dtype)]\n    rng = self.rng()\n    start_indices = rng.randint(-max(shape, default=0), max(shape, default=0), len(shape))\n    slice_sizes = rng.randint(0, shape, len(shape))\n    kwds = dict(start_indices=start_indices, slice_sizes=slice_sizes)\n    dense_func = partial(lax.dynamic_slice, **kwds)\n    sparse_func = partial(sparse.bcoo_dynamic_slice, **kwds)\n    self._CheckAgainstDense(dense_func, sparse_func, args_maker)\n    if jnp.issubdtype(dtype, jnp.floating):\n        self._CheckGradsSparse(dense_func, sparse_func, args_maker)\n    mat, = args_maker()\n    out = sparse_func(mat)\n    self.assertEqual(mat.n_batch, out.n_batch)\n    self.assertEqual(mat.n_sparse, out.n_sparse)\n    self.assertEqual(mat.n_dense, out.n_dense)\n    max_nse = math.prod(out.shape[out.n_batch:out.n_batch + out.n_sparse])\n    self.assertLessEqual(out.nse, max_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    x = jnp.array(rng(shape, dtype))\n    if out_dtype in unsigned_dtypes:\n        x = 10 * jnp.abs(x)\n    return [x]"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "@jtu.sample_product([dict(lhs_n_batch=lhs_n_batch, rhs_n_batch=rhs_n_batch, lhs_shape=lhs_shape, rhs_shape=rhs_shape, dimension_numbers=dimension_numbers) for lhs_shape, lhs_n_batch, rhs_shape, rhs_n_batch, dimension_numbers in [((5,), 0, (6,), 0, (([], []), ([], []))), ((3, 5), 0, (2, 4), 0, (([], []), ([], []))), ((3, 5), 1, (3, 4), 1, (([], []), ([0], [0]))), ((5,), 0, (5,), 0, (([0], [0]), ([], []))), ((7,), 0, (7,), 0, (([0], [0]), ([], []))), ((5, 7), 1, (7,), 0, (([1], [0]), ([], []))), ((2, 3, 4), 2, (2, 4), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4), 2, (2, 4), 1, (([2], [1]), ([], []))), ((2, 3, 4), 2, (3, 4), 1, (([2], [1]), ([1], [0]))), ((2, 3, 4), 2, (3, 4), 1, (([2], [1]), ([], []))), ((5, 7), 0, (7,), 0, (([1], [0]), ([], []))), ((2, 3, 4), 1, (4,), 0, (([2], [0]), ([], []))), ((2, 3, 4), 1, (2, 4), 1, (([2], [1]), ([0], [0]))), ((3, 2, 4), 1, (3, 4), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4), 0, (2,), 0, (([0], [0]), ([], []))), ((5, 7), 0, (7, 3), 0, (([1], [0]), ([], []))), ((2, 3, 4), 1, (4, 3), 0, (([2], [0]), ([], []))), ((2, 3, 4), 1, (2, 4, 3), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4, 3), 1, (2, 4, 3, 4), 1, (([2, 3], [1, 2]), ([0], [0]))), ((2, 3, 4, 3, 1), 2, (3, 2, 3, 4), 2, (([2, 3], [3, 2]), ([0, 1], [1, 0])))]], swap=[True, False], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\n@jax.default_matmul_precision('float32')\n@jtu.skip_on_flag('jax_skip_slow_tests', True)\ndef test_bcoo_spdot_general(self, lhs_shape, lhs_n_batch, rhs_shape, rhs_n_batch, dtype, swap, dimension_numbers):\n    if swap:\n        dimension_numbers = tuple((d[::-1] for d in dimension_numbers))\n        lhs_shape, rhs_shape = (rhs_shape, lhs_shape)\n        lhs_n_batch, rhs_n_batch = (rhs_n_batch, lhs_n_batch)\n    lhs_n_sparse = len(lhs_shape) - lhs_n_batch\n    rhs_batch = dimension_numbers[1][1]\n    lhs_contracting = dimension_numbers[0][0]\n    should_error = rhs_n_batch > len(rhs_batch) and lhs_n_sparse > len(lhs_contracting)\n    sprng = sptu.rand_bcoo(self.rng())\n    args_maker = lambda: [sprng(lhs_shape, dtype, n_batch=lhs_n_batch), sprng(rhs_shape, dtype, n_batch=rhs_n_batch)]\n\n    def f_dense(x, y):\n        return lax.dot_general(x, y, dimension_numbers=dimension_numbers)\n\n    def f_sparse(xsp, ysp):\n        return sparse.bcoo_dot_general(xsp, ysp, dimension_numbers=dimension_numbers)\n    if should_error:\n        with self.assertRaisesRegex(ValueError, '.*cannot have unused batch dims on rhs with unused sparse dims on lhs.'):\n            f_sparse(*args_maker())\n    else:\n        tol = {'float32': 1e-05, 'complex64': 1e-05, 'float64': 1e-14, 'complex128': 1e-14}\n        self._CheckAgainstDense(f_dense, f_sparse, args_maker, tol=tol)\n        self._CheckBatchingSparse(f_dense, f_sparse, args_maker, tol=tol)\n        if jnp.issubdtype(dtype, jnp.floating):\n            self._CheckGradsSparse(f_dense, f_sparse, args_maker, modes=['fwd'])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    factor_shape = shape[:-1] + (2 * shape[-1],)\n    a = rng(factor_shape, dtype)\n    return [np.matmul(a, jnp.conj(T(a)))]"
  },
  {
    "test_code": "@jtu.sample_product([dict(shape=shape, n_batch=layout.n_batch, n_dense=layout.n_dense) for shape in [(), (5,), (5, 8), (3, 4, 5), (3, 4, 3, 2)] for layout in sptu.iter_sparse_layouts(shape)], dtype=jtu.dtypes.numeric)\ndef test_bcoo_slice(self, shape, dtype, n_batch, n_dense):\n    rng = self.rng()\n    sprng = sptu.rand_bcoo(rng, n_batch=n_batch, n_dense=n_dense)\n    args_maker = lambda: [sprng(shape, dtype)]\n    slices = rng.randint(0, np.array(shape) + 1, (2, len(shape))).T\n    slices.sort(1)\n    start_indices, limit_indices = unzip2(slices)\n    strides = list(rng.randint(1, 4, len(shape)))\n    kwds = dict(start_indices=start_indices, limit_indices=limit_indices, strides=strides)\n    dense_func = partial(lax.slice, **kwds)\n    sparse_func = partial(sparse.bcoo_slice, **kwds)\n    self._CheckAgainstDense(dense_func, sparse_func, args_maker)\n    if jnp.issubdtype(dtype, jnp.floating):\n        self._CheckGradsSparse(dense_func, sparse_func, args_maker)\n    mat, = args_maker()\n    out = sparse_func(mat)\n    self.assertEqual(mat.n_batch, out.n_batch)\n    self.assertEqual(mat.n_sparse, out.n_sparse)\n    self.assertEqual(mat.n_dense, out.n_dense)\n    max_nse = math.prod(out.shape[out.n_batch:out.n_batch + out.n_sparse])\n    self.assertLessEqual(out.nse, max_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    factor_shape = shape[:-1] + (2 * shape[-1],)\n    a = rng(factor_shape, dtype)\n    return [np.matmul(a, jnp.conj(T(a)))]"
  },
  {
    "test_code": "@jtu.sample_product([dict(shape=shape, n_batch=layout.n_batch, n_dense=layout.n_dense) for shape in [(), (5,), (5, 8), (3, 4, 5), (3, 4, 3, 2)] for layout in sptu.iter_sparse_layouts(shape)], dtype=jtu.dtypes.numeric)\ndef test_bcoo_dynamic_slice(self, shape, dtype, n_batch, n_dense):\n    rng = self.rng()\n    sprng = sptu.rand_bcoo(rng, n_batch=n_batch, n_dense=n_dense)\n    args_maker = lambda: [sprng(shape, dtype)]\n    rng = self.rng()\n    start_indices = rng.randint(-max(shape, default=0), max(shape, default=0), len(shape))\n    slice_sizes = rng.randint(0, shape, len(shape))\n    kwds = dict(start_indices=start_indices, slice_sizes=slice_sizes)\n    dense_func = partial(lax.dynamic_slice, **kwds)\n    sparse_func = partial(sparse.bcoo_dynamic_slice, **kwds)\n    self._CheckAgainstDense(dense_func, sparse_func, args_maker)\n    if jnp.issubdtype(dtype, jnp.floating):\n        self._CheckGradsSparse(dense_func, sparse_func, args_maker)\n    mat, = args_maker()\n    out = sparse_func(mat)\n    self.assertEqual(mat.n_batch, out.n_batch)\n    self.assertEqual(mat.n_sparse, out.n_sparse)\n    self.assertEqual(mat.n_dense, out.n_dense)\n    max_nse = math.prod(out.shape[out.n_batch:out.n_batch + out.n_sparse])\n    self.assertLessEqual(out.nse, max_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    factor_shape = shape[:-1] + (2 * shape[-1],)\n    a = rng(factor_shape, dtype)\n    return [np.matmul(a, jnp.conj(T(a)))]"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@colocated_python.colocated_python\ndef f(x):\n    out_arrays = []\n    for shard in x.addressable_shards:\n        np_array = jax.device_get(shard.data)\n        input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n        output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n        out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n        out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n    out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    return out"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def f(x, y):\n    s = jit(jnp.sin)(x)\n    return jnp.sin(s) + jnp.cos(y)"
  },
  {
    "test_code": "@jtu.sample_product([dict(lhs_n_batch=lhs_n_batch, rhs_n_batch=rhs_n_batch, lhs_shape=lhs_shape, rhs_shape=rhs_shape, dimension_numbers=dimension_numbers) for lhs_shape, lhs_n_batch, rhs_shape, rhs_n_batch, dimension_numbers in [((5,), 0, (6,), 0, (([], []), ([], []))), ((3, 5), 0, (2, 4), 0, (([], []), ([], []))), ((3, 5), 1, (3, 4), 1, (([], []), ([0], [0]))), ((5,), 0, (5,), 0, (([0], [0]), ([], []))), ((7,), 0, (7,), 0, (([0], [0]), ([], []))), ((5, 7), 1, (7,), 0, (([1], [0]), ([], []))), ((2, 3, 4), 2, (2, 4), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4), 2, (2, 4), 1, (([2], [1]), ([], []))), ((2, 3, 4), 2, (3, 4), 1, (([2], [1]), ([1], [0]))), ((2, 3, 4), 2, (3, 4), 1, (([2], [1]), ([], []))), ((5, 7), 0, (7,), 0, (([1], [0]), ([], []))), ((2, 3, 4), 1, (4,), 0, (([2], [0]), ([], []))), ((2, 3, 4), 1, (2, 4), 1, (([2], [1]), ([0], [0]))), ((3, 2, 4), 1, (3, 4), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4), 0, (2,), 0, (([0], [0]), ([], []))), ((5, 7), 0, (7, 3), 0, (([1], [0]), ([], []))), ((2, 3, 4), 1, (4, 3), 0, (([2], [0]), ([], []))), ((2, 3, 4), 1, (2, 4, 3), 1, (([2], [1]), ([0], [0]))), ((2, 3, 4, 3), 1, (2, 4, 3, 4), 1, (([2, 3], [1, 2]), ([0], [0]))), ((2, 3, 4, 3, 1), 2, (3, 2, 3, 4), 2, (([2, 3], [3, 2]), ([0, 1], [1, 0])))]], swap=[True, False], dtype=jtu.dtypes.floating + jtu.dtypes.complex)\n@jax.default_matmul_precision('float32')\n@jtu.skip_on_flag('jax_skip_slow_tests', True)\ndef test_bcoo_spdot_general(self, lhs_shape, lhs_n_batch, rhs_shape, rhs_n_batch, dtype, swap, dimension_numbers):\n    if swap:\n        dimension_numbers = tuple((d[::-1] for d in dimension_numbers))\n        lhs_shape, rhs_shape = (rhs_shape, lhs_shape)\n        lhs_n_batch, rhs_n_batch = (rhs_n_batch, lhs_n_batch)\n    lhs_n_sparse = len(lhs_shape) - lhs_n_batch\n    rhs_batch = dimension_numbers[1][1]\n    lhs_contracting = dimension_numbers[0][0]\n    should_error = rhs_n_batch > len(rhs_batch) and lhs_n_sparse > len(lhs_contracting)\n    sprng = sptu.rand_bcoo(self.rng())\n    args_maker = lambda: [sprng(lhs_shape, dtype, n_batch=lhs_n_batch), sprng(rhs_shape, dtype, n_batch=rhs_n_batch)]\n\n    def f_dense(x, y):\n        return lax.dot_general(x, y, dimension_numbers=dimension_numbers)\n\n    def f_sparse(xsp, ysp):\n        return sparse.bcoo_dot_general(xsp, ysp, dimension_numbers=dimension_numbers)\n    if should_error:\n        with self.assertRaisesRegex(ValueError, '.*cannot have unused batch dims on rhs with unused sparse dims on lhs.'):\n            f_sparse(*args_maker())\n    else:\n        tol = {'float32': 1e-05, 'complex64': 1e-05, 'float64': 1e-14, 'complex128': 1e-14}\n        self._CheckAgainstDense(f_dense, f_sparse, args_maker, tol=tol)\n        self._CheckBatchingSparse(f_dense, f_sparse, args_maker, tol=tol)\n        if jnp.issubdtype(dtype, jnp.floating):\n            self._CheckGradsSparse(f_dense, f_sparse, args_maker, modes=['fwd'])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    p = rng((length,), dtype)\n    return [jnp.concatenate([jnp.zeros(leading, p.dtype), p, jnp.zeros(trailing, p.dtype)])]"
  },
  {
    "test_code": "@jtu.sample_product([dict(shape=shape, n_batch=layout.n_batch, n_dense=layout.n_dense) for shape in [(), (5,), (5, 8), (3, 4, 5), (3, 4, 3, 2)] for layout in sptu.iter_sparse_layouts(shape)], dtype=jtu.dtypes.numeric)\ndef test_bcoo_slice(self, shape, dtype, n_batch, n_dense):\n    rng = self.rng()\n    sprng = sptu.rand_bcoo(rng, n_batch=n_batch, n_dense=n_dense)\n    args_maker = lambda: [sprng(shape, dtype)]\n    slices = rng.randint(0, np.array(shape) + 1, (2, len(shape))).T\n    slices.sort(1)\n    start_indices, limit_indices = unzip2(slices)\n    strides = list(rng.randint(1, 4, len(shape)))\n    kwds = dict(start_indices=start_indices, limit_indices=limit_indices, strides=strides)\n    dense_func = partial(lax.slice, **kwds)\n    sparse_func = partial(sparse.bcoo_slice, **kwds)\n    self._CheckAgainstDense(dense_func, sparse_func, args_maker)\n    if jnp.issubdtype(dtype, jnp.floating):\n        self._CheckGradsSparse(dense_func, sparse_func, args_maker)\n    mat, = args_maker()\n    out = sparse_func(mat)\n    self.assertEqual(mat.n_batch, out.n_batch)\n    self.assertEqual(mat.n_sparse, out.n_sparse)\n    self.assertEqual(mat.n_dense, out.n_dense)\n    max_nse = math.prod(out.shape[out.n_batch:out.n_batch + out.n_sparse])\n    self.assertLessEqual(out.nse, max_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    p = rng((length,), dtype)\n    return [jnp.concatenate([jnp.zeros(leading, p.dtype), p, jnp.zeros(trailing, p.dtype)])]"
  },
  {
    "test_code": "@jtu.sample_product([dict(shape=shape, n_batch=layout.n_batch, n_dense=layout.n_dense) for shape in [(), (5,), (5, 8), (3, 4, 5), (3, 4, 3, 2)] for layout in sptu.iter_sparse_layouts(shape)], dtype=jtu.dtypes.numeric)\ndef test_bcoo_dynamic_slice(self, shape, dtype, n_batch, n_dense):\n    rng = self.rng()\n    sprng = sptu.rand_bcoo(rng, n_batch=n_batch, n_dense=n_dense)\n    args_maker = lambda: [sprng(shape, dtype)]\n    rng = self.rng()\n    start_indices = rng.randint(-max(shape, default=0), max(shape, default=0), len(shape))\n    slice_sizes = rng.randint(0, shape, len(shape))\n    kwds = dict(start_indices=start_indices, slice_sizes=slice_sizes)\n    dense_func = partial(lax.dynamic_slice, **kwds)\n    sparse_func = partial(sparse.bcoo_dynamic_slice, **kwds)\n    self._CheckAgainstDense(dense_func, sparse_func, args_maker)\n    if jnp.issubdtype(dtype, jnp.floating):\n        self._CheckGradsSparse(dense_func, sparse_func, args_maker)\n    mat, = args_maker()\n    out = sparse_func(mat)\n    self.assertEqual(mat.n_batch, out.n_batch)\n    self.assertEqual(mat.n_sparse, out.n_sparse)\n    self.assertEqual(mat.n_dense, out.n_dense)\n    max_nse = math.prod(out.shape[out.n_batch:out.n_batch + out.n_sparse])\n    self.assertLessEqual(out.nse, max_nse)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def args_maker():\n    p = rng((length,), dtype)\n    return [jnp.concatenate([jnp.zeros(leading, p.dtype), p, jnp.zeros(trailing, p.dtype)])]"
  },
  {
    "test_code": "def test_repr(self):\n    x = sparse.BCOO.fromdense(jnp.arange(5, dtype='float32'))\n    self.assertEqual(repr(x), 'BCOO(float32[5], nse=4)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=3, n_batch=1)')\n    y = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3), n_batch=1, n_dense=1)\n    self.assertEqual(repr(y), 'BCOO(float32[2, 3], nse=1, n_batch=1, n_dense=1)')\n    M_invalid = sparse.BCOO.fromdense(jnp.arange(6, dtype='float32').reshape(2, 3))\n    M_invalid.indices = jnp.array([])\n    self.assertEqual(repr(M_invalid), 'BCOO(<invalid>)')\n\n    @jit\n    def f(x):\n        self.assertEqual(repr(x), 'DynamicJaxprTracer[BCOO(float32[5], nse=4)]')\n    f(x)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "@partial(jax.jit, in_shardings=NamedSharding(mesh, PartitionSpec('x')), out_shardings=NamedSharding(mesh, PartitionSpec('x')), compiler_options=compiler_options)\ndef f(x):\n    agg = x\n    for _ in range(its):\n        agg = agg @ x\n    return agg"
  },
  {
    "test_code": "@jtu.sample_product(props=_generate_bcoo_dot_general_sampled_properties(), dtype=jtu.dtypes.floating + jtu.dtypes.complex)\n@jax.default_matmul_precision('float32')\n@jtu.skip_on_flag('jax_skip_slow_tests', True)\ndef test_bcoo_dot_general_sampled(self, props, dtype):\n    rng = jtu.rand_default(self.rng())\n    sprng = sptu.rand_bcoo(self.rng(), n_batch=props.n_batch, n_dense=props.n_dense)\n    out = jax.eval_shape(partial(lax.dot_general, dimension_numbers=props.dimension_numbers), jax.ShapeDtypeStruct(props.lhs_shape, dtype), jax.ShapeDtypeStruct(props.rhs_shape, dtype))\n    args_maker = lambda: [rng(props.lhs_shape, dtype), rng(props.rhs_shape, dtype), sprng(out.shape, dtype).indices]\n\n    def dense_fun(lhs, rhs, indices):\n        AB = lax.dot_general(lhs, rhs, dimension_numbers=props.dimension_numbers)\n        return sparse_bcoo._bcoo_extract(indices, AB)\n\n    def sparse_fun(lhs, rhs, indices):\n        return sparse.bcoo_dot_general_sampled(lhs, rhs, indices, dimension_numbers=props.dimension_numbers)\n    self._CheckAgainstDense(dense_fun, sparse_fun, args_maker)\n    if jnp.issubdtype(dtype, jnp.floating):\n        self._CheckGradsSparse(dense_fun, sparse_fun, args_maker, modes=['rev'], argnums=[0, 1])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/sparse_bcoo_bcsr_test.py",
    "function": "def _generate_bcoo_dot_general_sampled_properties(shapes=((5,), (2, 3), (2, 3, 4), (2, 3, 4, 4))) -> sptu.BatchedDotGeneralProperties:\n    \"\"\"Generator of properties for bcoo_dot_general_sampled tests.\"\"\"\n    rng = random.Random(0)\n    for shape in shapes:\n        for batch_dims in sptu.iter_subsets(range(len(shape))):\n            for contracting_dims in sptu.iter_subsets(remaining(range(len(shape)), batch_dims)):\n                lhs_permute = rng.sample(range(len(shape)), len(shape))\n                rhs_permute = rng.sample(range(len(shape)), len(shape))\n                lhs_shape = tuple((shape[p] for p in lhs_permute))\n                rhs_shape = tuple((shape[p] for p in rhs_permute))\n                dimension_numbers = (([lhs_permute.index(d) for d in contracting_dims], [rhs_permute.index(d) for d in contracting_dims]), ([lhs_permute.index(d) for d in batch_dims], [rhs_permute.index(d) for d in batch_dims]))\n                out = jax.eval_shape(partial(lax.dot_general, dimension_numbers=dimension_numbers), jax.ShapeDtypeStruct(lhs_shape, 'float32'), jax.ShapeDtypeStruct(rhs_shape, 'float32'))\n                for layout in sptu.iter_sparse_layouts(out.shape):\n                    yield sptu.BatchedDotGeneralProperties(lhs_shape=lhs_shape, rhs_shape=rhs_shape, n_batch=layout.n_batch, n_dense=layout.n_dense, dimension_numbers=dimension_numbers)"
  }
]