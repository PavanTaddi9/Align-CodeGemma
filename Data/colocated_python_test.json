[
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\ndef f():\n    return jnp.zeros([32, 10])"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f(x, r):\n    x = x.at[:, 0].set(x[:, 0] / r)\n    return x"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@partial(jnp.vectorize, excluded={1})\ndef f(x, y):\n    assert x.ndim == 0\n    assert y == 'foo'\n    return x"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.pmap\ndef f(x, y):\n    return x * y"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.jit\ndef f(x, y):\n    return jax.vmap(shard_alike, in_axes=(0, 1))(x, y)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f():\n    return random.uniform(self.make_key(3), (308000000, 128), dtype=jnp.bfloat16)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x):\n    return jax.lax.convert_element_type(x, FooTy())"
  },
  {
    "test_code": "def testInputsWithDifferentDeviceOrders(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())[:2]\n    if len(cpu_devices) < 2:\n        self.skipTest('Not enough CPU devices')\n\n    @colocated_python.colocated_python\n    def add(x: jax.Array, y: jax.Array) -> jax.Array:\n        arrays = [x.addressable_shards[1].data + y.addressable_shards[0].data, x.addressable_shards[0].data + y.addressable_shards[1].data]\n        return jax.make_array_from_single_device_arrays(y.shape, y.sharding, arrays)\n    add = add.specialize(devices=cpu_devices)\n    mesh1 = jax.sharding.Mesh([cpu_devices[0], cpu_devices[1]], 'x')\n    sharding1 = jax.sharding.NamedSharding(mesh1, jax.sharding.PartitionSpec('x'))\n    mesh2 = jax.sharding.Mesh([cpu_devices[1], cpu_devices[0]], 'x')\n    sharding2 = jax.sharding.NamedSharding(mesh2, jax.sharding.PartitionSpec('x'))\n    x = np.array([0, 2])\n    x = jax.device_put(x, sharding1)\n    y = np.array([4, 8])\n    y = jax.device_put(y, sharding2)\n    out = add(x, y)\n    self.assertEqual(out.sharding, sharding2)\n    out_device_list = [shard.device for shard in out.addressable_shards]\n    self.assertEqual(out_device_list, [cpu_devices[1], cpu_devices[0]])\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([2 + 4, 0 + 8]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@staticmethod\ndef add(dt, x, y):\n    fromscale = partial(jax.lax.convert_element_type, new_dtype=dt.float_dtype)\n    toscale = partial(jax.lax.convert_element_type, new_dtype=dt)\n    return toscale(jax.lax.max(fromscale(x), fromscale(y)))"
  },
  {
    "test_code": "def testStatefulObject(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n\n    @colocated_python.colocated_python_class\n    class Value:\n\n        def __init__(self, initial_value: np.ndarray) -> None:\n            self.value = initial_value\n\n        def add(self, x: jax.Array) -> jax.Array:\n            self.value += np.asarray(x)\n            return jax.device_put(self.value, x.sharding)\n\n        def fetch(self, x: jax.Array) -> jax.Array:\n            return jax.device_put(self.value, x.sharding)\n    value = Value(np.array(5))\n    x = np.array(1)\n    x = jax.device_put(x, cpu_devices[0])\n    out = jax.device_get(value.add(x))\n    self.assertEqual(out, np.array(6))\n    out = jax.device_get(value.add(x))\n    self.assertEqual(out, np.array(7))\n    out = jax.device_get(value.fetch(x))\n    self.assertEqual(out, np.array(7))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@staticmethod\ndef add(dt, x, y):\n    fromscale = partial(jax.lax.convert_element_type, new_dtype=dt.float_dtype)\n    toscale = partial(jax.lax.convert_element_type, new_dtype=dt)\n    return toscale(jax.lax.max(fromscale(x), fromscale(y)))"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x):\n    y = x * jnp.arange(3.0).reshape((1, 3))\n    return jnp.take_along_axis(y, idx, -1).sum()"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@partial(shard_map, mesh=mesh, in_specs=P('i'), out_specs=P())\ndef f(x):\n    return jax.lax.psum(((w * x) ** 2).sum(), 'i')"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(seed):\n    key = jax.random.key(seed)\n    return jax.random.uniform(key) + jax.random.normal(key)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x_ref):\n    ones = jnp.ones_like(x_ref)[slc]\n    ref_primitives.ref_addupdate(x_ref, slc, ones)\n    x1 = ref_primitives.ref_get(x_ref, slc)\n    x2 = x1 + ones\n    ref_primitives.ref_set(x_ref, slc, x2)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(self, ys):\n    return lax.fori_loop(0, 10, loop_body, jnp.ones(4, np.float32))"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(hx, _):\n    hx = jax.nn.sigmoid(hx + a)\n    return (hx, None)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x):\n    u, s, v = jnp.linalg.svd(a + x * b, full_matrices=full_matrices, compute_uv=compute_uv)\n    vdiag = jnp.vectorize(jnp.diag, signature='(k)->(k,k)')\n    return jnp.matmul(jnp.matmul(u, vdiag(s).astype(u.dtype)), v).real"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@jax.profiler.annotate_function\ndef f(x, *, name):\n    return x + 2 * len(name)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@partial(jax.jit, out_shardings=out_layout, donate_argnums=0)\ndef f(x):\n    return x * 2"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(z):\n    x_re = jnp.concatenate([jnp.real(z), jnp.imag(z)])\n    return f_re(x_re)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@run_state\ndef f(x_ref):\n    x = x_ref[...]\n\n    def _body(ref):\n        ref[...] = jnp.sin(ref[...])\n    x = run_state(_body)(x)\n    x_ref[...] = x"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@functools.partial(new_checkpoint, policy=policy)\ndef f(x):\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.einsum('ij,jk->ik', x, x, precision=lax.Precision.HIGHEST)\n    x = jnp.sin(x)\n    x = jnp.sum(x)\n    return x"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "@functools.partial(jax.jit, static_argnames=['c'])\ndef f(x, *, c):\n    return c * jnp.sin(x)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(x, y):\n\n    @partial(map_fun, in_axes=1, out_axes=2)\n    def h(y):\n        return jnp.sin(x + y)\n    return h(y).sum()"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(carry, x):\n    return (carry + jax.lax.psum(jnp.sum(x), axis_name='x'), None)"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def f(k1, k2, k3, k4):\n    batch_size = 1\n    seq_len = 1\n    input_size = 1\n    hidden_size = 1\n    bidirectional = False\n    num_directions = 2 if bidirectional else 1\n    num_layers = 1\n    x = jax.random.normal(k1, (batch_size, seq_len, input_size), dtype=jnp.float32)\n    h_0 = jax.random.normal(k2, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    c_0 = jax.random.normal(k3, (num_directions * num_layers, batch_size, hidden_size), dtype=jnp.float32)\n    seq_lengths = jnp.ones((batch_size,), dtype=jnp.int32) * seq_len\n    weights = rnn.init_lstm_weight(k4, input_size, hidden_size, num_layers, bidirectional)\n    return rnn.lstm(x, h_0, c_0, weights, seq_lengths=seq_lengths, input_size=input_size, hidden_size=hidden_size, num_layers=num_layers, dropout=False, bidirectional=bidirectional)"
  },
  {
    "test_code": "def testMakeColocatedPythonProgram(self):\n\n    def add_one(x):\n        return x + 1\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    sds = jax.ShapeDtypeStruct((), jnp.int32, sharding=sharding)\n    pickled_function = serialization._serialize(add_one)\n    program = ifrt_programs.make_colocated_python_program('add_one', pickled_function, [cpu_devices[0]], [sds], [sds])\n    del program",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "def testSimpleFunction(self):\n\n    @colocated_python.colocated_python\n    def add_one(x):\n        return x + 1\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    x = np.array(1)\n    x = jax.device_put(x, cpu_devices[0])\n    with _count_colocated_python_specialization_cache_miss() as count:\n        out = add_one(x)\n        out = jax.device_get(out)\n        self.assertEqual(out, np.array(2))\n        self.assertEqual(count(), 1)\n        out = add_one(x)\n        out = jax.device_get(out)\n        self.assertEqual(out, np.array(2))\n        self.assertEqual(count(), 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "def testSimpleFunctionWithTree(self):\n\n    @colocated_python.colocated_python\n    def add_one(x):\n        return jax.tree.map(lambda x: x + 1, x)\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    x = [np.array(1), (np.array(2), {'v': np.array(3)})]\n    x = jax.device_put(x, jax.sharding.SingleDeviceSharding(cpu_devices[0]))\n    with _count_colocated_python_specialization_cache_miss() as count:\n        out = add_one(x)\n        out = jax.device_get(out)\n        self.assertEqual(out, [np.array(2), (np.array(3), {'v': np.array(4)})])\n        self.assertEqual(count(), 1)\n        out = add_one(x)\n        out = jax.device_get(out)\n        self.assertEqual(out, [np.array(2), (np.array(3), {'v': np.array(4)})])\n        self.assertEqual(count(), 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "def testEmptyInputWithDevicesSpecialization(self):\n\n    @colocated_python.colocated_python\n    def make_zero():\n        return jnp.array(0)\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    with _count_colocated_python_specialization_cache_miss() as count:\n        make_zero = make_zero.specialize(devices=cpu_devices[:1])\n        out = make_zero()\n        out = jax.device_get(out)\n        self.assertEqual(out, np.array(0))\n        self.assertEqual(count(), 1)\n        out = make_zero()\n        out = jax.device_get(out)\n        self.assertEqual(out, np.array(0))\n        self.assertEqual(count(), 1)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "def testInputPolymorphismWithoutOutSpecsFn(self):\n\n    @colocated_python.colocated_python\n    def add_one(x):\n        return jax.tree.map(lambda x: x + 1, x)\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    x = np.array(1)\n    x = jax.device_put(x, cpu_devices[0])\n    with _count_colocated_python_specialization_cache_miss() as count:\n        out = add_one(x)\n        out = jax.device_get(out)\n        self.assertEqual(out, np.array(2))\n        self.assertEqual(count(), 1)\n        out = add_one(x)\n        out = jax.device_get(out)\n        self.assertEqual(out, np.array(2))\n        self.assertEqual(count(), 1)\n        x = [np.array(1), (np.array(2), {'v': np.array(3)})]\n        x = jax.device_put(x, jax.sharding.SingleDeviceSharding(cpu_devices[0]))\n        out = add_one(x)\n        out = jax.device_get(out)\n        self.assertEqual(out, [np.array(2), (np.array(3), {'v': np.array(4)})])\n        self.assertEqual(count(), 2)\n        out = add_one(x)\n        out = jax.device_get(out)\n        self.assertEqual(out, [np.array(2), (np.array(3), {'v': np.array(4)})])\n        self.assertEqual(count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "def testInputPolymorphismAllowedWithOutSpecsFn(self):\n\n    @colocated_python.colocated_python\n    def add_one(x):\n        return jax.tree.map(lambda x: x + 1, x)\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    x = np.array(1)\n    x = jax.device_put(x, cpu_devices[0])\n    with _count_colocated_python_specialization_cache_miss() as count:\n        add_one = add_one.specialize(out_specs_fn=lambda x: x)\n        out = add_one(x)\n        out = jax.device_get(out)\n        self.assertEqual(out, np.array(2))\n        self.assertEqual(count(), 1)\n        out = add_one(x)\n        out = jax.device_get(out)\n        self.assertEqual(out, np.array(2))\n        self.assertEqual(count(), 1)\n        x = [np.array(1), (np.array(2), {'v': np.array(3)})]\n        x = jax.device_put(x, jax.sharding.SingleDeviceSharding(cpu_devices[0]))\n        out = add_one(x)\n        out = jax.device_get(out)\n        self.assertEqual(out, [np.array(2), (np.array(3), {'v': np.array(4)})])\n        self.assertEqual(count(), 2)\n        out = add_one(x)\n        out = jax.device_get(out)\n        self.assertEqual(out, [np.array(2), (np.array(3), {'v': np.array(4)})])\n        self.assertEqual(count(), 2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "@parameterized.named_parameters(('on_main_thread', True), ('on_non_main_thread', False))\ndef testSequentialExecution(self, on_main_thread: bool):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    x = np.array(1)\n    x = jax.device_put(x, cpu_devices[0])\n    jax.block_until_ready(x)\n\n    @colocated_python.colocated_python\n    def sleep(x: jax.Array) -> jax.Array:\n        time.sleep(5)\n        return x\n    sleep = sleep.specialize(out_specs_fn=lambda x: x)\n\n    def sleep_twice_and_wait(x: jax.Array) -> None:\n        _ = sleep(x)\n        jax.block_until_ready(sleep(x))\n    start_time = time.time()\n    if on_main_thread:\n        sleep_twice_and_wait(x)\n    else:\n        t = threading.Thread(target=sleep_twice_and_wait, args=(x,))\n        t.start()\n        t.join()\n    elapsed_time = time.time() - start_time\n    self.assertGreaterEqual(elapsed_time, 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "def testConcurrentExecution(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    x = np.array(1)\n    x = jax.device_put(x, cpu_devices[0])\n    jax.block_until_ready(x)\n\n    @colocated_python.colocated_python\n    def sleep(x: jax.Array) -> jax.Array:\n        time.sleep(5)\n        return x\n    sleep = sleep.specialize(out_specs_fn=lambda x: x)\n\n    def sleep_and_wait(x: jax.Array) -> None:\n        jax.block_until_ready(sleep(x))\n    start_time = time.time()\n    t1 = threading.Thread(target=sleep_and_wait, args=(x,))\n    t2 = threading.Thread(target=sleep_and_wait, args=(x,))\n    t1.start()\n    t2.start()\n    sleep_and_wait(x)\n    t1.join()\n    t2.join()\n    elapsed_time = time.time() - start_time\n    self.assertGreaterEqual(elapsed_time, 5)\n    self.assertLess(elapsed_time, 10)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "def testInputsWithDifferentDeviceOrders(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())[:2]\n    if len(cpu_devices) < 2:\n        self.skipTest('Not enough CPU devices')\n\n    @colocated_python.colocated_python\n    def add(x: jax.Array, y: jax.Array) -> jax.Array:\n        arrays = [x.addressable_shards[1].data + y.addressable_shards[0].data, x.addressable_shards[0].data + y.addressable_shards[1].data]\n        return jax.make_array_from_single_device_arrays(y.shape, y.sharding, arrays)\n    add = add.specialize(devices=cpu_devices)\n    mesh1 = jax.sharding.Mesh([cpu_devices[0], cpu_devices[1]], 'x')\n    sharding1 = jax.sharding.NamedSharding(mesh1, jax.sharding.PartitionSpec('x'))\n    mesh2 = jax.sharding.Mesh([cpu_devices[1], cpu_devices[0]], 'x')\n    sharding2 = jax.sharding.NamedSharding(mesh2, jax.sharding.PartitionSpec('x'))\n    x = np.array([0, 2])\n    x = jax.device_put(x, sharding1)\n    y = np.array([4, 8])\n    y = jax.device_put(y, sharding2)\n    out = add(x, y)\n    self.assertEqual(out.sharding, sharding2)\n    out_device_list = [shard.device for shard in out.addressable_shards]\n    self.assertEqual(out_device_list, [cpu_devices[1], cpu_devices[0]])\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([2 + 4, 0 + 8]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "def testModuleVariableAccess(self):\n    try:\n        colocated_python._testing_non_serializable_object = tempfile.TemporaryFile()\n\n        @colocated_python.colocated_python\n        def set_global_state(x: jax.Array) -> jax.Array:\n            colocated_python._testing_global_state = x\n            return x + 1\n\n        @colocated_python.colocated_python\n        def get_global_state(x: jax.Array) -> jax.Array:\n            del x\n            return colocated_python._testing_global_state\n        cpu_devices = _colocated_cpu_devices(jax.local_devices())\n        x = np.array(1)\n        x = jax.device_put(x, cpu_devices[0])\n        y = np.array(2)\n        y = jax.device_put(y, cpu_devices[0])\n        jax.block_until_ready(set_global_state(x))\n        out = jax.device_get(get_global_state(y))\n        np.testing.assert_equal(out, np.array(1))\n    finally:\n        if '_testing_non_serializable_object' in colocated_python.__dict__:\n            colocated_python._testing_non_serializable_object.close()\n            del colocated_python._testing_non_serializable_object\n        if '_testing_global_state' in colocated_python.__dict__:\n            del colocated_python._testing_global_state",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "def testStringProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        upper_caser = np.vectorize(lambda x: x.upper(), otypes=[np.dtypes.StringDType()])\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            out_np_array = upper_caser(np_array)\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        return jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n    numpy_string_array = np.array([['abcd', 'efgh'], ['ijkl', 'mnop']], dtype=np.dtypes.StringDType())\n    mesh = jax.sharding.Mesh(np.array(cpu_devices[:2]).reshape((2, 1)), ('x', 'y'))\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    np.testing.assert_equal(out, np.array([['ABCD', 'EFGH'], ['IJKL', 'MNOP']], dtype=np.dtypes.StringDType()))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "def testBinaryDataProcessing(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 1:\n        self.skipTest('Need at least one CPU devices')\n\n    @colocated_python.colocated_python\n    def f(x):\n        out_arrays = []\n        for shard in x.addressable_shards:\n            np_array = jax.device_get(shard.data)\n            input_ints = struct.unpack('<ii', base64.b64decode(np_array[0].encode('ascii')))\n            output_string = base64.b64encode(struct.pack('<ii', input_ints[0] + 1, input_ints[1] + 1)).decode('ascii')\n            out_np_array = np.array([output_string], dtype=np.dtypes.StringDType())\n            out_arrays.append(jax.device_put(out_np_array, device=shard.device))\n        out = jax.make_array_from_single_device_arrays(sharding=x.sharding, shape=x.shape, arrays=out_arrays)\n        return out\n    input_string = base64.b64encode(struct.pack('<ii', 1001, 1002)).decode('ascii')\n    numpy_string_array = np.array([input_string], dtype=np.dtypes.StringDType())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n    x = jax.device_put(numpy_string_array, device=sharding)\n    out = f(x)\n    out = jax.device_get(out)\n    out_ints = struct.unpack('<ii', base64.b64decode(out[0].encode('ascii')))\n    self.assertEqual(out_ints[0], 1002)\n    self.assertEqual(out_ints[1], 1003)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "def testDetectInvalidMeshDevice(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if jax.local_devices()[0].id == cpu_devices[0].id:\n        self.skipTest('This test only works in a setup where accelerator and CPU devices use different device IDs.')\n    mesh = jax.sharding.Mesh(jax.local_devices(), 'x')\n    sharding = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec())\n\n    @colocated_python.colocated_python\n    def make_zero() -> jax.Array:\n        return jax.make_array_from_callback((), sharding, lambda _: np.array(0))\n    with self.assertRaisesRegex(ValueError, 'Invalid device ID'):\n        make_zero = make_zero.specialize(devices=cpu_devices)\n        jax.block_until_ready(make_zero())",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "def testObjectLifecycle(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    sharding = jax.sharding.SingleDeviceSharding(cpu_devices[0])\n\n    @colocated_python.colocated_python_class\n    class Object:\n\n        def __init__(self) -> None:\n            colocated_python._testing_initialized = True\n\n        def __del__(self) -> None:\n            colocated_python._testing_destroyed = True\n\n        def echo(self, x: jax.Array) -> jax.Array:\n            return x\n\n    @colocated_python.colocated_python\n    def check_initialized() -> jax.Array:\n        initialized = getattr(colocated_python, '_testing_initialized', False)\n        return jax.device_put(np.array(initialized), sharding)\n\n    @colocated_python.colocated_python\n    def check_destroyed() -> jax.Array:\n        destroyed = getattr(colocated_python, '_testing_destroyed', False)\n        return jax.device_put(np.array(destroyed), sharding)\n\n    @colocated_python.colocated_python\n    def cleanup():\n        if '_testing_initialized' in colocated_python.__dict__:\n            del colocated_python._testing_initialized\n        if '_testing_destroyed' in colocated_python.__dict__:\n            del colocated_python._testing_destroyed\n    check_initialized = check_initialized.specialize(devices=cpu_devices[:1])\n    check_destroyed = check_destroyed.specialize(devices=cpu_devices[:1])\n    cleanup = cleanup.specialize(devices=cpu_devices[:1])\n    try:\n        obj = Object()\n        self.assertEqual(jax.device_get(check_initialized()), False)\n        self.assertEqual(jax.device_get(check_destroyed()), False)\n        del obj\n        self.assertEqual(jax.device_get(check_initialized()), False)\n        self.assertEqual(jax.device_get(check_destroyed()), False)\n    finally:\n        cleanup()\n    try:\n        obj = Object()\n        self.assertEqual(jax.device_get(check_initialized()), False)\n        self.assertEqual(jax.device_get(check_destroyed()), False)\n        x = np.array(1)\n        x = jax.device_put(x, sharding)\n        obj.echo(x)\n        self.assertEqual(jax.device_get(check_initialized()), True)\n        self.assertEqual(jax.device_get(check_destroyed()), False)\n        del obj\n        self.assertEqual(jax.device_get(check_initialized()), True)\n        self.assertEqual(jax.device_get(check_destroyed()), True)\n    finally:\n        cleanup()",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "def testStatefulObject(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n\n    @colocated_python.colocated_python_class\n    class Value:\n\n        def __init__(self, initial_value: np.ndarray) -> None:\n            self.value = initial_value\n\n        def add(self, x: jax.Array) -> jax.Array:\n            self.value += np.asarray(x)\n            return jax.device_put(self.value, x.sharding)\n\n        def fetch(self, x: jax.Array) -> jax.Array:\n            return jax.device_put(self.value, x.sharding)\n    value = Value(np.array(5))\n    x = np.array(1)\n    x = jax.device_put(x, cpu_devices[0])\n    out = jax.device_get(value.add(x))\n    self.assertEqual(out, np.array(6))\n    out = jax.device_get(value.add(x))\n    self.assertEqual(out, np.array(7))\n    out = jax.device_get(value.fetch(x))\n    self.assertEqual(out, np.array(7))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  },
  {
    "test_code": "def testObjectWithCapturedSharding(self):\n    cpu_devices = _colocated_cpu_devices(jax.local_devices())\n    if len(cpu_devices) < 2:\n        self.skipTest(f'Need at least two CPU devices, got: {len(cpu_devices)}')\n    mesh = jax.sharding.Mesh(cpu_devices[0:2], 'x')\n    sharding1 = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec())\n    sharding2 = jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec('x'))\n\n    @colocated_python.colocated_python_class\n    class Value:\n\n        def __init__(self, initial_value: np.ndarray) -> None:\n            self.value = initial_value\n            self.sharding1 = sharding1\n            self.sharding2 = sharding2\n\n        def add_sharding1(self, x: jax.Array) -> jax.Array:\n            self.value += np.asarray(x)\n            return jax.device_put(self.value, self.sharding1)\n\n        def add_sharding2(self, x: jax.Array) -> jax.Array:\n            self.value += np.asarray(x)\n            return jax.device_put(self.value, self.sharding2)\n    value = Value(np.array([5, 15]))\n    x = np.array([1])\n    x = jax.device_put(x, jax.sharding.NamedSharding(mesh, jax.sharding.PartitionSpec()))\n    out = value.add_sharding1(x)\n    self.assertEqual(out.sharding, sharding1)\n    out = jax.device_get(out)\n    self.assertArraysEqual(out, np.array([6, 16]))\n    out = value.add_sharding2(x)\n    self.assertEqual(out.sharding, sharding2)\n    out = jax.device_get(out)\n    self.assertArraysEqual(out, np.array([7, 17]))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/colocated_python_test.py",
    "function": "def _colocated_cpu_devices(devices: Sequence[jax.Device]) -> Sequence[jax.Device]:\n    \"\"\"Returns CPU devices colocated with the given devices.\"\"\"\n    try:\n        return colocated_python.colocated_cpu_devices(devices)\n    except (ValueError, AttributeError):\n        cpu_backend_devices = jax.local_devices(backend='cpu')\n        device_index_map = {device.id: i for i, device in enumerate(jax.devices())}\n        available_devices = devices[:min(len(cpu_backend_devices), len(devices))]\n        return [cpu_backend_devices[device_index_map[d.id]] for d in available_devices]"
  }
]