[
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f():\n    jax.random.normal(jax.random.key(0), 1000)"
  },
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@partial(jax.jit, abstracted_axes=(None, 'n'))\ndef f(x):\n    return x[0]"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def zeros(shape):\n    if not isinstance(shape, (tuple, list)):\n        shape = (shape,)\n    return lax.broadcast(jnp.float32(0.0), shape)"
  },
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(x):\n    y = x + 2\n    return (jnp.nan, y)"
  },
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(x, y):\n    x, y = jax.lax.cond(x < 3, lambda x, y: (x * 2, y), lambda x, y: (x * 3, y), x, y)\n    return (x, y)"
  },
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(x):\n    return 0.0 / x"
  },
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f():\n    weird_dict = {lambda x: x: 2.0, lambda x: x * 2: 3}\n    weirder_dict = {lambda x: x: weird_dict}\n    x = 2.0\n    debugger.breakpoint(stdin=stdin, stdout=stdout, backend='cli')\n    del weirder_dict\n    return x"
  },
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(x):\n    out = jnp.zeros_like(x)\n\n    def body(i, j, k, refs):\n        x_ref, out_ref = refs\n        y = func(x_ref[i, j, k])\n        out_ref[i, j, k] += y\n    return for_loop.for_loop(x.shape, body, (x, out))[1].sum()"
  },
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.jit\ndef f(a, b, c, d, e):\n    return (a, b, c, d, e)"
  },
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(x):\n    return jsp.special.betainc(jnp.ones(3), 1.0, x)"
  },
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f():\n    return jnp.add(3.0, 4.0)"
  },
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(x, y):\n    z = jax_getattr(thing1, 'x')\n    w = jax_getattr(thing2, 'x')\n    out = jnp.sin(x * y * z * w)\n    jax_setattr(thing1, 'x', out)\n    jax_setattr(thing2, 'x', 2 * out)\n    return (3 * out, 4 * out)"
  },
  {
    "test_code": "def test_gpu_multi_node_initialize_and_psum(self):\n    coordinator_address = os.environ.get('SLURM_STEP_NODELIST', None)\n    if coordinator_address is not None and '[' in coordinator_address:\n        coordinator_address = coordinator_address.split('[')[0] + coordinator_address.split('[')[1].split(',')[0]\n    num_tasks = os.environ.get('SLURM_NPROCS', None)\n    taskid = os.environ.get('SLURM_PROCID', None)\n    localid = os.environ.get('SLURM_LOCALID', None)\n    port = '54321'\n    print(f'coord addr:port : {coordinator_address}:{port}\\nTotal tasks: {num_tasks}\\ntask id: {taskid}\\nlocal id: {localid}')\n    self.assertEqual(coordinator_address is None or num_tasks is None or taskid is None, False)\n    jax.config.update('jax_cuda_visible_devices', localid)\n    jax.distributed.initialize(coordinator_address=f'{coordinator_address}:{port}', num_processes=int(num_tasks), process_id=int(taskid))\n    print(f'Total devices: {jax.device_count()}, Total tasks: {int(num_tasks)}, Devices per task: {jax.local_device_count()}')\n    self.assertEqual(jax.device_count(), int(num_tasks) * jax.local_device_count())\n    x = jnp.ones(jax.local_device_count())\n    y = jax.pmap(lambda x: jax.lax.psum(x, 'i'), axis_name='i')(x)\n    self.assertEqual(y[0], jax.device_count())\n    print(y)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def split(self) -> jax.Array:\n    key = jax_getattr(self, 'key')\n    new_key, returned_key = jax.random.split(key)\n    jax_setattr(self, 'key', new_key)\n    return returned_key"
  },
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "@jax.vmap\n@jax.value_and_grad\n@jax.named_scope('foo')\ndef f(x):\n\n    @jax.named_scope('scan_body')\n    def body(carry, x):\n        return (carry * x, carry + x)\n    return lax.scan(body, x, jnp.arange(8.0))[0]"
  },
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f():\n    out = [rng(shape, dtype or jnp.float_) for shape, dtype in zip(shapes, dtypes)]\n    if np_arrays:\n        return out\n    return [jnp.asarray(a) if isinstance(a, (np.ndarray, np.generic)) else a for a in out]"
  },
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(c, a):\n    tracer_spy.append(c)\n    d = 0.75\n    b = jnp.sin(c * jnp.sum(jnp.cos(d * a)))\n    c = 0.9 * jnp.cos(d * jnp.sum(jnp.sin(c * a)))\n    return (c, b)"
  },
  {
    "test_code": "def test_pjit_gda_multi_input_multi_output(self):\n    jax.distributed.initialize()\n    global_mesh = jtu.create_mesh((8, 2), ('x', 'y'))\n    global_input_shape = (16, 2)\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    mesh_axes1 = jax.sharding.PartitionSpec('x', 'y')\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes1), cb)\n    mesh_axes2 = jax.sharding.PartitionSpec('x')\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes2), cb)\n    mesh_axes3 = jax.sharding.PartitionSpec(('x', 'y'))\n    gda3 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes3), cb)\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n\n        @functools.partial(pjit.pjit, out_shardings=(mesh_axes1, None, mesh_axes2))\n        def f(x, y, z):\n            return (x @ x.T, y, z)\n        out1, out2, out3 = f(gda1, gda2, gda3)\n        self.assertEqual(out1.shape, (16, 16))\n        self.assertEqual(out1.addressable_shards[0].data.shape, (2, 8))\n        expected_matrix_mul = global_input_data @ global_input_data.T\n        for s in out1.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), expected_matrix_mul[s.index])\n        self.assertEqual(out2.shape, (16, 2))\n        self.assertEqual(out2.addressable_shards[0].data.shape, (16, 2))\n        for s in out2.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data)\n        self.assertEqual(out3.shape, (16, 2))\n        self.assertEqual(out3.addressable_shards[0].data.shape, (2, 2))\n        for s in out3.addressable_shards:\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[s.index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh(self):\n    jax.distributed.initialize()\n    devices = self.sorted_devices()\n    mesh_devices = np.array(devices[0:8:2] + devices[1:8:2] + devices[8:16:2] + devices[9:16:2])\n    global_mesh = jax.sharding.Mesh(mesh_devices, ('x',))\n    global_input_shape = (16,)\n    mesh_axes = jax.sharding.PartitionSpec('x')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 1),), 0), 1: ((slice(4, 5),), 0), 2: ((slice(1, 2),), 0), 3: ((slice(5, 6),), 0), 4: ((slice(2, 3),), 0), 5: ((slice(6, 7),), 0), 6: ((slice(3, 4),), 0), 7: ((slice(7, 8),), 0), 8: ((slice(8, 9),), 0), 9: ((slice(12, 13),), 0), 10: ((slice(9, 10),), 0), 11: ((slice(13, 14),), 0), 12: ((slice(10, 11),), 0), 13: ((slice(14, 15),), 0), 14: ((slice(11, 12),), 0), 15: ((slice(15, 16),), 0)}\n    with jax.sharding.Mesh(global_mesh.devices, global_mesh.axis_names):\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (1,))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_pjit_gda_non_contiguous_mesh_2d(self):\n    jax.distributed.initialize()\n    global_mesh = self.create_2d_non_contiguous_mesh()\n    global_input_shape = (16, 2)\n    mesh_axes = jax.sharding.PartitionSpec('x', 'y')\n    global_input_data = np.arange(util.prod(global_input_shape)).reshape(global_input_shape)\n\n    def cb(index):\n        return global_input_data[index]\n    gda1 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, mesh_axes), cb)\n    expected_idx_rid = {0: ((slice(0, 2), slice(0, 1)), 0), 1: ((slice(4, 6), slice(0, 1)), 0), 2: ((slice(0, 2), slice(1, 2)), 0), 3: ((slice(4, 6), slice(1, 2)), 0), 4: ((slice(2, 4), slice(0, 1)), 0), 5: ((slice(6, 8), slice(0, 1)), 0), 6: ((slice(2, 4), slice(1, 2)), 0), 7: ((slice(6, 8), slice(1, 2)), 0), 8: ((slice(8, 10), slice(0, 1)), 0), 9: ((slice(12, 14), slice(0, 1)), 0), 10: ((slice(8, 10), slice(1, 2)), 0), 11: ((slice(12, 14), slice(1, 2)), 0), 12: ((slice(10, 12), slice(0, 1)), 0), 13: ((slice(14, 16), slice(0, 1)), 0), 14: ((slice(10, 12), slice(1, 2)), 0), 15: ((slice(14, 16), slice(1, 2)), 0)}\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, out_shardings=mesh_axes)\n        out = f(gda1)\n        for s in out.addressable_shards:\n            device_id = s.device.id\n            expected_index = expected_idx_rid[device_id][0]\n            expected_replica_id = expected_idx_rid[device_id][1]\n            self.assertEqual(s.index, expected_index)\n            self.assertEqual(s.replica_id, expected_replica_id)\n            self.assertEqual(s.data.shape, (2, 1))\n            np.testing.assert_array_equal(np.asarray(s.data), global_input_data[expected_index])\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=mesh_axes)\n        out = f(global_input_data)\n    with global_mesh:\n        f = pjit.pjit(lambda x: x, in_shardings=None, out_shardings=mesh_axes)\n        out = f(global_input_data)\n    gda2 = jax.make_array_from_callback(global_input_shape, jax.sharding.NamedSharding(global_mesh, jax.sharding.PartitionSpec(None)), cb)\n    with global_mesh:\n        f = pjit.pjit(lambda x, y: (x, y), in_shardings=(None, None), out_shardings=(mesh_axes, mesh_axes))\n        out1, out2 = f(global_input_data, gda2)",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  },
  {
    "test_code": "def test_pjit_gda_eval_shape(self):\n    jax.distributed.initialize()\n    with jtu.create_mesh((16,), 'x'):\n\n        @functools.partial(pjit.pjit, in_shardings=jax.sharding.PartitionSpec(None), out_shardings=jax.sharding.PartitionSpec('x'))\n        def f():\n            return jnp.zeros([32, 10])\n        self.assertEqual(f().shape, (32, 10))\n        self.assertEqual(jax.eval_shape(f).shape, (32, 10))",
    "assertions": [],
    "test_file": "/var/folders/q5/p2sqhr0d6nqb_h8x_fxyxpz80000gn/T/tmp_1jzy6em/jax/tests/multiprocess_gpu_test.py",
    "function": "def f(pred):\n\n    def true_fun():\n        x_ref[()] = 1.0\n\n    def false_fun():\n        x_ref[()] = 2.0\n    jax.lax.cond(pred, true_fun, false_fun)"
  }
]